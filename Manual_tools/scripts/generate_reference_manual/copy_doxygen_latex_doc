#!/usr/bin/perl -w

################################################################
# copy_doxygen_latex_doc
#
# Extract documentation from a doxygen-generated latex file
# and insert it in a CGAL Reference Manual's latex file
#
# Laurent Saboret, INRIA, 2005-2008

################################################################

use strict;
use File::Copy;


###########
# Constants
###########

# List of sections in a CGAL Reference Manual latex file.
# The list order defines the default position when a section is inserted.
my @known_section_titles = (
    '\ccDefinition', '\ccInclude', '\ccParameters', '\ccInheritsFrom', '\ccRefines',
    '\ccGeneralizes', '\ccIsModel', '\ccHeading{Design Pattern}', '\ccTypes',
    '\ccConstants', '\ccHeading{Variables}', '\ccCreation', '\ccOperations',
    '\ccHeading{Related Functions}', '\ccHasModels', '\ccImplementation',
#     '\ccHeading{Misc}',
    '\ccSeeAlso', '\ccExample'
);

# List of placeholder lines generated by cc_ref_wizard.
# They will be replaced by the generated documentation.
my @placeholders = (
    'The .*? \\\\ccRefName\\\\ does this and that\.',
    '\\\\ccGlobalFunction\{void \w+\(\);\}',
    'Concept',
    'ThisConcept \\\\\\\\',
    'ThatConcept',
    '\\\\ccNestedType\{TYPE\}\{some nested types\}',
    '\\\\ccConstructor\{.*?;\}\{[Dd]efault constructor\.\}',
    '\\\\ccMethod\{void foo\(\);\}\{some member functions\}',
    '\\\\ccc\{[Ss]ome_\w+\}[,\.]',
    '[Ss]ome(\\\\_\w+)+[,\.]',
);

# Conversion table from clear text to \ccHeading macros
my %heading_names = (
    '\ccHeading{Has Models}' => '\ccHasModels',
    '\ccHeading{Is Model for the Concepts}' => '\ccIsModel',
    '\ccHeading{Design Pattern}' => '\ccHeading{Design Pattern}',
    '\ccHeading{Generalizes}' => '\ccGeneralizes',
    '\ccHeading{Requirements}' => '\ccRequirements',
    '\ccHeading{Access Functions}' => '\ccAccessFunctions',
    '\ccHeading{Query Functions}' => '\ccQueryFunctions',
    '\ccHeading{Predicates}' => '\ccPredicates',
    '\ccHeading{Modifiers}' => '\ccModifiers',
    '\ccHeading{Implementation}' => '\ccImplementation',
#   '\ccHeading{Parameters}' => '\ccParameters', # processed separately
);

# Conversion table from clear text to \ccCommentHeading macros
my %comment_heading_names = (
    '\ccCommentHeading{Precondition}' => '\ccPrecond',
#     '\ccCommentHeading{Preconditions}' => '\ccPrecond',
);

# Warning sentence before automatically generated sections
my $warning = "% The section below is automatically generated. Do not edit!";

# Default variable name for \ccMethod
my $creation_variable = '\ccCreationVariable{a}  %% choose variable name for \ccMethod below';


##################
# Global variables
##################

my $debug = 0;                                  # Debug mode?
my $verbose = 0;                                # Verbose mode?


###########
# Functions
###########

# Print a string if Debug mode.
sub trace
{
    # Get parameter: string to print
    my $str = shift;

    if ($debug) {
      print $str;
    }
}


# Print a string if Verbose mode.
sub print_verbose
{
    # Get parameter: string to print
    my $str = shift;

    if ($verbose) {
      print $str;
    }
}


# Remove the placeholder text generated by cc_ref_wizard
# before inserting the generated documentation.
# Param: a buffer containing a CGAL Reference Manual template
# Return value: the formatted buffer
sub remove_cc_ref_wizard_placeholders
{
    # Get parameter: buffer containing a CGAL Reference Manual template
    my $cgal_buf = shift;

    # Remove any line in @placeholders
    foreach my $regex (@placeholders) {
        $cgal_buf =~ s/^$regex\n+//smg;
    }

    return $cgal_buf;
}


# Construct a pattern that matches any CGAL manual section's title.
# Note: prefixing or postfixing the pattern by ^ does not work.
sub get_any_section_title_pattern
{
    # Match \ccHeading{...}
    my $pattern = "(\\\\ccHeading\\\{.*?\\\}";

    # Match any title in @known_section_titles
    foreach my $t (@known_section_titles) {
        $pattern = $pattern . "|\Q$t\E";
    }

    # Match \end{ccRef...} == end of CGAL Reference Manual template
    $pattern = $pattern . "|\\\\end\\\{ccRef.*?\\\})";

    return $pattern;
}


# Unmangle characters mangled for Latex to get regular C++ code.
# See latex_mangle() above.
# Param: the buffer to format
# Return value: the formatted buffer
sub latex_unmangle
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Avoid tabs and consecutive spaces to ease parsing in the rest of this script
    $buf =~ s/( |\t)+/ /g;

    # Convert buffer back to Doxygen 1.5.5 format
    $buf =~ s/\\paragraph\[\{.*?\}\]/\\paragraph/g; # remove \paragraph[...] -> \paragraph

    # Unmangle comma (,), _, ~, <, >, *, &, [] characters mangled for Latex
    # to get regular C++ code (mangled back at end of script)
    $buf =~ s/, \\\//,/g;                       # , \/ -> ,
    $buf =~ s/\\_\\-/_/g;                       # \_\- -> _
    $buf =~ s/\$\\sim\$/~/g;                    # $\sim$ -> ~
    $buf =~ s/\$<\$/</g;                        # $<$ -> <
    $buf =~ s/\$>\$/>/g;                        # $>$ -> >
    $buf =~ s/\$\\ast\$/\*/g;                   # $\ast$ -> *
    $buf =~ s/\\&/&/g;                          # \& -> &
    $buf =~ s/\[\$\\,\$\]/\[\]/g;               # [$\,$] -> []

    # Remove Latex expressions that cgal_manual does not understand in macros:
    # \-, \char`\"{}, \par, \hspace, \tt, \pageref, \rm, \bf, \em, \label, \index,
    # \setlength
    $buf =~ s/\\-//g;                           # remove \-
    $buf =~ s/\\char`\\"\{\}/"/g;               # \char`\"{} -> "
    $buf =~ s/\\par\b//g;                       # remove \par (single word)
    $buf =~ s/\\hspace\{.*?\}//g;               # remove \hspace{...}
    #
    # loop to remove nested expressions
    for my $i (1..5) {
        $buf =~ s/\\pageref\{\w*\}//g;          # remove \pageref{...}
        $buf =~ s/\{\\rm\s+[^\{]*?\}//smg;      # remove {\rm ...}
        $buf =~ s/\{\\tt\s+([^\{]*?)\}/$1/smg;  # replace {\tt xxx} by xxx
        $buf =~ s/\{\\bf\s+([^\{]*?)\}/$1/smg;  # replace {\bf xxx} by xxx
        $buf =~ s/\{\\em\s+([^\{]*?)\}/$1/smg;  # replace {\em xxx} by xxx
        $buf =~ s/\\hfill\\label\{\w*\}//g;     # remove \hfill\label{...}
        $buf =~ s/\\label\{\w*\}//g;            # remove \label{...}
        $buf =~ s/\\doxyref\{(.*?)\}\{p\.\}\{.*?\}/$1/smg;
                                                # replace \doxyref{xxx}{p.}{...} by xxx
        $buf =~ s/\{\\footnotesize\s+(.*?)\s*\}\\\\/$1/smg;
                                                # replace {\footnotesize xxx} by xxx
    }
    #
    $buf =~ s/\\index\{[^\\]*\}//g;             # remove \index{...}
    $buf =~ s/\\setlength\{\\rightskip\}\{0pt plus 5cm\}//g;
                                                # remove \setlength{\rightskip}{0pt plus 5cm}

    # Return the formatted string
    return $buf;
}


# Remove formatting specific to doxygen
# Param: the buffer to format
# Return value: the formatted buffer
sub doxygen_latex_to_latex
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Remove CGAL_*_NAMESPACE keywords that doxygen doesn't parse properly
    # when the preprocessor is turned off.
    $buf =~ s/CGAL_\w*_NAMESPACE\s*//g;

    # Remove doxygen comments that are not interesting
    $buf =~ s/Implements .*//g;                 # Remove from "Implements" to end of line
    $buf =~ s/Reimplemented from .*//g;         # Same thing with "Reimplemented from"
    $buf =~ s/Implemented in .*//g;             # Same thing with "Implemented in"
    $buf =~ s/Reimplemented in .*//g;           # Same thing with "Reimplemented in"
    $buf =~ s/\[package\]//g;
    $buf =~ s/\[related\]//g;
    $buf =~ s/\[friend\]//g;

    # Add a \n before (parameters) descriptions to ease parsing
    $buf =~ s/\n?\\begin\{Desc\}/\n\\begin\{Desc\}/smg;

    # Use a canonic style to ease parsing
    $buf =~ s/ *, *([^\\])/, $1/g;              # Use a canonic style "item1, item2" for lists
    $buf =~ s/([\w\>]+)\s*&\s*/$1& /g;          # Use a canonic style "type& variable" for references
    $buf =~ s/(\w)=/$1 =/g;                     # Use a canonic style "variable = default" for default parameters
    $buf =~ s/=(\w)/= $1/g;                     #                    ""
    $buf =~ s/<\s*(.*?)\s*>/<$1>/g;             # Use a canonic style "type<parameters>" for template parameters
    $buf =~ s/Constructor& Destructor/Constructor & Destructor/g;
    $buf =~ s/\\item\[(.*?): +\]/\\item\[$1:\]/g;

    # "Desc" is a doxygen style based on "description".
    # "CompactItemize" is a doxygen style based on "itemize".
    $buf =~ s/\{Desc\}/\{description\}/g;
    $buf =~ s/\{CompactItemize\}/\{itemize\}/g;

    # Return the formatted string
    return $buf;
}


# Mangle C++ code for latex.
# Wrap words surrounded by simple quotes and C++ names (types/functions/variables) by \ccc{}.
# Emphasize words surrounded by double quotes using \em, by stars using \bf [L. Saboret's extension].
# See latex_unmangle() above.
# Param: the buffer to format
# Return value: the formatted buffer
sub latex_mangle
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Local variables when parsing buffer line by lines
    my ($line, @lines);

    # There is no \ccSubHeading macro yet
    $buf =~ s/\\ccSubHeading\{/\\subsubsection\{/g;

    #
    # Trust user
    #

    # Emphasize words surrounded by double quotes using \em, by stars using \bf [L. Saboret's extension].
    $buf =~ s/"(.*?)"/\{\\em $1\}/g;
    $buf =~ s/\*(\w*?)\*/\{\\bf $1\}/g;

    # Wrap words surrounded by simple quotes by \ccc{} [L. Saboret's extension].
    $buf =~ s/\'(((::|\w)+(<.*?>)?)+)\'/\\ccc\{$1\}/g;

    # Add carriage returns around \ccc{} for the line by line substitution below.
    $buf =~ s/(\\ccc\{.*?\})/\n$1\n/g;

    # \ccInclude, \ccHeading, \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable & \ccFunction
    # first curly braces pair must contain plain C++ code.
    # \subsubsection must protect _ as \_.
    # For the other lines, we wrap C++ types by \ccc{}.
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {
        # if first curly braces pair of a cgal_manual macro
        if ($line =~ /\\(ccInclude|ccHeading|ccSubHeading|ccNestedType|ccEnum|ccConstructor|ccMethod|ccVariable|ccFunction)/
         || $line =~ /\\ccc/)
        {
            # nothing to do
        }
        elsif ($line =~ /\\subsubsection/)
        {
            $line =~ s/_/\\_/g; #  _ -> \_
        }
        else
        {
            #
            # Try to be smart
            #

            # Wrap C++ types, including template params, by \ccc{}.
            $line =~ s/((\w*(_|::)\w*(<.*?>)?)+)/\\ccc\{$1\}/g;

            # Add carriage returns around \ccc{} for the line by line substitution below.
            $line =~ s/(\\ccc\{.*?\})/\n$1\n/g;
        }
        $buf = $buf . $line . "\n";             # concat lines back to $buf
    }

    # \ccInclude, \ccHeading, \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable & \ccFunction
    # first curly braces pair and \ccc expressions must contain plain C++ code.
    # For the other lines, we wrap concepts name by \ccc{}.
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {
        # if first curly braces pair of a cgal_manual macro
        if ($line =~ /\\(ccInclude|ccHeading|ccSubHeading|ccNestedType|ccEnum|ccConstructor|ccMethod|ccVariable|ccFunction)/
         || $line =~ /\\ccc/)
        {
            # nothing to do
        }
        else
        {
            #
            # Try to be smart
            #

            # Wrap concepts name by \ccc{}.
            # TODO: replace hard coded list of concepts by regex like [A-Z][a-z]+[A-Z]\w*
            $line =~ s/\b(PolylineSimplificationCostFunction)\b/\\ccc{$1\}/g;
            $line =~ s/\b(PolylineSimplificationStopPredicate)\b/\\ccc{$1\}/g;
            $line =~ s/\b(PolylineSimplificationVertex)\b/\\ccc{$1\}/g;
            $line =~ s/\b(ImplicitFunction)\b/\\ccc{$1\}/g;
            $line =~ s/\b(InputIterator)\b/\\ccc{$1\}/g;
            $line =~ s/\b(OutputIterator)\b/\\ccc{$1\}/g;
            $line =~ s/\b(ForwardIterator)\b/\\ccc{$1\}/g;

            # Add carriage returns around \ccc{} for the line by line substitution below.
            $line =~ s/(\\ccc\{.*?\})/\n$1\n/g;
        }
        $buf = $buf . $line . "\n";             # concat lines back to $buf
    }

    # \ccInclude, \ccHeading, \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable & \ccFunction
    # first curly braces pair and \ccc expressions must contain plain C++ code.
    # The other lines must contain regular latex text => we mangle back
    # ~, <, >, *, &, [] characters (see latex_unmangle() above).
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {
        # if first curly braces pair of a cgal_manual macro: plain C++ code
        if ($line =~ /\\(ccInclude|ccHeading|ccSubHeading|ccNestedType|ccEnum|ccConstructor|ccMethod|ccVariable|ccFunction)/
         || $line =~ /\\ccc/)
        {
            # Add/remove extra spaces to please cgal_manual
            $line =~ s/>(\w)/> $1/g;           # add space after template parameters
            $line =~ s/< (.*?) >/<$1>/g;       # remove spaces within template parameters
            $line =~ s/ & /& /g;
            $line =~ s/ \(/\(/g;
            $line =~ s/ +/ /g;                 # avoid consecutive spaces
        }
        # else: wrap C++ code for latex
        else
        {
            # Mangle back special latex characters
            $line =~ s/~/\$\\sim\$/g;           # ~ -> $\sim$
            $line =~ s/</\$<\$/g;               # < -> $<$
            $line =~ s/>/\$>\$/g;               # > -> $>$
            $line =~ s/\*/\$\\ast\$/g;          # * -> $\ast$
            $line =~ s/&/\\&/g;                 # & -> \&
            $line =~ s/\[\]/\[\$\\,\$\]/g;      # [] -> [$\,$]
        }
        $buf = $buf . $line . "\n";             # concat lines back to $buf
    }

    # Remove extra carriage returns around \ccc{} expressions
    $buf =~ s/\n(\\ccc{.*?\})\n/$1/smg;

    # Return the formatted string
    return $buf;
}


# Remove blank lines in the second curly braces pair of macros,
# that cgal_manual does not understand
# Param: the buffer to format
# Return value: the formatted buffer
sub remove_blank_lines_in_macros
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Remove trailing spaces to improve pattern matching
    $buf =~ s/ +\n/\n/g;

    # Remove blank lines in the second curly braces pair of macros,
    # that cgal_manual does not understand
    if ($buf =~ m/(.*?)\\paragraph(.*)/sm) {    # split $buf in $definition and $macros
        my $definition = $1;
        my $macros = $2;
        $macros =~ s/\n+/\n/g;                  # remove blank lines from $macros
        $buf = $definition . '\paragraph' . $macros;
    }                                           # put back in $buf

    # Return the formatted string
    return $buf;
}


# If $buf matches the function $pattern, return $buf, else return an empty string
sub keep_only_if_function
{
    my $buf = shift;
    my $pattern = shift;

    if ($buf =~ /\\paragraph\{.*\b\Q$pattern\E\b.*\}/) {
        return $buf;
    } else {
        return "";
    }
}


# Convert clear text to \ccHeading and \ccSubHeading macros
# Param: macro name in doxygen latex doc, of the form "Heading ...:" or "Subheading ..."
# Return value: the formatted macro name
sub convert_heading_name
{
    my $heading = shift;

    # Convert to \ccHeading or \subsubsection
    $heading =~ s/^Heading (.*?):?$/\\ccHeading\{$1\}/;
    $heading =~ s/^Subheading (.*?):?$/\\ccSubHeading\{$1\}/;

    # Use CGAL Manual shortcut if available
    if (defined($heading_names{$heading})) {
        $heading = $heading_names{$heading};
    }

    return $heading;
}


# Convert clear text to \ccCommentHeading macros.
# Param: macro name in doxygen latex doc, of the form "CommentHeading ...:".
# Return value: the formatted macro name.
sub convert_comment_heading_name
{
    my $heading = shift;

    # Convert to \ccCommentHeading
    $heading =~ s/^CommentHeading (.*?):$/\\ccCommentHeading\{$1\}/;

    # Use CGAL Manual shortcut if available
    if (defined($comment_heading_names{$heading})) {
        $heading = $comment_heading_names{$heading};
    }

    return $heading;
}


# Flatten a list if it contains only 1 item.
# Param: list in doxygen latex doc, of the form "\begin{description}...\end{description}".
# Return value: the list flattened or not.
sub flatten_one_item_list
{
    my $buf = shift;

    # Count the occurences of \item in the list
    my $count = 0;
    while ($buf =~ /\\item/g) { $count = $count + 1; }

    # Flatten the list if 1 item
    if ($count == 1)
    {
        $buf =~ s/\\begin\{description\}\s*\\item\s*(.*)\\end\{description\}/$1/sm;
    }

    return $buf;
}


# Convert @commentheading sections to \ccCommentHeading calls [L. Saboret + S. Hornus extension].
# Format (parameters) descriptions.
# Param: the buffer to format
# Return value: the formatted buffer
sub format_comment_headings
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Convert @commentheading sections to \ccCommentHeading calls [L. Saboret + S. Hornus extension].
    # - @commentheading is in fact an alias to "CommentHeading".
    # - the macro name starts at "CommentHeading" and ends with ":".
    $buf =~ s/(CommentHeading.*?:)/convert_comment_heading_name($1)/smge;

    # By default, doxygen uses "Parameters" as parameter list title.
    # We allow to change it with an @commentheading command right before the list [L. Saboret extension].
    $buf =~ s/\\ccCommentHeading\{([^\}]*)\}\s*(\\begin\{description\}\s*\\item)\[Parameters:\]/$2\[$1:\]/smg;

    # Convert function parameters, enum values and return value descriptions to \ccCommentHeading to minimize length and indentation
    $buf =~ s/\\begin\{description\}\s*\\item\[(Returns):\]\s*(.*?)\s*\\end\{description\}/\\ccCommentHeading\{$1\} $2/smg;
    $buf =~ s/\\begin\{description\}\s*\\item\[(Parameters|Template Parameters|Values):\]\s*(\\begin\{description\}.*?\\end\{description\})\s*\\end\{description\}/\\ccCommentHeading\{$1\}\n$2/smg;

    # Replace list items in bold (ie with square brackets around item) by italics (\ccc macro).
    $buf =~ s/\\item\[(.*?):\s*\]/\\item $1: /smg;         # regular list items (end by ':') => no italics
    $buf =~ s/\\item\[(.*?)\s*\]/\\item \\ccc\{$1\}: /smg; # parameters => italics

    # Flatten lists with only 1 item (to save space and avoid a cgal_manual bug
    # with 1-item lists inside the second curly braces pair of \ccXXX expressions).
    $buf =~ s/(\\begin\{description\}.*?\\end\{description\})/flatten_one_item_list($1)/smge;

    # TODO: Uncomment the next line to set vertical spacing = 0 in parameters descriptions
    # (=> prettier PDF but ugly Latex).
#     $buf =~ s/\\begin\{description\}(.*?)\\end\{description\}/\\ccGlue\n\\begin\{description\}\\itemsep=0pt\\parskip=0pt$1\\end\{description\}/smg;

    # Return the formatted string
    return $buf;
}


# L. Saboret's formatting extensions:
# Extract @headings sections from \Definition section.
# Param: the buffer to format
# Return value: the formatted buffer
sub format_headings
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Extract @heading sections from from detailed section.
    # - @heading is in fact an alias to "Heading".
    # - the macro name starts at "Heading" and ends with ":".
    # - the macro content lies on a unique line, except lists.
    #   Doxygen may concat lines, thus we also stop at the first dot.
    #
    # case of macros with list
    while ($buf =~ s/([^\}])\b(Heading [^\n]*?:)\s*([^\n\.]*?\\begin\{itemize\}.*?\\end\{itemize\}.*?)([\n\.])/$1/sm)
    {
        my $macro_name = convert_heading_name($2);
        my $macro_content = "$3$4";
        unless ($4 =~ /\n/) {
            $macro_content .= "\n";
        }
        unless ($buf =~ /\Q$macro_name\E/) { # if needed, add $macro_name section before \ccSeeAlso
            $buf =~ s/\\ccSeeAlso/$macro_name\n\n\n\n\\ccSeeAlso/sm;
        }
        $buf =~ s/\n\n\\ccSeeAlso/$macro_content\n\n\\ccSeeAlso/sm;
    }
    # case of macros on 1 line
    while ($buf =~ s/([^\}])\b(Heading [^\n]*?:)\s*(.*?)([\n\.])/$1/sm)
    {
        my $macro_name = convert_heading_name($2);
        my $macro_content = "$3$4";
        unless ($4 =~ /\n/) {
            $macro_content .= "\n";
        }
        unless ($buf =~ /\Q$macro_name\E/) { # if needed, add $macro_name section before \ccSeeAlso
            $buf =~ s/\\ccSeeAlso/$macro_name\n\n\n\n\\ccSeeAlso/sm;
        }
        $buf =~ s/\n\n\\ccSeeAlso/$macro_content\n\n\\ccSeeAlso/sm;
    }

    # If the \ccHasModels section is a list, flatten it
    # (for compatibility with the rest of CGAL manual).
    if ($buf =~ s/(.*?\\ccHasModels\n+[^\n]*?)\\begin\{itemize\}\n(.*?)\\end\{itemize\}(.*)//sm)
    {
        # Extract models from \ccHasModels section
        my $start  = $1;
        my $models = $2;
        my $end    = $3;

        # Remove \item list separators and
        # add \\ at the end of each line to force EOL
        $models =~ s/\\item\s/  \\\\\n/smg;
        $models =~ s/^ *\\\\\n//smg;

        # Insert back $models in the buffer
        $buf = $start . "\n\n" . $models . $end;
    }

    # Return the formatted string
    return $buf;
}


# Rename \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable and \ccFunction expressions.
# Params:
# - concept/struct/class/function to document (without namespace nor template parameters)
# - type of the item to document: "class/struct", "concept" or "function"
# - buffer containing a doxygen-generated latex file
# Return value: the formatted buffer
sub format_curly_brace_pairs_expressions
{
    # Get parameters:
    # - concept/struct/class/function to document (without namespace nor template parameters)
    my $item_to_document = shift;
    # - type of the item to document: "class/struct", "concept" or "function"
    my $item_type = shift;
    # - buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Rename \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable and \ccFunction expressions
    # and open a curly brace for the expression's comment
    # - if class/struct/concept...
    if ($item_type eq "class/struct" || $item_type eq "concept")
    {
        $buf =~ s/\\paragraph\{typedef.* (\w+)((\[.*\])?)\}/\\ccNestedType\{$1$2\}\n\{/g;
        $buf =~ s/\\paragraph\{enum\s(.*)\}/\\ccEnum\{enum $1\}\n\{/g;
        $buf =~ s/\\item\[Enumerator/\\item\[Values/g;
        $buf =~ s/\\paragraph\{\Q$item_to_document\E\s+\((.*)\}/\\ccConstructor\{$item_to_document \($1;\}\n\{/g;
        $buf =~ s/\\paragraph\{(template\s*<.*?>\s*)\Q$item_to_document\E\s+\((.*)\}/\\ccConstructor\{$1$item_to_document \($2;\}\n\{/g;
        $buf =~ s/\\paragraph\{([^\(\)]*?)\}/\\ccVariable\{$1;\}\n\{/g;
        $buf =~ s/\\paragraph\{(.*\(.*\).*)\}/\\ccMethod\{$1;\}\n\{/g;
    }
    # - ...or if function
    else
    {
        $buf =~ s/\\paragraph\{(.*)\}/\\ccFunction\{$1;\}\n\{/g;
    }

    # Move [static], [virtual], [protected] comments at the beginning of the expression's comment.
    $buf =~ s/(\[.*?\])(;?)\}\n\{/$2\}\n\{\n$1 \\\\/g;

    # Remove brackets in curly braces pairs (restored below):
    # - replace \begin{xxx}...\end{xxx} by \begin((xxx))...\end((xxx))
    $buf =~ s/\\begin\{(.*?)\}/\\begin\(\($1\)\)/smg;
    $buf =~ s/\\end\{(.*?)\}/\\end\(\($1\)\)/smg;
    # - replace \{ and \} by &#123; and &#125;
    $buf =~ s/\\\{/&\#123\;/g;
    $buf =~ s/\\\}/&\#125\;/g;

    # Close curly braces pairs.
    # Note: Sometimes, cgal_manual does not understand 2 or 3-items lists inside the second curly braces pair
    # of \ccXXX expressions => we put them after (flatten_one_item_list() takes care of 1-item lists).
#     $buf =~ s/(\{[^\}]*?)(\\begin\(\(description\)\).*?\\end\(\(description\)\))(\n+)\\cc/$1\n\}\n\\ccGlue\n$2\n\\ccGlue$3\\cc/smg;
    # TEMPORARY HACK: do it for enums to compile Surface_reconstruction_points_3 manual!!!
    $buf =~ s/(\\ccEnum\{.*?;}\s*\{[^\}]*?)(\\begin\(\(description\)\).*?\\end\(\(description\)\))(\n+)\\cc/$1\n\}\n\\ccGlue\n$2\n\\ccGlue$3\\cc/smg;
    $buf =~ s/(\{[^\}]*?)(\n+)\\cc/$1\n\}\n\\ccGlue$2\\cc/smg;

    # Restore brackets:
    # - replace \begin((xxx))...\end((xxx)) by \begin{xxx}...\end{xxx}
    $buf =~ s/\\begin\(\((.*?)\)\)/\\begin\{$1\}/smg;
    $buf =~ s/\\end\(\((.*?)\)\)/\\end\{$1\}/smg;
    # - replace back \{ and \}
    $buf =~ s/&\#123\;/\\\{/g;
    $buf =~ s/&\#125\;/\\\}/g;

    # \ccMethod does not support destructors and there is no \ccDestructor
    # macro => remove destructors.
    if ($item_type eq "class/struct" || $item_type eq "concept")
    {
        $buf =~ s/\\ccMethod\{.*?~\Q$item_to_document\E\s.*?\}\n\{.*?\}\n\\ccGlue\n//smg;
    }

    # Security: remove blank lines in curly braces pairs
    $buf =~ s/\{(\n)+/\{\n/g;
    $buf =~ s/(\n)+\}/\n\}/g;

    # Return the formatted string
    return $buf;
}


# Convert a list of include files to \ccInclude command(s).
# Param: list in doxygen latex doc, of the form "\begin{itemize}...\end{itemize}".
# Return value: the \ccInclude command(s) separated by new lines.
sub convert_include_file
{
    my $buf = shift;

    # Convert heading aand trailing
    $buf =~ s/\\begin\{itemize\}\s*(.*?)\s*\\end\{itemize\}/$1/sm;

    # Convert list items. The last one does not get a \n.
    while ($buf =~ s/\\item\s*include\/(.*?)(\\item)/\\ccInclude\{$1\}\n$2/sm) {}
    $buf =~ s/\\item\s*include\/(.*)/\\ccInclude\{$1\}/sm;

    return $buf;
}


# Format a buffer containing a doxygen-generated documentation of a class/struct/concept,
# in latex, to match CGAL Reference Manual's format.
# Params:
# - class/struct/concept name (without namespace nor template parameters)
# - buffer containing a doxygen-generated latex file
# - type of the item to document: "class/struct", "concept" or "function"
# Return value: the formatted buffer
sub format_doxygen_class_doc
{
    # Get parameters:
    # - class/struct/concept name (without namespace nor template parameters)
    my $className = shift;
    # - buffer containing a doxygen-generated latex file
    my $buf = shift;
    # - type of the item to document: "class/struct", "concept" or "function"
    my $item_type = shift;

    # Construct a pattern that matches any section title
    my $all_titles_pattern = get_any_section_title_pattern();

    # Local variables when parsing buffer line by lines
    my ($line, @lines);

    # Unmangle characters mangled for Latex to get regular C++ code
    # (mangled back at end of script)
    $buf = latex_unmangle($buf);

    # Remove formatting specific to doxygen
    $buf = doxygen_latex_to_latex($buf);

    # Remove CGAL:: and $className:: prefixes (implicit)
    $buf =~ s/CGAL::(\w+)/$1/g;
    $buf =~ s/$className(<.*?>)?::(\w+)/$2/g;

    # Remove blank lines in the second curly braces pair of macros,
    # that cgal_manual does not understand.
    $buf = remove_blank_lines_in_macros($buf);

    # Rename (for a class/struct) or delete (for a concept) the include file
    # and insert \ccSeeAlso title at the end of the document.
    if ($item_type eq "class/struct") {
        $buf =~ s/^The documentation.*?(\\begin\{itemize\}.*?include\/.*?\\end\{itemize\})/
                  "\n\n" . convert_include_file($1) . "\n\n\n\\ccSeeAlso\n\n\n"/sme;
    } else {
        $buf =~ s/The documentation for this.*/\n\n\\ccSeeAlso\n\n\n/sm;
    }

    # Insert \ccInheritsFrom (for a class/struct) or \ccRefines (for a concept) section
    # before \ccSeeAlso (from detailed section).
    if ($buf =~ s/^Inherits (.*?)\.$//sm)
    {
        my $superclass = $1;

        if ($item_type eq "concept") {
            $buf =~ s/\\ccSeeAlso/\\ccRefines\n\n$superclass\n\n\n\\ccSeeAlso/sm;
        } else {
            $buf =~ s/\\ccSeeAlso/\\ccInheritsFrom\n\n$superclass\n\n\n\\ccSeeAlso/sm;
        }
    }

    # Rename "Heading Parameters:" comment in \ccDefinition section as \ccParameters [L. Saboret extension]
    # or insert a new section before \ccSeeAlso
    unless ($buf =~ s/\bHeading Parameters:\s*/\n\\ccParameters\n\n/sm) {
        $buf =~ s/\\ccSeeAlso/\\ccParameters\n\n\n\\ccSeeAlso/sm;
    }

    # Insert template params at the beginning of \ccParameters section
    # (from detailed section)
    if ($buf =~ s/\\subsubsection\*\{(template.*)\}\n//)
    {
        # extract template params from \subsubsection* line
        my $full_template_declarations = $1;

        # Split template declaration(s) on several lines
        $full_template_declarations =~ s/(template<|, |> )(class|struct|typename)/$1\n$2/g; # add \n before each param
        $full_template_declarations =~ s/(class|struct) (\w+::)*\Q$className\E.*/$1 $className;/g;
                                                # keep only class/struct/concept name on last line
        $full_template_declarations =~ s/\n/  \\\\\n/smg;       # add \\ at the end of each line to force EOL
        $full_template_declarations =~ s/^ *\\\\\n//smg;        #                ""

        # Insert template params at the beginning of \ccParameters section
        $buf =~ s/\\ccParameters\n/\\ccParameters\n\n$full_template_declarations\n/;
    }

    # L. Saboret's formatting extensions:
    # Extract @headings sections from \Definition section.
    $buf = format_headings($buf);

    # L. Saboret's formatting extensions:
    # Move subheadings from brief to detailed section
    while ($buf =~ s/\\begin\{Indent\}(Subheading .*?)\n\\begin\{itemize\}\n\\item\n(.*?)$/\\item\n$2/sm)
    {
        my $subheading_name = $1;
        my $next_documented_item = $2;
        $next_documented_item =~ s/ & /& /g;
        $buf =~ s/(\\paragraph\{\Q$next_documented_item\E\})/
                 "\n" . convert_heading_name($subheading_name) . "\n\n$1\n"/e;
    }

    # Copy enumerations values from brief to detailed section
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {                    # for each line of buffer
        # if incomplete enum declaration in detailed section
        if ($line =~ /\\paragraph\{enum\s+(\w+)\}/) {
            my $enumName = $1;
            # Get enum values from brief section
            my $enumValues = "...";
            if ($buf =~ m/enum\s+\Q$enumName\E\s+\\\{(.*?)\\\}/sm) {
                $enumValues = $1;
                $enumValues =~ s/\n/ /smg;      # Remove carriage returns
            }
            # Copy enum values to detailed section
            $line =~ s/\\paragraph\{enum\s+\Q$enumName\E\}/\\paragraph\{enum $enumName \{$enumValues\};\}/
        }
        $buf = $buf . $line . "\n";             # concat line back to $buf
    }

    # Copy template parameters of templated methods from brief to detailed section
    if ($buf =~ m/\\subsubsection\*\{Public Member Functions\}\n\\begin\{itemize\}\n(.*?)\\end\{itemize\}/sm)
    {
        # extract template params from \subsubsection*{Public Member Functions} section
        my $methods = $1;

        # for each templated method
        while ($methods =~ m/(template\s*<.*?>\s*)(.*)/g)
        {
            my $template_params = $1;
            my $method = $2;

            # insert $template_params before $method in detailed section
            $buf =~ s/\\paragraph\{\Q$method\E\}/\\paragraph\{$template_params$method\}/
              or warn "INTERNAL ERROR: cannot extract template parameters of $method";
        }
    }

    # Rename \ccDefinition title
    $buf =~ s/\\subsubsection\{Detailed Description\}/\\ccDefinition\n/;

    # Rename \ccTypes title
    $buf =~ s/\\subsubsection\{Member Typedef Documentation\}/\n\n\\ccTypes/;

    # Rename \ccConstants title
    $buf =~ s/\\subsubsection\{Member Enumeration Documentation\}/\n\n\\ccConstants\n/;

    # Rename \ccHeading{Variables} title
    $buf =~ s/\\subsubsection\{Member Data Documentation\}/\n\n\\ccHeading\{Variables\}\n/;

    # Rename \ccCreation title
    unless ($buf =~ m/\\subsubsection\{Constructor & Destructor Documentation\}/) {
        $buf =~ s/\\subsubsection\{Member Function Documentation\}/\\subsubsection\{Constructor & Destructor Documentation\}\n\\subsubsection\{Member Function Documentation\}/;
    }
    $buf =~ s/\\subsubsection\{Constructor & Destructor Documentation\}/\n\n\\ccCreation\n/;

    # Rename \ccOperations title
    $buf =~ s/\\subsubsection\{Member Function Documentation\}/\n\n\\ccOperations\n/;

    # Rename \ccHeading{Related Functions} title
    $buf =~ s/\\subsubsection\{Friends And Related Function Documentation\}/\n\n\\ccHeading\{Related Functions\}\n/;

#     # Fallback is \ccHeading{Misc} title
#     $buf =~ s/\\subsubsection\{.*?\}/\n\n\\ccHeading\{Misc\}\n/;

    # Rename \ccFunction expressions of related functions
    $buf =~ s/(\\ccHeading\{Related Functions\}.*?$all_titles_pattern)/
              format_curly_brace_pairs_expressions("", "function", $1)/smge;

    # Rename \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable expressions
    $buf = format_curly_brace_pairs_expressions($className, $item_type, $buf);

    # Convert @commentheading sections to \ccCommentHeading calls [L. Saboret + S. Hornus extension].
    # Format (parameters) descriptions.
    $buf = format_comment_headings($buf);

    # Remove brief documentation
    $buf =~ s/\\subsection.*?($all_titles_pattern)/\n\n$1/sm;

    # Mangle C++ code for latex.
    # Wrap words surrounded by simple quotes and C++ names (types/functions/variables) by \ccc{}.
    $buf = latex_mangle($buf);

    # Return the formatted string
    return $buf;
}


# Format a buffer containing a doxygen-generated documentation of
# a function, in latex, to match CGAL Reference Manual's format.
# Params:
# - function name (without namespace nor template parameters)
# - buffer containing a doxygen-generated latex file
# Return value: the formatted buffer
sub format_doxygen_function_doc
{
    # Get parameters:
    # - function name (without namespace nor template parameters)
    my $functionName = shift;
    # - buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Construct a pattern that matches any section title
    my $all_titles_pattern = get_any_section_title_pattern();

    # Local variables when parsing buffer line by lines
    my ($line, @lines);

    # Unmangle characters mangled for Latex to get regular C++ code
    # (mangled back at end of script)
    $buf = latex_unmangle($buf);

    # Remove formatting specific to doxygen
    $buf = doxygen_latex_to_latex($buf);

    # Remove CGAL:: prefix (implicit)
    $buf =~ s/CGAL::(\w+)/$1/g;

    # Remove blank lines in the second curly braces pair of macros,
    # that cgal_manual does not understand
    $buf = remove_blank_lines_in_macros($buf);

    # Insert \ccSeeAlso title at the end of the document
    $buf = $buf . "\n\n\\ccSeeAlso\n\n\n";

    # Remove declaration of other functions
    $buf =~ s/(\\paragraph\{|\\subsubsection\{|\\ccSeeAlso)/((end))$1/g; # add marker at end of functions
    $buf =~ s/(\\paragraph\{.*?\(\(end\)\))/keep_only_if_function($1, $functionName)/smge; # remove other functions
    $buf =~ s/\(\(end\)\)//g; # remove markers

    # Ignore "@heading Parameters:" command in a function (backward compatibility).
    # Note: @heading is in fact an alias to "Heading".
    if ($buf =~ s/\bHeading Parameters:\s*//smg)
    {
        print "  WARNING: ignore '\@heading Parameters' in function $functionName\n";
    }

    # Copy full template declarations from brief section
    if ($buf =~ s/\\subsubsection\*\{Functions\}\n\\begin\{itemize\}\n(.*?)\\end\{itemize\}//sm)
    {
        # extract full template declarations from \subsubsection*{Functions} section
        my $full_template_declarations = $1;

        # Split $full_template_declarations to have 1 declaration per line
        # and keep only lines declaring $functionName.
        @lines = ($full_template_declarations =~ /^.*\b\Q$functionName\E\b.*$/mg);
        foreach my $line (@lines) {
            # Replace in $buf the short function declaration by the full template one
            if ($line =~ /^(.*)\b(\Q$functionName\E\b.*)$/) {
                my $template_params = $1;
                my $short_declaration = $2;
                $buf =~ s/\\paragraph\{.*?\Q$short_declaration\E.*?\}/\\paragraph\{$template_params $short_declaration\}/;
            }
        }
    }

    # L. Saboret's formatting extensions:
    # Extract @headings sections from \Definition section.
    $buf = format_headings($buf);

    # Rename \ccDefinition title
    $buf =~ s/\\subsubsection\{Function Documentation\}/\\ccDefinition\n/;

#     # Fallback is \ccHeading{Misc} title
#     $buf =~ s/\\subsubsection\{.*?\}/\n\n\\ccHeading\{Misc\}\n/;

    # Rename \ccFunction expressions
    $buf = format_curly_brace_pairs_expressions($functionName, "function", $buf);

    # Convert @commentheading sections to \ccCommentHeading calls [L. Saboret + S. Hornus extension].
    # Format (parameters) descriptions.
    $buf = format_comment_headings($buf);

    # Remove brief documentation
    $buf =~ s/\\subsection.*?($all_titles_pattern)/\n\n$1/sm;

    # Mangle C++ code for latex.
    # Wrap words surrounded by simple quotes and C++ names (types/functions/variables) by \ccc{}.
    $buf = latex_mangle($buf);

    # Return the formatted string
    return $buf;
}


# Insert a section of a doxygen-generated documentation in CGAL Reference Manual's buffer
# Params:
# - buffer containing a CGAL Reference Manual template
# - buffer containing a doxygen-generated latex file reformated for CGAL
# - section's title
# - Insert missing %START-AUTO..%END-AUTO sections?
# Return value: updated CGAL buffer
sub insert_manual_section
{
    # Get parameters:
    # - buffer containing a CGAL Reference Manual template
    my $cgal_buf = shift;
    # - buffer containing a doxygen-generated latex file reformated for CGAL
    my $doxy_buf = shift;
    # - section's title
    my $title = shift;

    # Uncomment the next line to test that obsolete sections are properly *emptied*
    # $doxy_buf = "";

    # Construct a pattern that matches any section title
    my $all_titles_pattern = get_any_section_title_pattern();

    # Extract $title section content from $doxy_buf:
    my $section = "";
    #
    # Special case: if one-line macro like \ccInclude
    if ($title eq '\ccInclude') {
      while ($doxy_buf =~ /^\s*(\Q$title\E\{.*?\})/smg) {
          $section = "$section\n$1";
      }
    }
    # General case
    elsif ($doxy_buf =~ /^\s*\Q$title\E(.*?)\s+$all_titles_pattern/sm) {
        $section = $1;
    }
    $section =~ s/^\s+//s;                  # Remove heading & trailing spaces
    $section =~ s/\s+$//s;                  # and extra carriage returns.

    # If $section is not empty, copy it to $cgal_buf.
    # If $cgal_buf doesn't already contain $title, add it.
    # If $cgal_buf doesn't already contain the %START-AUTO($title)..%END-AUTO($title) section, add it.
    if ($section ne "")
    {
        # cgal_manual requires \ccTagFullDeclarations to document properly
        # getters with 2 const/non const variants
        # => add \ccTagFullDeclarations at the beginning of \ccOperations section
        if ($title eq '\ccOperations') {
          $section = "\\ccTagFullDeclarations\n\n" . $section;
        }

        # Add $warning\n%START-AUTO($title)..%END-AUTO($title) around $section
        $section = "$warning\n%START-AUTO($title)\n\n" . $section . "\n\n%END-AUTO($title)";

        # Add \ccCreationVariable after \ccCreation
        my $title_extra = ($title eq '\ccCreation') ? "\n$creation_variable" : "";

        # If %START-AUTO..%END-AUTO section exists, replace it
        if ($cgal_buf =~ s/($warning\n)?%START-AUTO\(\Q$title\E\).*?%END-AUTO\(\Q$title\E\)/$section/sm)
        {
            print_verbose "  Update section $title\n";
        }
        else  # Else, insert a new %START-AUTO..%END-AUTO section
        {
            my $success = 0;                # Successful insertion?

            # If section's title exists, insert $section there.
            #
            # Special case: \ccInclude section is a one-line macro
            if ($title eq '\ccInclude') {
                # If \ccInclude{.*?} macro exists, *replace* it by %START-AUTO..%END-AUTO section
                if ($cgal_buf =~ s/^(\s*)\Q$title\E\{.*?\}/$1$section/sm) {
                    $success = 1;
                }
            } else { # if not \ccInclude
                # If section's title exists, *append* %START-AUTO..%END-AUTO section after it.
                if ($cgal_buf =~ s/^(\s*\Q$title\E.*?)(\s*$all_titles_pattern(\s|\b))/$1\n\n$section$2/sm) {
                    $success = 1;
                }
            }

            # Else, insert title + %START-AUTO..%END-AUTO section before
            # the first section that appears after $title in @known_section_titles.
            if (not $success)
            {
                my $after_title = 0;        # indicate if we passed $title in @known_section_titles
                foreach my $t (@known_section_titles)
                {
                    if ($after_title)
                    {
                        # Special case: \ccInclude section is a one-line macro
                        if ($title eq '\ccInclude') {
                            if ($cgal_buf =~ s/(\s+)(\Q$t\E\b)/$1$section$1$2/sm) {
                                  $success = 1;
                                  last;
                              }
                        } else { # if not \ccInclude
                            if ($cgal_buf =~ s/(\s+)(\Q$t\E\b)/$1$title$title_extra\n\n$section$1$2/sm) {
                                  $success = 1;
                                  last;
                            }
                        }
                    }
                    if ($t eq $title) { $after_title = 1; }
                }
            }

            # Else, insert title + %START-AUTO..%END-AUTO section at the end of the buffer
            if (not $success) {
                $success = ($cgal_buf =~ s/(\s+)(\\end\{ccRef)/$1$title$title_extra\n\n$section$1$2/sm);
            }

            # Notify user
            if ($success) { print_verbose "  Add section $title\n"; }
            else          { warn  "  Cannot add section $title"; }
        }
    }
    # If $section is empty, empty %START-AUTO($title)..%END-AUTO($title) section in $cgal_buf
    else
    {
        $section = "$warning\n%START-AUTO($title)\n%END-AUTO($title)";

        # If %START-AUTO..%END-AUTO section exists, empty it
        if ($cgal_buf =~ s/($warning\n)?%START-AUTO\(\Q$title\E\).*?%END-AUTO\(\Q$title\E\)/$section/sm)
        {
            # Notify user
            print "  WARNING: section $title is empty!\n" unless ($title eq '\ccCreation');
        }
    }

    # Return updated CGAL buffer
    return $cgal_buf;
}


# Insert doxygen-generated documentation in CGAL Reference Manual's buffer
# Params:
# - Concept/struct/class/... to document (without namespace nor template parameters)
# - buffer containing a CGAL Reference Manual template
# - buffer containing a doxygen-generated latex file reformated for CGAL
# - Insert missing %START-AUTO..%END-AUTO sections?
# Return value: updated CGAL buffer
sub merge_manuals
{
    # Get parameters:
    # - Concept/struct/class/... to document (without namespace nor template parameters)
    my $item_to_document = shift;
    # - buffer containing a CGAL Reference Manual template
    my $cgal_buf = shift;
    # - buffer containing a doxygen-generated latex file reformated for CGAL
    my $doxy_buf = shift;

    # Uncomment the next lines to test that automatic sections are properly *created*
    # $cgal_buf =~ s/$warning\s%START-AUTO\(\\ccInclude\)\s*(\\ccInclude\{.*?\}\s)\s*%END-AUTO\(\\ccInclude\)\s*/$1/smg;
    # $cgal_buf =~ s/$warning\s%START-AUTO\(.*?\).*?%END-AUTO\(.*?\)\s*//smg;

    # Extract from $cgal_buf the part about $item_to_document
    if ($cgal_buf =~ s/(.*)(^\s*\\begin\{ccRef.*?\b$item_to_document[\s<\}].*?\\end\{ccRef.*?\}\s*)(.*)//sm)
    {
        my $start            = $1;
        my $part_to_document = $2;
        my $end              = $3;

        # Remove the placeholder text generated by cc_ref_wizard
        # before inserting the generated documentation.
        $part_to_document = remove_cc_ref_wizard_placeholders($part_to_document);

        # Security: empty all %START-AUTO..%END-AUTO sections
        $part_to_document =~ s/($warning\n)?(%START-AUTO\(.*?\)).*?(%END-AUTO\(.*?\))/$1$2\n$3/smg;

        # Get list of sections present in either file
        my %actual_section_titles;
        my $all_titles_pattern = get_any_section_title_pattern();
        while ($part_to_document =~ m/($all_titles_pattern)/g) {
            $actual_section_titles{$1} = "true";
        }
        while ($doxy_buf =~ m/($all_titles_pattern)/g) {
            $actual_section_titles{$1} = "true";
        }

        # Copy each section's documentation
        foreach my $title (keys %actual_section_titles) {
            $part_to_document = insert_manual_section($part_to_document, $doxy_buf, $title);
        }

        # Insert back $part_to_document in the buffer
        $cgal_buf = $start . $part_to_document . $end;
    }
    else
    {
        warn "INTERNAL ERROR: cannot insert doxygen-generated documentation in CGAL Reference Manual";
    }

    # Return updated CGAL buffer
    return $cgal_buf;
}


# Print usage and exit
sub usage
{
print <<"END_USAGE";
copy_doxygen_latex_doc extracts a documentation from a doxygen-generated latex file and inserts it in a CGAL Reference Manual's latex file.

Usage:
copy_doxygen_latex_doc [options] item_to_document doxygen_generated_documentation.tex reference_manual.tex
    item_to_document    Concept/struct/class/... to document (without namespace nor template parameters)
    -h, --help          Print this help
    -v, --verbose       Verbose mode
    -d, --debug         Debug mode

See generate_reference_manual usage for details.
END_USAGE

exit;
}


#######
# Main
#######

# Variables
my $item_to_document = undef;                   # Concept/struct/class/... to document (without namespace nor template parameters)
my $doxygen_generated_file = undef;             # Input file
my $cgal_manual_file = undef;                   # Output file

# Decode parameters
if ($#ARGV == -1) {                             # If no parameter
    usage();
}
foreach my $arg_num (0 .. $#ARGV)
{
    my $arg = $ARGV[$arg_num];
    if ($arg =~ /^(-h|--help)$/) {
        usage();
    } elsif ($arg =~ /^(-d|--debug)$/) {
        $debug = 1;
    } elsif ($arg =~ /^(-v|--verbose)$/) {
        $verbose = 1;
    } elsif ($arg =~ /^-/) {                    # If unknown option
        usage();
    } else {                                    # Item to document or input file or output file
        if (not defined($item_to_document)) {
            $item_to_document = $arg;
        } elsif (not defined($doxygen_generated_file)) {
            $doxygen_generated_file = $arg;
        } elsif (not defined($cgal_manual_file)) {
            $cgal_manual_file = $arg;
        }
    }
}
if (not defined($cgal_manual_file)) {           # If item to document or input file or output file is missing
    usage();
}

# Read doxygen-generated documentation
open(DOXYGEN_DOC, "< $doxygen_generated_file")
    or die "Can\'t open $doxygen_generated_file: $!";
undef $/; # set slurp mode
my $doxygen_generated_buffer = <DOXYGEN_DOC>;
close(DOXYGEN_DOC)
    or die "Can\'t close $doxygen_generated_file: $!";

# Read CGAL template Reference Manual
open(CGAL_MANUAL, "< $cgal_manual_file")
    or die "Can\'t open $cgal_manual_file: $!";
undef $/; # set slurp mode
my $cgal_manual_buffer = <CGAL_MANUAL>;
close(CGAL_MANUAL)
    or die "Can\'t close $cgal_manual_file: $!";

# Get type of the item to document: "class/struct", "concept" or "function"
my $item_type;
if (($doxygen_generated_file =~ /.*\/class/) or ($doxygen_generated_file =~ /.*\/struct/))
{
    if ($cgal_manual_buffer =~ /\\begin\{ccRefConcept\}/) {
        $item_type = "concept";
    } else {
        $item_type = "class/struct";
    }
} else {
    $item_type = "function";
}

# Format it to match CGAL Reference Manual's format
my $formated_doxygen_buffer;
if (($doxygen_generated_file =~ /.*\/class/) or ($doxygen_generated_file =~ /.*\/struct/))
{
    $formated_doxygen_buffer = format_doxygen_class_doc($item_to_document,
                                                        $doxygen_generated_buffer,
                                                        $item_type);
} else {
    $formated_doxygen_buffer = format_doxygen_function_doc($item_to_document,
                                                           $doxygen_generated_buffer);
}

# Debug stuff: write formated doxygen output to .doxy file
if ($debug)
{
    my $formated_doxygen_file = "$cgal_manual_file.doxy";
    open(FORMATED_DOXYGEN_DOC, "> $formated_doxygen_file")
        or die "Can\'t open $formated_doxygen_file: $!";
    (print FORMATED_DOXYGEN_DOC $formated_doxygen_buffer)
        or die "Can\'t write to $formated_doxygen_file: $!";
    close(FORMATED_DOXYGEN_DOC)
        or die "Can\'t close $formated_doxygen_file: $!";
}

# Debug stuff: backup output file to .bak file
if ($debug)
{
    my $backup = "$cgal_manual_file.bak";
    copy($cgal_manual_file, $backup)
        or die "Can\'t copy $cgal_manual_file to $backup: $!";
}

# Insert formated doxygen output in CGAL Reference Manual's buffer
$cgal_manual_buffer = merge_manuals($item_to_document,
                                    $cgal_manual_buffer,
                                    $formated_doxygen_buffer);

# Write CGAL Reference Manual
open(CGAL_MANUAL, "> $cgal_manual_file")
    or die "Can\'t open $cgal_manual_file: $!";
(print CGAL_MANUAL $cgal_manual_buffer)
    or die "Can\'t write to $cgal_manual_file: $!";
close(CGAL_MANUAL)
    or die "Can\'t close $cgal_manual_file: $!";

