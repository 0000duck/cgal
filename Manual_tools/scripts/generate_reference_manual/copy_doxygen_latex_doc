#!/usr/bin/perl -w

################################################################
# copy_doxygen_latex_doc
#
# Extract documentation from a doxygen-generated latex file
# and insert it in a CGAL Reference Manual's latex file
#
# Laurent Saboret, INRIA, 2005-2008

################################################################

use strict;
use File::Copy;


##################
# Global variables
##################

# List of sections in a CGAL Reference Manual latex file.
# The list order defines the default position when a section is inserted.
my @known_section_titles = ('\ccDefinition', '\ccParameters', '\ccInheritsFrom', '\ccRefines',
'\ccGeneralizes', '\ccIsModel', '\ccHeading{Design Pattern}', '\ccTypes', '\ccConstants',
'\ccHeading{Variables}', '\ccCreation', '\ccOperations', '\ccHasModels', '\ccImplementation',
'\ccExample', '\ccSeeAlso');

# List of placeholder lines generated by cc_ref_wizard.
# They will be replaced by the generated documentation.
my @placeholders = (
    'The \w+ \\\\ccRefName\\\\ does this and that\.',
    '\\\\ccGlobalFunction\{void \w+\(\);\}',
    'Concept',
    'ThisConcept \\\\\\\\',
    'ThatConcept',
    '\\\\ccNestedType\{TYPE\}\{some nested types\}',
    '\\\\ccConstructor\{\w+\(\);\}\{default constructor\.\}',
    '\\\\ccMethod\{void foo\(\);\}\{some member functions\}',
    '\\\\ccc\{[Ss]ome_\w+\}[,\.]',
    '[Ss]ome(\\\\_\w+)+[,\.]',
);

# Conversion table from clear text to macro names
my %macro_names = (
    '\ccHeading{Has Models}' => '\ccHasModels',
    '\ccHeading{Is Model for the Concepts}' => '\ccIsModel',
    '\ccHeading{Refines}' => '\ccRefines',
    '\ccHeading{Design Pattern}' => '\ccHeading{Design Pattern}',
#   '\ccHeading{Parameters}' => '\ccParameters',
    '\ccHeading{Inherits From}' => '\ccInheritsFrom',
    '\ccHeading{Generalizes}' => '\ccGeneralizes',
    '\ccHeading{Requirements}' => '\ccRequirements',
    '\ccHeading{Access Functions}' => '\ccAccessFunctions',
    '\ccHeading{Query Functions}' => '\ccQueryFunctions',
    '\ccHeading{Predicates}' => '\ccPredicates',
    '\ccHeading{Modifiers}' => '\ccModifiers',
    '\ccHeading{Implementation}' => '\ccImplementation',
);

# Warning sentence before automatically generated sections
my $warning = "% The section below is automatically generated. Do not edit!";

# Default variable name for \ccMethod
my $creation_variable = '\ccCreationVariable{a}  %% choose variable name for \ccMethod below';


###########
# Functions
###########

# Remove the placeholder text generated by cc_ref_wizard
# before inserting the generated documentation.
# Param: a buffer containing a CGAL Reference Manual template
# Return value: the formatted buffer
sub remove_cc_ref_wizard_placeholders
{
    # Get parameter: buffer containing a CGAL Reference Manual template
    my $cgal_buf = shift;

    # Remove any line in @placeholders
    foreach my $regex (@placeholders) {
        $cgal_buf =~ s/^$regex\n+//smg;
    }

    return $cgal_buf;
}


# Construct a pattern that matches any section title
sub get_any_section_title_pattern
{
    # Match \ccHeading{...}
    my $pattern = "(\\\\ccHeading\\\{.*?}";

    # Match any title in @known_section_titles
    foreach my $t (@known_section_titles) {
        $pattern = $pattern . "|\Q$t\E";
    }

    $pattern = $pattern . ")";

    return $pattern;
}


# Unmangle characters mangled for Latex to get regular C++ code.
# See latex_mangle() above.
# Param: the buffer to format
# Return value: the formatted buffer
sub latex_unmangle
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Avoid consecutive spaces/tabs to ease parsing in the rest of this script
    $buf =~ s/( |\t)+/ /g;

    # Unmangle _, ~, <, >, *, &, [] characters mangled for Latex
    # to get regular C++ code (mangled back at end of script)
    $buf =~ s/\\_\\-/_/g;                       # \_\- -> _
    $buf =~ s/\$\\sim\$/~/g;                    # $\sim$ -> ~
    $buf =~ s/\$<\$/</g;                        # $<$ -> <
    $buf =~ s/\$>\$/>/g;                        # $>$ -> >
    $buf =~ s/\$\\ast\$/\*/g;                   # $\ast$ -> *
    $buf =~ s/\\&/&/g;                          # \& -> &
    $buf =~ s/\[\$\\,\$\]/\[\]/g;               # [$\,$] -> []

    # Remove Latex expressions that cgal_manual does not understand in macros:
    # \-, \char`\"{}, \par, \hspace, \tt, \pageref, \rm, \bf, \em, \label, \index,
    # \setlength
    $buf =~ s/\\-//g;                           # remove \-
    $buf =~ s/\\char`\\"\{\}/"/g;               # \char`\"{} -> "
    $buf =~ s/\\par\b//g;                       # remove \par (single word)
    $buf =~ s/\\hspace\{.*?\}//g;               # remove \hspace{...}
    #
    # loop to remove nested expressions
    for my $i (1..5) {
        $buf =~ s/\\pageref\{\w*\}//g;          # remove \pageref{...}
        $buf =~ s/\{\\rm\s+[^\{]*?\}//smg;      # remove {\rm ...}
        $buf =~ s/\{\\tt\s+([^\{]*?)\}/$1/smg;  # replace {\tt xxx} by xxx
        $buf =~ s/\{\\bf\s+([^\{]*?)\}/$1/smg;  # replace {\bf xxx} by xxx
        $buf =~ s/\{\\em\s+([^\{]*?)\}/$1/smg;  # replace {\em xxx} by xxx
        $buf =~ s/\\hfill\\label\{\w*\}//g;     # remove \hfill\label{...}
        $buf =~ s/\\label\{\w*\}//g;            # remove \label{...}
        $buf =~ s/\\doxyref\{(.*?)\}\{p\.\}\{.*?\}/$1/smg;
                                                # replace \doxyref{xxx}{p.}{...} by xxx
        $buf =~ s/\{\\footnotesize\s+(.*?)\s*\}\\\\/$1/smg;
                                                # replace {\footnotesize xxx} by xxx
    }
    #
    $buf =~ s/\\index\{[^\\]*\}//g;             # remove \index{...}
    $buf =~ s/\\setlength\{\\rightskip\}\{0pt plus 5cm\}//g;
                                                # remove \setlength{\rightskip}{0pt plus 5cm}

    # Return the formatted string
    return $buf;
}


# Remove formatting specific to doxygen
# Param: the buffer to format
# Return value: the formatted buffer
sub doxygen_latex_to_latex
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Remove CGAL_*_NAMESPACE keywords that doxygen doesn't parse properly
    # when the preprocessor is turned off.
    $buf =~ s/CGAL_\w*_NAMESPACE\s*//g;

    # Remove doxygen comments that are not interesting
    $buf =~ s/Implements \S*(\.| \.)?//g;       # Remove from "Implements" to end of sentence
    $buf =~ s/Reimplemented from \S*(\.| \.)?//g; # Same thing with "Reimplemented from"
    $buf =~ s/Implemented in .*//g;             # Same thing with "Implemented in"
    $buf =~ s/Reimplemented in .*//g;           # Same thing with "Reimplemented in"
    $buf =~ s/\[package\]//g;

    # Add a \n before (parameters) descriptions to ease parsing
    $buf =~ s/\n?\\begin\{Desc\}/\n\\begin\{Desc\}/smg;

    # "Desc" is a doxygen style based on "description",
    # "CompactItemize" is a doxygen style based on "itemize"
    $buf =~ s/\{Desc\}/\{description\}/g;
    $buf =~ s/\{CompactItemize\}/\{itemize\}/g;

    # Return the formatted string
    return $buf;
}


# Mangle C++ code for latex.
# Wrap words surrounded by simple quotes and C++ names (types/functions/variables) by \ccc{}.
# Emphasize words surrounded by double quotes using \em [L. Saboret's extension].
# See latex_unmangle() above.
# Param: the buffer to format
# Return value: the formatted buffer
sub latex_mangle
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Local variables when parsing buffer line by lines
    my ($line, @lines);

    # There is no \ccSubHeading macro yet
    $buf =~ s/\\ccSubHeading\{/\\subsubsection\{/g;

    # Wrap words surrounded by simple quotes by \ccc{} [L. Saboret's extension].
    # We add carriage returns around \ccc{} for next line by line substitutions.
    $buf =~ s/\'(((::|\w)+(<.*?>)?)+)\'/\n\\ccc{$1\}\n/g;

    # \ccHeading, \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable & \ccFunction
    # first curly braces pair must contain plain C++ code.
    # \subsubsection must protect _ as \_.
    # For the other lines, we wrap C++ types by \ccc{}.
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {
        # if first curly braces pair of a cgal_manual macro
        if ($line =~ /\\(ccHeading|ccSubHeading|ccNestedType|ccEnum|ccConstructor|ccMethod|ccVariable|ccFunction)/
             || $line =~ /\\ccc/)
        {
            # nothing to do
        }
        elsif ($line =~ /\\subsubsection/)
        {
            $line =~ s/_/\\_/g; #  _ -> \_
        }
        else
        {
            # Wrap C++ types, including template params, by \ccc{}.
            # We add carriage returns around \ccc{} for next line by line substitution.
            $line =~ s/((\w*(_|::)\w*(<.*?>)?)+)/\n\\ccc{$1\}\n/g;
        }
        $buf = $buf . $line . "\n";             # concat lines back to $buf
    }

    # \ccHeading, \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable & \ccFunction
    # first curly braces pair and \ccc expressions must contain plain C++ code.
    # The other lines must contain regular latex text => we mangle back
    # ~, <, >, *, &, [] characters (see latex_unmangle() above).
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {
        # if first curly braces pair of a cgal_manual macro: plain C++ code
        if ($line =~ /\\(ccHeading|ccSubHeading|ccNestedType|ccEnum|ccConstructor|ccMethod|ccVariable|ccFunction)/
         || $line =~ /\\ccc/)
        {
            # Remove extra spaces to please cgal_manual
            $line =~ s/< (.*?) >/<$1>/g;
            $line =~ s/ & /& /g;
            $line =~ s/ \(/\(/g;
        }
        # else: wrap C++ code for latex
        else
        {
            # Mangle back special latex characters
            $line =~ s/~/\$\\sim\$/g;           # ~ -> $\sim$
            $line =~ s/</\$<\$/g;               # < -> $<$
            $line =~ s/>/\$>\$/g;               # > -> $>$
            $line =~ s/\*/\$\\ast\$/g;          # * -> $\ast$
            $line =~ s/&/\\&/g;                 # & -> \&
            $line =~ s/\[\]/\[\$\\,\$\]/g;      # [] -> [$\,$]
        }
        $buf = $buf . $line . "\n";             # concat lines back to $buf
    }

    # Remove extra carriage returns around \ccc{} expressions
    $buf =~ s/\n(\\ccc{.*?\})\n/$1/smg;

    # Emphasize words surrounded by double quotes using \em [L. Saboret's extension].
    $buf =~ s/"(.*?)"/\{\\em $1\}/smg;

    # Return the formatted string
    return $buf;
}


# Remove blank lines in the second curly braces pair of macros,
# that cgal_manual does not understand
# Param: the buffer to format
# Return value: the formatted buffer
sub remove_blank_lines_in_macros
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Remove trailing spaces to improve pattern matching
    $buf =~ s/ +\n/\n/g;

    # Remove blank lines in the second curly braces pair of macros,
    # that cgal_manual does not understand
    if ($buf =~ m/(.*?)\\paragraph(.*)/sm) {    # split $buf in $definition and $macros
        my $definition = $1;
        my $macros = $2;
        $macros =~ s/\n+/\n/g;                  # remove blank lines from $macros
        $buf = $definition . '\paragraph' . $macros;
    }                                           # put back in $buf

    # Return the formatted string
    return $buf;
}


# If $buffer matches $pattern, return $buffer, else return an empty string
sub keep_only_if_match
{
    my $buffer = shift;
    my $pattern = shift;

    if ($buffer =~ /\b\Q$pattern\E\b/sm) {
        return $buffer;
    } else {
        return "";
    }
}


# Convert clear text to macro name
# Param: heading name in doxygen latex doc, of the form "Heading ...:" or "Subheading ..."
# Return value: the formatted macro name
sub convert_heading_name
{
    my $heading = shift;

    # Convert to \ccHeading or \subsubsection
    $heading =~ s/^Heading (.*?):?$/\\ccHeading\{$1\}/;
    $heading =~ s/^Subheading (.*?):?$/\\ccSubHeading\{$1\}/;

    # Use CGAL Manual shortcut if available
    if (defined($macro_names{$heading})) {
        $heading = $macro_names{$heading};
    }

    return $heading;
}


# L. Saboret's formatting extensions:
# Extract @headings sections from \Definition section.
# Param: the buffer to format
# Return value: the formatted buffer
sub extented_format_headings
{
    # Get parameter: buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Extract @headings sections from from detailed section.
    # @heading is in fact an alias to "Heading".
    # - the macro name starts at "Heading" and ends with ":".
    # - the macro content lies on a unique line, except lists.
    #   Doxygen may concat lines, thus we also stop at the first dot.
    #
    # case of macros with list
    while ($buf =~ s/([^\}])\b(Heading [^\n]*?:)\s*([^\n\.]*?\\begin\{itemize\}.*?\\end\{itemize\}.*?)([\n\.])/$1/sm)
    {
        my $macro_name = convert_heading_name($2);
        my $macro_content = "$3$4";
        unless ($4 =~ /\n/) {
            $macro_content .= "\n";
        }
        unless ($buf =~ /\Q$macro_name\E/) { # if needed, add $macro_name section before \ccSeeAlso
            $buf =~ s/\\ccSeeAlso/$macro_name\n\n\n\n\\ccSeeAlso/sm;
        }
        $buf =~ s/\n\n\\ccSeeAlso/$macro_content\n\n\\ccSeeAlso/sm;
    }
    # case of macros on 1 line
    while ($buf =~ s/([^\}])\b(Heading [^\n]*?:)\s*(.*?)([\n\.])/$1/sm)
    {
        my $macro_name = convert_heading_name($2);
        my $macro_content = "$3$4";
        unless ($4 =~ /\n/) {
            $macro_content .= "\n";
        }
        unless ($buf =~ /\Q$macro_name\E/) { # if needed, add $macro_name section before \ccSeeAlso
            $buf =~ s/\\ccSeeAlso/$macro_name\n\n\n\n\\ccSeeAlso/sm;
        }
        $buf =~ s/\n\n\\ccSeeAlso/$macro_content\n\n\\ccSeeAlso/sm;
    }

    # If the \ccHasModels section is a list, flatten it
    # (for compatibility with the rest of CGAL manual).
    if ($buf =~ s/(.*?\\ccHasModels\n+[^\n]*?)\\begin\{itemize\}\n(.*?)\\end\{itemize\}(.*)//sm)
    {
        # Extract models from \ccHasModels section
        my $start  = $1;
        my $models = $2;
        my $end    = $3;

        # Remove \item list separators and
        # add \\ at the end of each line to force EOL
        $models =~ s/\\item\s/  \\\\\n/smg;
        $models =~ s/^ *\\\\\n//smg;

        # Insert back $models in the buffer
        $buf = $start . "\n\n" . $models . $end;
    }

    # Return the formatted string
    return $buf;
}


# Rename \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable and \ccFunction expressions.
# Params:
# - concept/struct/class/... to document (without namespace)
# - type of the item to document: "class/struct" or "function"
# - buffer containing a doxygen-generated latex file
# Return value: the formatted buffer
sub format_curly_brace_pairs_expressions
{
    # Get parameters:
    # - concept/struct/class/... to document (without namespace)
    my $item_to_document = shift;
    # - type of the item to document: "class/struct" or "function"
    my $item_type = shift;
    # - buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Rename \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable and \ccFunction expressions
    # and open a curly brace for the expression's comment
    # - if class/struct...
    if ($item_type =~ m/class\/struct/)
    {
        $buf =~ s/\\paragraph\{typedef.* (\w+)((\[.*\])?)\}/\\ccNestedType\{$1$2\}\n\{/g;
        $buf =~ s/\\paragraph\{enum\s(.*)\}/\\ccEnum\{enum $1\}\n\{/g;
        $buf =~ s/\\item\[Enumerator/\\item\[Enumeration values/g;
        $buf =~ s/\\paragraph\{\Q$item_to_document\E\s+\((.*)\}/\\ccConstructor\{$item_to_document \($1;\}\n\{/g;
        $buf =~ s/\\paragraph\{([^\(\)]*?)\}/\\ccVariable\{$1;\}\n\{/g;
        $buf =~ s/\\paragraph\{(.*\(.*\).*)\}/\\ccMethod\{$1;\}\n\{/g;
    }
    # - ...or if function
    else
    {
        $buf =~ s/\\paragraph\{(.*)\}/\\ccFunction\{$1;\}\n\{/g;
    }

    # Move [static], [virtual], [protected] comments at the beginning of the expression's comment.
    $buf =~ s/(\[.*?\])(;?)\}\n\{/$2\}\n\{\n$1 \\\\/g;

    # Remove brackets in curly braces pairs (restored below):
    # - replace \begin{xxx}...\end{xxx} by \begin((xxx))...\end((xxx))
    $buf =~ s/\\begin\{(.*?)\}/\\begin\(\($1\)\)/smg;
    $buf =~ s/\\end\{(.*?)\}/\\end\(\($1\)\)/smg;
    # - replace \{ and \} by &#123; and &#125;
    $buf =~ s/\\\{/&\#123\;/g;
    $buf =~ s/\\\}/&\#125\;/g;

    # Close curly braces pairs
    # Note: cgal_manual does not understand lists inside the second curly braces pair
    # of \ccXXX expressions => we put them after
    $buf =~ s/\{([^\}]*?)(\\begin\(\(description\)\).*?\\end\(\(description\)\))(\n+)\\cc/\{$1\n\}\n\\ccGlue\n$2\n\\ccGlue$3\\cc/smg;
    $buf =~ s/\{([^\}]*?)(\n+)\\cc/\{$1\n\}\n\\ccGlue$2\\cc/smg;

    # Restore brackets:
    # - replace \begin((xxx))...\end((xxx)) by \begin{xxx}...\end{xxx}
    $buf =~ s/\\begin\(\((.*?)\)\)/\\begin\{$1\}/smg;
    $buf =~ s/\\end\(\((.*?)\)\)/\\end\{$1\}/smg;
    # - replace back \{ and \}
    $buf =~ s/&\#123\;/\\\{/g;
    $buf =~ s/&\#125\;/\\\}/g;

    # \ccMethod does not support destructors and there is no \ccDestructor
    # macro => remove destructors
    if ($item_type =~ m/class\/struct/)
    {
        $buf =~ s/\\ccMethod\{.*?~\Q$item_to_document\E\s.*?\}\n\{.*?\}\n\\ccGlue\n//smg;
    }

    # Security: remove blank lines in curly braces pairs
    $buf =~ s/\{(\n)+/\{\n/g;
    $buf =~ s/(\n)+\}/\n\}/g;

    # Return the formatted string
    return $buf;
}


# Format a buffer containing a doxygen-generated documentation of a class/struct,
# in latex, to match CGAL Reference Manual's format.
# Params:
# - class/struct name (without namespace)
# - buffer containing a doxygen-generated latex file
# Return value: the formatted buffer
sub format_doxygen_class_struct_doc
{
    # Get parameters:
    # - class/struct name (without namespace)
    my $className = shift;
    # - buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Local variables when parsing buffer line by lines
    my ($line, @lines);

    # Unmangle characters mangled for Latex to get regular C++ code
    # (mangled back at end of script)
    $buf = latex_unmangle($buf);

    # Remove formatting specific to doxygen
    $buf = doxygen_latex_to_latex($buf);

    # Remove blank lines in the second curly braces pair of macros,
    # that cgal_manual does not understand
    $buf = remove_blank_lines_in_macros($buf);

    # Remove extra stuff and insert \ccSeeAlso title at the end of the document
    $buf =~ s/The documentation for this.*/\n\n\\ccSeeAlso\n\n\n/sm;

    # Rename "Heading Parameters:" comment in \ccDefinition section as \ccParameters [L. Saboret extension]
    # or insert a new section before \ccSeeAlso
    unless ($buf =~ s/\bHeading Parameters:\s*/\n\\ccParameters\n\n/sm) {
        $buf =~ s/\\ccSeeAlso/\\ccParameters\n\n\n\\ccSeeAlso/sm;
    }

    # Insert template params at the beginning of \ccParameters section
    # (from detailed section)
    if ($buf =~ s/\\subsubsection\*\{(template.*)\}\n//)
    {
        # extract template params from \subsubsection* line
        my $parameters = $1;

        # Split template declaration(s) on several lines
        $parameters =~ s/(template<|, |> )(class|struct|typename)/$1\n$2/g; # add \n before each param
        $parameters =~ s/(class|struct) (\w+::)*\Q$className\E.*/$1 $className;/g;
                                                # keep only class/struct name on last line
        $parameters =~ s/\n/  \\\\\n/smg;       # add \\ at the end of each line to force EOL
        $parameters =~ s/^ *\\\\\n//smg;        #                ""

        # Insert template params at the beginning of \ccParameters section
        $buf =~ s/\\ccParameters\n/\\ccParameters\n\n$parameters\n/;
    }

    # L. Saboret's formatting extensions:
    # Extract @headings sections from \Definition section.
    $buf = extented_format_headings($buf);

    # L. Saboret's formatting extensions:
    # Move subheadings from brief to detailed section
    while ($buf =~ s/\\begin\{Indent\}(Subheading .*?)\n\\begin\{itemize\}\n\\item\n(.*?)$/\\item\n$2/sm)
    {
        my $subheading_name = $1;
        my $next_documented_item = $2;
        $next_documented_item =~ s/ & /& /g;
        $buf =~ s/(\\paragraph\{\Q$next_documented_item\E\})/
                 "\n" . convert_heading_name($subheading_name) . "\n\n$1\n"/e;
    }

    # Copy enumerations values from brief to detailed section
    @lines = split(/\n/, $buf);
    $buf = "";
    foreach $line (@lines) {                    # for each line of buffer
        # if incomplete enum declaration in detailed section
        if ($line =~ /\\paragraph\{enum\s+(\w+)\}/) {
            my $enumName = $1;
            # Get enum values from brief section
            my $enumValues = "...";
            if ($buf =~ m/enum\s+\Q$enumName\E\s+\\\{(.*?)\\\}/sm) {
                $enumValues = $1;
                $enumValues =~ s/\n/ /smg;      # Remove carriage returns
            }
            # Copy enum values to detailed section
            $line =~ s/\\paragraph\{enum\s+\Q$enumName\E\}/\\paragraph\{enum $enumName \{$enumValues\};\}/
        }
        $buf = $buf . $line . "\n";             # concat line back to $buf
    }

    # Rename \ccDefinition title
    $buf =~ s/\\subsubsection\{Detailed Description\}/\\ccDefinition\n/;

    # Rename \ccTypes title
    $buf =~ s/\\subsubsection\{Member Typedef Documentation\}/\n\n\\ccTypes/;

    # Rename \ccConstants title
    $buf =~ s/\\subsubsection\{Member Enumeration Documentation\}/\n\n\\ccConstants\n/;

    # Rename \ccHeading{Variables} title
    $buf =~ s/\\subsubsection\{Member Data Documentation\}/\n\n\\ccHeading\{Variables\}\n/;

    # Rename \ccCreation title
    unless ($buf =~ m/\\subsubsection\{Constructor & Destructor Documentation\}/) {
        $buf =~ s/\\subsubsection\{Member Function Documentation\}/\\subsubsection\{Constructor & Destructor Documentation\}\n\\subsubsection\{Member Function Documentation\}/;
    }
    $buf =~ s/\\subsubsection\{Constructor & Destructor Documentation\}/\n\n\\ccCreation\n/;

    # Rename \ccOperations title
    $buf =~ s/\\subsubsection\{Member Function Documentation\}/\n\n\\ccOperations\n/;

    # Rename \ccNestedType, \ccEnum, \ccConstructor, \ccMethod, \ccVariable expressions
    $buf = format_curly_brace_pairs_expressions($className, "class/struct", $buf);

    # Remove CGAL:: prefix (implicit)
    $buf =~ s/CGAL::(\w+)/$1/g;

    # Mangle C++ code for latex.
    # Wrap words surrounded by simple quotes and C++ names (types/functions/variables) by \ccc{}.
    # Emphasize words surrounded by double quotes using \em [L. Saboret's extension].
    $buf = latex_mangle($buf);

    # Remove brief documentation
    my $all_titles_pattern = get_any_section_title_pattern();
    $buf =~ s/\\subsection.*?($all_titles_pattern)/\n\n$1/sm;

    # Return the formatted string
    return $buf;
}


# Format a buffer containing a doxygen-generated documentation of
# a function, in latex, to match CGAL Reference Manual's format.
# Params:
# - function name (without namespace)
# - buffer containing a doxygen-generated latex file
# Return value: the formatted buffer
sub format_doxygen_function_doc
{
    # Get parameters:
    # - function name (without namespace)
    my $functionName = shift;
    # - buffer containing a doxygen-generated latex file
    my $buf = shift;

    # Local variables when parsing buffer line by lines
    my ($line, @lines);

    # Unmangle characters mangled for Latex to get regular C++ code
    # (mangled back at end of script)
    $buf = latex_unmangle($buf);

    # Remove formatting specific to doxygen
    $buf = doxygen_latex_to_latex($buf);

    # Remove blank lines in the second curly braces pair of macros,
    # that cgal_manual does not understand
    $buf = remove_blank_lines_in_macros($buf);

    # Insert \ccSeeAlso title at the end of the document
    $buf = $buf . "\n\n\\ccSeeAlso\n\n\n";

    # Remove declaration of other functions
    # (loop to remove consecutive functions)
    for my $i (1..5) {
        $buf =~ s/(\\paragraph\{.*?)(\\paragraph\{|\\ccSeeAlso)/keep_only_if_match($1, $functionName) . "$2"/smge;
    }

    # Format "Heading Parameters:" comments [L. Saboret extension]
    $buf =~ s/\bHeading Parameters:\s*(\\begin\{description\}\s*\\item)\[Parameters:\]/$1\[Template Parameters:\]/smg;

    # Insert \ccParameters section before \ccSeeAlso
    # (from brief section)
    if ($buf =~ s/\\subsubsection\*\{Functions\}\n\\begin\{itemize\}\n(.*?)\\end\{itemize\}//sm)
    {
        # extract template params from \subsubsection*{Functions} section
        my $parameters = $1;

        # Keep only lines declaring the $functionName template(s)
        @lines = ($parameters =~ /^.*\b\Q$functionName\E\b.*$/mg);
        $parameters = join("\n", @lines);

        # Split template declaration(s) on several lines
        $parameters =~ s/(template<|, |> )(class|struct|typename)/$1\n$2/g; # add \n before each param
        $parameters =~ s/(template\s*<.*?>)\s*/$1\n/smg;
                                                # keep return type on separate line
        $parameters =~ s/\s*\b\Q$functionName\E\b(.*)/\n$functionName$1;\n/g;
                                                # keep function name on separate line
        $parameters =~ s/\n/  \\\\\n/smg;       # add \\ at the end of each line to force EOL
        #$parameters =~ s/^ *\\\\\n//smg;        #                ""

        # insert $parameters before \ccSeeAlso
        $buf =~ s/\\ccSeeAlso/\\ccParameters\n\n$parameters\n\n\n\\ccSeeAlso/sm;
    }

    # L. Saboret's formatting extensions:
    # Extract @headings sections from \Definition section.
    $buf = extented_format_headings($buf);

    # Rename \ccDefinition title
    $buf =~ s/\\subsubsection\{Function Documentation\}/\\ccDefinition\n/;

    # Rename \ccFunction expressions
    $buf = format_curly_brace_pairs_expressions($functionName, "function", $buf);

    # Remove CGAL:: prefix (implicit)
    $buf =~ s/CGAL::(\w+)/$1/g;

    # Mangle C++ code for latex.
    # Wrap words surrounded by simple quotes and C++ names (types/functions/variables) by \ccc{}.
    # Emphasize words surrounded by double quotes using \em [L. Saboret's extension].
    $buf = latex_mangle($buf);

    # Remove brief documentation
    my $all_titles_pattern = get_any_section_title_pattern();
    $buf =~ s/\\subsection.*?($all_titles_pattern)/\n\n$1/sm;

    # Return the formatted string
    return $buf;
}


# Insert a section of a doxygen-generated documentation in CGAL Reference Manual's buffer
# Params:
# - buffer containing a CGAL Reference Manual template
# - buffer containing a doxygen-generated latex file reformated for CGAL
# - section's title
# - Insert missing %START-AUTO..%END-AUTO sections?
# Return value: updated CGAL buffer
sub insert_manual_section
{
    # Get parameters:
    # - buffer containing a CGAL Reference Manual template
    my $cgal_buf = shift;
    # - buffer containing a doxygen-generated latex file reformated for CGAL
    my $doxy_buf = shift;
    # - section's title
    my $title = shift;

    # Construct a pattern that matches any section title
    my $all_titles_pattern = get_any_section_title_pattern();

    # Extract $title section from $doxy_buf
    my $section = "";
    if ($doxy_buf =~ /^\s*\Q$title\E\s(.*?)\s+$all_titles_pattern\s/sm) {
        $section = $1;
        $section =~ s/^\s+//s;                  # Remove heading & trailing spaces
        $section =~ s/\s+$//s;                  # and extra carriage returns
    }

    # If $section is not empty, copy it to $cgal_buf
    # If $cgal_buf doesn't already contain $title, add it
    # If $cgal_buf doesn't already contain the %START-AUTO($title)..%END-AUTO($title) section, add it
    if ($section ne "")
    {
        # Add $warning\n%START-AUTO($title)..%END-AUTO($title) around $section
        $section = "$warning\n%START-AUTO($title)\n\n" . $section . "\n\n%END-AUTO($title)";

        # Add \ccCreationVariable after \ccCreation
        my $title_extra = ($title eq '\ccCreation') ? "\n$creation_variable" : "";

        # If %START-AUTO..%END-AUTO section exists, replace it
        unless ($cgal_buf =~ s/($warning)*\s*%START-AUTO\(\Q$title\E\).*?%END-AUTO\(\Q$title\E\)/$section/sm)
        {
            # Else, insert a new %START-AUTO..%END-AUTO section
            my $success = 0;                # Successful insertion?

            # If section's title exists, insert %START-AUTO..%END-AUTO section after it
            if ($cgal_buf =~ s/^(\s*\Q$title\E\b.*?)(\s+$all_titles_pattern\s)/$1\n\n$section$2/sm) {
                $success = 1;
            } else {
                # Else, insert title + %START-AUTO..%END-AUTO section before
                # the first section that appears after $title in @known_section_titles.
                my $after_title = 0;        # indicate if we passed $title in @known_section_titles
                foreach my $t (@known_section_titles) {
                    if ($after_title) {
                        if ($cgal_buf =~ s/(\s+)(\Q$t\E\b)/$1$title$title_extra\n\n$section$1$2/sm) {
                            $success = 1;
                            last;
                        }
                    }
                    if ($t eq $title) { $after_title = 1; }
                }

                # Else, insert title + %START-AUTO..%END-AUTO section
                # at the end of the buffer.
                unless ($success) {
                    $success = ($cgal_buf =~ s/(\s+)(\\end\{ccRef)/$1$title$title_extra\n\n$section$1$2/sm);
                }
            }

            # Notify user
            if ($success) { print "  Insert section $title\n"; }
            else          { warn  "  Cannot insert section $title"; }
        }
    }
    # If $section is empty, empty %START-AUTO($title)..%END-AUTO($title) section in $cgal_buf
    else
    {
        $section = "$warning\n%START-AUTO($title)\n%END-AUTO($title)";
        $cgal_buf =~ s/($warning)*\s*%START-AUTO\(\Q$title\E\).*?%END-AUTO\(\Q$title\E\)/$section/sm;
    }

    # Return updated CGAL buffer
    return $cgal_buf;
}


# Insert doxygen-generated documentation in CGAL Reference Manual's buffer
# Params:
# - Concept/struct/class/... to document
# - buffer containing a CGAL Reference Manual template
# - buffer containing a doxygen-generated latex file reformated for CGAL
# - Insert missing %START-AUTO..%END-AUTO sections?
# Return value: updated CGAL buffer
sub merge_manuals
{
    # Get parameters:
    # - Concept/struct/class/... to document
    my $item_to_document = shift;
    # - buffer containing a CGAL Reference Manual template
    my $cgal_buf = shift;
    # - buffer containing a doxygen-generated latex file reformated for CGAL
    my $doxy_buf = shift;

    # Extract from $cgal_buf the part about $item_to_document
    if ($cgal_buf =~ s/(.*)(^\s*\\begin\{ccRef.*?\s*\{$item_to_document[\s<\}].*?\\end\{ccRef.*?\})(.*)//sm)
    {
        my $start            = $1;
        my $part_to_document = $2;
        my $end              = $3;

        # Remove the placeholder text generated by cc_ref_wizard
        # before inserting the generated documentation.
        $part_to_document = remove_cc_ref_wizard_placeholders($part_to_document);

        # Get list of sections present in either file
        my %actual_section_titles;
        my $all_titles_pattern = get_any_section_title_pattern();
        while ($part_to_document =~ m/($all_titles_pattern)/g) {
            $actual_section_titles{$1} = "true";
        }
        while ($doxy_buf =~ m/($all_titles_pattern)/g) {
            $actual_section_titles{$1} = "true";
        }

        # Copy each section's documentation
        foreach my $title (keys %actual_section_titles) {
            $part_to_document = insert_manual_section($part_to_document, $doxy_buf, $title);
        }

        # Insert back $part_to_document in the buffer
        $cgal_buf = $start . $part_to_document . $end;
    }

    # Return updated CGAL buffer
    return $cgal_buf;
}


# Print usage and exit
sub usage
{
print <<"END_USAGE";
copy_doxygen_latex_doc extracts a documentation from a doxygen-generated latex file and inserts it in a CGAL Reference Manual's latex file.

Usage:
copy_doxygen_latex_doc [options] item_to_document doxygen_generated_documentation.tex template_manual.tex
    -h, --help      Print this help
    -d, --debug     Debug mode

See generate_reference_manual usage for details.
END_USAGE

exit;
}


#######
# Main
#######

# Variables
my $item_to_document = undef;                   # Concept/struct/class/... to document
my $doxygen_generated_file = undef;             # Input file
my $cgal_manual_file = undef;                   # Output file
my $debug = 0;                                  # Debug mode?

# Decode parameters
if ($#ARGV == -1) {                             # If no parameter
    usage();
}
foreach my $arg_num (0 .. $#ARGV)
{
    my $arg = $ARGV[$arg_num];
    if ($arg =~ /^(-h|--help)$/) {
        usage();
    } elsif ($arg =~ /^(-d|--debug)$/) {
        $debug = 1;
    } elsif ($arg =~ /^-/) {                    # If unknown option
        usage();
    } else {                                    # Item to document or input file or output file
        if (not defined($item_to_document)) {
            $item_to_document = $arg;
        } elsif (not defined($doxygen_generated_file)) {
            $doxygen_generated_file = $arg;
        } elsif (not defined($cgal_manual_file)) {
            $cgal_manual_file = $arg;
        }
    }
}
if (not defined($cgal_manual_file)) {           # If item to document or input file or output file is missing
    usage();
}

# Read doxygen-generated documentation
open(DOXYGEN_DOC, "< $doxygen_generated_file")
    or die "Can\'t open $doxygen_generated_file: $!";
undef $/; # set slurp mode
my $doxygen_generated_buffer = <DOXYGEN_DOC>;
close(DOXYGEN_DOC)
    or die "Can\'t close $doxygen_generated_file: $!";

# Format it to match CGAL Reference Manual's format
my $formated_doxygen_buffer;
if (($doxygen_generated_file =~ /.*\/class/) or ($doxygen_generated_file =~ /.*\/struct/))
{
    $formated_doxygen_buffer = format_doxygen_class_struct_doc($item_to_document,
                                                               $doxygen_generated_buffer);
} else {
    $formated_doxygen_buffer = format_doxygen_function_doc($item_to_document,
                                                           $doxygen_generated_buffer);
}

# Debug stuff: write formated doxygen output to .doxy file
if ($debug)
{
    my $formated_doxygen_file = "$cgal_manual_file.doxy";
    open(FORMATED_DOXYGEN_DOC, "> $formated_doxygen_file")
        or die "Can\'t open $formated_doxygen_file: $!";
    (print FORMATED_DOXYGEN_DOC $formated_doxygen_buffer)
        or die "Can\'t write to $formated_doxygen_file: $!";
    close(FORMATED_DOXYGEN_DOC)
        or die "Can\'t close $formated_doxygen_file: $!";
}

# Debug stuff: backup output file to .bak file
if ($debug)
{
    my $backup = "$cgal_manual_file.bak";
    copy($cgal_manual_file, $backup)
        or die "Can\'t copy $cgal_manual_file to $backup: $!";
}

# Read CGAL template Reference Manual
open(CGAL_MANUAL, "< $cgal_manual_file")
    or die "Can\'t open $cgal_manual_file: $!";
undef $/; # set slurp mode
my $cgal_manual_buffer = <CGAL_MANUAL>;
close(CGAL_MANUAL)
    or die "Can\'t close $cgal_manual_file: $!";

# Insert formated doxygen output in CGAL Reference Manual's buffer
$cgal_manual_buffer = merge_manuals($item_to_document,
                                    $cgal_manual_buffer,
                                    $formated_doxygen_buffer);

# Write CGAL Reference Manual
open(CGAL_MANUAL, "> $cgal_manual_file")
    or die "Can\'t open $cgal_manual_file: $!";
(print CGAL_MANUAL $cgal_manual_buffer)
    or die "Can\'t write to $cgal_manual_file: $!";
close(CGAL_MANUAL)
    or die "Can\'t close $cgal_manual_file: $!";

