#!/usr/bin/ruby

require 'xml/libxml'

def normalize_declaration( decl )
  decl = decl.gsub( /\s+/, ' ' );
  decl = decl.gsub( /(\w) ([&()=:;,<>])/, '\1\2' );
  decl = decl.gsub( /([()=:;,<>]) (\w)/, '\1\2' );
  decl = decl.gsub( /([()=:;,<>]) ([&();,])/, '\1\2' );
  decl = decl.gsub( /([();,]) ([()=:;,<>])/, '\1\2' );
  if decl =~ /([^(]+[(])/ then
    decl=$1+remove_argnames($')
  end
  return decl
end


def split_typename( decl )
  nesting_level = 0
  position = 0
  result = ""
  decl.each_byte do |c|
    char = ""
    char << c
    #puts decl.slice( position, decl.length )
    case char
      when '<' then nesting_level += 1
      when '>' then nesting_level -= 1
      when /[,)]/
        if nesting_level == 0 then
          return result, decl.slice( position, decl.length )
        end
    end
    result << c
    position += 1
  end
  return result, ""
end

def remove_argnames( decl )
  result = ""
  until decl =~ /^[)]/ || decl == "" do
    type_with_default, decl = split_typename( decl )
    #puts "type with default: #{type_with_default}"
    # remove default
    if type_with_default =~ /^([^=]+)=/ then
      type = $1
    else
      type = type_with_default
    end
    # remove argname (possibly moving a trailing [] part 
    if type =~ /\s*(\*+)?\s*\w+(\[\w+\])?$/ then
      type = $`
      type += $1 if $1 != nil
      type += $2 if $2 != nil
    end
    result << type
    if( decl =~ /,/ ) then
      result << ","
      decl = $'
    end
    #puts "type: [#{type}] \t ......rest: #{decl}"
  end
  return result + decl
end


def match_and_consume( s, regex_string )
  printf "              match: [#{regex_string}] .. "
  regex = Regexp.new( regex_string )
  if s =~ regex then
    s = s.sub( regex, "" )
    puts " ok! remaining #{s}"
    return true
  end
  puts " no match."
  return false
end


# convenience class
class Declaration
  def initialize( name )
    @name = name
  end

  def match( regex_string )
    name = match_and_consume( name, regex_string )
  end

end

class Doxygen
  def initialize( filename )
    @doxy_xml=XML::Document.file(filename)
    @items = {}
  end

  def collect_items
    collect_compounds
    collect_global_items
  end

  def collect_compounds
    @doxy_xml.find( '/doxygen/compounddef[@kind=\'struct\' or @kind=\'class\']' ).each do |compound|
      compoundname=get_xpath_content(compound,'compoundname')
      location=compound.find('location').to_a.first
      lineno=location["line"]
      filename=location["file"]
      puts "compound idfier: #{compoundname} kind: #{compound['kind']}" # line: #{lineno} file: #{filename}"
      collect_members( compound, 'typedef' )
      collect_members( compound, 'function' )
    end
  end

  def collect_members( compound, kind )
    puts "members of kind #{kind}:"
    compound.find("sectiondef/memberdef[@kind=\'#{kind}\']").each do |memberdef|
      type=get_xpath_content(memberdef,'type')
      name=get_xpath_content(memberdef,'name')
      definition=get_xpath_content(memberdef,'definition')
      argsstring=get_xpath_content(memberdef,'argsstring')
      name="#{definition}#{argsstring}"
      location=memberdef.find('location').to_a.first
      lineno=location["line"]
      filename=location["file"]
      puts "  member: #{name} \ttype: #{type} \tline: #{lineno}" # file: #{filename}"
    end
  end

  def member_matches_texname( memberdef, texname, strip_const_from_return_types )
    is_const=""
    if memberdef['const'] == 'yes' then
      is_const = "const"
    end
    argsstring=get_xpath_content(memberdef,'argsstring')
    type=get_xpath_content(memberdef,'type')
    if strip_const_from_return_types then
      type=type.gsub( /_const_/, "_" )
    end
    name=get_xpath_content(memberdef,'name')
    doxyname="#{type} #{name}#{argsstring};"
    #puts "--- raw decl: #{doxyname}"
    doxyname=normalize_declaration( doxyname )
    #puts "--- doxyname: #{doxyname}"
    return doxyname == texname
  end

  def find_member( compoundname, memberkind, texname )
    texname=normalize_declaration( texname )
    puts "- find_member"
    puts "-- compoundname: #{compoundname}"
    puts "-- memberkind: #{memberkind}"
    puts "-- texname: #{texname}"
    xpath_ckind='(@kind=\'struct\' or @kind=\'class\')'
    xpath_cname="(compoundname=\'#{compoundname}\')"
    xpath_mkind="(@kind=\'#{memberkind}\')"
    #xpath_mname="(name=\'#{membername}\')"
    xpath_compound="/doxygen/compounddef[#{xpath_ckind} and #{xpath_cname}]"
    xpath_member="/sectiondef/memberdef[#{xpath_mkind}]" # and #{xpath_mname}
    xpath_query="#{xpath_compound}#{xpath_member}"
    #puts "xpath query: #{xpath_query}"

    for strip_const_from_return_type in [false,true]
      @doxy_xml.find( xpath_query ).each do |memberdef|
        if member_matches_texname( memberdef, texname, strip_const_from_return_type )
          return memberdef
        end
      end
    end
    return nil
  end
end

class Tex
  def initialize( filename, doxy )
    @tex_xml  = XML::Document.file( filename )
    @doxy = doxy
  end

  def list_all_refpages()
    @tex_xml.find('/manual_tools_output/package').each do |package|
      puts "package: #{package['id']}"
      package.find('refpage[refcat=\'Concept\']').each do |refpage|
        scope=get_xpath_content(refpage,'globalscope')
        refcat=get_xpath_content(refpage,'refcat')

        puts "  refpage id: #{refpage['id']} \tscope: #{scope}"
        refpage.find('item').each do |item|
          name=get_xpath_content(item,'name')
          kind=get_xpath_content(item,'kind')
          comment=get_xpath_content(item,'comment')
          #puts "    item name: #{name}"
          #puts "    item kind: #{kind}"
          #puts "    item comment: #{comment}"

          if kind == "function" then
            #puts "    item name: #{name}"
            #puts "    item comment: #{comment}"
          elsif kind == "memberfunction" then
            memberdef=@doxy.find_member( "#{scope}#{refpage['id']}" , "function", name )
            if memberdef == nil then
              puts "!! did not find doxygen equivalent for \"#{name}\" in \"#{scope}#{refpage['id']}\""
            else
              definition=get_xpath_content(memberdef,'definition')
              puts "+++ OK! found memberdef: #{definition}"
            end
          end

        end # each item
      end # each refpage
    end # each package
  end # def list_all_refpages

end

def get_xpath_content( node, xpath )
  s=node.find( xpath ).to_a.first.to_s
  if s == nil then
    return ""
  else
    return s.strip
  end
end

doxy = Doxygen.new( ARGV[0] )
tex = Tex.new( ARGV[1], doxy )

tex.list_all_refpages



#s = remove_argnames( "long int bla=CGAL::my_default_value<xxx<yyy>::bla>,bool blubb)" )
#s = remove_argnames( "void bla(type<param> bla,bool blubb,float x)const;" )
#s = normalize_declaration( "void bla(NT values[D],int *bla = default);" )
#puts "result: #{s}"