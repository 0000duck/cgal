#!/bin/sh
# ----------------------------------------------------
# ----------------------------------------------------
# autotest_cgal: a script to automagically install and
#   test internal CGAL releases
# $Id: autotest_cgal 39459 2007-07-23 08:58:48Z spion $
# ----------------------------------------------------
# You will need
#  * GNU wget and ftp
#  * or alternatively curl
#
# Furthermore you have to edit .autocgalrc in order to
# cutomize it for your environment.
# In particular you have to change the BUILHOSTS
# variable to contain the names of your hosts and
# set the COMPILERS_<hostname> variables to the
# os-compilers descriptions on which you want to run
# the testsuite.
# ----------------------------------------------------
# ----------------------------------------------------

#sets the umask to 022 & 0777
umask 022


SCP="scp"
WGET="wget"
WGET_OPTS="--no-check-certificate"
CURL="curl"
CURL_OPTS="-k --remote-name --silent --location-trusted"
CGAL_URL="https://cgal.geometryfactory.com/CGAL/Members/Releases"
LATEST_LOCATION="${CGAL_URL}/LATEST"
TAR="tar"
GZIP="gzip"
GUNZIP="gunzip"
COMPRESSOR="${GZIP}"
SENDMAIL="mail"
CGAL_TESTER=`whoami`
CGAL_TESTER_NAME="${CGAL_TESTER}"
CGAL_TESTER_ADDRESS="${CGAL_TESTER}"
CONSOLE_OUTPUT="y"
CGAL_ROOT=`pwd`
FTP_SERVER="ftp-sop.inria.fr"
FTP_STORE_DIR="geometrica/Incoming"
FTP_OPTS="-p -v -n"
UPLOAD_RESULT_DESTINATION="cgaltest@cgal.geometryfactory.com:incoming"
BUILD_HOSTS="must_be_set_in_.autocgalrc"
MAIL_ADDRESS="must_be_set_in_.autocgalrc"
MYSHELL="must_be_set_in_.autocgalrc"
ACTUAL_DIR=`pwd`
FTP="ftp"
LOGS_DIR="${CGAL_ROOT}/AUTOTEST_LOGS"
RSH="rsh"
LOCK_FILE="${CGAL_ROOT}/autotest_cgal.lock"
NICE_OPTIONS="-19"

for arg in "$@"
do
  if [ "$arg" = "-c" ]; then
    echo "Using latest unzipped release instead of getting a new one from the server"
    USE_LATEST_UNZIPPED="y"
  fi
  
  if [ "$arg" = "-l" ]; then
    echo "Not uploading results to dashboard"
    DO_NOT_UPLOAD="y"
  fi
done

# Now loading autocgalrc.
if [ -f $HOME/.autocgalrc ]; then
  . $HOME/.autocgalrc
else
  echo "CONFIGURATION FILE .autocgalrc NOT FOUND";
fi



#
# write to logfile
#

# $1 = logfile
log()
{
    LOGFILE=${1}
    shift
    if [ -n "${CONSOLE_OUTPUT}" ]; then
	printf "${*} ...\n"
    fi
    printf "\n-------------------------------------------------------\n" \
	>> ${LOGFILE}
    printf "  ${*} ...\n" \
	>> ${LOGFILE}
    printf "\n-------------------------------------------------------\n" \
	>> ${LOGFILE}
}

# $1 = logfile
log_done()
{
    if [ -n "${CONSOLE_OUTPUT}" ]; then
	printf \
	" done\n-------------------------------------------------------\n"
    fi
    printf "\n-------------------------------------------------------\n" \
	>> ${1}
    printf "  **DONE**\n" \
	>> ${1}
    printf "\n-------------------------------------------------------\n" \
	>> ${1}
}

#
# produce a string containing the actual date/time
#  (used to identify files)
#

datestr()
{
    date +%d%m%Y%H%M
}

#
# function to put result files on the web
#

# $1 = source filename (full path)
# $2 = target filename (basename only)
put_on_web()
{
  echo "Uploading results ${1} to $UPLOAD_RESULT_DESTINATION/$2"
  
  "$SCP" "${1}" "$UPLOAD_RESULT_DESTINATION"/$2 | tee -a ${ACTUAL_LOGFILE} 2>&1
}

error()
{
    if [ -n "${CONSOLE_OUTPUT}" ]; then
	printf "\nERROR: ${*}, exiting.\n"
    fi
    printf "\nERROR: ${*}, exiting.\n" >> ${ACTUAL_LOGFILE}
    ${COMPRESSOR} -9f ${ACTUAL_LOGFILE}
    FILENAME="${CGAL_RELEASE_ID}-log`datestr`.gz"
    mv ${ACTUAL_LOGFILE}.gz ${LOGS_DIR}/${FILENAME}
    if [ ! "${MAIL_ADDRESS}" = "must_be_set_in_.autocgalrc" ]; then
      for i in ${MAIL_ADDRESS}; do
        printf "ERROR\n${LOGS_DIR}/${FILENAME}\n" | \
            ${SENDMAIL} -s "completed autotest" ${i}
      done
    fi
    rm -rf $LOCK_FILE;
    exit 1
}



#
# function to print the value of variable $1
#

value_of()
{
    _value=`eval "printf '$'${1}"`
    eval "printf \"${_value}\""
}

#
# function for executing a command remotely
#

# $1 = HOST
# $2 = COMMAND
remote_command()
{
    if [ "${1}" = "localhost" ]; then
	eval $2
    else
      printf "** Logging into host ${1} **\n"
      ${RSH} ${1} ${MYSHELL} \"${2}\"
    fi
}

#
# function for building the CGAL libs
#

# $1 = HOST
build_cgal_libs()
{
    LOCAL_BUILD_ON="`value_of BUILD_ON_${1}`"

    if [ -z "${LOCAL_BUILD_ON}" ]; then
      LOCAL_BUILD_ON=`value_of COMPILERS_${1}`
    fi
    
    if [ "${LOCAL_BUILD_ON}" = "all" ]; then
      LOCAL_BUILD_ON=""
      cd ${CGAL_DIR}/cmake/platforms
      for platform in * 
      do
        if [ -d "${platform}" ]; then
          LOCAL_BUILD_ON="${LOCAL_BUILD_ON} ${platform}"
        fi
      done    
    fi
    
    for i in ${LOCAL_BUILD_ON}; do
      
      CGAL_BINARY_DIR=${CGAL_BINARY_DIR_BASE}/${i}
      
      log ${ACTUAL_LOGFILE} "   under ${CGAL_BINARY_DIR}"
      
      if [ ! -d ${CGAL_BINARY_DIR} ]; then
        mkdir ${CGAL_BINARY_DIR}
      fi
      
      remote_command ${1} "cd ${CGAL_BINARY_DIR}; \
                           cmake -DWITH_demo=FALSE -DWITH_examples=FALSE -DWITH_CGALPDB=FALSE ../../..; \
                           make -fMakefile" | tee -a ${ACTUAL_LOGFILE} 2>&1
                           
      if [ -f "${CGAL_BINARY_DIR}/CMakeFiles/CMakeError.log" ]; then                           
        cp ${CGAL_BINARY_DIR}/CMakeFiles/CMakeError.log  ${CGAL_TEST_DIR}/CMakeError_${i}.log
      fi
      
      if [ -f "${CGAL_BINARY_DIR}/CMakeFiles/CMakeOutput.log" ]; then                           
        cp ${CGAL_BINARY_DIR}/CMakeFiles/CMakeOutput.log ${CGAL_TEST_DIR}/CMakeOutput_${i}.log
      fi
      
    done
      
}

#-----------------------------------------------
# testsuite script parallel
#-----------------------------------------------
# $1 = HOST
# $2 = COMPILERS
run_testsuite()
{
    for i in ${2}; do
	test_script ${1} ${i}
    done
}


# ---------------------------------------------------
# test script NEW
# create additional directories to test in parallel
# on multiple platforms
# the variable PROCESSORS_electra, where electra is the
# name of the machine, is used to specify the number of
# processors to use
# ---------------------------------------------------
# $1 = HOST
# $2 = PLATFORM
test_script()
{
	NUMBER_OF_PROCESSORS="`value_of PROCESSORS_${1}`"
        CGAL_BINARY_DIR=${CGAL_BINARY_DIR_BASE}/${2}
	cd ${CGAL_BINARY_DIR}
	log ${ACTUAL_LOGFILE}.${1} "Testing on ${1} with ${2}"
        if [ "${NUMBER_OF_PROCESSORS}" = "1" ] ; then
	  MAKE_OPTS=""
        else
	  MAKE_OPTS="-j ${NUMBER_OF_PROCESSORS}"
        fi
        cat > ${CGAL_BINARY_DIR}/localtestscript.${1} <<EOF
CGAL_TESTER='${CGAL_TESTER}';
CGAL_TESTER_NAME='${CGAL_TESTER_NAME}';
CGAL_TESTER_ADDRESS='${CGAL_TESTER_ADDRESS}';
CGAL_DIR='${CGAL_BINARY_DIR}';
CGAL_TEST_PLATFORM='${2}';
export CGAL_TESTER CGAL_TESTER_NAME CGAL_TESTER_ADDRESS CGAL_DIR CGAL_TEST_PLATFORM;
rm -rf ${CGAL_BINARY_DIR}/test;
cp -r ${CGAL_TEST_DIR} ${CGAL_BINARY_DIR}/test;
cd ${CGAL_BINARY_DIR}/test;
[ -n "${ULIMIT_OPTIONS}" ] && ulimit ${ULIMIT_OPTIONS};
nice ${NICE_OPTIONS} make ${MAKE_OPTS} -fmakefile2;
echo 'COLLECTING RESULTS';
./collect_cgal_testresults_from_cmake;
echo 'COPYING RESULTS';
cp results_${CGAL_TESTER}_${2}.tar.gz results_${CGAL_TESTER}_${2}.txt ${CGAL_TEST_DIR};
echo 'REMOVING LOCAL_TEST_DIR';
cd ..;
rm -rf ${CGAL_BINARY_DIR}/test
EOF
        chmod ugo+x ${CGAL_BINARY_DIR}/localtestscript.${1}
        remote_command ${1} "${CGAL_BINARY_DIR}/localtestscript.${1}" | tee -a ${ACTUAL_LOGFILE}.${1} 2>&1
	log_done ${ACTUAL_LOGFILE}.${1}
	#
	# collect results and put them on the web
	#
        cd ${CGAL_TEST_DIR}
	log ${ACTUAL_LOGFILE}.${1} "PUTTING RESULTS ON THE WEB"
	log ${ACTUAL_LOGFILE}.${1} "RESULTS COLLECTED "${2}"-"${1}
	${TAR} cf test_results-${1}.tar "results_"$CGAL_TESTER"_"${2}".tar.gz" "results_"$CGAL_TESTER"_"${2}".txt"
	${COMPRESSOR} -9f test_results-${1}.tar
	FILENAME=${CGAL_RELEASE_ID}-test`datestr`-${2}-cmake.tar.gz
	LOGFILENAME="${CGAL_RELEASE_ID}-log`datestr`-${1}.gz"
	${COMPRESSOR} -9f ${ACTUAL_LOGFILE}.${1}
	mv ${ACTUAL_LOGFILE}.${1}.gz ${LOGS_DIR}/${LOGFILENAME}

        echo "Test results: ${CGAL_TEST_DIR}/test_results-${1}.tar.gz"
        
        if [ -z "${DO_NOT_UPLOAD}" ]; then
	  put_on_web test_results-${1}.tar.gz ${FILENAME}
        fi       

    #
    # notify the CGAL world
    #
    if [ ! "${MAIL_ADDRESS}" = "must_be_set_in_.autocgalrc" ]; then
      for i in ${MAIL_ADDRESS}; do
        echo "Notifying ${i} about autotest finished." 
        printf "result collection::\n${FILENAME}\n" | ${SENDMAIL} -s "autohandle" ${i}
      done
    fi
}



# ----------------------------------------------------
# get CGAL
#

get_cgal()
{
    log ${ACTUAL_LOGFILE} "getting CGAL"
    rm -f ${CGAL_ZIPFILE}
    if [ -n "${USE_CURL}" ]; then
        ${CURL} ${CURL_OPTS} ${CGAL_LOCATION} >> ${ACTUAL_LOGFILE} 2>&1
    else
        ${WGET} ${WGET_OPTS} ${CGAL_LOCATION} >> ${ACTUAL_LOGFILE} 2>&1
    fi
    if [ ${?} != 0 ]; then
	error "Could not get CGAL"
    fi
    log_done ${ACTUAL_LOGFILE}
}


# ----------------------------------------------------
# unzip/untar CGAL
#

unzip_cgal()
{
    cd ${CGAL_ROOT}
    log ${ACTUAL_LOGFILE} "unzipping CGAL"
    if [ "${USE_TARGZ}" = "y" ]; then
      DECOMPRESSOR="${GUNZIP}"
      log_done ${ACTUAL_LOGFILE}
    fi
    if [ "${USE_TARBZ}" = "y" ]; then
      DECOMPRESSOR="bunzip2"
    fi
    log ${ACTUAL_LOGFILE} "untarring CGAL"
    ${DECOMPRESSOR} -c ${CGAL_ZIPFILE} | ${TAR} xvf - >> ${ACTUAL_LOGFILE} 2>&1
    if [ ${?} != 0 ]; then
      error "Could not untar CGAL"
    fi
    
    # check, if CGAL_DIR exists
    if [ ! -d ${CGAL_DIR} ]; then
      error "directory ${CGAL_DIR} does not exist"
    fi
  
    log_done ${ACTUAL_LOGFILE}
}


# ----------------------------------------------------
# copy stuff from old CGAL installation
#

copy_old_stuff()
{
  # copy config build configuration files
  if [ ! ${OLD_CGAL_DIR} -ef ${CGAL_DIR} ]; then

    # Each build platform is given by a folder under cmake/build 
    cd ${OLD_CGAL_BINARY_DIR_BASE}
    for platform in * 
    do

      if [ -d "${platform}" ]; then

        # if the platform folder doesn't exist in the tested release it is created now.
        if [ ! -d "${CGAL_BINARY_DIR_BASE}/${platform}" ]; then
          log ${ACTUAL_LOGFILE} "Creating platform folder ${platform} in ${CGAL_BINARY_DIR_BASE}/"
          mkdir "${CGAL_BINARY_DIR_BASE}/${platform}"
        fi
        
        # If there is any configuration cached in the old release, copy it
        if [ -f "${platform}/CMakeCache.txt" ]; then
          log ${ACTUAL_LOGFILE} "Copying old ${platform}/CMakeCache.txt into ${CGAL_BINARY_DIR_BASE}/${platform}/"
          sed "s/${OLD_CGAL_RELEASE_ID}/${CGAL_RELEASE_ID}/g" "${platform}/CMakeCache.txt" >> "${CGAL_BINARY_DIR_BASE}/${platform}/CMakeCache.txt"
        fi
        
      fi
    
    done
    
    log_done ${ACTUAL_LOGFILE}
    
  fi  
}


# ----------------------------------------------------
# build cgal
#

build_cgal()
{
    log ${ACTUAL_LOGFILE} "building cgal libs"
    for i in ${BUILD_HOSTS}; do
	build_cgal_libs ${i}
    done
    log_done ${ACTUAL_LOGFILE}
    ${COMPRESSOR} -9f ${ACTUAL_LOGFILE}
    mv ${ACTUAL_LOGFILE}.gz \
	${LOGS_DIR}/${CGAL_RELEASE_ID}-log`datestr`.gz
}


# ----------------------------------------------------
# run the testsuites
#

run_test()
{
    log ${ACTUAL_LOGFILE} "running the testsuites"
    if [ -n "${CONSOLE_OUTPUT}" ]; then
	printf "\n-------------------------------------------------------\n"
    fi
    
    for i in ${BUILD_HOSTS}; do
    
      LOCAL_TEST_ON=`value_of COMPILERS_${i}`
      
      if [ "${LOCAL_TEST_ON}" = "all" ]; then
        LOCAL_TEST_ON=""
        cd ${CGAL_BINARY_DIR_BASE}
        for platform in * 
        do
          if [ -d "${platform}" ]; then
            LOCAL_TEST_ON="${LOCAL_TEST_ON} ${platform}"
          fi
        done    
      fi
      
      for j in ${LOCAL_TEST_ON}; do
	run_testsuite ${i} ${j} &
      done
              
    done
}


# ----------------------------------------------------
# START OF MAIN BODY
# ----------------------------------------------------

USE_TARGZ="n"
USE_TARBZ="n"
# logfile
ACTUAL_LOGFILE="${CGAL_ROOT}/`basename ${0}`.log"

cd $CGAL_ROOT

CRITICAL="n"
if [ "${MYSHELL}" = "must_be_set_in_.autocgalrc" ]; then
  log ${ACTUAL_LOGFILE} "MYSHELL must be set in .autocgalrc"
  CRITICAL="y"
fi
if [ "${CRITICAL}" = "y" ]; then
  error "COULD NOT DETERMINE MYSHELL!"
fi

lockfile -r 5 $LOCK_FILE;
if [ ${?} != 0 ]; then
  echo "COULD NOT AQUIRE LOCK!";
  exit 1;
fi

setup_dirs_for_latest_in_server()
{
  if [ -r "LATEST" ]; then
    rm -rf LATEST
  fi
    log ${ACTUAL_LOGFILE} "getting LATEST"
    if [ -n "${USE_CURL}" ]; then
      ${CURL} ${CURL_OPTS} ${LATEST_LOCATION} >> ${ACTUAL_LOGFILE} 2>&1
    else
      ${WGET} ${WGET_OPTS} ${LATEST_LOCATION} >> ${ACTUAL_LOGFILE} 2>&1
    fi
  if [ ! -f "LATEST" ]; then
    error "COULD NOT DOWNLOAD LATEST!"
  fi
  if [ -r "RELEASE_NR" ]; then
    cmp LATEST RELEASE_NR > ${ACTUAL_LOGFILE}
    if [ ! ${?} != 0 ]; then
      log ${ACTUAL_LOGFILE} "This release has already been tested."
      rm -f $LOCK_FILE;
      exit 1;
    fi
  fi
  
  for i in `cat LATEST`
  do
    CGAL_LOCATION="${CGAL_URL}/${i}";
    CGAL_ZIPFILE="${i}";
  done
    
  OLD_CGAL_RELEASE_ID=`cat "RELEASE_NR" | sed "s/.tar.gz//" | sed "s/.tar.bz2//" `
  
  CGAL_RELEASE_ID=`echo $CGAL_ZIPFILE | sed "s/.tar.gz//"`
  if [ ! "${CGAL_RELEASE_ID}" = "${CGAL_ZIPFILE}" ]; then
    USE_TARGZ="y"
  else
    CGAL_RELEASE_ID=`echo $CGAL_ZIPFILE | sed "s/.tar.bz2//"`
    if [ ! "${CGAL_RELEASE_ID}" = "${CGAL_ZIPFILE}" ]; then
      USE_TARBZ="y"
    fi
  fi
  
  CGAL_CURRENT_RELEASE_ID=`echo $CGAL_RELEASE_ID | sed -e 's/-I.*//'`-I
  
  # dir for the actual release
  CGAL_DIR=${CGAL_ROOT}/${CGAL_RELEASE_ID}
  
  # dir of the previous release
  # HAS TO exist !
  # (used to copy config/install files and evt. gmp stuff)
  OLD_CGAL_DIR=${CGAL_ROOT}/CGAL-I
  CURRENT_CGAL_DIR=${CGAL_ROOT}/${CGAL_CURRENT_RELEASE_ID}
  
  CGAL_TEST_DIR=${CGAL_DIR}/test

  OLD_CGAL_BINARY_DIR_BASE=${OLD_CGAL_DIR}/cmake/platforms
  CGAL_BINARY_DIR_BASE=${CGAL_DIR}/cmake/platforms
}

setup_dirs_for_latest_unzipped()
{
  
  for i in `cat RELEASE_NR`
  do
    CGAL_ZIPFILE="${i}";
  done
    
  CGAL_RELEASE_ID=`echo $CGAL_ZIPFILE | sed "s/.tar.gz//"`
  
  CGAL_CURRENT_RELEASE_ID=`echo $CGAL_RELEASE_ID | sed -e 's/-I.*//'`-I
  
  # dir for the actual release
  CGAL_DIR=${CGAL_ROOT}/${CGAL_RELEASE_ID}
  
  # check, if CGAL_DIR exists
  if [ ! -d ${CGAL_DIR} ]; then
    error "directory ${CGAL_DIR} does not exist"
  fi
  
  # dir of the previous release
  # HAS TO exist !
  # (used to copy config/install files and evt. gmp stuff)
  OLD_CGAL_DIR=${CGAL_ROOT}/CGAL-I
  
  CURRENT_CGAL_DIR=${CGAL_ROOT}/${CGAL_CURRENT_RELEASE_ID}
  
  CGAL_TEST_DIR=${CGAL_DIR}/test
  
  OLD_CGAL_BINARY_DIR_BASE=${OLD_CGAL_DIR}/cmake/platforms
  CGAL_BINARY_DIR_BASE=${CGAL_DIR}/cmake/platforms
}


setup_dirs()
{
  if [ -n "${USE_LATEST_UNZIPPED}" ]; then
    setup_dirs_for_latest_unzipped
  else
    setup_dirs_for_latest_in_server
  fi
  
  log ${ACTUAL_LOGFILE} "CGAL_ZIPFILE            = ${CGAL_ZIPFILE}"
  log ${ACTUAL_LOGFILE} "CGAL_RELEASE_ID         = ${CGAL_RELEASE_ID}"
  log ${ACTUAL_LOGFILE} "CGAL_CURRENT_RELEASE_ID = ${CGAL_CURRENT_RELEASE_ID}"
  log ${ACTUAL_LOGFILE} "CGAL_DIR                = ${CGAL_DIR}"
  log ${ACTUAL_LOGFILE} "OLD_CGAL_RELEASE_ID     = ${OLD_CGAL_RELEASE_ID}"
  log ${ACTUAL_LOGFILE} "OLD_CGAL_DIR            = ${OLD_CGAL_DIR}"
  log ${ACTUAL_LOGFILE} "CURRENT_CGAL_DIR        = ${CURRENT_CGAL_DIR}"
  
  # check, if OLD_CGAL_DIR exists and is a symbolic link
  if [ ! -r ${OLD_CGAL_DIR} -o ! -d ${OLD_CGAL_DIR} ]; then
    error "directory ${OLD_CGAL_DIR} does not exist"
  fi
  if [ ! -h ${OLD_CGAL_DIR} ]; then
    error "${OLD_CGAL_DIR} has to be a symbolic link"
  fi
  
  if [ ! -r ${LOGS_DIR} ]; then
    mkdir $LOGS_DIR
  fi
  
}

update_symlinks()
{
  rm ${OLD_CGAL_DIR}
  ln -s `basename ${CGAL_DIR}` ${OLD_CGAL_DIR}
  
  if [ ! ${OLD_CGAL_DIR} -ef ${CURRENT_CGAL_DIR} ]; then
    rm ${CURRENT_CGAL_DIR}
    ln -s `basename ${CGAL_DIR}` ${CURRENT_CGAL_DIR}
  fi
}

# ----------------------------------------------------
# some sanity checks
#

# remove old logfile
rm -f ${ACTUAL_LOGFILE}

if [ ! "${MAIL_ADDRESS}" = "must_be_set_in_.autocgalrc" ]; then
  for i in ${MAIL_ADDRESS}; do
    echo "Notifying ${i} about autotest started."
    printf "subject says it all\n" | \
        ${SENDMAIL} -s "Started autotest" ${i}
  done
fi

# do the job


main_procedure()
{
  if [ "${BUILD_HOSTS}" = "must_be_set_in_.autocgalrc" ]; then
    error "BUILD_HOSTS must be set in .autocgalrc"
  else
    for i in ${BUILD_HOSTS}; do
      TEXT="`value_of COMPILERS_${i}`"
      if [ -z "${TEXT}" -a "${i}" != "localhost" ]; then
        error "COMPILERS_${i} must be defined in .autocgalrc"
      else
        TEXT="`value_of PROCESSORS_${i}`"
        TEMPVAR="PROCESSORS_${i}"
        if [ -z "${TEXT}" ]; then
          log ${ACTUAL_LOGFILE} "\ngiving default 1 values TO PROCESSORS_${i} ...";
          eval $TEMPVAR="1";
        fi
      fi
    done
  fi
  
  setup_dirs
  
  if [ -z "${USE_LATEST_UNZIPPED}" ]; then
    get_cgal
    unzip_cgal
  fi
   
  if [ ! ${OLD_CGAL_DIR} -ef ${CGAL_DIR} ]; then
    copy_old_stuff
  fi
    
  build_cgal
  
  if [ ! ${OLD_CGAL_DIR} -ef ${CGAL_DIR} ]; then
    update_symlinks
  fi
  
  if [ "${BUILD_HOSTS}" = "localhost" ]; then
    TEXT="`value_of COMPILERS_localhost`"
    if [ -z "${TEXT}" ]; then
      printf "Skipping testing phase.\n" 
      SKIP_TEST="y"
    fi
  fi
        
  if [ -z "${SKIP_TEST}" ]; then
    run_test
  fi
  
  # restore settings:
  cd ${CGAL_ROOT}
  
  if [ -e "LATEST" ]; then
    mv LATEST RELEASE_NR
  fi
  
  rm -f $LOCK_FILE;
}

main_procedure;

# EOF
