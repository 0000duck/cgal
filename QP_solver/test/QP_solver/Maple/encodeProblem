# This file will be read by a .mema-File and provides a Maple routine
# encodeProblemToMPS (see below for description).

bailout:= proc(msg::string)
  printf("An error occurred: %s\n",msg);
  if type(QPSOLVERTESTSUITE,boolean) then
    `quit`(1);
  fi;
end:

encodeNumber:= proc(numberType,value)
  if numberType = 1 then # integer?
    sprintf("%a",value)
  elif numberType = 2 then # rational?
    sprintf("%a/%a",numer(value),denom(value))
  else
    sprintf("%.17f",evalf(value,20))
  fi;
end:

numberFormat:= proc(numberType)
  if numberType = 1 then "integer"
  elif numberType = 2 then "rational"
  else "floating-point"
  fi;
end:

determineNumerType:= proc(currentNumberType,m::Matrix)
local i,j,numberType;
  numberType:= currentNumberType;
  for i from 1 to RowDimension(m) do
    for j from 1 to ColumnDimension(m) do
      if numberType = 1 and not type(m[i,j],integer) then
         numberType:= 2; # rational
      fi;
      if numberType = 2 and not type(m[i,j],rational) then
         numberType:= 3; # double
      fi;
    od
  od;
  numberType;
end:

# Encode the problem to file fpath in MPS-format.
# You can pass the Boolean false for D, fl, l, fu, or/and u
# in case you are dealing with an LP or with no bounds, respectively.
# Note: In rel, a -1 means "<=", a zero means "=", and a 1 means ">=".
# Note: fpath should simply be the filename (e.g. "PD_Dual_Eq_QPE_solver"
# for "PD_Dual_Eq_QPE_solver.mema"); if fpath contains a path (e.g.
# "../data/PD_Dual_Eq_QPE_solver") then this path will be ignored.
simpleEncodeProblemToMPS:= proc(A::Matrix, rel::Matrix, b::Matrix, c::Matrix, D,
  fl, l, fu, u, # must be row Matrix's
  desc::string, gen_desc::string, fpath::string)
local i, j, dim, m, n, fd, rowType, numberType, dummy, filename, comment, cl;
  # get problem dimensions:
  dim := LinearAlgebra[Dimensions];
  m := dim(A)[1]; 
  n := dim(A)[2];

  # do some sanity checks:
  if RowDimension(rel) <> m then
    bailout("Number of row-types is different from number of constraints.");
  fi;

  # determine number-type:
  numberType:= 1; # integer (see procedure encodeNumber above)
  numberType:= determineNumerType(numberType,A);
  numberType:= determineNumerType(numberType,b);
  numberType:= determineNumerType(numberType,c);
  if not type(D,boolean) then
    numberType:= determineNumerType(numberType,c);
  fi;
  if not type(l,boolean) then
    numberType:= determineNumerType(numberType,c);
  fi;
  if not type(u,boolean) then
    numberType:= determineNumerType(numberType,c);
  fi;
  printf("Will output file in %s format.\n",numberFormat(numberType));

  # open output file:
  if StringTools[FirstFromRight]("/",fpath) <> 0 then
    StringTools[RegMatch]("^.*/([^/]*)$",fpath,'dummy','filename');
  else
    filename:= fpath;
  fi;
  filename:= cat("../testsuite-data/",filename);
  #printf("fpath is %s\n",filename);
  fd:= fopen(cat(filename, ".mps"), WRITE);
  #printf("fd is %d.\n",fd);

  # write header:
  fprintf(fd,"* Number-type: %s\n",numberFormat(numberType));
  fprintf(fd,"* Description: %s\n",desc);
  fprintf(fd,"* Generated-by: %s\n",gen_desc);
  if type(Flags,string) then
    printf("Adding flags '%s'.",Flags);
    fprintf(fd,"* Flags: %s\n",Flags);
  fi;
  fprintf(fd,"NAME %s\n",my_name);

  # write ROWS section:
  fprintf(fd,"ROWS\n");
  fprintf(fd," N obj\n");  # a "row" for the objective function
  for i from 1 to m do
    if rel[i,1] = -1 then rowType:= "L" elif rel[i,1] = 0 then rowType:= "E" else rowType:= "G" fi;
    fprintf(fd," %s c%d\n",rowType, i);
  od;

  # write COLUMNS section:
  # (a) ouput objective function:
  fprintf(fd,"COLUMNS\n");
  cl:= [];
  for i from 1 to n do
    cl:= [op(cl),
          sprintf("  x%d  obj  %s\n",i,encodeNumber(numberType,c[1,i]))];
  od:
  # (b) ouput A matrix function:
  for i from 1 to m do
    for j from 1 to n do
	cl:= [op(cl),
      	 sprintf("  x%d  c%d  %s\n",j,i,encodeNumber(numberType,A[i,j]))];
    od
  od;
  cl:= sort(cl);
  for i from 1 to nops(cl) do
    fprintf(fd,"%s",cl[i]);
  od;

  # write RHS section:
  fprintf(fd,"RHS\n");
  for i from 1 to m do
    fprintf(fd,"  rhs  c%d  %s\n",i,encodeNumber(numberType,b[i,1]));
  od;

  # write BOUNDS section:
  if not type(fl,boolean) then
    fprintf(fd,"BOUNDS\n");
    for i from 1 to n do
      if (not is(fl[1,i],1) and not is(fl[1,i],0)) or 
         (not is(fu[1,i],1) and not is(fu[1,i],0)) then
        fclose(fd);
        bailout("fl or fu do not contain values from {0,1}");
      fi;
      if not (fl[1,i]=1 and is(l[1,i],0)) then
        if fl[1,i]=1 then
          fprintf(fd,"  LO  BND  x%d  %s\n",i,encodeNumber(numberType,l[1,i])); 
        else
          fprintf(fd,"  MI  BND  x%d\n",i);
        fi;
      fi;
      if fu[1,i]=1 then
        fprintf(fd,"  UP  BND  x%d  %s\n",i,encodeNumber(numberType,u[1,i]));
      fi;
    od;
  fi;

  # write DMATRIX section:
  # Note: CPLEX only understands QMATRIX sections and not
  # our proprietary DMATRIX section.
  if not type(D,boolean) then
    fprintf(fd,"QMATRIX\n");
    for i from 1 to n do
      for j from 1 to n do
        fprintf(fd,"  x%d  x%d  %s\n",i,j,encodeNumber(numberType,2*D[i,j]));
      od
    od;
  fi;

  # write footer:
  fprintf(fd,"ENDATA\n");

  # close output file:
  fclose(fd);
end:

encodeProblemToMPS:= proc(A::Matrix, rel::Matrix, b::Matrix, c::Matrix, D,
  fl, l, fu, u, # must be row Matrix's
  desc::string, gen_desc::string, fpath::string)
local dim, m, n, i, bn, cn, ln, un, t, tm, fln, fun;

  # export the original problem as an MPS file:
  simpleEncodeProblemToMPS(A,rel,b,c,D,fl,l,fu,u,
    desc,gen_desc,fpath);

  # create another problem by translating x to x+constant
  # and output this problem in MPS format, too:
  dim := LinearAlgebra[Dimensions];
  m := dim(A)[1]; 
  n := dim(A)[2];
  
  # create the translation vector:
  t:= Vector([seq(i,i=1..n)]);
  tm:= Matrix([[seq(i,i=1..n)]]);

  # bounds:  
  if not type(fl,boolean) then
    ln:= l+tm;
    un:= u+tm;
    fln:= fl;
    fun:= fu;
  else
    ln:= tm;
    un:= false;
    fln:= Matrix([[seq(1,i=1..n)]]); 
    fun:= Matrix([[seq(0,i=1..n)]]); 
  fi;
  
  # other quantities:
  bn:= b + (A.Transpose(tm));
  if not type(D,boolean) then
    cn:= c - 2*tm.Transpose(D);
  else
    cn:= c;
  fi;

  simpleEncodeProblemToMPS(A,rel,bn,cn,D,fln,ln,fun,un,
    cat(desc, " (shifted)"),gen_desc,cat(fpath,"_shifted"));
end:

# for compatiblity with Frans' original output format:
encodeUbLpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
                fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,false,fl,l,fu,u,desc,gen_desc,fpath);
end:
encodeLpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,false,false,false,false,false,desc,gen_desc,fpath);
end:
encodeUbQpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,d,fl,l,fu,u,desc,gen_desc,fpath);
end:
encodeQpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,d,false,false,false,false,desc,gen_desc,fpath);
end:
encodeUbLpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
                fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,false,fl,l,fu,u,desc,gen_desc,fpath);
end:
encodeLpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,false,false,false,false,false,desc,gen_desc,fpath);
end:
encodeUbQpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,d,fl,l,fu,u,desc,gen_desc,fpath);
end:
encodeQpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,d,false,false,false,false,desc,gen_desc,fpath);
end:
encodeUbLpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
                fl::Matrix, l::Matrix, fu::Matrix, u::Matrix, 
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,false,fl,l,fu,u,desc,gen_desc,fpath);
end:
encodeLpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix, 
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,false,false,false,false,false,desc,gen_desc,fpath);
end:
encodeUbQpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,d,fl,l,fu,u,desc,gen_desc,fpath);
end:
encodeQpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
  encodeProblemToMPS(a,rel,b,c,d,false,false,false,false,desc,gen_desc,fpath);
end:

# the rest of this file is for compatibility with Frans' old (i.e., pre-MPS) format:
if type(QPSOLVEROLDFORMAT,boolean) and QPSOLVEROLDFORMAT then

encodeQpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	
	fd:= fopen(cat(fpath, ".data_r"), WRITE);
	

	m := Dimensions(a)[1]; 
	n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
   
	writeTags(fd, "r", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 1);

	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeRatMatrix(fd, a, m, n);
 

	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
		fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;

	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeRatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
	        writeRatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;

	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeRatMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;

	fclose(fd);
	
end proc;

encodeUbQpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	
	fd:= fopen(cat(fpath, ".data_r"), WRITE);
	

	m := Dimensions(a)[1]; 
	n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
   
	writeTags(fd, "r", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);


	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeRatMatrix(fd, a, m, n);
 

	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
		fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;

	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeRatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
	        writeRatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;

	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeRatMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	writeRatExplicitBounds(fd, n, fl, l, fu, u);
	
	fclose(fd);
	
end proc;

encodeLpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix, 
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	
	fd:= fopen(cat(fpath, ".data_r"), WRITE);
	

	m := Dimensions(a)[1]; 
	n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "r", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 1);
		
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeRatMatrix(fd, a, m, n);
 

	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
		fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;

	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeRatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
	        writeRatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;

	fclose(fd);
	
end proc;

encodeUbLpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
                fl::Matrix, l::Matrix, fu::Matrix, u::Matrix, 
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	
	fd:= fopen(cat(fpath, ".data_r"), WRITE);
	

	m := Dimensions(a)[1]; 
	n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "r", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
		
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeRatMatrix(fd, a, m, n);
 

	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
		fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;

	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeRatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
	        writeRatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	writeRatExplicitBounds(fd, n, fl, l, fu, u);

	fclose(fd);
	
end proc;


encodeQpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_f"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "f", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 1);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeFloatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeFloatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeFloatMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	fclose(fd);
	
end proc;

encodeUbQpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_f"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "f", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeFloatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeFloatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeFloatMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	writeFloatExplicitBounds(fd, n, fl, l, fu, u);
	
	fclose(fd);
	
end proc;


encodeLpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_f"), WRITE);
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	    
	writeTags(fd, "f", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 1);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeFloatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeFloatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
		
	fclose(fd);
	
end proc;


encodeUbLpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
                fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_f"), WRITE);
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	    
	writeTags(fd, "f", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeFloatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeFloatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	writeFloatExplicitBounds(fd, n, fl, l, fu, u);

	fclose(fd);
	
end proc;


encodeQpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_i"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "i", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 1);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeIntMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeIntMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeIntMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	fclose(fd);
	
end proc;


encodeUbQpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_i"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "i", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeIntMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeIntMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeIntMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	writeIntExplicitBounds(fd, n, fl, l, fu, u);
	
	fclose(fd);
	
end proc;



encodeLpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_i"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, desc);
	    
	writeTags(fd, "i", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 1);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeIntMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeIntMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
		
	fclose(fd);
	
end proc;


encodeUbLpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
                fl::Matrix, l::Matrix, fu::Matrix, u::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_i"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, desc);
	    
	writeTags(fd, "i", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeIntMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeIntMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	writeIntExplicitBounds(fd, n, fl, l, fu, u);
		
	fclose(fd);
	
end proc;



writeRatMatrix:=proc(fileDesc, matrix, m, n)
	local i, j;
	for i from 1 by 1 to m do
	    for j from 1 by 1 to n do
	        if type(matrix[i,j], fraction) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a%s%a", matrix[i,j], "/", 1);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeRatMatrixTransposed:=proc(fileDesc, matrix, m, n)
	local i, j;
	for j from 1 by 1 to n do
	    for i from 1 by 1 to m do
	        if type(matrix[i,j], fraction) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a%s%a", matrix[i,j], "/", 1);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

		 	  
writeFloatMatrix:=proc(fileDesc, matrix, m, n)
	local i, j;
	for i from 1 by 1 to m do
	    for j from 1 by 1 to n do
	        if type(matrix[i,j], float) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeFloatMatrixTransposed:=proc(fileDesc, matrix, m, n)
	local i, j;
	for j from 1 by 1 to n do
	    for i from 1 by 1 to m do
	        if type(matrix[i,j], float) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;


writeIntMatrix:=proc(fileDesc, matrix, m, n)
	local i, j;
	for i from 1 by 1 to m do
	    for j from 1 by 1 to n do
	        if type(matrix[i,j], integer) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeIntMatrixTransposed:=proc(fileDesc, matrix, m, n)
	local i, j;
	for j from 1 by 1 to n do
	    for i from 1 by 1 to m do
	        if type(matrix[i,j], integer) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeTags:=proc(fileDesc, inputDataType, isLinear, isSymmetric,
        hasEqualitiesOnlyAndFullRank, isInStandardForm) 
	fprintf(fileDesc, "%s", "tags\n");
	fprintf(fileDesc, "%s\t\t%s\n", "input_data_type", inputDataType);
	fprintf(fileDesc, "%s\t\t%d\n", "is_linear", isLinear);
	fprintf(fileDesc, "%s\t\t%d\n", "is_symmetric", isSymmetric);
	fprintf(fileDesc, "%s\t%d\n", "has_equalities_only_and_full_rank",
        hasEqualitiesOnlyAndFullRank);
	fprintf(fileDesc, "%s\t%d\n", "is_in_standard_form", isInStandardForm);
	fprintf(fileDesc, "\n");
end proc;


writeDescription:=proc(fileDesc, desc)
	local q, r, i, line;
	line := 79;
	q := iquo(length(desc), line);
	r := irem(length(desc), line);
	for i from 1 by 1 to q do
	    fprintf(fileDesc, "%s%s%s", "#", desc[(i-1)*line+1 .. i*line], "\n");
	end do; 
	if (r > 0) then
	    fprintf(fileDesc, "%s%s%s", "#", desc[q*line+1 .. length(desc)],
	        "\n");
	fi;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeIntExplicitBounds:=proc(fd, n, fl, l, fu, u)

	if (Dimensions(fl)[1] = 1) and (Dimensions(fl)[2] = n) then
	        fprintf(fd, "%s", "fl\n");
		writeIntMatrix(fd, fl, 1, n);
	else
	        printf("%s", "wrong dimensions in fl\n");
	end if;

	if (Dimensions(l)[1] = 1) and (Dimensions(l)[2] = n) then
	        fprintf(fd, "%s", "l\n");
		writeIntMatrix(fd, l, 1, n);
	else
	        printf("%s", "wrong dimensions in l\n");
	end if;

	if (Dimensions(fu)[1] = 1) and (Dimensions(fu)[2] = n) then
	        fprintf(fd, "%s", "fu\n");
		writeIntMatrix(fd, fu, 1, n);
	else
	        printf("%s", "wrong dimensions in fu\n");
	end if;

	if (Dimensions(u)[1] = 1) and (Dimensions(u)[2] = n) then
	        fprintf(fd, "%s", "u\n");
		writeIntMatrix(fd, u, 1, n);
	else
	        printf("%s", "wrong dimensions in u\n");
	end if;
end proc;

writeFloatExplicitBounds:=proc(fd, n, fl, l, fu, u)

	if (Dimensions(fl)[1] = 1) and (Dimensions(fl)[2] = n) then
	        fprintf(fd, "%s", "fl\n");
		writeIntMatrix(fd, fl, 1, n);
	else
	        printf("%s", "wrong dimensions in fl\n");
	end if;

	if (Dimensions(l)[1] = 1) and (Dimensions(l)[2] = n) then
	        fprintf(fd, "%s", "l\n");
		writeFloatMatrix(fd, l, 1, n);
	else
	        printf("%s", "wrong dimensions in l\n");
	end if;

	if (Dimensions(fu)[1] = 1) and (Dimensions(fu)[2] = n) then
	        fprintf(fd, "%s", "fu\n");
		writeIntMatrix(fd, fu, 1, n);
	else
	        printf("%s", "wrong dimensions in fu\n");
	end if;

	if (Dimensions(u)[1] = 1) and (Dimensions(u)[2] = n) then
	        fprintf(fd, "%s", "u\n");
		writeFloatMatrix(fd, u, 1, n);
	else
	        printf("%s", "wrong dimensions in u\n");
	end if;
end proc;

writeRatExplicitBounds:=proc(fd, n, fl, l, fu, u)

	if (Dimensions(fl)[1] = 1) and (Dimensions(fl)[2] = n) then
	        fprintf(fd, "%s", "fl\n");
		writeIntMatrix(fd, fl, 1, n);
	else
	        printf("%s", "wrong dimensions in fl\n");
	end if;

	if (Dimensions(l)[1] = 1) and (Dimensions(l)[2] = n) then
	        fprintf(fd, "%s", "l\n");
		writeRatMatrix(fd, l, 1, n);
	else
	        printf("%s", "wrong dimensions in l\n");
	end if;

	if (Dimensions(fu)[1] = 1) and (Dimensions(fu)[2] = n) then
	        fprintf(fd, "%s", "fu\n");
		writeIntMatrix(fd, fu, 1, n);
	else
	        printf("%s", "wrong dimensions in fu\n");
	end if;

	if (Dimensions(u)[1] = 1) and (Dimensions(u)[2] = n) then
	        fprintf(fd, "%s", "u\n");
		writeRatMatrix(fd, u, 1, n);
	else
	        printf("%s", "wrong dimensions in u\n");
	end if;
end proc;

isLinear:=proc(D, n)
	local zero, ret;
	
	zero := LinearAlgebra[ZeroMatrix](n,n);
	if (LinearAlgebra[Equal](D,zero)) then
		ret := 1;
	else
		ret := 0;
	fi;
	return ret;
end proc;

hasEqualitiesOnlyAndFullRank:=proc(a, relop, m)
	local zero, ret;
	
	zero:=LinearAlgebra[ZeroMatrix](m,1);
	if (LinearAlgebra[Equal](relop, zero) and 
	    LinearAlgebra[Rank](a) = m) then
	    ret := 1;
	else
	    ret := 0;
	fi;
	return ret;
end proc;
	
isSymmetric:=proc(D)
	local ret;
	if (LinearAlgebra[Equal](D, LinearAlgebra[Transpose](D))) then	
		ret := 1;
	else
		ret := 0;
	fi;
	return ret;
end proc;

fi; # compatibility