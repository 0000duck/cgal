% =============================================================================
% The CGAL User Manual
% Chapter: Geometric Optimisation
% Section: QP solver
% =============================================================================
\newcommand{\qprel}{\ccTexHtml{\gtreqless}{&nbsp;~&nbsp;}}

\ccUserChapter{QP\_solver}\label{QP_solver}
\ccChapterRelease{Release: WIP (\today)}
\ccChapterAuthor{Kaspar Fischer \and Bernd G{\"a}rtner 
\and Sven Sch{\"o}nherr \and Frans Wessendorp}

\section{Getting Started}
This section explains what linear and quadratic programs are, where
they typically occur in geometric computing, and which other, more
specialized \cgal\ packages exist for solving some of these typical
quadratic programs. If your intended application is not covered
by these packages, \cgal's general quadratic programming solver might
be of use to you.

We conclude this section with a simple example of a quadratic program
and show how it can be solved using \cgal's general quadratic
programming solver.

\subsection{What is a Quadratic Program?}
This package lets you solve \emph{convex quadratic programs} of the 
general form
\begin{eqnarray*}
\mbox{(QP)}&\mbox{minimize} & x^{T}Dx + c^{T}x + c_0 \\
&\mbox{subject to}   & Ax\qprel b, \\
&& l \leq x \leq u
\end{eqnarray*}
over $n$ variables $x=(x_0,\ldots,x_{n-1})$.

Here, $A \in \R^{m \times n}$ is the \emph{constraint matrix} and $b
\in \R^{m}$ the \emph{right-hand} side. The symbol ``$\qprel$'' in the
program's set $Ax \qprel b$ of $m$ \emph{constraints} indicates that for
$i=1,\ldots,m$, the $i$-th constraint may either be an inequality
$(Ax)_i \leq b_i$ or $(Ax)_i \geq b_i$, or an equality $(Ax)_i = b_i$.

Furthermore, $l\in
(\R\cup\{-\infty\})^n$ and $r\in (\R\cup\{\infty\})^n$ are \emph{bounds}
for the variables. Consequently, each
variable $x_j$, $j\in\{0,\ldots,n-1\}$, can be \emph{free} (if
$l_j=-\infty$ and $r_j=\infty$), \emph{upper-bounded} (if
$u_j\neq\infty$) and/or \emph{lower-bounded} (if
$l_j\neq-\infty)$.  

$D \in \R^{n \times n}$ is the \emph{quadratic
objective function matrix}. $D$ must be symmetric and 
positive-semidefinite in order for the \emph{quadratic objective function}
$x^{T}Dx$ to be convex. $c \in \R^{n}$ is the \emph{linear
objective function}, and $c_0$ is the \emph{constant term}. The full
\emph{objective function} is the sum of the quadratic, the linear, and
the constant term.

\emph{Solving} the quadratic program means to find a vector $x^*$ such
that $Ax^*\qprel b, l\leq x^*\leq u$ (a \emph{feasible solution}) with
the smallest objective function value among all feasible solutions.
Such a solution may not exist, see Sections
\ref{sec:QP-infeasible} and \ref{sec:QP-unbounded} below.

\subsection{Linear, Nonnegative, and Free Programs}
If $D=0$, the quadratic program is in fact a \emph{linear program},
and in the case that $l$ is the zero vector and all entries of
$u$ are $\infty$, the program is said to be \emph{nonnegative}. The 
package offers dedicated solution methods for these special cases,
see Sections \ref{sec:QP-lp} and \ref{sec:QP-nonnegative} below.

Often, there are no bounds at all for the variables, i.e.\ all entries
of $l$ are $-\infty$, and all entries of $u$ are $\infty$. Such a
program is called \emph{free}. There is no dedicated solution method
for this case (a free quadratic or linear program is treated like a
general quadratic or linear program), but the package provides models
for free programs that save you from specifying the infinite bounds (see
Section \ref{sec:QP-important_constraints} for an example). 

\subsection{Linear and Quadratic Programs in Geometry}


\subsection{A first example}
Let's consider the following quadratic program in two variables:
\[
\begin{array}{lrcl}
\mbox{minimize}       & x^2 + 4(y-4)^2 &(=& x^2 + 4y^2 - 32y + 64) \\
\mbox{subject to}     & x + y &\leq& 7 \\
                      & -x + 2y &\leq& 4 \\
                      & x &\geq& 0 \\
                      & y &\geq& 0 \\
                      & y &\leq& 4
\end{array}
\]

Figure \ref{fig:QP-first_qp} shows a planar drawing of this. The figure
depicts the five inequalities of the program, along with the
\emph{feasible region} (green), the set of points that satisfy all the
five constraints. The dashed elliptic curves represent \emph{contour lines} 
of the objective function, i.e. along each dashed curve, the objective
function value is constant. 

The global minimum of the objective function is attained at 
the point $(0,4)$, and the minimum within the feasible region appears
at the point $(2,3)$ marked with a black dot. The value of the objective
function at this optimal solution is $2^2 + 4(3-4)^2 = 8$.

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center}
\includegraphics{QP_solver/first_qp} % omit suffix .eps to supprt PS and PDF
\end{center}
\end{ccTexOnly}
\caption{A quadratic program in two variables
\label{fig:QP-first_qp}}

\begin{ccHtmlOnly}
<CENTER>
<IMG BORDER=0 SRC="./first_qp.gif" ALIGN=center ALT="A quadratic program in two variables">
</CENTER>
\end{ccHtmlOnly}
\end{figure}

Here is how this quadratic program can be solved in \cgal\ (for an example
how to work with the type \ccc{double} as input type see Section 
\ref{sec:QP-working_from_iterators}).
The output will be:
\begin{verbatim}
Optimal feasible solution: 2/1  3/1
Optimal objective function value: 8/1
\end{verbatim}

\ccIncludeExampleCode{QP_solver/first_qp.cpp}

\subsection{Finding D }

\section{Which Programs can Efficiently be Solved?}
\label{sec:QP-efficiency}
This can quite precisely be answered in terms of the following
parameters.
\begin{tabular}{lcl}
$n$ &: & the number of variables (or columns of $A$),\\
$m$ &: &the number of constraints (or rows of $A$),\\
$e$ &: &the number of equality constraints,\\
$r$ &: &the rank of the quadratic objective function matrix $D$.
\end{tabular}
The runtime is approximately linear in $\max(n,m)$, 
but with a factor heavily depending on $\min(n,e)+r$.
Therefore, the solver will be efficient only if $\min(n,e)+r$ is small.

Here are the scenarios in which this applies:
\begin{itemize}
\item Quadratic programs with a small number of variables, but
  possibly a large number of inequality constraints
\item Linear programs with a small number of equality constraints but
  possibly a large number of variables
\item Quadratic programs with a small number of equality constraints and
  $D$ of small rank, but possibly with a large number of variables
\end{itemize} 

How small is small? If $\min(n,e)+r$ is up to $10$, the solver will
probably be very fast, even if $\max(n,m)$ goes into the millions. 
If $\min(n,m)+r$ is up to a few hundreds, you may still get a solution 
within reasonable time, depending on the problem characteristics.

If you have a problem where both $n$ and $e$ are above
$1,000$, say, then chances are high that \cgal\ cannot solve it.
This even holds if the problem is \emph{sparse}, i.e. has a small
number of nonzero elements in $A$ and $D$. \cgal's quadratic programming
solver is tailored to \emph{dense} problems and therefore does not 
profit from sparse input.


\section{How Robust is the Solver?}
Given that you use an \emph{exact number type} for the 
calculations (as in the example program above), the solver
will give you \emph{exact rational output}, for \emph{every}
convex quadratic program. This means, there are no robustness
issues with the solver. Not taking bugs into account, the solver 
may fail to compute a solution only if
\begin{itemize}
\item the quadratic program is too large (see previous Section 
\ref{sec:QP-efficiency}), 
\item the quadratic objective function matrix $D$ is not 
positive-semidefinite, or
\item the solver internally cycles. This may happen in very rare
cases (so rare actually that it does not pay off to take
precautions against internal cycling by default). However, if
you have a hunch that the solver cycles on your problem,
there are means to switch to a slower variant that is guaranteed
not to cycle, see\ldots 
\end{itemize}

\section{Solving Linear Programs}\label{sec:QP-lp}
You can solve a linear program by solving a quadratic program with
quadratic objective function matrix $D=0$. But there is a more efficient
dedicated function for solving a linear program that also saves you
from providing $D$ in the first place. 

Let's go back to our first quadratic program from above and change it 
into a linear program by simply removing the quadratic part of the
objective function:

\[
\begin{array}{lrcl}
\mbox{minimize}       & - 32y + 64 \\
\mbox{subject to}     & x + y &\leq& 7 \\
                      & -x + 2y &\leq& 4 \\
                      & x &\geq& 0 \\
                      & y &\geq& 0 \\
                      & y &\leq& 4
\end{array}
\] 

Figure \ref{fig:QP-first_lp} shows how this looks like. We will not
visualize a linear objective function with contour lines but with
arrows instead. The arrow represents the (direction) of the vector $-c$,
and we are looking for a feasible solution that is ``extreme'' in the direction
of the arrow. In our small example, this is the unique point ``on'' the
two constraints $x_1+x_2\leq 7$ and $-x_1+x_2\leq 4$, the point
$(10/3,11/3)$ marked with a black dot. The optimal objective function
value is $-32(11/3)+64=-160/3$.

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center}
\includegraphics{QP_solver/first_lp} % omit suffix .eps to supprt PS and PDF
\end{center}
\end{ccTexOnly}
\caption{A linear program in two variables
\label{fig:QP-first_lp}}

\begin{ccHtmlOnly}
<CENTER>
<IMG BORDER=0 SRC="./first_lp.gif" ALIGN=center ALT="A linear program in two variables">
</CENTER>
\end{ccHtmlOnly}
\end{figure}

Here is a \cgal\ code for solving it. Its output is
\begin{verbatim}
Optimal feasible solution: 10/3  11/3
Optimal objective function value: -160/3
\end{verbatim}

\ccIncludeExampleCode{QP_solver/first_lp.cpp}

\section{Solving Nonnegative Programs}\label{sec:QP-nonnegative}

Often, the bounds in a quadratic or linear program are of the special
type $x\geq 0$. Programs of this type are called nonnegative and
can be solved by dedicated \cgal\ functions. This is more efficient than
calling the general functions, and it saves you from providing any bound
information at all. If we go back to our first quadratic program and
remove the constraint $y\leq 4$, we arrive at a nonnegative quadratic
program: 

\[
\begin{array}{lrcl}
\mbox{minimize}       & x^2 + 4(y-4)^2 &(=& x^2 + 4y^2 - 32y + 64) \\
\mbox{subject to}     & x + y &\leq& 7 \\
                      & -x + 2y &\leq& 4 \\
                      & x,y &\geq& 0
\end{array}
\]

Figure \ref{fig:QP-first_nonnegative_qp} contains 
the planar illustration; since the constraint $y\leq 4$ was 
redundant, the feasible region and the optimal solution do 
not change. 

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center}
\includegraphics{QP_solver/first_nonnegative_qp} 
\end{center}
\end{ccTexOnly}
\caption{A nonnegative quadratic program in two variables
\label{fig:QP-first_nonnegative_qp}}

\begin{ccHtmlOnly}
<CENTER>
<IMG BORDER=0 SRC="./first_nonnegative_qp.gif" ALIGN=center ALT="A linear program in two variables">
</CENTER>
\end{ccHtmlOnly}
\end{figure}

The following program will therefore again output
\begin{verbatim}
Optimal feasible solution: 2/1  3/1
Optimal objective function value: 8/1
\end{verbatim}

\ccIncludeExampleCode{QP_solver/first_nonnegative_qp.cpp}

Finally, a dedicated function is available for nonnnegative linear
programs as well. Let's take our linear program from above and remove
the constraint $y\leq 4$ to obtain a nonnegative linear program. At
the same time we remove the constant objective function term to get
a ``minimal'' input and a ``shortest'' program; the optimal value is
$-32(11/3)=-352/3$.

\[
\begin{array}{lrcl}
\mbox{minimize}       & - 32y \\
\mbox{subject to}     & x + y &\leq& 7 \\
                      & -x + 2y &\leq& 4 \\
                      & x,y &\geq& 0 \\
\end{array}
\] 

This can be solved as follows; the output is
\begin{verbatim}
Optimal feasible solution: 10/3  11/3
Optimal objective function value: -352/3
\end{verbatim}

\ccIncludeExampleCode{QP_solver/first_nonnegative_lp.cpp}

\section{Working from Iterators I}\label{sec:QP-working_from_iterators}
In the examples of the previous sections, the linear or quadratic
program was explicitly represented by arrays. In general, other types
of containers or implicit representations may occur, so the
generic interface to the solver is iterator-based. Let's look at a
situation in which a linear program is given implicitly, and
access to it is gained through properly constructed iterators.

The problem we are going to solve is the following: given points
$p_1,\ldots p_{n}$ in $d$-dimensional space and another point $p$: is
$p$ in the convex hull of $\{p_1,\ldots,p_{n}\}$? In formulas, this is
the case if and only if there real coefficients
$\lambda_1,\ldots,\lambda_n$ such that $p$ is a convex combination of
$p_1,\ldots,p_n$: 
\[
p = \sum_{j=1}^{n}~\lambda_j~p_j, \quad \sum_{j=1}^{n}~\lambda_j = 1,
\quad \lambda_j \geq 0 \mbox{~for all $j$.}
\]
The problem of testing the existence of such $\lambda_j$ can 
be expressed as a linear program. It becomes particularly easy
when we use the homogeneous representations of the points: if
$q_1,\ldots,q_n,q\in\R^{d+1}$ are homogeneous coordinates for
$p_1,\ldots,p_n,p$ with positive homogenizing coordinates 
$h_1,\ldots,h_n,h$, we have
\[q_j = h_j \cdot (p_j \mid 1) \mbox{~for all $j$, and~} q = h \cdot
(p\mid 1).\] Now, nonnegative $\lambda_1,\ldots,\lambda_n$ are
suitable coefficients for a convex combination if and only if
\[\sum_{j=1}^n~ \lambda_j(p_j \mid 1) = (p\mid 1), \]
equivalently, if there are $\mu_1,\ldots,\mu_n$ 
(with $\mu_j = \lambda_j \cdot h/{h_j}$ for all $j$) such that
\[
\sum_{j=1}^n~\mu_j~q_j = q, \quad \mu_j \geq 0\mbox{~for all $j$}.
\]

The linear program now tests for the existence of nonnegative $\mu_j$
that satisfy the latter equation. Below is the code; it defines a
function that solves the linear program, given $p$ and
$p_1,\ldots,p_n$ (through an iterator range).

\ccIncludeExampleCode{QP_solver/solve_convex_hull_containment_lp.h}

To see this in action, let us call it with $p_1=(0,0), p_2=(10,0),
p_3=(0,10)$ fixed (they define a triangle) and all integral points $p$
in $[0,10]^2$. We know that $p$ is in the convex hull of
$\{p_1,p_2,p_3\}$ if and only if its two coordinates sum up to $10$ at
most.

\ccIncludeExampleCode{QP_solver/convex_hull_containment.cpp}

\subsection{Using Makers}
You already noticed in the previous example that the actual 
template arguments for 
\ccc{CGAL::Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, C_it>} 
can be quite elaborate, and this only gets worse if you plug more 
iterators into each other. In general, you want to construct a 
program from given expressions for the iterators, but the
types of these expressions are probably very complicated and 
difficult to look up. 

You can avoid the explicit construction of the type
\ccc{CGAL::Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, C_it>} 
if you only need an expression of it, e.g.\ to pass it directly 
as an argument to the solving function. Here is how this works.

\ccIncludeExampleCode{QP_solver/solve_convex_hull_containment_lp2.h}

\section{Working from Iterators II}\label{sec:QP-working_from_iteratorsII}
Here we discuss another typical application of quadratic programming
in geometry; its iterator-based solution is somewhat more advanced,
since the constraint matrix is quite naturally available row-wise, 
but the solver needs it column-wise.

The problem is that of finding the point $q$
in the intersection of halfspaces that is closest to a given point $p$, 
see Figure \ref{fig:QP-closest_point}. 

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center}
\includegraphics{QP_solver/closest_point} 
\end{center}
\end{ccTexOnly}
\caption{The closest point in the intersection of halfspaces
\label{fig:QP-closest_point}}

\begin{ccHtmlOnly}
<CENTER>
<IMG BORDER=0 SRC="./closest_point.gif" ALIGN=center ALT="The closest point in the intersection of halfspaces">
</CENTER>
\end{ccHtmlOnly}
\end{figure}

Let us assume that the closed halfspaces are modeled as positive halfspaces
defined by objects of type \ccc{CGAL::Hyperplane_d<Kernel>} in $d$-dimensional
space. Such a hyperplane has the formula 
\[\sum_{0\leq i< d}~ h_{i}x_{i} + h_{d}=0,\]
and the positive halfspace is the set of all $x=(x_{0},\ldots,x_{d-1})$ 
such that 
\[\sum_{0\leq i< d}~h_{i}x_{i} + h_{d} \geq 0.\]

Now we want to minimize the quadratic function $\|p-x\|^2$ among all $x$
that are contained in all the positive halfspaces. Expanding this function
yields 
\[
\|p-x\|^2 = x^{T}x - 2p^{T}x + p^{T}p.
\]
Consequently, the quadratic objective function matrix $D$ is the identity
matrix, the linear objective function vector $c$ is 
$(-2p_{0},\ldots -2p_{d-1})$, and the constant term $c_{0}$ is
\[
\sum_{0\leq i< d}~ p_{i}^2.
\]  


\section{The Important Variables}
If we have an optimal solution $x^*$ of a linear or quadratic program,
the ``important'' variables are typically the ones that are not on
their bounds. In case of a nonnegative program, these are the nonzero
variables.  Going back to the example of the previous Section
\ref{sec:QP-working_from_iterators}, we can easily interpret their
importance: the nonzero variables correspond to points $p_j$ that
actually contribute to the convex combination that yields $p$. 

The following example shows how we can access the important variables.
We generate a set of points on a line and then find the ones that 
contribute to the convex combinations of intermediate points.

\ccIncludeExampleCode{QP_solver/important_variables.cpp}

Not surprisingly, only two points contribute to any convex
combination.

\section{The Important Constraints}\label{sec:QP-important_constraints}
If we have a linear or quadratic program with many inequality constraints,
the ``important'' constraints are typically the ones that are satisfied with
equality at the optimal solution. 




\section{Working from MPS Files}

\section{Infeasibility}\label{sec:QP-infeasible}

\section{Unboundedness}\label{sec:QP-unbounded}




\section{Solution Certificates}



