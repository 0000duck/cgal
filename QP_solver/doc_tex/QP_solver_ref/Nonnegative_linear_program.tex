\begin{ccRefClass}{Nonnegative_linear_program<NT>}

\ccInclude{CGAL/QP_models.h}

\ccDefinition
An object of class \ccRefName\ describes a linear program of the form
%%
\begin{eqnarray*}
\mbox{(LP)}& \mbox{minimize} & c^{T}x+c_0 \\
&\mbox{subject to}   & Ax\qprel b, \\
&                    & x \geq 0
\end{eqnarray*}
%%
in $n$ real variables $x=(x_0,\ldots,x_{n-1})$.
Here, 
\begin{itemize}
\item $A$ is an $m\times n$ matrix (the constraint matrix), 
\item $b$ is an $m$-dimensional vector (the right-hand side),
\item $\qprel$ is an $m$-dimensional vector of relations 
from $\{\leq, =, \geq\}$, 
\item $c$ is an $n$-dimensional vector (the linear objective
  function), and 
\item $c_0$ is a constant.
\end{itemize}

This class allows you to build your program entry by entry, using
the set-methods below. If you only need to wrap existing (random-access)
iterators, then you may use the classes 
\ccc{Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it>} and \ccc{Nonnegative_linear_program_from_pointers<NT>}). 
If you want to read a nonnegative linear program in \ccc{MPSFormat} from a 
file, please use the model \ccc{Nonnegative_linear_program_from_mps<NT>}.

\ccIsModel
\ccc{NonnegativeLinearProgramInterface}

\ccTypes

\ccNestedType{NT}{The number type of the program entries.}

\ccCreation
\ccIndexClassCreation
\ccCreationVariable{lp}

\ccConstructor{
Nonnegative_linear_program(CGAL::Comparison_result default_r = CGAL::EQUAL);}
{constructs a nonnegative
linear program with no variables and no constraints, ready
for data to be added. Unless relations are explicitly set, 
relations will be of type \ccc{default_r}. 
Numerical entries that are not explicitly set will default to $0$.}

\ccOperations

\ccCreationVariable{lp}

\ccMethod{bool is_linear() const;}{returns \ccc{true}.}

\ccMethod{bool is_nonnegative() const;}{returns \ccc{true}.}

\ccMethod{void set_a (int j, int i, const NT& val);}{sets the entry $A_{ij}$
in column $j$ and row $i$ of the constraint matrix $A$ of \ccVar\ to 
\ccc{val}. An existing entry is overwritten. \ccVar\ is enlarged if
necessary to accomodate this entry.}

\ccMethod{void set_b (int i, const NT& val);}{sets the entry $b_i$
of \ccVar\ to \ccc{val}. An existing entry is overwritten. 
\ccVar\ is enlarged if necessary to accomodate this entry.}

\ccMethod{void set_c (int j, const NT& val);}{sets the entry $c_j$
of \ccVar\ to \ccc{val}. An existing entry is overwritten. 
\ccVar\ is enlarged if necessary to accomodate this entry.}

\ccMethod{void set_c0 (const NT& val);}{sets the entry $c_0$
of \ccVar\ to \ccc{val}. An existing entry is overwritten.}

\ccSeeAlso
\ccc{Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, C_it>}\\
\ccc{Nonnegative_linear_program_from_pointers<NT>}\\
\ccc{Nonnegative_linear_program_from_mps<NT>}

\end{ccRefClass}
