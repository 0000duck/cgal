\begin{ccRefClass}{Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, C_it>}

\ccInclude{CGAL/QP_models.h}

\ccDefinition
An object of class \ccRefName\ describes a linear program of the form
%%
\begin{eqnarray*}
\mbox{(LP)}& \mbox{minimize} & c^{T}x+c_0 \\
&\mbox{subject to}   & Ax\qprel b, \\
&                    & x \geq 0
\end{eqnarray*}
%%
in $n$ real variables $x=(x_0,\ldots,x_{n-1})$.
Here, 
\begin{itemize}
\item $A$ is an $m\times n$ matrix (the constraint matrix), 
\item $b$ is an $m$-dimensional vector (the right-hand side),
\item $\qprel$ is an $m$-dimensional vector of relations 
from $\{\leq, =, \geq\}$, 
\item $c$ is an $n$-dimensional vector (the linear objective
  function), and 
\item $c_0$ is a constant.
\end{itemize}

This class is simply a wrapper for existing iterators, and it does not
copy the program data (if you need a copy, you may use the class 
\ccc{Nonnegative_linear_program<NT>}).

It frequently happens that all values in one of the vectors from
above are the same, for example if the system $Ax\qprel b$ is 
actually a system of equations $Ax=b$. To get an iterator over such a 
vector, it is not necessary to store multiple copies of the value in
some container; an instance of the class \ccc{Const_oneset_iterator<T>},
constructed from the value in question, does the job more efficiently.

\ccIsModel
\ccc{NonnegativeLinearProgramInterface}


\ccCreation
\ccIndexClassCreation
\ccCreationVariable{lp}

\ccConstructor{Nonnegative_linear_program_from_iterators(int n, int m, 
  const A_it& a, 
  const B_it& b,
  const R_it& r,
  const C_it& c,
  const std::iterator_traits<C_it>value_type& c0 = 0
  )}{constructs \ccVar\ from given random-access iterators and the constant 
\ccc{c0}. The passed iterators are merely stored, no copying of the program 
data takes place. How these iterators are supposed to encode the nonnegative 
linear program is described in \ccc{NonnegativeLinearProgramInterface}.}

\ccExample

\ccReferToExampleCode{QP_solver/first_nonnegative_lp_from_iterators.cpp}\\
\ccReferToExampleCode{QP_solver/solve_convex_hull_containment_lp.h}

\ccSeeAlso
\ccc{NonnegativeLinearProgramInterface}
\ccc{Quadratic_program<NT>}\\
\ccc{Quadratic_program_from_mps<NT>}
\end{ccRefClass}
