\begin{ccRefClass}{Quadratic_program_from_mps<NT>}

\ccInclude{CGAL/QP_models.h}

\ccDefinition
An object of class \ccRefName\ describes a convex quadratic program of the 
general form
%%
\begin{eqnarray*}
\mbox{(QP)}& \mbox{minimize} & x^{T}Dx+c^{T}x+c_0 \\
&\mbox{subject to}   & Ax\qprel b, \\
&                    & l \leq x \leq u
\end{eqnarray*}
%%
in $n$ real variables $x=(x_0,\ldots,x_{n-1})$. If $D=0$, the program is
a linear program; if the variable bounds are $x\geq 0$, we have a 
nonnegative program. More specifically,  
\begin{itemize}
\item $A$ is an $m\times n$ matrix (the constraint matrix), 
\item $b$ is an $m$-dimensional vector (the right-hand side),
\item $\qprel$ is an $m$-dimensional vector of relations 
from $\{\leq, =, \geq\}$, 
\item $l$ is an $n$-dimensional vector of lower
bounds for $x$,
\item $u$ is an $n$-dimensional vector of upper bounds for
$x$, 
\item $D$ is a symmetric positive-semidefinite $n\times n$ matrix (the
  quadratic objective function),
\item $c$ is an $n$-dimensional vector (the linear objective
  function), and 
\item $c_0$ is a constant.
\end{itemize}

The program data are read from an input stream in \ccc{MPSFormat}. This is
a commonly used format for encoding linear and quadratic programs that
is understood by many solvers. All values are expected to be readable
into type \ccc{NT}. The constructed program can be further manipulated 
by using the set-methods below.

\ccIsModel
\ccc{QuadraticProgramInterface}\\
\ccc{LinearProgramInterface}\\
\ccc{NonnegativeQuadraticProgramInterface}\\
\ccc{NonnegativeLinearProgramInterface}

\ccTypes
\ccNestedType{NT}{The number type of the program entries.}

\ccCreation
\ccIndexClassCreation
\ccCreationVariable{qp}

\ccConstructor{Quadratic_program_from_mps(std::istream& in)} 
{reads \ccVar\ from the input stream \ccc{in}.}

\ccOperations

\ccMethod{bool is_valid() const;}{returns \ccc{true} if and only if an
MPS-encoded quadratic program could be extracted from the input stream.}

\ccMethod{const std::string& get_name_of_variable (int j) const;} 
{returns the name of the $j$-th variable. \ccPrecond j must not refer to a variable that has been added later, using one of the set methods below.}

\ccMethod{bool is_linear() const;}{returns \ccc{true} if and only if 
\ccVar\ is a linear program.}

\ccMethod{bool is_nonnegative() const;}{returns \ccc{true} if and only if  
\ccVar\ is a nonnegative program.}

\ccMethod{const std::string& get_error() const;}{if !\ccVar\ccc{.is_valid()},
this method returns an error message explaining why the input does not
conform to the \ccc{MPSFormat}.}

\ccMethod{void set_a (int j, int i, const NT& val);}{sets the entry $A_{ij}$
in column $j$ and row $i$ of the constraint matrix $A$ of \ccVar\ to 
\ccc{val}. An existing entry is overwritten. \ccVar\ is enlarged if
necessary to accomodate this entry.}

\ccMethod{void set_b (int i, const NT& val);}{sets the entry $b_i$
of \ccVar\ to \ccc{val}. An existing entry is overwritten. 
\ccVar\ is enlarged if necessary to accomodate this entry.}

\ccMethod{void set_l (int j, bool is_finite, const NT& val = NT(0));}
{if \ccc{is_finite}, this sets the entry $l_j$ of \ccVar\ to \ccc{val},
otherwise it sets $l_j$ to $-\infty$. An existing entry is overwritten. 
\ccVar\ is enlarged if necessary to accomodate this entry.}

\ccMethod{void set_u (int j, bool is_finite, const NT& val = NT(0));}
{if \ccc{is_finite}, this sets the entry $u_j$ of \ccVar\ to \ccc{val},
otherwise it sets $u_j$ to $\infty$. An existing entry is overwritten. 
\ccVar\ is enlarged if necessary to accomodate this entry.}

\ccMethod{void set_c (int j, const NT& val);}{sets the entry $c_j$
of \ccVar\ to \ccc{val}. An existing entry is overwritten. 
\ccVar\ is enlarged if necessary to accomodate this entry.}

\ccMethod{void set_c0 (const NT& val);}{sets the entry $c_0$
of \ccVar\ to \ccc{val}. An existing entry is overwritten.}

\ccMethod{void set_d (int i, int j, const NT& val);}{sets the entries 
$2D_{ij}$ and $2D_{ji}$ of \ccVar\ to \ccc{val}. Existing entries are 
overwritten. \ccVar\ is enlarged if necessary to accomodate these entries.
\ccPrecond \ccc{j <= i}}

\ccExample

\ccReferToExampleCode{QP_solver/first_qp_from_mps.cpp}\\
\ccReferToExampleCode{QP_solver/first_lp_from_mps.cpp}\\
\ccReferToExampleCode{QP_solver/first_nonnegative_qp_from_mps.cpp}\\
\ccReferToExampleCode{QP_solver/first_nonnegative_lp_from_mps.cpp}

\ccSeeAlso
\ccc{Quadratic_program<NT>}\\
\ccc{Quadratic_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it>}\\
\ccc{Linear_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, C_it>}\\
\ccc{Nonnegative_quadratic_program_from_iterators<A_it, B_it, R_it, D_it, C_it>}\\
\ccc{Nonnegative_linear_program_from_iterators<A_it, B_it, R_it, C_it>}
\end{ccRefClass}
