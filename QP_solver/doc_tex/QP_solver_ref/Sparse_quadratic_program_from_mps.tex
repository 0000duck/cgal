\begin{ccRefClass}{Sparse_quadratic_program_from_mps<NT>}

\ccInclude{CGAL/QP_models.h}

\ccDefinition
An object of class \ccRefName\ describes a convex quadratic program of the form
%%
\begin{eqnarray*}
\mbox{(QP)}& \mbox{minimize} & x^{T}Dx+c^{T}x+c_0 \\
&\mbox{subject to}   & Ax\qprel b, \\
&                    & l \leq x \leq u
\end{eqnarray*}
%%
in $n$ real variables $x=(x_0,\ldots,x_{n-1})$.
Here, 
\begin{itemize}
\item $A$ is an $m\times n$ matrix (the constraint matrix), 
\item $b$ is an $m$-dimensional vector (the right-hand side),
\item $\qprel$ is an $m$-dimensional vector of relations 
from $\{\leq, =, \geq\}$, 
\item $l$ is an $n$-dimensional vector of lower
bounds for $x$,
\item $u$ is an $n$-dimensional vector of upper bounds for
$x$, 
\item $D$ is a symmetric positive-semidefinite $n\times n$ matrix (the
  quadratic objective function),
\item $c$ is an $n$-dimensional vector (the linear objective
  function), and 
\item $c_0$ is a constant.
\end{itemize}

The program data are read from an input stream in \ccc{MPSFormat}. This is
a commonly used format for encoding linear and quadratic programs that
is understood by many solvers. 

\textbf{Note:} 
The space requirements are bounded by the number of nonzero entries
in the program description. However, if you can afford space
$\Theta(nm + n^2)$, the model \ccc{Quadratic_program_from_mps<NT>}
might be preferrable, since in the latter model, access to the iterators 
in \ccc{QuadraticProgramInterface} will be faster.

As a rule of thumb, if there is a need for the sparse model
\emph{because both $m$ and $n$ are large}, then \cgal's quadratic
programming solver will probably not be able to solve it anyway.

\ccIsModel
\ccc{QuadraticProgramInterface}

\ccCreation
\ccIndexClassCreation
\ccCreationVariable{qp}

\ccConstructor{Sparse_quadratic_program_from_mps(std::istream& in)} {reads \ccVar\ from the input stream \ccc{in}.}

\ccOperations

\ccMethod{bool is_valid() const;}{returns \ccc{true} if and only if an
MPS-encoded program could be extracted from the input stream.}

\ccMethod{const std::string& name_of_variable (int i) const;} {returns the name of the $i$-th variable.\ccPrecond \ccVar\ccc{.is_valid()}}

\ccMethod{bool is_linear() const;}{returns \ccc{true} if and only if the quadratic program read into \ccVar\ is a linear program.
\ccPrecond \ccVar\ccc{.is_valid()}}

\ccMethod{bool is_nonnegative() const;}{returns \ccc{true} if and only if the quadratic program read into \ccVar\ is a nonnegative program
\ccPrecond \ccVar\ccc{.is_valid()}.}

\ccMethod{const std::string& error() const;}{returns an error message explaining why the input is not in MPS format \ccPrecond \ccc{!} \ccVar\ccc{.is_valid()}}

\ccSeeAlso
\ccc{Quadratic_program_from_mps<NT>}\\
\ccc{Quadratic_program<NT>}\\
\ccc{Quadratic_program_from_iterators<A_it, B_it, R_it, FL_it, L_it, FU_it, U_it, D_it, C_it>}\\
\ccc{Quadratic_program_from_pointers<NT>}


\end{ccRefClass}
