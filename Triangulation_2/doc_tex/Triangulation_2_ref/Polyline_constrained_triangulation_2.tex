
\begin{ccRefClass}{Polyline_constrained_triangulation_2<Tr>}


The class \ccRefName\ 
implements a constrained triangulation 
with an additional data
structure called the  constraint hierarchy 
that keeps track of  the input constraints and of their refinement
in the triangulation.

The class \ccc{Polyline_constrained_triangulation_2<Tr>}
inherits from its template parameter Tr, which has to be instantiated
by a constrained or constrained Delaunay  triangulation.

The class \ccRefName\ inherits from the base class the type \ccc{Constraint},
which is a \ccc{std::pair<Point,Point>}. In addition to pairs
of points representing a segment, this class supports polyline constraints 
given as \ccc{Range} of points. 

According to its intersection tag, the base class
will support intersecting input constraints or not.
When intersections of input constraints are supported,
the base class constructs a triangulation  of the  arrangement
of the constraints,
introducing new vertices at each proper intersection
point and  refining the input constraints into sub-constraints
which are edges (more precisely constrained edges) of the
triangulation. 
In this context, the constraint hierarchy 
keeps track of  the input constraints and of their refinement
in the triangulation. This data structure 
maintains for each input constraints 
the sequence of intersection vertices added on this constraint.
The constraint hierarchy also allows the user to retrieve the set
of constrained edges of the triangulation, and for each
constrained edge,  the set of input constraints that overlap it.

\ccInclude{CGAL/Polyline_constrained_triangulation_2.h}

\ccInheritsFrom
\ccc{Tr} which is either a \ccc{CGAL::Constrained_triangulation_2<Traits,Tds>} or a \ccc{CGAL::Constrained_Delaunay_triangulation_2<Traits,Tds>}.

\ccTypes 
\ccTypedef{typedef Tr Triangulation;}{the triangulation base class.}

\ccNestedType{Constaint_id}{The identifier of a polyline constraint.}
\ccNestedType{Constraint_iterator}{An iterator to visit
all the input  constraints. The order of visit is arbitrary.
The value type of this iterator  is a \ccc{Constraint_id}.}

\ccNestedType{Subconstraint_iterator}{An iterator 
to visit all the sub-constraints  of the triangulation.
The order of visit is arbitrary.
The value type of this iterator is a pair 
\ccc{std::pair<Vertex_handle, Vertex_handle>}
corresponding to the vertices of  the
sub-constraint.}

\ccNestedType{Vertices_in_constraint_iterator}{ An iterator on the
vertices of the chain of triangulation edges representing a
constraint. The value type of this iterator is \ccc{Vertex_handle}.}

\ccNestedType{Points_in_constraint_iterator}{ An iterator on the
points of the chain of triangulation edges representing a
constraint. The value type of this iterator is \ccc{Point}.
A \ccc{Vertices_in_constraint_iterator} can be converted into
a \ccc{Points_in_constraint_iterator}, but not the other way round.}

\ccTypedef{typedef Context;}{This type is intended to describe
a constraint enclosing  a sub-constraint  and the position of the
sub-constraint in this constraint.
It provides three member functions \ccc{vertices_begin()}, \ccc{vertices_end()}
and \ccc{current()} returning 
iterators of the type \ccc{Vertices_in_constraint_iterator}
on the sequence of vertices of the enclosing constraint. 
These iterators point
respectively on the first vertex of the enclosing constraint,
past the last vertex  
and on the first vertex of the sub-constraint.}



\ccTypedef{typedef Context_iterator;}{An iterator on 
 constraints enclosing a given sub-constraint. The value type of this
iterator
is \ccc{Context}.}


\ccCreation
\ccCreationVariable{pct}

\ccConstructor{Polyline_constrained_triangulation_2(const Geom_traits& gt=Geom_traits())}
{Introduces an empty triangulation.}

\ccConstructor{Polyline_constrained_triangulation_2(const
Polyline_constrained_triangulation_2& ct);}{Copy constructor.}


\ccConstructor{ template<class InputIterator> 
Polyline_constrained_triangulation_2(
        			InputIterator first,
                               	InputIterator last,
                               const Geom_traits& gt= Geom_traits());}
{Introduces a constrained triangulation 
from the constraints in the range
$\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$.
\ccPrecond The \ccc{value_type} of \ccc{first} and \ccc{last}
 is either \ccc{Constraint} or a \ccc{Range} of points.
}



\ccHeading{Assignment}

\ccMethod{Polyline_constrained_triangulation_2 operator=(const
Polyline_constrained_triangulation_2& tr);}
{Assignment. All the vertices and faces are duplicated.
 The constraint hierarchy is also duplicated.}

\ccMethod{void swap(Polyline_constrained_triangulation_2 tr);}
{The triangulations \ccc{tr} and \ccVar\ are swapped.
This operation should be preferred to \ccVar\ = \ccc{tr} or to
\ccc{t(tr)} if \ccc{tr} is deleted after that.}

\ccHeading{Insertion and Removal}
The class \ccRefName\ overwrites the following insertion and removal
member functions for points and constraints.

\ccMethod{Vertex_handle insert(const Point& p, 
Face_handle start = Face_handle() );}
{Inserts point \ccc{p} as a vertex of the triangulation.}

\ccMethod{Vertex_handle insert(const Point& p,
		       Locate_type lt,
		       Face_handle loc, int li );}
{inserts a point \ccc{p} whose location is assumed 
to be given by \ccc{(lt,loc,li)}.}

\ccMethod{Vertex_handle push_back(const Point& p);}
{Equivalent to \ccc{insert(p)}.}

\ccMethod{template < class InputIterator >
          size_type
          insert(InputIterator first, InputIterator last);}
{Inserts the points in the range
 $\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$.
 Returns the number of inserted points.
 \ccPrecond The \ccc{value_type} of \ccc{first} and \ccc{last}
 is \ccc{Point}.}


\ccMethod{ Constraint_id insert_constraint(std::pair<Point,Point> c);}
{Inserts the constraint \ccc{c}.}

\ccMethod{ Constraint_id insert_constraint(Point a, Point b);}
{Inserts the constraint segment \ccc{ab} in the triangulation. }

\ccMethod{ Constraint_id insert_constraint(Vertex_handle va, Vertex_handle vb);}
{ Inserts a constraint whose endpoints are the vertices 
pointed by \ccc{va} and \ccc{vb} in the triangulation. }


\ccMethod{template <class PolygonTraits_2,class Container> Constraint_id insert_constraint(const Polygon_2<PolygonTraits_2,Container>& P);}
{ Inserts the polygon \ccc{P} as constraint.}


\ccMethod{ template < class InputIterator >
           size_type 
           insert_constraint(InputIterator first, InputIterator last);}
{ Inserts the constraint 
$\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$.
\ccPrecond The \ccc{value_type} of \ccc{InputIterator} is \ccc{Point}.}


\ccMethod{ template < class InputIterator >
           size_type 
           insert_constraints(InputIterator first, InputIterator last);}
{ Inserts constraints in the range
$\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$.
\ccPrecond The \ccc{value_type} of \ccc{first} and \ccc{last}
 is either \ccc{std::pair<Point>}, or \ccc{Polygon_2}, or a \ccc{Range} of points.}

\ccMethod{void remove_constraint(Constraint_id id);}
{Removes the constraint \ccc{id}.}


\ccHeading{Queries}
\ccMethod{ Constraint_iterator constraints_begin() const;}
{Returns a \ccc{Constraint_iterator} pointing on the first
constraint.}
\ccGlue
\ccMethod{Constraint_iterator constraints_end()   const;}
{Returns a \ccc{Constraint_iterator} pointing past the last
constraint.}
\ccGlue
\ccMethod{Subconstraint_iterator subconstraints_begin() const;}
{Returns a \ccc{Subconstraint_iterator} pointing on the first
sub-constraint.}
\ccGlue
\ccMethod{Subconstraint_iterator subconstraints_end() const;}
{Returns a \ccc{Subconstraint_iterator} pointing past the last
sub-constraint.}
\ccGlue
\ccMethod{int number_of_enclosing_constraints(Vertex_handle va, 
				      Vertex_handle vb);}
{Returns the number of constraints enclosing the sub-constraint
\ccc{(va,vb).}
\ccPrecond \ccc{va} and \ccc{vb} refer to  the vertices
of a constrained edge of the triangulation.}
\ccGlue
\ccMethod{Context  context(Vertex_handle va, Vertex_handle vb);}
{Returns the \ccc{Context}  relative to  one of the constraint 
enclosing  the sub-constraint  \ccc{(va,vb)}.
\ccPrecond \ccc{va} and \ccc{vb} refer to  the vertices
of a constrained edge of the triangulation.}
\ccGlue
\ccMethod{Context_iterator   contexts_begin(Vertex_handle va, 
				    Vertex_handle vb);}
{Returns an iterator pointing on the first \ccc{Context}
of the sequence of \ccc{Contexts}
corresponding to the constraints enclosing the sub-constraint\ccc{(va,vb).}
\ccPrecond \ccc{va} and \ccc{vb} refer to  the vertices
of a constrained edge of the triangulation.}
\ccGlue
\ccMethod{Context_iterator   contexts_end(Vertex_handle va, 
				  Vertex_handle vb);}
{Returns an iterator past the last  \ccc{Context}
of the sequence of \ccc{Contexts}
corresponding to the constraints enclosing the  \ccc{(va,vb).}
\ccPrecond \ccc{va} and \ccc{vb} refer to  the vertices
of a constrained edge of the triangulation.}
\ccGlue
\ccMethod{Vertices_in_constraint_iterator 
vertices_in_constraint_begin(Constraint_id id);}
{Returns an iterator on the first vertex on the constraint
\ccc{id}.}
\ccGlue
\ccMethod{Vertices_in_constraint_iterator 
vertices_in_constraint_end(Constraint_id id);}
{Returns an iterator past the last vertex on  the constraint
\ccc{id}.}

\ccHeading{Operations on Constraints}

\ccMethod{Constraint_id concatenate(Constraint_id first, Constraint_id second);}
{Concatenates \ccc{first} and \ccc{second}. 
\ccPrecond The last vertex of \ccc{first} and the first vertex of \ccc{second}
must be identical.}

\ccMethod{Constraint_id split(Constraint_id first, Vertices_in_constraint_iterator vcit);}
{Splits a constraint in two constraints, so that \ccc{vcit} becomes the first
vertex of the new constraint. Returns the new constraint.
\ccPrecond \ccc{vcit} must not be the last vertex on the constraint.}

%\ccMethod{template <class OutputIterator>
%  Vertices_in_constraint_iterator
%  insert_vertex_in_constraint(Constraint_id cid, Vertices_in_constraint_iterator pos, 
%			      Vertex_handle vh, OutputIterator out);}
%{Inserts \ccc{vh} before \ccc{pos}. Returns an iterator pointing on the newly inserted vertex.
% Writes the modified faces to \ccc{out}.}

\ccHeading{Polyline Simplification}

The polyline simplification algorithm of in Chapter~\ref{chapter-polylinesimplification}
uses the following functions.

\ccMethod{Vertices_in_constraint_iterator
  remove_vertex_from_constraint(Constraint_id cid, Vertices_in_constraint_iterator pos, bool keep_point = false);}
{Removes the vertex at \ccc{pos} from the constraint and the triangulation.
If \ccc{keep_points} is \ccc{true} only the vertex but not the point is removed from the constraint \ccc{cid}.} 

\ccMethod{Vertices_in_constraint_iterator
  remove_points_from_constraint(Constraint_id cid);}
{Removes the points that were kept in the constraint \ccc{cid}.}

\ccMethod{Vertices_in_constraint_iterator
  remove_points_from_constraints();}
{Removes the points that were kept in the constraints.}

User code may exclude vertices in polyline constraints from getting removed with 
the following function.

\ccMethod{bool is_removable(Vertex_handle vh) const;}
{Returns \ccc{true} iff the vertex shall not be removed.}

\ccMethod{bool set_removable(Vertex_handle vh, bool b);}
{Sets the marker of a vertex to \ccc{b}, and returns the previous value.}

\ccMethod{bool is_fixed(Vertices_in_constraint_iterator it) const;}
{Returns \ccc{true} iff the vertex shall not be simplified.}



\ccSeeAlso
\ccc{CGAL::Constrained_triangulation_plus_2<Tr>} \\
\ccc{CGAL::Constrained_triangulation_2<Traits,Tds>} \\
\ccc{CGAL::Constrained_Delaunay_triangulation_2<Traits,Tds>} \\
\ccc{ConstrainedTriangulationTraits_2} \\
\ccc{ConstrainedDelaunayTriangulationTraits_2}

\end{ccRefClass}

