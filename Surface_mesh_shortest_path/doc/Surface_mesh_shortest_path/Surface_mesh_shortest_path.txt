namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Surface_mesh_shortest_path
\anchor chaptersurfacemeshshortestpath
\cgalAutoToc
\author Stephen Kiazyk, Sébastien Loriot, and Éric Colin de Verdière

This package provides an algorithm to compute shortest paths on a triangulated surface mesh.

\cgalFigureBegin{Shortest_path_main,shortest_paths_overview.png}
The shortest paths computation on a terrain.
\cgalFigureEnd

\section Surface_mesh_shortest_pathIntroduction Introduction

An example of an application of shortest paths would be planning the motion of a robot across the surface a 3-dimensional terrain.  Using a 2-dimensional approximation would fail to capture anything interesting about the terrain we are trying to cross, and would give a poor solution.  The problem is often called the <em>Discrete Geodesic Problem</em>.  Although the more general version of this problem, shortest paths in 3D in the presence of obstacles, is NP-Hard, when all motion is constrained to the 2D surface of an object it can be solved efficiently.

  The algorithm in this package builds a data structure to efficiently answer queries of this form: given a polyhedral surface \f$\cal{P}\f$, a set of source points \f$S\f$ on \f$\cal{P}\f$, and a target point \f$t\f$ also on \f$\cal{P}\f$, find a shortest path \f$\lambda\f$ between \f$q\f$ and any element \f$s \in S\f$, where \f$\lambda\f$ is constrained to the surface of \f$\cal{P}\f$.

The algorithm used is based on a paper by Xin and Wang \cgalCite{XinWang2009improvingchenandhan}, a fast and practical algorithm for exact computation of shortest paths. It is an extension of earlier results by Chen and Han \cgalCite{ch-spp-96} and Mitchell, Mount, and Papadimitriou \cgalCite{mmp-dgp-87} .

\section Surface_mesh_shortest_pathHowToUse How To Use

In order to use the algorithm, one creates an instance of the `Surface_mesh_shortest_path` class, passing in a model of the `FaceListGraph`, and appropriate property maps for ID lookup of vertex, halfedge, and face items, and a map between vertices and their locations as `Point_3` instances.

\subsection Surface_mesh_shortest_pathTraitsClass Traits Class
  The `SurfaceMeshShortestPathTraits` concept provides all of the necessary geometric primitives for the shortest path algorithm. A default model of this concept is provided by `Surface_mesh_shortest_path_traits`. It requires a Cartesian geometry kernel, and a model of the \cgal BGL `FaceListGraph` concept.
  
\subsubsection Surface_mesh_shortest_pathKernelRecommendataions Kernel Recommendations
  The recommended kernel to use with this package is `CGAL::Exact_predicates_inexact_constructions`.
  
  It is recommended that users avoid using the `CGAL::Exact_predicates_exact_constructions_with_sqrt` kernel with this package. In order to compute the distance along the surface, it is necessary to unfold sequences of faces, edge-to-edge, out into a common plane.  The functor `Construct_triangle_3_to_triangle_2_projection` provides an initial layout of the first face in a sequence, by rotating a given face into the XY plane.  `Construct_triangle_3_along_segment_2_flattening` unfolds a triangle into the plane, using a specified segment as a base.  Since this results in a chain of constructed triangles in the plane, the exact representation types used with this kernel (either CORE::Expr or leda::real) will process extremely slow, even on very simple inputs.  This is because the exact representations will effectively add an \f$O(n)\f$ factor to every computation.
  
  Although algorithm uses `sqrt` operations, it will also work on geometry kernels which do not support `sqrt` by first converting the kernel's number type to `double`, performing the `sqrt`, and converting it back. Note that it is preferable to use a kernel with directly supports `sqrt`.

\subsubsection Surface_mesh_shortest_pathFaceListGraph Face List Graph
  
  The `FaceListGraph` type must support all of the \cgal BGL (boost graph library) extension operations for the `FaceListGraph` concept. Any surface mesh on 3D points may be used with this package; there are no restrictions on the genus, connectivity, or convexity of the input surface. However, additional property maps for the data items must be provided to the `Surface_mesh_shortest_path` class upon construction.

\subsubsection Surface_mesh_shortest_pathIndexPropertyMaps Item Index Property Maps

  The algorithm requires property maps which map each `boost::GraphTraits<FaceListGraph>::%vertex_descriptor`, `boost::GraphTraits<FaceListGraph>::%halfedge_descriptor`, and `boost::GraphTraits<FaceListGraph>::%face_descriptor` to a 0-based array index respectively. For the sake of efficiency, it is best to use a face graph which supports \f$O(1)\f$ item ID lookup.  This can be achieved, for example, by using `CGAL::Polyhedron_items_with_id_3` items traits with `CGAL::Polyhedron_3`, and then setting the ids using `CGAL::set_halfedgeds_items_id()`. This is the default supported by the `Surface_mesh_shortest_path` class.

\subsubsection Surface_mesh_shortest_pathPointPropertyMap Vertex Point Property Map

  The algorithm must be provided a property map which translates between a `boost::GraphTraits<FaceListGraph>::%vertex_descriptor` item and its location in 3D space as a `Point_3` instance.
  
\subsection Surface_mesh_shortest_pathBarycentric Barycentric Coordinates and Face Locations

  The source and target locations of the algorithm are specified either using vertices (specifically `boost::GraphTraits<FaceListGraph>::%vertex_descriptor`), or face/location pairs, where the location is represented using a <em>Barycentric Coordinate</em> in the face. Given a point \f$p\f$ that lies inside and on the plane of triangle \f$(A,B,C)\f$, its barycentric coordinate is a real-valued triple \f$(b_0,b_1,b_2)\f$ such that \f$p = b_0\cdot~A + b_1\cdot~B + b_2\cdot~C\f$, and \f$b_0 + b_1 + b_2 = 1\f$. 

\subsection Surface_mesh_shortest_pathClass Surface Mesh Shortest Path Class

  The `Surface_mesh_shortest_path` class must be constructed with a model of `FaceListGraph`, and (optionally) 
  - Vertex, Halfedge, and Face index property maps for `FaceListGraph`
  - A Vertex -> `Point_3` property map for `FaceListGraph`
  - An model of the `SurfaceMeshShortestPathTraits` class (passing in an instance is only necessary if the traits class has local state)
  
  To add source points to the shortest paths computation, use the method `Surface_mesh_shortest_path::add_source_point()` (or `Surface_mesh_shortest_path::add_source_points()` to add an iterator range). This method accepts `boost::GraphTraits<FaceListGraph>::%vertex_descriptor`, or `Surface_mesh_shortest_path::Face_location` instances as input. The return value from this method, `Surface_mesh_shortest_path::Source_point_iterator` is a `bidirectional_iterator` which can be dereferenced to get the `Surface_mesh_shortest_path::Face_location` of the source point. Source points can be removed from the structure by passing this iterator to `Surface_mesh_shortest_path::remove_source_point()`.
  
  The shortest paths data structure will be automatically built on the first call to any shortest paths query function after any source points have been added or removed, but you can also manually (re-)build it using `Surface_mesh_shortest_path::build_sequence_tree()`. You can test if build_sequence_tree needs to be called by calling `Surface_mesh_shortest_path::changed_since_last_build()`, which will return true if any changes to the source points happened since the structure was last built.

  Computing shortest path distances can be accomplished with `Surface_mesh_shortest_path::shortest_distance_to_source_points()`, which will return as a pair the raw distance to the target and a `Surface_mesh_shortest_path::Source_point_iterator` to the source point which was closest to the target.  If no shortest path exists between the (if, for example, the face graph is disconnected), a negative distance is returned and the iterator will be equal to `Surface_mesh_shortest_path::source_points_end()`.

  The complete shortest path sequence can be obtained using `Surface_mesh_shortest_path::shortest_path_sequence_to_source_points()`, by providing a visitor object conforming to the `SurfaceMeshShortestPathVisitor` concept.

  `Surface_mesh_shortest_path::shortest_path_points_to_source_points()` will return the shortest path sequence as a 3D polyline to an output iterator, useful for quick visualization of the shortest path.  

  Other utility methods exist for converting between raw surface locations, Face_location objects, and other parametric descriptions of surface locations.  See the reference manual entries for `Surface_mesh_shortest_path::point()`, `Surface_mesh_shortest_path::face_location()`, and `Surface_mesh_shortest_path::locate()` for details.
  
\section Surface_mesh_shortest_pathExamples Examples

\subsection Surface_mesh_shortest_pathSimpleExample Simple Example

The following example shows how to get the shortest path to every vertex from an arbitrary source point on the surface.  Note that this example uses the `Polyhedron_items_with_id_3` traits class.  This algorithm must store auxiliary data with each vertex, halfedge, and facet, thus it is most efficient to have unique 0-based indices assigned to each.

\cgalExample{Surface_mesh_shortest_path/shortest_paths_with_id.cpp}

\subsection Surface_mesh_shortest_pathExampeWithoutId Example Using Polyhedron Items without IDs

Although it is preferred to have the indices built into each item, we can also support meshes without an ID on each item using an external index.  The following example shows how to achieve this.

\cgalExample{Surface_mesh_shortest_path/shortest_paths_no_id.cpp}

\subsection Surface_mesh_shortest_pathOpenMeshExample OpenMesh Example

This is the same example as above, except it shows replacing the traits class to use a different polyhedron model, specifically an OpenMesh model.

\cgalExample{Surface_mesh_shortest_path/shortest_paths_OpenMesh.cpp}

\subsection Surface_mesh_shortest_pathMultipleSources Using Multiple Source Points

This example shows computing the sequence tree from multiple source points, using an iterator range of Face_location objects, generated at random.

\cgalExample{Surface_mesh_shortest_path/shortest_paths_multiple_sources.cpp}

\subsection Surface_mesh_shortest_pathSequenceVisitor Shortest Path Sequence Visitor

This example shows how to use the `SurfaceMeshShortestPathVisitor` concept to get detailed information about the sequence of edges/vertices crossed by a shortest path between two face locations.

\cgalExample{Surface_mesh_shortest_path/shortest_path_sequence.cpp}

\section Surface_mesh_shortest_pathBenchmarks Benchmarks

These benchmarks were run using randomly generated source and destination points over multiple trials.  It can be re-generated using 

\code{.sh}
> ./run_benchmarks.sh
\endcode

And then pasting the contents of benchmark_table_1.txt and benchmark_table_10.txt into the doc.  For more details on how they were generated, see benchmarks/Surface_mesh_shortest_path/readme.txt

\subsection Surface_mesh_shortest_pathBenchmark1SourcePoint 1 Source Point
<center>
Model | Number of Vertices | Average Construction Time (s) | Average Query Time (s) | Peak Memory Usage (MB)
---|---|---|---|---
ellipsoid.off | 162 | 0.0027295 | 7.40586e-07 | 0.407711
anchor.off | 519 | 0.0299827 | 2.32319e-06 | 3.91138
rotor.off | 600 | 0.0216147 | 1.61736e-06 | 3.12876
spool.off | 649 | 0.0262101 | 1.88397e-06 | 3.71902
handle.off | 1165 | 0.0536712 | 2.46942e-06 | 7.31243
couplingdown.off | 1841 | 0.0812034 | 2.32528e-06 | 9.98382
bones.off | 2154 | 0.00677263 | 4.36882e-07 | 0.998184
mushroom.off | 2337 | 0.168037 | 3.44629e-06 | 21.8545
elephant.off | 2775 | 0.112904 | 2.27093e-06 | 13.8964
cow.off | 2904 | 0.137597 | 2.71387e-06 | 17.4167
knot1.off | 3200 | 0.204201 | 3.21024e-06 | 25.4091
retinal.off | 3643 | 0.241778 | 3.4899e-06 | 30.5278
femur.off | 3897 | 0.17326 | 2.49904e-06 | 21.5583
knot2.off | 5760 | 0.179074 | 2.02929e-06 | 22.6905
bull.off | 6200 | 0.308128 | 2.85312e-06 | 34.882
fandisk.off | 6475 | 0.610659 | 4.30535e-06 | 72.7803
lion-head.off | 8356 | 0.759157 | 4.19128e-06 | 86.1152
turbine.off | 9210 | 1.52087 | 7.32596e-06 | 166.021
man.off | 17495 | 1.28541 | 4.0026e-06 | 147.971
</center>

\subsection Surface_mesh_shortest_pathBenchmark10SourcePoints 10 Source Points
<center>
Model | Number of Vertices | Average Construction Time (s) | Average Query Time (s) | Peak Memory Usage (MB)
---|---|---|---|---
ellipsoid.off | 162 | 0.00194863 | 6.27676e-07 | 0.242311
anchor.off | 519 | 0.027487 | 2.04003e-06 | 3.34674
rotor.off | 600 | 0.015236 | 1.15787e-06 | 2.0513
spool.off | 649 | 0.0154939 | 1.21151e-06 | 2.1055
handle.off | 1165 | 0.035476 | 1.74682e-06 | 4.60842
couplingdown.off | 1841 | 0.0650064 | 1.91965e-06 | 7.80432
bones.off | 2154 | 0.0316228 | 1.09652e-06 | 3.86604
mushroom.off | 2337 | 0.0977199 | 2.19256e-06 | 11.7491
elephant.off | 2775 | 0.0957201 | 1.98378e-06 | 11.2864
cow.off | 2904 | 0.109437 | 2.22009e-06 | 13.0479
knot1.off | 3200 | 0.139582 | 2.30477e-06 | 16.3045
retinal.off | 3643 | 0.165497 | 2.46546e-06 | 18.5969
femur.off | 3897 | 0.147421 | 2.13258e-06 | 16.9767
knot2.off | 5760 | 0.305406 | 2.69684e-06 | 34.0953
bull.off | 6200 | 0.285024 | 2.46339e-06 | 30.669
fandisk.off | 6475 | 0.35459 | 2.7666e-06 | 39.328
lion-head.off | 8356 | 0.542517 | 3.10691e-06 | 58.5894
turbine.off | 9210 | 0.861633 | 3.97833e-06 | 88.9927
man.off | 17495 | 1.14717 | 3.61002e-06 | 121.451
</center>

\subsection Surface_mesh_shortest_pathQueryComparison Comparison of Construction and Query Times with multiple source points

The following figures track the construction time, query time, and peak memory usage for the various test models as the number of source points increases.  Notice that none of the values increase significantly as the number of source points increases.  In fact, in most cases, the running time and memory go down.  This is because a larger number of source points tends to result in a more flat sequence tree, which translates to reduced runtime and memory costs.

\cgalFigureBegin{Benchmark_construction,benchmark_plot_construction.png}
  Plot of construction times against different numbers of source points.
\cgalFigureEnd

\cgalFigureBegin{Benchmark_query,benchmark_plot_query.png}
  Plot of query times against different numbers of source points.
\cgalFigureEnd

\cgalFigureBegin{Benchmark_memory,benchmark_plot_memory.png}
  Plot of peak memory usage against different numbers of source points.
\cgalFigureEnd

\section Surface_mesh_shortest_pathTheory Implementation Details

\subsection Surface_mesh_shortest_pathDefinitions Definitions

\subsubsection Surface_mesh_shortest_pathGeodesics Geodesic Paths
  A <em>geodesic</em> curve is a `locally shortest` path on the surface of some manifold, that is, it cannot be made shorter by some local perturbations. On the surface of a polyhedron, this translates to a curve where, when the faces crossed by the curve are unrolled into the plane, the curve forms a straight line. Another way of describing it is that there is exactly \f$\pi\f$ surface angle to both sides at every point along the curve. A geodesic curve between two points is not necessarily a shortest path, but all shortest paths on polyhedra are formed by sequences of one or more geodesic paths.
  
  \cgalFigureBegin{Geodesic_perspective,perspectiveGeodesic.png}
  A geodesic on the surface of a simple polyhedron.
  \cgalFigureEnd
  
  \cgalFigureBegin{Geodesic_unrolled,unrolledGeodesic.png}
  The same geodesic, with its faces unrolled into the plane. Note in the unfolding, the geodesic forms a straight line.
  \cgalFigureEnd

\subsubsection Surface_mesh_shortest_pathVisibilityWindow Visibility Window
  A <em>visibility window</em> (or <em>visibility cone</em>) is a pair of geodesic curves which enclose a <em>locally flat</em> region of the polyhedron. Locally flat means that between every pair of points inside the window, there is exactly one geodesic path between them which also stays inside the bounds of the window. Thus, operations, such as distance calculations, can be done with normal 2D euclidean operations while inside the window.  When a visibility window encounters a vertex (which are <em>not</em> flat), a <em>branch</em> occurs, forming a sub-window to either side.
  
  \cgalFigureBegin{Visibility_window_1,visibilityCone-1.png}
  A single visibility window, before it encounters a vertex.
  \cgalFigureEnd
  
  \cgalFigureBegin{Visibility_window_2,visibilityCone-2.png}
  After encountering a convex vertex, the visibility window branches to either side (blue on the left, red on the right).  Note that the two new windows immediately overlap on the other side of the vertex, since the surrounding surface area is less than \f$2 \pi\f$. Points inside this region of overlap might have two possible shortest paths from the origin point.
  \cgalFigureEnd

\subsubsection Surface_mesh_shortest_pathSaddleVertex Saddle Vertices
  A <em>saddle vertex</em> on a polyhedron is a vertex \f$v\f$ where the sum surface angle of all faces incident at \f$v\f$ is greater than \f$2 \pi\f$, or, in simpler terms, one cannot flatten all the faces incident to \f$v\f$ into the plane without overlap.  Identifying and dealing with saddle vertices are important shortest path algorithms, because they form <em>blind spots</em> which cannot be reached by a single geodesic curve.
  
  \cgalFigureBegin{Saddle_vertex,saddleVertex.png}
  A visibility window (shaded blue) encounters a saddle vertex; the shaded red region behind the vertex is not reachable with a geodesic from the origin point (assuming the geodesic must stay inside the initial window).
  \cgalFigureEnd
  
\subsubsection Surface_mesh_shortest_pathSequenceTree The Sequence Tree

  In order to compute shortest paths, we build a <em>sequence tree</em> (or <em>cone tree</em>) from each source point.  The sequence tree describes the combinatoric structure of all potential shortest paths originating from a single source point, by organizing them into a hierarchy of visibility windows.
  
  Whenever a vertex of the polyhedron is encountered, a branch occurs in the sequence tree. If the vertex is a non-saddle vertex, then only two children are created, one for each edge incident to that vertex on the current face. If the vertex is a saddle vertex, in addition to the two children mentioned above, a special type of node, called a <em>pseudo-source</em>, is created which branches out in all directions from the vertex to account for the fact that some of the region around the vertex cannot be reached by a simple geodesic path from the source.
  
  Once a sequence tree is built, the shortest path to any target point can be found efficiently.

\subsection Surface_mesh_shortest_pathAlgorithmOverview Algorithm Overview
  The size of a sequence tree would normally be exponential in the complexity of the polyhedral model, thus a simple breadth-first is not feasible.  Rather, we apply techniques to eliminate entire branches which are provably unable to contain shortest paths from the source point(s).  The techniques used are given in greater detail in a paper by Xin and Wang \cgalCite{XinWang2009improvingchenandhan}, which itself expands on earlier work by Chen and Han \cgalCite{ch-spp-96} and Mitchell, Mount, and Papadimitriou \cgalCite{mmp-dgp-87} .
  
\subsection Surface_mesh_shortest_pathContinuousDijkstra Continuous Dijkstra 
  Continuous Dijkstra is simply the application of the graph-search algorithm to a non-discrete setting.  As we build the search tree, newly created nodes are tagged with a distance metric, and inserted into a priority queue, such that the shortest distance nodes are always first.

\subsection Surface_mesh_shortest_pathOneAngleOneSplit One angle, one split
  This observation by Chen and Han states that out of all the branches that occur at any given vertex of the polyhedron, only a limited number have more than one child which can define shortest paths.  This is accomplished by maintaining, for each vertex, all nodes of the sequence tree which can contain that vertex inside their visibility window.
  
- For each vertex, only <em>one</em> two-way branch may occur per face incident to that vertex, specifically, that of the nearest node to that vertex which crosses that face.  We call that closest node the <em>occupier</em> of that vertex.
- If the vertex is a saddle vertex, only one psuedo-source may be established at that vertex, this time by the absolute nearest node to that vertex.

  This method alone can decrease the running time for construction of the sequence tree construction to polynomial time.
  
\subsection Surface_mesh_shortest_pathDistanceFiltering Distance Filtering

  An additional distance filter proposed by Xin and Wang helps prune the search tree even further by comparing the current node's distance to the closest distance so far of the three vertices on the current face. Details on this method can be found in their paper \cgalCite{XinWang2009improvingchenandhan} .

*/
} /* namespace CGAL */
