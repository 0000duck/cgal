% -------------------------------------------------------------------------
\subsection{Introduction}

The benchmark file format is proposed for the benchmarks of algebra data, 
as well as curve and surface data.
The scope of this format is on purpose restricted to benchmarks with
the aim to keep the format specification compact, easy, and (to a
large extend) free of redundancies. For example, ellipses do not have
a special format since they can be represented as conics, and so far
no application that we are evaluating with our benchmarks would
benefit from a more specialized representation of ellipses (we will see 
later, that single benchmarks files may include only ellipses, which
allows users to specialize their representation internally).

We provide a complete and small reference implementation in \CC\ that
can be used as a separate library or integrated into an
application. However, the aim is to keep the format sufficiently easy
and small that application developers could choose to implement their
own parser easily.

At its core the format supports typed and structured information about
polynomials, curves, and surfaces, based on long integers, float
approximations, algebraic numbers etc. Simple benchmarks might just
represent a sequence of conics, but the format is intended to support
also more advanced benchmarks later on, for example, that contain
hierarchical constructions with boolean operations and affine
transformations over surfaces. The \ascii\ based format is human
readable and changeable. Keywords provide strong type and structural
information, help a human reader, and provide redundancies that help
the parser to check for format errors that would be difficult to find
in a format of plain unstructured coefficients. The look of the format
is inspired by the \cgal\ convention for the pretty-print output
formatting that objects look like their \CC\ constructor syntax.

Hierarchical structures need a recursive grammar. We actually opted
for the compiler constructions tools \texttt{flex} and \texttt{bison}
to encode the file format grammar in its intuitive way of lexical
analysis and a grammar production system. One need not be familiar
with these tools, their sources will look a bit unfamiliar, but the
file format grammar shows much more explicit than in a hand written
recursive parser in C/\CC.  In the doc, we point to the key places
where one can add additional tokens and grammar rules. \texttt{Flex}
and \texttt{bison} are program generators that produce C programs (we
use them as \CC\ programs though). To simplify installation, we ship
the generated \CC\ files, so that there is no need for \texttt{flex}
or \texttt{bison} when building the parser.

To ease the use of the parser, we provide a visitor interface,
following the visitor design pattern~\cite{cgal:ghjv-dpero-95}.  An
application would derive its own visitor from the
\texttt{Benchmark\_visitor} base class. This design choice makes the
parser independent of application types, such as long integers.
Instead, the parser keeps almost all recognized literals in strings of
type \texttt{std::string}. Users that are more experienced with
\texttt{yacc} or \texttt{bison} parser generators can of course also
change the \texttt{bison} source to accomplish their application
specific parsing directly in there.

