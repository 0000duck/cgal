\ccRefPageBegin
 
\def\ccLongParamLayout{\ccFalse}
\begin{ccRefConcept}{GeneralPolygonWithHoles_2}


\ccRefines
% ========
\ccc{GpsTraitsGeneralPolygonWithHoles_2}

\ccTypes
% ======
\ccThree{GeneralPolygonWithHoles}{Hole_const_iterator~}{}
\ccThreeToTwo

% \ccNestedType{Size}{number of holes size type.}

\ccNestedType{General_polygon_2}{the general-polygon type used to
represent the outer boundary and each hole. Must Model the \ccc{GeneralPolygon_2} Concept.}

\ccNestedType{Hole_const_iterator}{a bidirectional iterator
  over the polygonal holes. Its value type is
  \ccc{General_polygon_2}.}

\ccDefinition
% ===========
A model of this concept represents a general polygon with holes. The
concept requires the ability to access the general polygon that
represents the outer boundary and the general polygons that represent
the holes.

% \lcTex{\ccwParamIndent=0mm}
\ccThree{GeneralPolygonWithHoles_2}{polygon.outer_boundary()~~~}{}
\ccThreeToTwo

\ccCreation
\ccCreationVariable{polygon}

\ccConstructor{GeneralPolygonWithHoles_2();}{default constructor.}
\ccGlue
\ccConstructor{GeneralPolygonWithHoles_2(GeneralPolygonWithHoles_2 other);}
{copy constructor.}
\ccGlue
\ccMethod{GeneralPolygonWithHoles_2 operator=(other);}{assignment operator.}

\ccConstructor{GeneralPolygonWithHoles_2(General_polygon_2 & outer);}
{constructs a general polygon with holes that has no holes using a given general polygon \ccc{outer} as the outer boundary.}

\ccConstructor{template <class InputIterator>
GeneralPolygonWithHoles_2(General_polygon_2 & outer,
                          InputIterator begin, InputIterator end);}
{constructs a general polygon with holes using a given general polygon
\ccc{outer} as the outer boundary and a given range of holes. If \ccc{outer}
is an empty general polygon, then an unbounded polygon with holes will be
created. The holes must be contained inside the outer boundary, and the
polygons representing the holes must be simple and pairwise disjoint, except
perhaps at the vertices.}

\ccPredicates
% ===========
\ccMethod{bool is_unbounded();}
{returns \ccc{true} if the outer boundary is empty, and \ccc{false}
otherwise.}

\ccAccessFunctions
% ================

\ccMethod{const General_polygon_2 & outer_boundary() const;}
{returns the general polygon that represents the outer boundary. Note that this polygon is not necessarily a valid (simple) general polygon because it may be relatively simple.}


\ccMethod{Hole_const_iterator holes_begin() const;}
{returns the begin iterator of the holes.}
\ccGlue
\ccMethod{Hole_const_iterator holes_end() const;}
{returns the past-the-end iterator of the holes.}

\ccHasModels
%===========
\ccc{CGAL::General_polygon_with_holes_2<General_polygon>}\\
\ccc{CGAL::Polygon_with_holes_2<Kernel,Container>}\\
\ccc{CGAL::Gps_circle_segment_traits_2<Kernel>::Polygon_with_holes_2}\\
\ccc{CGAL::Gps_traits_2<ArrTraits,GeneralPolygon>::Polygon_with_holes_2}

\end{ccRefConcept}

\ccRefPageEnd
