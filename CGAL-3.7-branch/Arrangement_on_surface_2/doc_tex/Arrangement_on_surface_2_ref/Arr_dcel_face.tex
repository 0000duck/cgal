% +------------------------------------------------------------------------+
% | Reference manual page: Arr_dcel_face.tex
% +------------------------------------------------------------------------+
% | 
% | Package: Arrangement_2
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

\begin{ccRefConcept}{ArrangementDcelFace}

\ccDefinition

A face record in a \dcel\ data structure. A face may either be unbounded,
otherwise it has an incident halfedge along the chain defining its outer
boundary. A face may also contain holes and isolated vertices in its
interior.

\ccCreationVariable{f}

\ccTypes
%=======

\ccNestedType{Vertex}{the corresponding \dcel\ vertex type.}
\ccGlue
\ccNestedType{Halfedge}{the corresponding \dcel\ halfedge type.}

\ccNestedType{Hole_iterator}{a bidirectional iterator over the holes in 
inside the face. Its value-type is \ccStyle{Halfedge*}.}

\ccNestedType{Isolated_vertex_iterator}{a bidirectional iterator over the
isolated vertices in inside the face. Its value-type is \ccStyle{Vertex*}.}

The non-mutable iterators \ccc{Hole_const_iterator},
and \ccc{Isolated_vertex_const_iterator} are also defined.

\ccCreation
%==========

\ccConstructor{Arr_dcel_face();}
   {default constructor.}

\ccMethod{void assign (const Self& other);}
   {assigns \ccVar{} with the contents of the \ccc{other} face.}

\ccHtmlNoLinksFrom{   % to avoid linkage of Vertex, etc to HDS::Vertex

\ccAccessFunctions
%=================

All functions below also have \ccc{const} counterparts, returning non-mutable
pointers or iterators:

\ccMethod{bool is_unbounded() const;}
  {returns whether the face is unbounded.}

\ccMethod{Halfedge* halfedge();}
  {returns an incident halfedge along the outer boundary of the face.
   If \ccVar{} has no outer boundary, the function returns \ccc{NULL}.}

\ccMethod{size_t number_of_holes() const;}
  {returns the number of holes inside \ccVar{}.}
\ccGlue
\ccMethod{Hole_iterator holes_begin();}
  {returns a begin-iterator for the holes inside \ccVar{}.}
\ccGlue
\ccMethod{Hole_iterator holes_end();}
  {returns a past-the-end iterator for the holes inside \ccVar{}.}

\ccMethod{size_t number_of_isolated_vertices() const;}
  {returns the number of isolated vertices inside \ccVar{}.}
\ccGlue
\ccMethod{Isolated_vertex_iterator isolated_vertices_begin();}
  {returns a begin-iterator for the isolated vertices inside \ccVar{}.}
\ccGlue
\ccMethod{Isolated_vertex_iterator isolated_vertices_end();}
  {returns a past-the-end iterator for the isolated vertices inside 
   \ccVar{}.}

\ccModifiers
%===========

\ccMethod{void set_unbounded (bool flag);}
  {sets the face as unbounded (if \ccc{flag} is \ccc{true}), or as a bounded
   face (if it is \ccc{false}).}

\ccMethod{void set_halfedge (Halfedge* e);}
  {sets the incident halfedge.}

\ccMethod{void add_hole (Halfedge* e);}
  {adds \ccc{e} as a hole inside \ccVar{}.}

\ccMethod{void erase_hole (Hole_iterator it);}
  {removes the hole that \ccc{it} points to from inside \ccVar{}.}
  
\ccMethod{void add_isolated_vertex (Vertex* v);}
  {adds \ccc{v} as an isolated vertex inside \ccVar{}.}

\ccMethod{void erase_isolated_vertex (Isolated_vertex_iterator it);}
  {removes the isolated vertex that \ccc{it} points to from inside \ccVar{}.}

} % ccHtmlNoLinksFrom

\ccSeeAlso

\ccc{ArrangementDcel}\lcTex{ 
     (\ccRefPage{ArrangementDcel})}\\
\ccc{ArrangementDcelVertex}\lcTex{
     (\ccRefPage{ArrangementDcelVertex})} \\
\ccc{ArrangementDcelHalfedge}\lcTex{
     (\ccRefPage{ArrangementDcelHalfedge})}

\end{ccRefConcept}  

\ccRefPageEnd
