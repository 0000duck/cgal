% +------------------------------------------------------------------------+
% | Reference manual page: Apollonius_graph_2.tex
% +------------------------------------------------------------------------+
% | 12.04.2000   Author
% | Package: Package
% | 
%\RCSdef{\RCSRegulartriangulationtraitsRev}{$Id$}
%\RCSdefDate{\RCSRegulartriangulationtraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Apollonius_graph_2<Gt,Agds>}
%% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries
\ccCreationVariable{traits}
\ccDefinition

The class \ccRefName\ represents the
Apollonius graph. It supports insertions and deletions of sites.
It is templated by two template arguments \ccc{Gt}, which
must be a model of \ccc{ApolloniusGraphTraits_2}, and \ccc{Agds},
which must be a model of \ccc{ApolloniusGraphDataStructure_2}.
The second template argument defaults to
\ccc{CGAL::Triangulation_data_structure_2< 
CGAL::Apollonius_graph_vertex_base_2<Gt,true>,
CGAL::Triangulation_face_base_2<Gt> >}.

\ccInclude{CGAL/Apollonius_graph_2.h}

\ccIsModel
\ccc{DelaunayGraph_2}

\ccTypes

\ccThree{typedef Data_structure}{Triangulation_data_structure+}{}
%
\ccTypedef{typedef Agds  Data_structure;}{A type for the underlying
data structure.}
\ccGlue
\ccTypedef{typedef Data_structure Triangulation_data_structure;}
{Same as the \ccc{Data_structure} type. This type has been introduced
  in order for the \ccRefName\ class to be a
  model of the \ccc{DelaunayGraph_2} concept.}
\ccGlue
\ccTypedef{typedef Gt Geom_traits;}{A type for the geometric traits.}
\ccGlue
\ccTypedef{typedef Gt::Point_2 Point_2;}{A type for the
point defined in the geometric traits.}
\ccGlue
\ccTypedef{typedef Gt::Site_2  Site_2;}
{A type for the Apollonius site, defined in the geometric traits.}
%

% MK:: in the following copy text from TDS

The vertices and faces of the Apollonius graph are accessed
through \ccc{handles}, 
\ccc{iterators} and \ccc{circulators}. 
The iterators and circulators
are all bidirectional and non-mutable.
The circulators and iterators are assignable to the 
corresponding handle types, and they are also convertible to the
corresponding handles.
The edges of the Apollonius graph can also be visited through iterators
and circulators,
the edge circulators and iterators
are also bidirectional and non-mutable.
In the following, we call {\it infinite} any face or edge 
incident  to the infinite vertex and the infinite vertex itself.
Any other feature (face, edge or vertex) of the Apollonius graph is said 
to be {\it finite}.
Some iterators (the \ccc{All} iterators ) allow to visit finite or 
infinite features while the others (the \ccc{Finite} iterators) visit only
finite features. Circulators visit both infinite and finite features.

\ccThree{typedef Data_structure::Vertex_circulator}
{All_vertices_iterator+}{}
%
% MK:: change the edge definition as follows?
\ccTypedef{typedef Data_structure::Edge Edge;} {the edge type.
The \ccc{Edge(f,i)} is the edge common to faces \ccc{f} and 
\ccc{f.neighbor(i)}. It is also the edge joining the vertices
\ccc{vertex(cw(i))} and \ccc{vertex(ccw(i))} of \ccc{f}.
\ccPrecond{\ccc{i} must be \ccc{0}, \ccc{1} or \ccc{2}.}}
\ccGlue
\ccTypedef{typedef Data_structure::Vertex Vertex;}
{A type for a vertex.}
\ccGlue
\ccTypedef{typedef Data_structure::Face Face;}
{A type for a face.}
\ccGlue
\ccTypedef{typedef Data_structure::Vertex_handle Vertex_handle;}
{A type for a handle to a vertex.}
\ccGlue
\ccTypedef{typedef Data_structure::Face_handle Face_handle;}
{A type for a handle to a face.}
\ccGlue
\ccTypedef{typedef Data_structure::Vertex_circulator Vertex_circulator;}
{A type for a circulator over vertices incident to a given vertex.}
\ccGlue
\ccTypedef{typedef Data_structure::Face_circulator Face_circulator;}
{A type for a circulator over faces incident to a given vertex.}
\ccGlue
\ccTypedef{typedef Data_structure::Edge_circulator Edge_circulator;}
{A type for a circulator over edges incident to a given vertex.}
\ccGlue
\ccTypedef{typedef Data_structure::Vertex_iterator
  All_vertices_iterator;}
{A type for an iterator over all vertices.}
\ccGlue
\ccTypedef{typedef Data_structure::Face_iterator
  All_faces_iterator;}
{A type for an iterator over all faces.}
\ccGlue
\ccTypedef{typedef Data_structure::Edge_iterator
  All_edges_iterator;}
{A type for an iterator over all edges.}
\ccGlue
\ccTypedef{typedef Data_structure::size_type size_type;}
{An unsigned integral type.}
%
\ccTwo{Apollonius_graph_2<Gt,Agds>::Finite_vertices_iterator+}{}
\ccNestedType{Finite_vertices_iterator}
{A type for an iterator over finite vertices.}
\ccGlue
\ccNestedType{Finite_faces_iterator}
{A type for an iterator over finite faces.}
\ccGlue
\ccNestedType{Finite_edges_iterator}
{A type for an iterator over finite edges.}
%


In addition to iterators and circulators for vertices and faces,
iterators for sites are provided. In particular there are iterators
for the entire set of sites, the hidden sites and the visible sites of
the Apollonius graph.

\ccTwo{Apollonius_graph_2<Gt,Agds>::Visible_sites_iterator+}{}

\ccNestedType{Sites_iterator}
{A type for an iterator over all sites.}
\ccGlue
\ccNestedType{Visible_sites_iterator}
{A type for an iterator over all visible sites.}
\ccGlue
\ccNestedType{Hidden_sites_iterator}
{A type for an iterator over all hidden sites.}

\ccCreationVariable{ag}

\ccCreation
\ccThree{Apollonius_graph_2<Gt,Agds>}{ag = other other}{}
\ccThreeToTwo
%
\ccConstructor{Apollonius_graph_2(Gt gt=Gt());}{Creates an
Apollonius graph using \ccc{gt} as geometric traits.}
%
\ccConstructor{template< class Input_iterator >
Apollonius_graph_2(Input_iterator first, Input_iterator beyond,
Gt gt=Gt());} {Creates an Apollonius graph using \ccc{gt} as
geometric traits and inserts all sites in the range
[\ccc{first}, \ccc{beyond}).
\ccPrecond{\ccc{Input_iterator} must be a model of
\ccc{InputIterator}. The value type of
\ccc{Input_iterator} must be \ccc{Site_2}.}}
%
\ccConstructor{Apollonius_graph_2(const Apollonius_graph_2<Gt,Agds>& other)}
{Copy constructor. All faces and vertices are duplicated. After the
  construction, 
  \ccVar\ and \ccc{other} refer to two different Apollonius graphs~: if
  \ccc{other} is modified, \ccVar\ is not.}
%
\ccMethod{Apollonius_graph_2<Gt,Agds>
operator=(const Apollonius_graph_2<Gt,Agds>& other);}
{Assignment. If \ccc{ag} and \ccc{other} are the same object
  nothing is done. Otherwise, all the vertices and faces are
  duplicated. After the assignment, \ccVar\ and \ccc{other} refer to
  different Apollonius graphs~: if \ccc{other} is modified, \ccVar\ is
  not.}




\ccAccessFunctions
% MK:: in the following copy text from TDS
\ccThree{Data_structure}{ag.number_of_visible_sites()+}{}
\ccThreeToTwo
%
\ccMethod{Geom_traits geom_traits();}
{Returns a reference to the Apollonius graph traits object.}
\ccGlue
\ccMethod{Data_structure data_structure();}{Returns a reference to the
underlying data structure.}
\ccGlue
\ccMethod{Data_structure tds();}{Same as \ccc{data_structure()}. This
  method has been added in compliance with the \ccc{DelaunayGraph_2}
  concept.}
\ccGlue
\ccMethod{int dimension();}
{Returns the dimension of the Apollonius graph.}
\ccGlue
\ccMethod{size_type number_of_vertices();}
{Returns the number of finite vertices.}
\ccGlue
\ccMethod{size_type number_of_visible_sites();}
{Returns the number of visible sites.}
\ccGlue
\ccMethod{size_type number_of_hidden_sites();}
{Returns the number of hidden sites.}
\ccGlue
\ccMethod{size_type number_of_faces();}
         {Returns the number of faces (both finite and infinite) of the
           Apollonius graph.}
\ccGlue
\ccMethod{Face_handle infinite_face();}
{Returns a  face incident to the \ccc{infinite_vertex}.}
\ccGlue
\ccMethod{Vertex_handle
          infinite_vertex();}
{Returns the \ccc{infinite_vertex}.}
\ccGlue
\ccMethod{Vertex_handle finite_vertex();}
{Returns a vertex distinct from  the \ccc{infinite_vertex}.
\ccPrecond{The number of (visible) vertices in the Apollonius graph must
  be at least one.}}




\ccHeading{Traversal of the Apollonius graph}


An Apollonius graph can be seen as a container of faces and vertices.
Therefore the Apollonius graph provides several iterators and circulators
that allow to traverse it (completely or partially).



\ccHeading{Face, Edge and Vertex Iterators}

\ccThree{Finite_vertices_iterator}{ag.finite_vertices_begin()+}{}

The following iterators allow respectively to visit 
finite faces,  finite edges and  finite vertices
of the Apollonius graph. These iterators are non-mutable,
bidirectional and their value types are respectively
\ccc{Face}, \ccc{Edge} and \ccc{Vertex}. 
They are all invalidated by any change in the Apollonius graph.

\ccMethod{Finite_vertices_iterator finite_vertices_begin();}
{Starts at an arbitrary finite vertex.}
\ccGlue
\ccMethod{Finite_vertices_iterator finite_vertices_end();}
{Past-the-end iterator.}

\ccMethod{Finite_edges_iterator finite_edges_begin();}
{Starts at an arbitrary finite edge.}
\ccGlue
\ccMethod{Finite_edges_iterator finite_edges_end();}
{Past-the-end iterator.}

\ccMethod{Finite_faces_iterator finite_faces_begin();}
{Starts at an arbitrary finite face.}
\ccGlue
\ccMethod{Finite_faces_iterator finite_faces_end()
const;}{Past-the-end iterator.}

The following iterators allow respectively to visit all
(both finite and infinite) faces, edges and vertices
of the Apollonius graph. These iterators are non-mutable, bidirectional
and their value types are respectively
\ccc{Face}, \ccc{Edge} and \ccc{Vertex}. 
They are all invalidated by any change in the Apollonius graph.


\ccMethod{All_vertices_iterator all_vertices_begin();}
{Starts at an arbitrary  vertex.}
\ccGlue
\ccMethod{All_vertices_iterator all_vertices_end();}
{Past-the-end iterator.}

\ccMethod{All_edges_iterator all_edges_begin();}
{Starts at an arbitrary edge.}
\ccGlue
\ccMethod{All_edges_iterator all_edges_end();}
{Past-the-end iterator.}

\ccMethod{All_faces_iterator all_faces_begin();}
{Starts at an arbitrary face.}
\ccGlue
\ccMethod{All_faces_iterator all_faces_end();}
{Past-the-end iterator.}



\ccHeading{Site iterators}

The following iterators allow respectively to visit 
all sites, the visible sites and the hidden sites.
These iterators are non-mutable, bidirectional and their value type
is \ccc{Site_2}. They are all invalidated by any change in the
Apollonius graph.


\ccMethod{Sites_iterator sites_begin();}
{Starts at an arbitrary site.}
\ccGlue
\ccMethod{Sites_iterator sites_end();}
{Past-the-end iterator.}

\ccMethod{Visible_sites_iterator visible_sites_begin();}
{Starts at an arbitrary visible site.}
\ccGlue
\ccMethod{Visible_sites_iterator visible_sites_end();}
{Past-the-end iterator.}

\ccMethod{Hidden_sites_iterator hidden_sites_begin();}
{Starts at an arbitrary hidden site.}
\ccGlue
\ccMethod{Hidden_sites_iterator hidden_sites_end();}
{Past-the-end iterator.}


\ccThree{Vertex_circulator}{t.number_of_vertices()x}{}
\ccThreeToTwo



\ccHeading{Face, Edge and Vertex Circulators}

The Apollonius graph also provides circulators that allow to visit 
respectively all faces or edges incident to a given vertex
or all vertices adjacent to a given vertex.
These circulators are non-mutable and bidirectional.
 The operator \ccc{operator++} moves the circulator
counterclockwise around the vertex while
the \ccc{operator--} moves clockwise.
A face circulator is invalidated by any modification of the face
pointed to.
An edge circulator is invalidated by any modification
in one of the two faces incident to the edge pointed to.
A vertex circulator is invalidated by any modification
in any of the faces adjacent to the vertex pointed to.

\ccMethod{Face_circulator incident_faces(Vertex_handle v);}
{Starts at an arbitrary face incident
to \ccc{v}.}
\ccGlue
\ccMethod{Face_circulator incident_faces(Vertex_handle v, Face_handle f);}
{Starts at face \ccc{f}.
\ccPrecond Face \ccc{f} is incident to vertex \ccc{v}.}
\ccGlue
\ccMethod{Edge_circulator incident_edges(Vertex_handle v);}
{Starts at an arbitrary edge incident
to \ccc{v}.}
\ccGlue
\ccMethod{Edge_circulator incident_edges(Vertex_handle v, Face_handle f);}
{Starts at the first edge of \ccc{f} incident to 
\ccc{v}, in counterclockwise order around \ccc{v}.
\ccPrecond Face \ccc{f} is incident to vertex \ccc{v}.}
\ccGlue
\ccMethod{Vertex_circulator incident_vertices(Vertex_handle v);}
{Starts at an arbitrary  vertex incident
to \ccc{v}.}
\ccGlue
\ccMethod{Vertex_circulator incident_vertices(Vertex_handle v, Face_handle f);}
{Starts at the first vertex of \ccc{f} adjacent  to \ccc{v}
in  counterclockwise order around \ccc{v}.
\ccPrecond Face \ccc{f} is incident to vertex \ccc{v}.}



\ccHeading{Traversal of the Convex Hull}

Applied on the \ccc{infinite_vertex}
the above  functions  allow to visit the vertices on the convex hull and
the infinite edges and faces. Note that a counterclockwise
traversal of the vertices adjacent to the \ccc{infinite_vertex} is
a clockwise traversal of the convex hull.

\ccMethod{Vertex_circulator incident_vertices(ag.infinite_vertex());}{}
\ccGlue
\ccMethod{Vertex_circulator incident_vertices(ag.infinite_vertex(),
  Face_handle f);}{}
\ccGlue
\ccMethod{Face_circulator incident_faces(ag.infinite_vertex());}{}
\ccGlue
\ccMethod{Face_circulator incident_faces(ag.infinite_vertex(),
  Face_handle f);}{}
\ccGlue
\ccMethod{Edge_circulator incident_edges(ag.infinite_vertex());}{}
\ccGlue
\ccMethod{Edge_circulator incident_edges(ag.infinite_vertex(),
  Face_handle f);}{}




\ccPredicates
The class \ccRefName\ provides methods to test
the finite or infinite character of any feature.
\ccThree{bool }{ag.is_infinite( Face_handle f, int i)x}{}

%
\ccMethod{bool
          is_infinite(Vertex_handle v) const;}
{\ccc{true}, iff \ccc{v} is the \ccc{infinite_vertex}.}
\ccGlue
\ccMethod{bool
          is_infinite(Face_handle f) const;}
{\ccc{true}, iff face \ccc{f} is infinite.}
\ccGlue
\ccMethod{bool is_infinite(Face_handle f, int i) const;}
{\ccc{true}, iff edge \ccc{(f,i)} is infinite.}
\ccGlue
\ccMethod{bool
          is_infinite(Edge e) const;}
{\ccc{true}, iff edge \ccc{e} is infinite.}
\ccGlue
\ccMethod{bool
          is_infinite(Edge_circulator ec) const;}
{\ccc{true}, iff edge \ccc{*ec} is infinite.}



\ccHeading{Insertion}
\ccThree{Vertex_handle }{ag.insert(Site_2 s)+}{}
%

\ccMethod{template< class Input_iterator >
unsigned int insert(Input_iterator first, Input_iterator beyond);}
{Inserts the sites in the range
[\ccc{first},\ccc{beyond}). The number of sites in the range
  [\ccc{first}, \ccc{beyond}) is returned.
% MK:: Implement this method with copying and sorting
\ccPrecond{\ccc{Input_iterator} must be a model of
  \ccc{InputIterator} and its value type must be
  \ccc{Site_2}.}}
%
\ccGlue
\ccMethod{Vertex_handle  insert(Site_2 s);}{Inserts the
site \ccc{s} in the Apollonius graph. If \ccc{s} is visible then the
vertex handle of \ccc{s} is returned, otherwise 
\ccc{Vertex_handle(NULL)} is returned.}
%
\ccGlue
\ccMethod{Vertex_handle insert(Site_2 s, Vertex_handle
vnear);}{Inserts \ccc{s} in the Apollonius graph using the site
associated with \ccc{vnear} as an estimate for the nearest neighbor of
the center of \ccc{s}. If \ccc{s} is visible then the vertex handle of
\ccc{s} is returned, otherwise \ccc{Vertex_handle(NULL)} is
returned.}


\ccHeading{Removal}
\ccThree{void }{ag.remove(Vertex_handle v)+}{}
%
\ccMethod{void  remove(Vertex_handle v);}{Removes the site
associated to the vertex handle \ccc{v} from the Apollonius
graph.
\ccPrecond{\ccc{v} must correspond to a valid finite
vertex of the Apollonius graph.}}


\ccHeading{Nearest neighbor location}
\ccThree{Vertex_handle }{ag.nearest_neighbor(Point_2 p)+}{}
%
\ccMethod{Vertex_handle  nearest_neighbor(Point_2 p);}
{Finds the nearest neighbor of the point \ccc{p}. In other words it
finds the site whose Apollonius cell contains \ccc{p}. Ties are broken
arbitrarily and one of the nearest neighbors of \ccc{p} is
returned. If there are no visible sites in the Apollonius diagram
\ccc{Vertex_handle(NULL)} is returned.}
\ccGlue
\ccMethod{Vertex_handle  nearest_neighbor(Point_2 p,
Vertex_handle vnear);}{Finds the nearest neighbor of the point
\ccc{p} using the site associated with \ccc{vnear} as an
estimate for the nearest neighbor of \ccc{p}. Ties are broken
arbitrarily and one of the nearest neighbors of \ccc{p} is
returned. If there are no visible sites in the Apollonius diagram
\ccc{Vertex_handle(NULL)} is returned.}


\ccHeading{Access to the dual}

The \ccc{Apollonius_graph_2} class provides access to the duals of
the faces of the graph. The dual of a face of the Apollonius graph is
a site. If the originating face is infinite, its dual is a site with
center at infinity (or equivalently with infinite weight), which means
that it can be represented geometrically as a line. If the
originating face is finite, its dual is a site with finite center and
weight. In the following three methods the returned object is
assignable to either \ccc{Site_2} or \ccc{Gt::Line_2}, depending on
whether the corresponding face of the Apollonius graph is finite or
infinite, respectively.

\ccThree{Gt::Object_2}{ag.dual(Finite_edges_iterator ei)+}{}
%
\ccMethod{Gt::Object_2  dual(Face_handle f) const;}{Returns the
dual corresponding to the face handle \ccc{f}. The returned object can
be assignable to one of the following: \ccc{Site_2}, \ccc{Gt::Line_2}.}
\ccGlue
\ccMethod{Gt::Object_2  dual(All_faces_iterator it) const;}{Returns the
dual of the face to which \ccc{it} points to. The returned object can
be assignable to one of the following: \ccc{Site_2}, \ccc{Gt::Line_2}.}
\ccGlue
\ccMethod{Gt::Object_2  dual(Finite_faces_iterator it) const;}{Returns
  the dual of the face to which \ccc{it} points to. The returned
  object can be assignable to one of the following: \ccc{Site_2},
  \ccc{Gt::Line_2}.}


\ccHeading{I/O}
\ccThree{Stream&}{ag.draw_primal(Stream& str)+}{}
\ccThreeToTwo
%
\ccMethod{template< class Stream >
Stream& draw_primal(Stream& str);}{Draws the Apollonius graph to
the stream \ccc{str}.
\ccPrecond{The following operators must be defined:\\
\ccc{Stream& operator<<(Stream&, Gt::Segment_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Ray_2)}.}
}
\ccGlue
\ccMethod{template < class Stream > 
Stream& draw_dual(Stream& str);}{Draws the dual of the
Apollonius graph, i.e., the Apollonius diagram, to the stream
\ccc{str}.
\ccPrecond{The following operators must be defined:\\
\ccc{Stream& operator<<(Stream&, Gt::Segment_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Ray_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Line_2)}.}
}
\ccThree{Stream&}{ag.draw_primal_edge(Edge e, Stream& str)+}{}
\ccThreeToTwo
\ccGlue
\ccMethod{template< class Stream >
Stream& draw_primal_edge(Edge e, Stream& str);}{Draws the edge
  \ccc{e} of the Apollonius graph to the stream \ccc{str}.
\ccPrecond{The following operators must be defined:\\
\ccc{Stream& operator<<(Stream&, Gt::Segment_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Ray_2)}.}
}
\ccGlue
\ccMethod{template< class Stream >
Stream& draw_dual_edge(Edge e, Stream& str);}{Draws the dual of the
  edge \ccc{e} to the stream \ccc{str}. The dual of \ccc{e} is an edge
  of the Apollonius diagram.
\ccPrecond{The following operators must be defined:\\
\ccc{Stream& operator<<(Stream&, Gt::Segment_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Ray_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Line_2)}.}
}
%
\ccThree{std::ostream&}{ag.file_output(std::ostream& os)+}{}
\ccThreeToTwo
\ccGlue
\ccMethod{void file_output(std::ostream& os);}{Writes the current
  state of the Apollonius graph to an output stream. In particular,
  all visible and hidden sites are written as well as the
  underlying combinatorial data structure.}
\ccGlue
\ccMethod{void file_input(std::istream& is);}{Reads the state of the
  Apollonius graph from an input stream.}
%
\ccGlue
\ccFunction{std::ostream& operator<<(std::ostream& os,
  Apollonius_graph_2<Gt,Agds> ag);}
{Writes the current state of the Apollonius graph to an output stream.}
\ccGlue
\ccFunction{std::istream& operator>>(std::istream& is,
  Apollonius_graph_2<Gt,Agds> ag);}
{Reads the state of the Apollonius graph from an input stream.}


\ccHeading{Validity check}
\ccThree{bool}{ag.is_valid(bool verbose = false, int level = 1)+}{}
%
% MK:: change the output stream in the code
\ccMethod{bool is_valid(bool verbose = false, int level = 1);}
{Checks the validity of the Apollonius graph. If \ccc{verbose} is
\ccc{true} a short message is sent to \ccc{std::cerr}. If \ccc{level}
is 0, only the data structure is validated. If \ccc{level} is 1, then
both the data structure and the Apollonius graph are
validated. Negative values of \ccc{level} always return true, and
values greater then 1 are equivalent to \ccc{level} being 1.}

\ccHeading{Miscellaneous}
\ccThree{void}{ag.swap(& other)+}{}
%
\ccMethod{void clear();}{Clears all contents of the Apollonius graph.}
\ccGlue
% MK:: add this method make copy(...) protected and see doc of TDS
\ccMethod{void swap(Apollonius_graph_2<Gt,Agds>
other);}{The Apollonius graphs
\ccc{other} and \ccVar\ are swapped. \ccVar.\ccc{swap(other)} should
be preferred to \ccVar\ccc{ = other} or to \ccVar\ccc{(other)} if
\ccc{other} is deleted afterwards.}




\ccSeeAlso
\ccc{DelaunayGraph_2}\\
\ccc{ApolloniusGraphTraits_2}\\
\ccc{ApolloniusGraphDataStructure_2}\\
\ccc{ApolloniusGraphVertexBase_2}\\
\ccc{TriangulationFaceBase_2}\\
\ccc{CGAL::Apollonius_graph_traits_2<K,Method_tag>}\\
\ccc{CGAL::Apollonius_graph_filtered_traits_2<CK,CM,EK,EM,FK,FM>}\\
\ccc{CGAL::Triangulation_data_structure_2<Vb,Fb>}\\
\ccc{CGAL::Apollonius_graph_vertex_base_2<Gt,StoreHidden>}\\
\ccc{CGAL::Triangulation_face_base_2<Gt>}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+
