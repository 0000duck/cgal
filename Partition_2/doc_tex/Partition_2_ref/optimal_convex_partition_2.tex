\begin{ccRefFunction}{optimal_convex_partition_2}

Function that produces a set of convex polygons 
that represent a partitioning of a polygon defined on a sequence of 
points. 
The number of convex polygons produced is minimal.
\ccIndexSubsubitem{polygon partitioning}{convex}{optimal}

\ccInclude{CGAL/partition_2.h}

\ccFunction{
template <class InputIterator, class OutputIterator, class Traits>
OutputIterator optimal_convex_partition_2(InputIterator first,
                                          InputIterator beyond,
                                          OutputIterator result,
                                          const Traits& traits = Default_traits);
}
{
computes a partition of the polygon defined
by the points in the range [\ccc{first}, \ccc{beyond}) into convex
polygons. The counterclockwise-oriented partition polygons are written to
the sequence starting at position \ccc{result}.  The past-the-end iterator for
the resulting sequence of polygons is returned.
\ccPrecond The points in the range [\ccc{first}, \ccc{beyond}) define a
simple, counterclockwise-oriented polygon.
}

\ccHeading{Requirements}
%\ccIndexSubitem[C]{optimal_convex_partition_2}{preconditions}
\begin{enumerate}
    \item \ccc{Traits} is a model of the concept OptimalConvexPartitionTraits\_2%
          \ccIndexMainItem[c]{OptimalConvexPartitionTraits_2}.
          For the purposes of checking the
          postcondition that the partition is valid, \ccc{Traits} should
          also be a model of ConvexPartitionIsValidTraits\_2.
          \ccIndexMainItem[c]{ConvexPartitionIsValidTraits_2}
    \item \ccc{OutputIterator::value_type} should be
          \ccc{Traits::Polygon_2}.
    \item \ccc{InputIterator::value_type} should be \ccc{Traits::Point_2},
          which should also be the type of the points stored in an object
          of type \ccc{Traits::Polygon_2}.
\end{enumerate}

The default traits class \ccc{Default_traits} is \ccc{Partition_traits_2},
%\ccIndexTraitsClassDefault{optimal_convex_partition_2}
with the representation type determined by \ccc{InputIterator::value_type}.

\ccSeeAlso
\ccRefIdfierPage{CGAL::approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::convex_partition_is_valid_2} \\
\ccRefIdfierPage{CGAL::greene_approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::partition_is_valid_2} \\
\ccRefIdfierPage{CGAL::Partition_is_valid_traits_2<Traits, PolygonIsValid>}


\ccImplementation
This function implements the dynamic programming algorithm of Greene 
\cite{g-dpcp-83}, which requires $O(n^4)$ time and $O(n^3)$ space to
produce a partitioning of a polygon with $n$ vertices.  

\ccExample

The following program computes an optimal
convex partitioning of a polygon using the default
traits class and stores the partition polygons in the list 
\ccc{partition_polys}.  
It then asserts that the partition produced is valid.  The
traits class used for testing the validity is derived from the
traits class used to produce the partition with the function object
class \ccc{CGAL::Is_convex_2}\ccIndexMainItem[C]{Is_convex_2} used
to define the required \ccc{Is_valid} type. 
(Note that this assertion is superfluous unless the 
postcondition checking for \ccc{optimal_convex_partition_2} has been
turned off.)

\ccIncludeExampleCode{Partition_2/optimal_convex_partition_2.C}


\end{ccRefFunction}
