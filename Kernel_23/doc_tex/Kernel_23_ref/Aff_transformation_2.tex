\begin{ccRefClass}{Aff_transformation_2<Kernel>}

\ccDefinition
The class \ccRefName\ represents two-dimensional affine transformations. 
The general form of an affine transformation is based on a homogeneous
representation of points. Thereby all transformations can be realized by
matrix multiplications. 

Multiplying the transformation matrix by a scalar does not change the
represented transformation. Therefore, any transformation represented
by a matrix with rational entries can be represented by a
transformation matrix with integer entries as well. (Multiply the
matrix with the common denominator of the rational entries.) Hence, it
is sufficient to use the number type \ccStyle{Kernel::RT} to represent
the entries of the transformation matrix.

{\cgal} offers several specialized affine transformations. Different
constructors are provided to create them. They are parameterized with
a symbolic name to denote the transformation type, followed by
additional parameters. The symbolic name tags solve ambiguities in the
function overloading and they make the code more readable, i.e., what
type of transformation is created.

Since two-dimensional points have three homogeneous coordinates, we
have a $3\times 3$ matrix ${(m_{ij})}_{i,\,j=0\ldots 2}$.

If the homogeneous representations are normalized (the homogenizing
coordinate is 1), then the upper left $2\times 2$ matrix realizes
linear transformations. In the matrix form of a translation, the
translation vector $(v_0,\,v_1,\,1)$ appears in the last column of the
matrix. The entries $m_{20}$ and $m_{21}$ are always zero and
therefore do not appear in the constructors.

\ccCreation
\ccCreationVariable{t}

\ccConstructor{Aff_transformation_2(const Identity_transformation& );}
            {introduces an identity transformation.}

\ccConstructor{Aff_transformation_2(const Translation,
                                    const Vector_2<Kernel> &v);}
            {introduces a translation by a vector $v$.}

\ccConstructor{Aff_transformation_2(const Rotation,
                             const Direction_2<Kernel> &d,
                             const Kernel::RT &num,
                             const Kernel::RT &den = RT(1));}
            {approximates the rotation over the angle indicated by direction 
             $d$, such that the differences between the sines and cosines
             of the rotation given by d and the approximating rotation
             are at most $num/den$ each.
             \ccPrecond $num/den>0$ and $d != 0$. }

\ccConstructor{Aff_transformation_2(const Rotation,
                                       const Kernel::RT &sine_rho, 
                                       const Kernel::RT &cosine_rho, 
                                       const Kernel::RT &hw = RT(1));}
            {introduces a rotation by the angle \ccStyle{rho}.
             \ccPrecond 
             $sine\_rho^2 + cosine\_rho^2 == hw^2$.}

\ccConstructor{Aff_transformation_2(const Scaling,
                                       const Kernel::RT &s,
                                       const Kernel::RT &hw = RT(1));}
            {introduces a scaling by a scale factor $s/hw$.}

\newsavebox{\arrtwo}
\newsavebox{\arrlintwo}
\newsavebox{\transvectwo}

\savebox{\arrtwo}{\small $\left(\begin{array}{ccc}
                 m_{00} & m_{01} & m_{02}\\
                 m_{10} & m_{11} & m_{12}\\
                  0     &  0     & hw
              \end{array}\right)$}

\savebox{\arrlintwo}{\small $\left(\begin{array}{cc}
                 m_{00} & m_{01}\\
                 m_{10} & m_{11}
              \end{array}\right)$}

\savebox{\transvectwo}{\small $\left(\begin{array}{c}
                 m_{02}\\
                 m_{12}
              \end{array}\right)$}

\ccConstructor{Aff_transformation_2(
                const Kernel::RT &m00, const Kernel::RT &m01, const Kernel::RT &m02,
                const Kernel::RT &m10, const Kernel::RT &m11, const Kernel::RT &m12,
                const Kernel::RT &hw = RT(1));}
            {introduces a general affine transformation in the
             \ccTexHtml{$3 \times 3$ matrix form \usebox{\arrtwo}.}%
             {3x3 matrix <IMG ALIGN=CENTER SRC="fig/arrtwo.gif"> .}
             The sub-matrix \ccTexHtml{$1\over hw$\usebox{\arrlintwo}}%
             {<span class="math">hw<SUP>-1</SUP></span> <IMG ALIGN=CENTER 
             SRC="fig/arrlintwo.gif">} contains the scaling and rotation 
             information, the vector \ccTexHtml{$1\over hw$
             \usebox{\transvectwo}}{<span class="math">hw<SUP>-1</SUP></span>
             <IMG ALIGN=CENTER SRC="fig/transvectwo.gif">}
             contains the translational part of the transformation.}

\savebox{\arrtwo}{\small $\left(\begin{array}{ccc}
                 m_{00} & m_{01} & 0\\
                 m_{10} & m_{11} & 0\\
                  0     &  0     & hw
              \end{array}\right)$}
                  
\ccConstructor{Aff_transformation_2(
                                       const Kernel::RT &m00, const Kernel::RT &m01,
                                       const Kernel::RT &m10, const Kernel::RT &m11,
                                       const Kernel::RT &hw = RT(1));}
            {introduces a general linear transformation 
             \ccTexHtml{\usebox{\arrtwo},}{<IMG ALIGN=CENTER 
               SRC="fig/arrtwo2.gif"> ,}
             i.e.\ there is no translational part.}


\ccOperations

The main thing to do with transformations is to apply them on
geometric objects. Each class \ccStyle{Class_2<Kernel>} representing
a geometric object has a member function:

\ccStyle{Class_2<Kernel>  transform(Aff_transformation_2<Kernel> t)}.


The transformation classes provide a member function \ccStyle{transform()}
for points, vectors, directions, and lines:

\ccMethod{Point_2<Kernel>  transform(const Point_2<Kernel> &p) const;}
       {}
\ccGlue
\ccMethod{Vector_2<Kernel>  transform(const Vector_2<Kernel> &p) const;}
       {}
\ccGlue
\ccMethod{Direction_2<Kernel>  transform(const Direction_2<Kernel> &p) const;}
       {}
\ccGlue
\ccMethod{Line_2<Kernel>  transform(const Line_2<Kernel> &p) const;}
       {}

\cgal\ provides function operators for these member functions:

\ccMethod{Point_2<Kernel>  operator()(const Point_2<Kernel> &p) const;}
       {}
\ccGlue
\ccMethod{Vector_2<Kernel>  operator()(const Vector_2<Kernel> &p) const;}
       {}
\ccGlue
\ccMethod{Direction_2<Kernel>  operator()(const Direction_2<Kernel> &p) const;}
       {}
\ccGlue
\ccMethod{Line_2<Kernel>  operator()(const Line_2<Kernel> &p) const;}
       {}

\ccHeading{Miscellaneous}

\ccMethod{Aff_transformation_2<Kernel> operator*(const Aff_transformation_2<Kernel> &s) const;}{composes two affine transformations.}

\ccMethod{Aff_transformation_2<Kernel>  inverse() const;}
       {gives the inverse transformation.}

%\ccMethod{Aff_transformation_2<Kernel>  transpose() const;}
%       {returns the affine transformation defined by transposing
%       the linear transformation in \ccVar\ and setting the
%       translational part to zero.}

\ccMethod{bool                 is_even() const;}
       {returns \ccStyle{true}, if the transformation is not reflecting,
        i.e.\ the determinant of the involved linear transformation is
        non-negative.}

\ccMethod{bool                 is_odd() const;}
       {returns \ccStyle{true}, if the transformation is reflecting.}


%\ccMethod{Aff_transformation_2<Kernel>  general_form() const;}
%       {returns the affine transformation in matrix form.}

The matrix entries of a matrix representation of a 
\ccStyle{Aff_transformation_2<Kernel>}
can be accessed trough the following member functions:

\ccMethod{Kernel::FT          cartesian(int i, int j) const;}
                      {}
\ccGlue
\ccMethod{Kernel::FT          m(int i, int j) const;}
       {returns entry $m_{ij}$ in a matrix representation in which $m_{22}$ is 1.}

\ccMethod{Kernel::RT          homogeneous(int i, int j) const;}
                      {}
\ccGlue
\ccMethod{Kernel::RT          hm(int i, int j) const;}
       {returns entry $m_{ij}$ in some fixed matrix representation.} 


For affine transformations  no I/O operators are defined.

%\ccImplementation
%Depending on the constructor we have different internal representations.
%This approach uses less memory and the transformation can be applied
%faster.
%
%Affine transformations offer no \ccStyle{transform()} member function
%for complex objects because they are defined in terms of  points vectors and 
%directions.  As the internal representation of a complex object
%is private the transformation code should go there.

\ccSeeAlso
\ccc{Identity_transformation}, 
\ccc{Rotation}, 
\ccc{Scaling},
\ccc{Translation} \\
\ccc{rational_rotation_approximation}

\ccExample

\begin{cprog}
  typedef Cartesian<double>        K;
  typedef Aff_transformation_2<K>  Transformation;
  typedef Point_2<K>               Point;
  typedef Vector_2<K>              Vector;
  typedef Direction_2<K>           Direction;

  Transformation rotate(ROTATION, sin(pi), cos(pi));
  Transformation rational_rotate(ROTATION,Direction(1,1), 1, 100);
  Transformation translate(TRANSLATION, Vector(-2, 0));
  Transformation scale(SCALING, 3);

  Point q(0, 1);
  q = rational_rotate(q); 

  Point p(1, 1);

  p = rotate(p); 

  p = translate(p); 

  p = scale(p);
\end{cprog} 

The same would have been achieved with

\begin{cprog}

  Transformation transform = scale * (translate * rotate);
  p = transform(Point(1.0, 1.0));
\end{cprog} 

\ccSeeAlso
\ccRefIdfierPage{CGAL::Aff_transformation_3<Kernel>} \\
\ccRefIdfierPage{CGAL::Identity_transformation} \\
\ccRefIdfierPage{CGAL::Reflection} \\
\ccRefIdfierPage{CGAL::Rotation} \\
\ccRefIdfierPage{CGAL::Scaling} \\
\ccRefIdfierPage{CGAL::Translation} \\

\end{ccRefClass} 

