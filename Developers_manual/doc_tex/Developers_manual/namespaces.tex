% =============================================================================
% The CGAL Developers' Manual
% Chapter: Namespaces
% -----------------------------------------------------------------------------
% file   : namespaces.tex
% authors: Stefan Schirra <stschirr@mpi-sb.mpg.de>
% -----------------------------------------------------------------------------
% $Id$
% $Date$
% =============================================================================

\chapter{Namespaces\label{chap:namespaces}}
\ccChapterAuthor{Stefan Schirra}

Names, in particular (member) function names and class names should 
be descriptive and easily remembered. So it is not surprising that
different libraries or packages choose the same name for corresponding
or similar classes and functions. A common approach to solving the
naming problem is to add a prefix,\ccIndexMainItem{prefix} for example, 
OpenGL adds \ccc{gl}
and FLTK adds \ccc{fl}. \leda\ uses prefix \ccc{leda_}%
\ccIndexSubitem{prefix}{\ccFont leda_}
\ccIndexSubitem{\leda}{prefix}
to some extent, 
but you have to tell \leda\ not to make the corresponding unprefixed names 
available as well.\footnote{\cgal's
makefile does this by setting \ccc{-DLEDA_PREFIX}.} Initially, \cgal\ used
prefix \ccc{CGAL_}. 
At the beginning of 1999, it was decided to drop prefix \ccc{CGAL_} and to 
introduce namespace \ccc{CGAL}. 

\section{Namespace CGAL}
\ccIndexSubitem{namespace}{\ccFont CGAL}
All names introduced by \cgal\ should be in namespace \ccc{CGAL}, \eg: 
\begin{verbatim}
#include <something>

namespace CGAL {

class My_new_cgal_class {};

My_new_cgal_class 
my_new_function( My_new_cgal_class& );

} // namespace CGAL
\end{verbatim}
Make sure not to have include statements nested between 
\verb+ namespace CGAL { + and \verb+ } // namespace CGAL+.
Otherwise all names defined in the file included will be 
added to namespace \ccc{CGAL}.

\section{Namespace {\tt internal}}
\ccIndexSubitem{namespace}{\ccFont internal}
All names introduced by \cgal\ which are not documented to the user
should be under an \ccc{internal} subnamespace of \ccc{CGAL}, \eg:
\begin{verbatim}
namespace CGAL { namespace internal {

class My_undocumented_class {};

void my_new_function( My_undocumented_class& );

}} // namespace CGAL::internal

namespace CGAL { namespace Package { namespace internal { namespace tags {

class Some_further_class_local_to_Package;

}}}} // namespace CGAL::Package::internal::tags
\end{verbatim}


\section{Namespace CGAL::NTS}

{\em \textbf{Note:} This section will be revised once the forthcoming
  revision of the \CC-standard gets into a more definite state. The
  standard library has similar problems, e.g. for \ccc{swap()},
  see\begin{ccTexOnly}\footnote{\path'http://www.open-std.org/jtc1/sc22/wg21/docs/cwg\_toc.html'}\end{ccTexOnly}
  issues% 
  \begin{ccHtmlOnly}
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">
  \end{ccHtmlOnly}%
  225\ccTexHtml{,}{</a>,}%
  \begin{ccHtmlOnly}
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">
  \end{ccHtmlOnly}%
  226\ccTexHtml{,}{</a>,} and%
  \begin{ccHtmlOnly}
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">
  \end{ccHtmlOnly}%
  229\ccTexHtml{.}{</a>.}
  Currently, \ccc{CGAL::NTS} does not exist anymore, and the
  \ccc{CGAL_NTS} macro boils down to \ccc{CGAL::}. As the future
  interface is not yet fixed, people should still follow the
  guidelines given below.}

We should not define 
templates in \cgal\ that are likely to conflict with templates in 
other namespaces.
For this reason, we have another namespace \ccc{NTS}%
\ccIndexSubitem{namespace}{\ccFont CGAL::NTS}
nested in \ccc{CGAL}, which contains potentially conflicting
template functions.

\subsection{Which function calls should be qualified in \cgal\ code?}
Out current policy is:
\begin{itemize}
\item
\ccc{max} should be used without qualification\ccIndexGlobalFunction{max}
\item
\ccc{min} should be used without qualification\ccIndexGlobalFunction{min}
\item
For the following functions, templates are provided in nested namespace
\ccc{NTS}:
\begin{itemize}
\item[]\ccc{abs}\ccIndexGlobalFunction{abs}
\item[]\ccc{compare}\ccIndexGlobalFunction{compare}
\item[]\ccc{gcd}\ccIndexGlobalFunction{gcd}
\item[]\ccc{is_negative}\ccIndexGlobalFunction{is_negative}
\item[]\ccc{is_positive}\ccIndexGlobalFunction{is_positive}
\item[]\ccc{is_one}\ccIndexGlobalFunction{is_one}
\item[]\ccc{is_zero}\ccIndexGlobalFunction{is_zero}
\item[]\ccc{sign}\ccIndexGlobalFunction{sign}
\item[]\ccc{square}\ccIndexGlobalFunction{square}
\end{itemize}
Calls of the above functions should be qualified using macro 
\ccc{CGAL_NTS},% 
\index{CGAL_NTS macro@{\tt CGAL\_NTS} macro}
which maps to \ccc{CGAL::NTS::}\footnote{The use of
the macro eases future changes in our policy.}: For example,
\begin{verbatim}
if ( CGAL_NTS is_zero(0) ) { /* ... */ } 
\end{verbatim}
\item
The following functions can be qualified by \ccc{CGAL_NTS} as well:
\begin{itemize} 
\item[]\ccc{to_double}\ccIndexGlobalFunction{to_double}
\item[]\ccc{is_valid}\ccIndexGlobalFunction{is_valid}
\item[]\ccc{is_finite}\ccIndexGlobalFunction{is_finite}
\item[]\ccc{sqrt}\ccIndexGlobalFunction{sqrt}\\
\item[]\ccc{div}\ccIndexGlobalFunction{div}\\
Whenever the argument of \ccc{sqrt} is a concrete type, \ie, it does
not depend on a template parameter, you should qualify the call of
\ccc{sqrt}, for example \verb+std::sqrt(2.0)+
\end{itemize}
Here, qualification with \ccc{CGAL::} works as well.
\end{itemize}
Summarizing, you can always qualify functions on number types
with \ccc{CGAL_NTS} besides \ccc{min} and \ccc{max}.

\InternalOnly{

\section{Requirements and recommendations}

Requirements:
\begin{itemize}
\item all names defined by \cgal\ are in namespace \ccc{CGAL}
  (including namespaces nested in namespace \ccc{CGAL}).
\item qualify calls of \ccc{is_zero}, \ccc{is_one}, \ccc{is_negative},
  \ccc{is_positive}, \ccc{sign}, \ccc{abs}, \ccc{compare},
  \ccc{square} by \texttt{CGAL\_NTS}.
  \ccIndexSubitem{qualification}{\ccFont CGAL_NTS}%
\end{itemize}

%% Recommendations:
%% \begin{itemize}
%% \item Don't qualify calls of \ccc{max} and \ccc{min}.
%% \item Don't use \ccc{CGAL::} qualification inside namespace \ccc{CGAL},%
%% \ccIndexSubitem{qualification}{\ccFont CGAL::}
%% unless it is required by a compiler or to resolve a name conflict with a
%% local type in a scope enclosed by namespace \ccc{CGAL}.
%% \end{itemize}

}

