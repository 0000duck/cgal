% +------------------------------------------------------------------------+
% | Reference manual page: Monge_via_jet_fitting.tex
% +------------------------------------------------------------------------+
% | 09.02.2006   Marc Pouget and Frédéric Cazals
% | Package: Jet_fitting_3
% | 
\RCSdef{\RCSMongeviajetfittingRev}{$Id$}
\RCSdefDate{\RCSMongeviajetfittingDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Monge_via_jet_fitting<DataKernel, LocalKernel = Cartesian<double>, LinAlgTraits = Lapack>} 
 %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition
  
The class \ccRefName\ is designed to perform the estimation of the
local differential quantities at a given point. Since points are given
through an iterator ---and its past the end, it is assumed the point
where the calculation is carried out is the first point provided by
the iterator.
%%
The results are stored in instances of the classes \ccc{Monge_form} and
\ccc{Monge_form_condition_numbers}, the particular information returned depending on
the degrees specified for the polynomial fitting and for the Monge form.


\ccInclude{CGAL/Monge_via_jet_fitting.h}

\ccParameters
The class \ccRefName\ has three template parameters. Parameter
\ccc{DataKernel} provides  the geometric classes and tools
corresponding to the input points, and also selected members of the
\ccc{Monge_form} class. Parameter  \ccc{LocalKernel} provides
the geometric classes and tools required by local
computations. Parameter \ccc{LinAlgTraits} features the linear
algebra algorithms required by the fitting method.

\ccTypes

%\ccNestedType{TYPE}{some nested types}
\ccTypedef{  typedef DataKernel   Data_Kernel;}{}
\ccGlue
\ccTypedef{  typedef LocalKernel  Local_Kernel;}{}
\ccGlue
\ccTypedef{   typedef typename std::vector<typename
Data_Kernel::Point_3>::iterator Range_Iterator; }{} 
\ccGlue
\ccTypedef{  typedef Monge_form<Data_Kernel>   Monge_form;}{}
\ccGlue
\ccTypedef{  typedef Monge_form_condition_numbers<Local_Kernel> Monge_form_condition_numbers;}{}

\ccCreation
\ccCreationVariable{monge_fitting}  %% choose variable name, given by \ccVar

\ccConstructor{Monge_via_jet_fitting(Range_Iterator begin, Range_Iterator end, 
int d, int dprime, Monge_form &monge_form,
Monge_form_condition_numbers &monge_form_condition_numbers);} {The
constructor performs all the computations. The $N$ input points are
given by the \ccc{Range_Iterators}, \ccc{d} is the degree of the
fitted polynomial, \ccc{dprime} is the degree of the expected Monge
coefficients, outputs are stored in \ccc{monge_form} and
\ccc{monge_form_condition_numbers}.
\ccPrecond $N \geq N_d:=(d+1)(d+2)/2$, $1 \leq d$, $dprime \leq d$, $1
\leq dprime \leq 4$ } 

%\ccOperations

%\ccMethod{void foo();}{some member functions}

\ccSeeAlso

\ccc{Monge_form},
\ccc{Monge_form_condition_numbers}
\ccc{Lapack}.

%\ccExample

%A short example program.
%Instead of a short program fragment, a full running program can be
%included using the 
%\verb|\ccIncludeExampleCode{Jet_fitting_3/Monge_via_jet_fitting.C}| 
%macro. The program example would be part of the source code distribution and
%also part of the automatic test suite.

%\begin{ccExampleCode}
%void your_example_code() {
%}
%\end{ccExampleCode}

%% \ccIncludeExampleCode{Jet_fitting_3/Monge_via_jet_fitting.C}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

