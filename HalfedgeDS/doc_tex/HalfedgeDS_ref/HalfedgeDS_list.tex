% +------------------------------------------------------------------------+
% | Reference manual page: HalfedgeDS_list.tex
% +------------------------------------------------------------------------+
% | 22.03.1999   Lutz Kettner
% | Package: HalfedgeDS
% | 
\RCSdef{\RCSHalfedgeDSlistRev}{$Id$}
\RCSdefDate{\RCSHalfedgeDSlistDate}{$Date$}
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{HalfedgeDS_list<Traits,HalfedgeDSItems,Alloc>}
\ccRefLabel{CGAL::HalfedgeDS_list}

\ccDefinition
  
The class \ccRefName\ is a model for the \ccc{HalfedgeDS} concept.
\ccRefName\ is a list-based representation with bidirectional
iterators that supports removal.

\ccInclude{CGAL/HalfedgeDS_list.h}

\ccIsModel

\ccRefConceptPage{HalfedgeDS<Traits,Items,Alloc>}

\ccTypes
\ccThree{typedef bidirectional_iterator_tag;}{Supports_removal;;}{}

\ccTypedef{typedef bidirectional_iterator_tag iterator_category;}{}
\ccGlue
\ccTypedef{typedef CGAL::Tag_true Supports_removal;}{}

\ccOperations

Besides operations required from the concept
\ccc{HalfedgeDS<Traits,Items,Alloc>}, this class supports
additionally:

\ccCreationVariable{hds}
\ccThree{void}{hds.vertices}{}

\ccMethod{void vertices_splice( Vertex_iterator target, Self &source,
                          Vertex_iterator first, Vertex_iterator last);}
    {inserts elements in the range [\ccc{first, last}) before position 
     \ccc{target} and removes the elements from \ccc{source}. It takes 
     constant time if \ccc{&source == &}\ccVar; otherwise, it takes linear
     time in the size of the range. \ccPrecond [\ccc{first, last}) is a
     valid range in \ccc{source}. \ccc{target} is not in the range
     [\ccc{first, last}).}

\ccMethod{void halfedges_splice( Halfedge_iterator target, Self &source,
                            Halfedge_iterator first, Halfedge_iterator last);}
    {inserts elements in the range [\ccc{first, last}) before position 
     \ccc{target} and removes the elements from \ccc{source}. It takes 
     constant time if \ccc{&source == &}\ccVar; otherwise, it takes linear
     time in the size of the range. \ccPrecond [\ccc{first, last}) is a
     valid range in \ccc{source}. \ccc{target} is not in the range
     [\ccc{first, last}).}

\ccMethod{void faces_splice( Face_iterator target, Self &source,
                             Face_iterator first, Face_iterator last);}
    {inserts elements in the range [\ccc{first, last}) before position 
     \ccc{target} and removes the elements from \ccc{source}. It takes 
     constant time if \ccc{&source == &}\ccVar; otherwise, it takes linear
     time in the size of the range. \ccPrecond [\ccc{first, last}) is a
     valid range in \ccc{source}. \ccc{target} is not in the range
     [\ccc{first, last}).}

\ccMethod{\bf\ttfamily void ccbs_splice( Ccb_iterator target, Self &source,
                             Ccb_iterator first, Ccb_iterator last);}
    {\bf\ttfamily inserts elements in the range [\ccc{first, last}) before position 
     \ccc{target} and removes the elements from \ccc{source}. It takes 
     constant time if \ccc{&source == &}\ccVar; otherwise, it takes linear
     time in the size of the range. \ccPrecond [\ccc{first, last}) is a
     valid range in \ccc{source}. \ccc{target} is not in the range
     [\ccc{first, last}).}


\ccSeeAlso

\ccRefIdfierPage{CGAL::HalfedgeDS_default}\\
\ccRefIdfierPage{CGAL::HalfedgeDS_vector}\\
\ccRefConceptPage{HalfedgeDSItems}\\
\ccRefIdfierPage{CGAL::Polyhedron_3<Traits>}\\
\ccRefIdfierPage{CGAL::HalfedgeDS_items_decorator<HDS>}\\
\ccRefIdfierPage{CGAL::HalfedgeDS_decorator<HDS>}\\
\ccRefIdfierPage{CGAL::HalfedgeDS_const_decorator<HDS>}


\ccImplementation

\ccRefName\ uses internally the \ccc{CGAL::In_place_list} container class.
The copy constructor and the assignment operator need $O(n)$ time with
$n$ the total number of vertices, halfedges, and faces. The former 
suboptimal implementation with an $O(n \log n)$ runtime has been replaced
with a faster implementation based on hashing for the pointer lookup.

\ccc{CGAL_ALLOCATOR(int)} is used as default argument for the
\ccc{Alloc} template parameter.  

\end{ccRefClass} %

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+
