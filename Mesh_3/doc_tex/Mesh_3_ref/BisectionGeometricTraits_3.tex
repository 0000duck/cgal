% +------------------------------------------------------------------------+
% | Reference manual page: BisectionGeometricTraits_3.tex
% +------------------------------------------------------------------------+
% | 23.02.2009   Author
% | Package: Package
% |
\RCSdef{\RCSBisectionGeometricTraitsRev}{$Id: header.tex 40270 2007-09-07 15:29:10Z lsaboret $}
\RCSdefDate{\RCSBisectionGeometricTraitsDate}{$Date: 2007-09-07 17:29:10 +0200 (Ven, 07 sep 2007) $}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{BisectionGeometricTraits_3}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
The concept \ccRefName\ describes a geometric traits class
that provides the basic types and operations 
to implement a model of \ccc{MeshDomain_3}
based solely on  intersection detections. 
Points in the  non-empty intersections  are herein computed
by  bisection. 

Such traits class  is relevant when intersection detections
can be performed efficiently. For instance, when bounding surfaces
are implicitly described by a function (such as an isosurface of a 3D
function from $\mathbb{R}^3$ to $\mathbb{R}$), the do-intersect predicate with a segment
is computed by evaluations of the function values at both end points
of the segment.
 
\ccTypes

\ccNestedType{FT}{Numerical type. Must be a model of
  \ccc{SqrtFieldNumberType} and constructible from a \ccc{double}.}
\ccGlue
\ccNestedType{Point_3}{The point type. Must have a
  constructor \ccc{Point_3(FT, FT, FT)}.}
\ccGlue
\ccNestedType{Segment_3}{Segment type.}
\ccGlue
\ccNestedType{Ray_3}{Ray type.}
\ccGlue
\ccNestedType{Line_3}{Line type.}
\ccGlue
\ccNestedType{Vector_3}{Vector type.}
\ccGlue
\ccNestedType{Sphere_3}{Sphere type.}

\ccTwo{Construct_translated_point_3}{}

\ccNestedType{Compute_scalar_product_3}
{Function object providing the operator\\
\ccc{FT operator()(Vector_3 v, Vector_3 w)} which returns the scalar
(inner) product of the two vectors \ccc{v} and \ccc{w}.}

\ccNestedType{Compute_squared_distance_3}
{Function object providing the operator\\
\ccc{FT operator()(Point_3, Point_3)} which returns the squared distance
between two points.}

\ccNestedType{Compute_squared_radius_3}
{Function object providing the operator\\
\ccc{FT operator()(Sphere_3 s)} which returns the squared radius
of~\ccc{s}.}

\ccNestedType{Construct_center_3}
{Function object providing the operator\\
\ccc{Point_3 operator()(Sphere_3 s)} which returns the center of
the sphere~\ccc{s}.}

\ccNestedType{Construct_midpoint_3}
{Function object providing the operator\\
\ccc{Point_3 operator()(Point_3 p, Point_3 q)} which computes
the midpoint of the segment \ccc{pq}.}

\ccNestedType{Construct_point_on_3}
{Function object providing the following operators:\\
  \ccc{Point_3 operator()(Line_3 l,int i);} which returns an
  arbitrary point on \ccc{l}. It holds \ccStyle{point(i) == point(j)}, iff
  \ccStyle{i==j}. Furthermore, is directed from \ccStyle{point(i)} to
  \ccStyle{point(j)}, for all \ccStyle{i} $<$ \ccStyle{j}.\\
  \ccc{Point_3 operator()(Ray_3 r,int i);} which returns a point on
  \ccc{r}. \ccStyle{point(0)} is the source, \ccStyle{point(i)}, with
  $i>0$, is different from the source. \ccPrecond{$i \geq 0$.}\\
  \ccc{Point_3 operator()(Segment_3 s,int i);} which returns either source
  or target of \ccc{s}: \ccStyle{point(0)} returns the source of \ccc{s},
  \ccStyle{point(1)} returns the target of \ccc{s}. Parameter
  \ccStyle{i} is taken modulo 2, which gives easy access to the other end
  point.
}

\ccNestedType{Construct_segment_3}
{Function object providing the operator\\
  \ccc{Segment_3 operator()(Point_3 p, Point_3 q);} which
  returns a segment with source $p$ and target $q$, directed from the
  source to the target.}

\ccNestedType{Construct_scaled_vector_3}
{Function object providing the operator\\
\ccc{Vector_3 operator()(Vector_3 v, FT scale)} which returns
the vector \ccc{v} scaled by a factor \ccc{scale}.}

\ccNestedType{Construct_translated_point_3}
{Function object providing the operator\\
\ccc{Point_3 operator()(Point_3 p, Vector_3 v)} which returns
the point obtained by translating \ccc{p} by the vector~\ccc{v}.}

\ccNestedType{Construct_vector_3}
{Function object providing the operator\\
\ccc{Vector_3 operator()(Point_3 a, Point_3 b)} which returns
the vector \ccc{b-a}.}

\ccNestedType{Has_on_bounded_side_3}
{Function object providing the operator\\
\ccc{bool operator()(Sphere_3 s, Point_3 p);} which
returns true iff $p$ lies on the bounded side of $s$.}

\ccOperations

The following functions give access to the predicate and construction
objects:

\ccThree{onstruct_translated_point_3xxx}{construct_translated_point_3_object()x}{}
\ccCreationVariable{traits}

\ccMethod{Compute_scalar_product_3 compute_scalar_product_3_object();}{}
\ccMethod{Compute_squared_distance_3 compute_squared_distance_3_object();}{}
\ccMethod{Compute_squared_radius_3 compute_squared_radius_3_object();}{}
\ccMethod{Construct_center_3 construct_center_3_object();}{}
\ccMethod{Construct_midpoint_3 construct_midpoint_3_object();}{}
\ccMethod{Construct_point_on_3 construct_point_on_3_object();}{}
\ccMethod{Construct_scaled_vector_3 construct_scaled_vector_3_object();}{}
\ccMethod{Construct_segment_3 construct_segment_3_object();}{}
\ccMethod{Construct_translated_point_3 construct_translated_point_3_object();}{}
\ccMethod{Construct_vector_3 construct_vector_3_object();}{}
\ccMethod{Has_on_bounded_side_3 has_on_bounded_side_3_object();}{}

\ccHasModels

Any \cgal{} Kernel.

\ccSeeAlso
\ccRefConceptPage{ImplicitSurfaceTraits_3} \\
\ccRefConceptPage{IntersectionGeometricTraits_3} \\
\ccRefIdfierPage{CGAL::Implicit_mesh_domain_3<Function,BGT>} \\
\ccRefIdfierPage{CGAL::Labeled_image_mesh_domain_3<Image,BGT>} 


% \ccExample

% A short example program.
% Instead of a short program fragment, a full running program can be
% included using the 
% \verb|\ccIncludeExampleCode{Package/BisectionGeometricTraits_3.C}| 
% macro. The program example would be part of the source code distribution and
% also part of the automatic test suite.

% \begin{ccExampleCode}
% void your_example_code() {
% }
% \end{ccExampleCode}

%% \ccIncludeExampleCode{Package/BisectionGeometricTraits_3.C}

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

