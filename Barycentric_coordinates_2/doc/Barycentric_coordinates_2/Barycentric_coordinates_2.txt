namespace CGAL {

/*!

\mainpage User Manual
\anchor Chapter_2D_Generalized_Barycentric_Coordinates
\anchor chapterGeneralizedBarycentricCoordinates
\cgalAutoToc

\authors Dmitry Anisimov, David Bommes, Kai Hormann, and Pierre Alliez

\section gbc_introduction Introduction

The package <em>2D Generalized Barycentric Coordinates</em> offers an efficient and robust implementation of two-dimensional closed-form generalized barycentric coordinates defined for simple two-dimensional polygons. If coordinates with respect to multivariate scattered points instead of a polygon are required, please refer to natural neighbour coordinates from the package \ref chapinterpolation "2D and Surface Function Interpolation". 

In particular, the package includes an implementation of \ref wp_example "Wachspress", \ref mv_example "mean value", and \ref dh_example "discrete harmonic coordinates" and provides some extra functions to compute barycentric coordinates with respect to segments (\ref seg_example "segment coordinates") and triangles (\ref tri_example "triangle coordinates"). Section \ref gbc_theory gives a short introduction to the topic of barycentric coordinates. 

\section gbc_interface Interface

Each class to compute barycentric coordinates is parameterized by a traits class that specifies the types and geometric primitives to be used in the computation. The default traits class for the package is  `CGAL::Barycentric_coordinates::Barycentric_traits_2` that presents the two-dimensional \cgal kernel and gives the default two-dimensional input to the class.

The main entry point to the component is an input iterator over the vertices of a polygon. The polygon's vertices must be ordered and can be of any type. However, internally the classes with coordinate functions use the type `CGAL::Point_2`, that is why an appropriate traits class that converts the user's type to the `CGAL::Point_2` must be provided. The same argument holds for query points.

Mean value coordinates are the most generic coordinate functions in this package because they allow an arbitrary simple polygon as input. Wachspress and discrete harmonic coordinates are, by definition, limited to strictly convex polygons. Segment coordinates take as input any non-degenerate segment, and triangle coordinate functions allow an arbitrary non-degenerate triangle.

Any point in the plane may be taken as a query point. However, we do not recommend to use Wachspress and discrete harmonic coordinates with query points outside the closure of a polygon because at some of those points these coordinate functions are not well-defined as explained in Section \ref gbc_degeneracies. 

Once instantiated for some polygon, the coordinate functions can be computed multiple times for different query points with respect to all the vertices of the provided polygon. In order to compute basis functions, use the function `compute()`. In order to compute barycentric weights directly without normalization for a strictly interior query point, use the function `compute_weights()`.

The output of the computation is a set of coordinate values at the current query point with respect to all the vertices of the polygon, and it can be stored in an arbitrary container providing an appropriate output iterator. In addition, all the classes return a pointer to the last stored element and status of the computation (boolean true or false).

\section gbc_examples Examples

\subsection wp_example Wachspress Coordinates
In the following example we create a random strictly convex polygon with 1000 random interior points and compute Wachspress coordinates at all these points with respect to all the polygon's vertices. In order to do so, we create 1000 random points, then we take the convex hull of this set of points as our polygon, and compute Wachspress coordinates for all the randomly defined points. We use the `Simple_cartesian` kernel with double type and store the obtained coordinate values in <a href="http://en.cppreference.com/w/cpp/container/vector">`std::vector`</a> container. The output iterator is <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">`std::back_insert_iterator`</a>, and it is handled automatically by the class.

\cgalExample{Barycentric_coordinates_2/Wachspress_coordinates_example.cpp}

\subsection dh_example Discrete Harmonic Coordinates
In this example we compute discrete harmonic coordinates for a set of <span style="color:#00CC00">interior</span>, <span style="color:#FF0033">boundary</span>, and <span style="color:#0099FF">exterior</span> points with respect to the unit square. We also show how to accelerate computations using additional parameters of the function `compute()`. The used kernel is exact, and we use <a href="http://en.cppreference.com/w/cpp/container/vector">`std::vector`</a> as an output container. Since all the points are symmetric, it is easy to debug the correctness of the obtained coordinate values. The output iterator is <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">`std::back_insert_iterator`</a>.

\anchor dh_coord_example
\cgalFigureBegin{dh__example,discrete_harmonic_coordinates_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/Discrete_harmonic_coordinates_example.cpp}

\subsection mv_example Mean Value Coordinates
This is an example that shows how to compute mean value coordinates for a set of <span style="color:#00CC00">green points</span> in the star-shaped polygon. We note that this type of coordinates is well-defined for such a concave polygon while Wachspress and discrete harmonic coordinates are not. However, it may give some negative coordinate values for points outside the <span style="color:#CC0000">kernel</span>. We use inexact data type, an <a href="http://en.cppreference.com/w/cpp/container/vector">`std::vector`</a> container, and the <a href="http://en.cppreference.com/w/cpp/iterator/back_insert_iterator">std::back_insert_iterator</a> to compute and store the resulting coordinate values. 

\anchor mv_coord_example
\cgalFigureBegin{mv__example,mean_value_coordinates_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/Mean_value_coordinates_example.cpp}

\subsection tri_example Triangle Coordinates
In this example we show how to use the class `CGAL::Barycentric_coordinates::Triangle_coordinates_2` with the `Simple_cartesian` kernel for a double type. We compute coordinates for three sets of points: <span style="color:#00CC00">interior</span>, <span style="color:#FF0033">boundary</span>, and <span style="color:#0099FF">exterior</span>. Note that some of the coordinate values for the exterior points are negative. We use a standard <a href="http://en.cppreference.com/w/cpp/container/vector">`std::vector`</a> container and the <a href="http://en.cppreference.com/w/cpp/iterator/insert_iterator">`std::insert_iterator`</a> to access and store the resulting values.

\anchor tri_coord_example
\cgalFigureBegin{tri__example,triangle_coordinates_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/Triangle_coordinates_example.cpp}

\subsection seg_example Segment Coordinates
This is a very simple and short example on how to use the class `CGAL::Barycentric_coordinates::Segment_coordinates_2`. We compute coordinate functions at three <span style="color:#00CC00">interior points</span> along the segment \f$[v_0, v_1]\f$ and at two <span style="color:#0099FF">exterior points</span> outside this segment along its supporting line. We use the exact kernel and return the coordinate values as a 2D point of the type `CGAL::Point_2`. Again, the symmetry of the query points allows us to see if there are any errors in the computation of the coordinates.

\anchor seg_coord_example
\cgalFigureBegin{seg__example,segment_coordinates_example.png}
Example's point pattern.
\cgalFigureEnd

\cgalExample{Barycentric_coordinates_2/Segment_coordinates_example.cpp}

\section gbc_degeneracies Degeneracies and Special Cases

\anchor compute_seg_coord
\subsection gbc_deg_segment_coordinates Segment Coordinates
Segment coordinates can be computed exactly if an exact data type is chosen. The segment itself, with respect to which we compute coordinates, must be not degenerate. If both conditions are satisfied, then the computation never breaks down. However, to compute coordinate functions, the user must be sure about a query point being exactly on the line \f$L\f$ supporting the segment. Since in many applications this is not the case, and a query point may lie very close but not exactly on this line, the class is able to handle this situation.

\cgalFigureBegin{projection,projection.png}
The scalar projection \f$p'\f$ of the <span style="color:#006400">vector</span> \f$p\f$ onto the <span style="color:#800000">vector</span> \f$q\f$.
\cgalFigureEnd

Suppose that some query point \f$v\f$ does not lie exactly on the line \f$L\f$, but is some distance \f$d\f$ away as shown in the figure above. If we want to compute the segment barycentric coordinate \f$b_1(v)\f$ with respect to the vertex \f$v_1\f$, we first find the scalar projection \f$p'\f$ of the vector \f$p\f$ onto the vector \f$q\f$ and then normalize it by the length of \f$q\f$. This gives the segment barycentric coordinate \f$b_1(v') = b_1(v)\f$ if \f$v\f$ lies exactly on the line.

\b Warning: Do not abuse the feature described above because it does not give correct segment barycentric coordinates for the point \f$v\f$ but rather those for \f$v'\f$. Moreover, segment barycentric coordinates for the point \f$v\f$ being not exactly on \f$L\f$ do not exist. But, if the non-zero distance \f$d\f$ is due to some numerical instability when computing the location of the point \f$v\f$ or any other problem which causes the point to be not exactly on the line, the final segment barycentric coordinates will be, at least approximately, correct.

With inexact data types, these coordinates give the correct result up to the precision of the chosen type.

\subsection gbc_deg_triangular_coordinates Triangle Coordinates

These coordinates can be computed exactly if an exact data type is chosen, for any query point in the plane and with respect to any non-degenerate triangle. No special cases are handled. The computation always gives the correct result. The notion of correctness depends on the precision of the used data type. Note that for exterior points some coordinate values will be negative.

\subsection gbc_deg_wachspress_coordinates Wachspress Coordinates
Wachspress coordinates are well-defined in the closure of any <b>strictly convex polygon</b>. Therefore, for any query point from the polygon's closure with an exact data type, these coordinates are computed exactly and no false result is expected. For inexact data types, the resulting precision of the computation is due to the involved algorithm and chosen data type. In the following paragraph we discuss two available algorithms for computing Wachspress coordinate functions. One of them is `CGAL::Barycentric_coordinates::PRECISE`, the other is `CGAL::Barycentric_coordinates::FAST`. 

\anchor wp_polygon
\cgalFigureBegin{wp__notations,wp_notations.png}
Notation for Wachspress coordinates.
\cgalFigureEnd

To compute Wachspress weights we follow \cite cgal:bc:fhk-gcbcocp-06 and use the formula 

<center>\f$w_i = \frac{C_i}{A_{i-1}A_i}\f$</center> 

with \f$i = 1\dots n\f$ where \f$n\f$ is the number of the polygon's vertices. In order to compute the coordinates, we normalize these weights,

<center>\f$b_i = \frac{w_i}{W^{wp}}\qquad\f$ with \f$\qquad W^{wp} = \sum_{j=1}^n w_j.\f$</center>

This formula becomes unstable when approaching to the boundary of the polygon (\f$\approx 1.0e-10\f$ and closer). To fix the problem we modify the weights \f$w_i\f$,

<center>\f$\bar{w}_i = C_i\prod_{j\not=i-1,i} A_j\f$.</center>

After the normalization as above, this gives us the precise algorithm to compute Wachspress coordinates but with the \f$O(n^2)\f$ performance only. The fast \f$O(n)\f$ algorithm uses the standard weights \f$w_i\f$. Note that mathematically this modification does not change the coordinates.

It is known that for strictly convex polygons the denominator's zero set of the Wachspress coordinates (\f$W^{wp} = 0~\f$) is a curve, which (in many cases) lies quite far away from the polygon. Speaking precisely, it goes through the intersection points of the continuations of the polygon's edges. Therefore, computation of Wachspress coordinates outside the polygon is possible only at points that do not belong to this curve.

\cgalFigureBegin{zero__set,zero_set.png}
<span style="color:#800000">Zero set</span> of the Wachspress coordinates' denominator \f$W^{WP}\f$ for a non-regular hexagon.
\cgalFigureEnd

\b Warning: We do not recommend to use Wachspress coordinates for exterior points!

\subsection gbc_deg_discrete_harmonic_coordinates Discrete Harmonic Coordinates

Discrete harmonic coordinates have the same requirements as Wachspress coordinates. They are well-defined in the closure of any <b>strictly convex polygon</b> and, if an exact data type is chosen, they are computed exactly. But, unlike Wachspress basis functions, these coordinates are not necessarily positive. In particular, the weight function \f$w_i\f$ is positive if and only if \f$\alpha+\beta < \pi\f$ (see the figure below for notation). For inexact data types, the precision of the computation is due to the involved algorithm and chosen data type. Again, we describe two algorithms to compute the coordinate functions: one is precise and one is fast.

\cgalFigureBegin{dh__notations,dh_notations.png}
Notation for discrete harmonic coordinates.
\cgalFigureEnd

To compute discrete harmonic weights we follow \cite cgal:bc:fhk-gcbcocp-06 and use the formula

<center>\f$w_i = \frac{r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i}{A_{i-1}A_i}\f$</center> 

with \f$i = 1\dots n\f$ where \f$n\f$ is the number of the polygon's vertices. In order to compute the coordinates, we normalize these weights,

<center>\f$b_i = \frac{w_i}{W^{dh}}\qquad\f$ with \f$\qquad W^{dh} = \sum_{j=1}^n w_j.\f$</center>

This formula becomes unstable when approaching to the boundary of the polygon (\f$\approx 1.0e-10\f$ and closer). To fix the problem, similarly to the previous subsection, we modify the weights \f$w_i\f$ as

<center>\f$\bar{w}_i = (r_{i+1}^2A_{i-1}-r_i^2B_i+r_{i-1}^2A_i)\prod_{j\not=i-1,i} A_j\f$.</center>

After the normalization as above, this gives us the precise algorithm to compute discrete harmonic coordinates but with the \f$O(n^2)\f$ performance only. The fast \f$O(n)\f$ algorithm uses the standard weights \f$w_i\f$. Again, mathematically this modification does not change the coordinates.

\b Warning: As for Wachspress coordinates, we do not recommend to use discrete harmonic coordinates for exterior points because the curve \f$W^{dh} = 0\f$ may have several components, and one of them always goes through the polygon's vertices. However, if you are sure that the query point does not belong to this curve, you can use them as in the \ref dh_example example.

\subsection gbc_deg_mean_value_coordinates Mean Value Coordinates

Unlike all the previous coordinates, mean value coordinates cannot be computed exactly due to an inevitable square root operation. Although, if an exact data type is used, the precision of the computation depends only on two \cgal functions: `CGAL::to_double()` and `CGAL::sqrt()`. On the other hand, mean value coordinates are well-defined everywhere in the plane for any simple polygon.

\cgalFigureBegin{mv__notations,mv_notations.png}
Notation for mean value coordinates.
\cgalFigureEnd

For these coordinate functions we also have two algorithms: one is precise and one is fast. The first one works everywhere in the plane, and the precision of the computation depends only on the chosen data type. However, its limit is the standard double type which is used internally to compute the square root. This algorithm is based on the following weight formula from \cite cgal:bc:f-wmvc-14

<center>\f$w_i = \sigma_i\bar{w}_i\qquad\f$ with \f$\qquad\bar{w}_i = (r_{i-1}r_{i+1}-d_{i-1}d_{i+1})^{1/2}\prod_{j\not= i-1,i}(r_jr_{j+1} + d_jd_{j+1})^{1/2}\qquad\f$ where \f$\qquad r_i = \|d_i\|.\f$</center> 

Since \f$\bar{w}_i\f$ is always positive, we have to append to it the proper sign \f$\sigma_i\f$ of the signed mean value weight function, which can be found efficiently (see the figures below). Basically, this weight function is always positive to the left from the <span style="color:#800000">red piecewise linear curve</span>, and it is negative to the right from this curve moving in counterclockwise direction. 

\cgalFigureBegin{mv__weight__signs,mv_weight_signs_convex.png,mv_weight_signs_concave.png}
Signs of the mean value weight \f$w_i\f$ depending on the region with respect to a convex \f$P\f$ and a concave \f$P'\f$ polygon.
\cgalFigureEnd

After the normalization of these weights as before we obtain the precise \f$O(n^2)\f$ algorithm. The fast \f$O(n)\f$ algorithm uses the pseudocode from <a href="http://www.inf.usi.ch/hormann/nsfworkshop/presentations/Hormann.pdf">here</a>. To compute weights \f$w_i\f$ without normalization we use formulas from the same pseudocode. Note that they are getting unstable if a query point is closer than \f$\approx 1.0e-10\f$ to the polygon's boundary, similarly to Wachspress and discrete harmonic coordinates.

\section gbc_performance Performance

Apart from the most important requirement on barycentric coordinates to be as precise as possible, it is very important for them to be as fast as possible to evaluate. These coordinate functions are used in many applications where they must be computed for millions of points and, thus, the real time usage of coordinates is crucial. When writing the code, we tried to fulfil this important requirement, and in this section we present a few results about the computational time of the implemented coordinate functions.

The structure of the speed test that we ran for all the functions consists of computing coordinate values (or weights) at >= 1 million strictly interior points with respect to some polygon (or triangle, or segment). At each iteration of the loop we create a query point, pass it to the function, and compute all the related coordinates. We run this loop 10 times in a row, and the time presented in the log-log scale plot at the end of the section is the arithmetic mean of all trials. A typical example of the performed test for triangle coordinates can be found below. This example also illustrates how to construct an iterator and pass it to the class. In the example we create an iterator that writes coordinate values for each new query point over coordinate values of the previous point in the fixed-size standard C++ array, so that memory is allocated only once.

\cgalExample{Barycentric_coordinates_2/Triangle_coordinates_speed_test.cpp}

The time to compute coordinates depends on many factors such as memory allocation, input kernel, output container, number of points, and so on. In our tests we used the most standard C++ and \cgal features with minimum memory allocation. Therefore, the final time presented is the average time that can be expected without deep optimization but still with efficient memory allocation. It also means that it may vary depending on the usage of the package.

The machine used in all the tests is a MacBook Pro 2011 with 2 GHz Intel Core i7 processor (2 cores) and 8 GB 1333 MHz DDR3 memory. The installed operating system is OS X 10.9 Maverick. In order to compile the speed test suite, we used the Clang 5.0 64bit compiler. The resulting timings can be found in the figure below.

\cgalFigureBegin{time,time.png}
Time in seconds to compute \f$n\f$ coordinate functions for a polygon with \f$n\f$ vertices at 1 million points. Solid \f$O(n^2)\f$ and dashed \f$O(n)\f$ algorithms for <span style="color:#3333FF">Wachspress</span>, <span style="color:#FF0033">discrete harmonic</span>, and <span style="color:#00CC00">mean value</span> coordinates.
\cgalFigureEnd

From the figure above it is easy to see that, when we have a polygon with a small number of vertices, the \f$O(n^2)\f$ algorithm is as fast as the \f$O(n)\f$ algorithm but, when we increase the number of vertices, the linear algorithm outperforms the squared one, as expected. One of the reasons for this to happen is because for a small number of vertices the operation of multiplication over \f$n-2\f$ elements inside the \f$O(n^2)\f$ algorithm, when computing weights, takes almost the same time as the corresponding operation of division in the \f$O(n)\f$ algorithm. For a polygon with many vertices this multiplication is much slower.

\section gbc_implementation Implementation Details

The generic design of the package was developed in 2013 by Dmitry Anisimov and David Bommes with many useful comments by Kai Hormann and Pierre Alliez. The package consists of 10 classes, 3 enumerations, and one namespace. Appropriate iterators are used to provide an efficient access to data and pass them to one of the generic algorithms to compute coordinates. Once instantiated for a polygon (triangle, segment), the coordinate functions can be computed multiple times for different query points with respect to all the vertices of the provided polygon (triangle, segment). All the classes are fully templated and have a simple and similar design. For example, if the function to compute coordinates within one class is named `compute()`, it has the same name within all other classes. Yet, the number of functions can differ from one class to another. 

The implemented algorithms for computing coordinates do not depend on a particular kernel, and all the coordinate functions can be computed exactly, if an exact kernel is used, apart from mean value coordinates. The latter coordinates involve a square root operation, which results in a slightly worse precision with exact data types due to temporal conversion into a floating point type. The computed coordinates can be stored in an arbitrary container if an appropriate <a href="http://en.cppreference.com/w/cpp/concept/Iterator">output iterator</a> is provided. 

It is worth noting that `CGAL::Barycentric_coordinates::Segment_coordinates_2` are used to compute generalized barycentric coordinates along the polygon's boundary. Hence, one can use a trick for segment coordinates from \ref gbc_degeneracies section if one is convinced that a point must lie exactly on the polygon's boundary but due to some numerical instabilities it does not.

The package is implemented in a way that later, if needed, other two-dimensional generalized barycentric coordinates can be easily added to the package.  

\section gbc_theory Theory of 2D Generalized Barycentric Coordinates

In 1827, the famous German mathematician and theoretical astronomer <a href="http://en.wikipedia.org/wiki/August_Ferdinand_Möbius">August Ferdinand Möbius</a> (1790--1868) proposed a method \cite cgal:bc:m-dbc-27  to find coordinates of a point in the plane with respect to the vertices of a triangle. These coordinates are called <a href="http://mathworld.wolfram.com/BarycentricCoordinates.html">triangle barycentric coordinates</a> (sometimes <a href="http://en.wikipedia.org/wiki/Barycentric_coordinate_system">area coordinates</a>), and they are widely used in a variety of applications. Some of these applications are linear interpolation over a triangle and a triangle inclusion test. The first one is used for so-called <a href="http://en.wikipedia.org/wiki/Shading">shading</a>, and the second one arises in the <a href="http://en.wikipedia.org/wiki/Rasterization">rasterization</a> step when an image in vector graphics format needs to be converted into a raster image. 

Triangle barycentric coordinates have many important properties, including \em constant and <em>linear precision</em>, <em> the Lagrange property</em>, and <em>positivity inside a triangle</em>. These properties make these coordinates a unique tool in many scientific fields. If we restrict triangle coordinates to one of its edges and its supporting line, we get barycentric coordinates with respect to a segment. We call these coordinates \ref gbc_deg_segment_coordinates "segment coordinates" and compute them as explained \ref compute_seg_coord "here".

Let us show a couple of plots for the coordinates described above. To plot segment coordinates we take a line \f$y = 0.4\f$ and define \ref fig__seg__example "a segment" \f$[v_0, v_1]\f$ on this line. Then we sample this segment and compute segment coordinates for all the sample points. If we plot the segment coordinate function at all the defined points with respect to \f$v_1\f$, we get the <span style="color:blue">blue line</span> depicted in the figure below. It grows from zero at \f$v_0\f$ to one at \f$v_1\f$.

\cgalFigureBegin{seg__coord__interp,seg__coord__interp.png}
<span style="color:blue">Segment coordinates</span> for all the <span style="color:#00CC00">segment points</span> with respect to \f$v_1 = (2.0,\ 0.4)\f$.
\cgalFigureEnd

If we want to plot triangle coordinates, we follow a similar approach. We take \ref fig__tri__example "a triangle" \f$[v_0, v_1, v_2]\f$ in the plane and sample its interior and boundary with a number of points. Once we have this sampling, we plot one of the triangle coordinate functions (here with respect to the third vertex of the triangle) at all the defined sample points. Likewise, we can plot the coordinate function with respect to the first or second vertex. The resulting function is a linear function (shown in the figure below) that grows from zero along the first edge \f$[v_0, v_1]\f$ to one at the chosen vertex \f$v_2\f$.

\cgalFigureBegin{tri__coord__interp,tri__coord__interp.png}
Triangle coordinates with respect to \f$v_2 = (1.0,\ 2.0)\f$. The colour bar indicates the range of values for the chosen coordinate function.
\cgalFigureEnd

Since many applications require to work with more complex planar geometric shapes than segments and triangles, it seems natural to investigate a generalized version of triangle coordinates with respect to arbitrary polygons. The first attempt was taken in 1975 by E. L. Wachspress \cite cgal:bc:w-rfeb-75, and the resulting generalized barycentric coordinates are now called Wachspress coordinates \cite cgal:bc:mlbd-gbcip-02. \ref gbc_deg_wachspress_coordinates "These coordinates" are well-defined for arbitrary <em>strictly convex</em> polygons and have all the properties of triangle coordinates \cite cgal:bc:fhk-gcbcocp-06. Unfortunately, they are not well-defined for weakly convex and concave polygons and break down in this setting. 

Analogously to the previous cases we want to plot the Wachspress coordinate function and see how it looks like. Let us choose a \ref wp_polygon "non-regular hexagon", slightly rotate it, and move one of its vertices towards the line through its two adjacent neighbours. We sample interior and boundary of this polygon as before and plot the coordinate function at all the defined sample points with respect to the vertex that we moved. We see that we get a smooth function, which is linear along edges and grows from zero to one, as the colour bar indicates.

\anchor wp_plot
\cgalFigureBegin{wp__coord__interp,wp__coord__interp.png}
The Wachspress coordinate function with values from zero to one as the colour bar indicates.
\cgalFigureEnd

Another type of generalized barycentric coordinates goes back to Pinkall and Polthier in 1993 \cite cgal:pp-cdmsc-93 and Eck et al. in 1995 \cite cgal:bc:eddhls-maam-95 in the context of \ref chapsurface_mesh_parameterization "triangle mesh parameterization". They are called discrete harmonic coordinates. \ref gbc_deg_discrete_harmonic_coordinates "These coordinates" are well-defined, similarly to Wachspress coordinates, for arbitrary <em>strictly convex</em> polygons and inherit all the properties of triangle coordinates <em>apart from the positivity inside a polygon</em> because they can take on negative values. Another interesting property of these coordinate functions is that they coincide with Wachspress coordinates for any polygon whose vertices lie on a common circle.

To plot discrete harmonic coordinates we take \ref wp_plot "the same polygon" as for Wachspress coordinates and plot the function with respect to the same vertex. Again, we get a smooth function, which is linear along edges and grows from zero to one. The distribution of colours in the plot shows the difference between discrete harmonic and Wachspress coordinates for the chosen polygon and vertex.

\anchor dh_plot
\cgalFigureBegin{dh__coord__interp,dh__coord__interp.png}
The discrete harmonic coordinate function with values from zero to one as the colour bar indicates.
\cgalFigureEnd

The last type of generalized barycentric coordinates that we discuss are mean value coordinates \cite cgal:f-mvc-03 proposed by M. Floater in 2003. Based on the <a href="http://en.wikipedia.org/wiki/Mean_value_theorem">mean value theorem</a>, \ref gbc_deg_mean_value_coordinates "these coordinates", unlike Wachspress and discrete harmonic coordinates, are well-defined for arbitrary <em>simple polygons</em>, inherit all the properties of triangle coordinates for any convex polygon, and <em>lack only the positivity property for general concave polygons</em>. Hormann and Floater prove in \cite cgal:bc:hf-mvcapp-06 that these coordinates are positive inside the kernel of a star-shaped polygon. They are also positive in the closure of any quadrilateral. Like discrete harmonic weights, mean value weights are often used in the context of \ref chapsurface_mesh_parameterization "triangle mesh parameterization."

In order to show the particular behaviour of mean value coordinates with an application to concave polygons, we take \ref fig__mv__example "a star-shaped polygon" with ten vertices \f$[v_0, \dots, v_9]\f$, sample its interior and boundary, and plot the coordinate function with respect to the fourth vertex \f$v_3\f$. As the colour bar indicates, the obtained function grows from a slightly negative value to one at the chosen vertex. It is also smooth and linear along edges.

\cgalFigureBegin{mv__coord__interp,mv__coord__interp.png}
Mean value coordinates with respect to \f$v_3\f$. The colour bar indicates the range of values for the chosen coordinate function.
\cgalFigureEnd

<b>Interesting fact</b>: All the coordinates discussed in this section and implemented in the package come from one and the same family of generalized barycentric coordinates named <em>3-point family of coordinates</em> \cite cgal:bc:fhk-gcbcocp-06. 

\section gbc_acknowledgments Acknowledgments
The authors wish to thank <a href="http://www.inf.usi.ch/phd/schneider/">Teseo Schneider</a> and <a href="http://search.usi.ch/people/5ae37d3d990b431a02b95b0b606da2e6/Schaerfig-Randolf">Randolf Schaerfig</a> for helpful comments and discussions. To create pictures for this manual the two programs were used: <a href="http://www.geogebra.org/cms/en/">Geogebra</a> and <a href="http://www.mathworks.com/products/matlab/?s_tid=hp_fp_ml">Matlab</a>. 

*/

}
