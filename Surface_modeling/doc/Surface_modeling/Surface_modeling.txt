namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_SurfaceModeling

\cgalAutoToc
\author TODO

\section Surface_Modeling_Intro Introduction
Surface mesh deformation is the process of transforming the shape of the surface mesh under control constraints without requiring any additional structure other than surface itself. 

In this package, we implement the algorithm described in \cite Sorkine2007AsRigidAs, 
where a nonlinear deformation energy is minimized under constraints to preserve rigidity as much as possible. 

\section Surface_Modeling_Overview Overview 
Since there is a close relation between differential representations and as-rigid-as possible deformation, we would like to 
start with a brief overview of related topics.

\subsection Surface_Modeling_Overview_Laplacian Laplacian Representation 
Laplacian coordinates are a way of representing the mesh differentially, which use the local coordinate of a vertex 
with respect to its one-ring neighbors (i.e. cell), rather than its global position. The Laplacian coordinate of a vertex is:

\f[
\begin{equation}
L(\mathbf{v}_i) = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}(\mathbf{v}_i - \mathbf{v}_j),
  \label{eq:lap_open}
\end{equation}
\f]

where \f$\mathbf{v}_i\f$ is the current vertex, \f$N(\mathbf{v}_i)\f$ is the set of one-ring neighbor vertices 
of \f$\mathbf{v}_i\f$, and \f$w_{ij}\f$ is a weight between \f$\mathbf{v}_i\f$ and neighbor \f$\mathbf{v}_j\f$. 
A simple choice for weighting schema can be uniform weights where each neighbor vertex is weighted 
by \f$1/|N(\mathbf{v}_i)|\f$, which actually corresponds to subtracting the average of neighbor vertices from the current vertex (\cgalFigureRef{Simple_laplacian}).
We use cotangent weights \cite Pinkall1993Cotangent to eliminate the effect of non-uniform discretization of the mesh model.

\cgalFigureBegin{Simple_laplacian,simple_mesh_with_laplacian.png}
A simple mesh structure. Red square is the average of neighbors of the yellow vertex. Blue vector represents Laplacian coordinate of the yellow vertex.
\cgalFigureEnd

Considering the mesh as a whole, it is possible to generate a linear system which results in Laplacian coordinates of all vertices:

\f[
\begin{equation}
\mathbf{L}\mathbf{V} = \delta,
  \label{eq:lap_system}
\end{equation}
\f]

where \f$n\f$ is number of vertices in the mesh, \f$\mathbf{L}\f$ is an \f$n \times n\f$ matrix, called Laplacian matrix, 
in which each row is filled according to Eq.\f$\eqref{eq:lap_open}\f$ , \f$\mathbf{V}\f$ is an \f$n \times 1\f$ vector consisting of 
global positions of vertices; and \f$\delta\f$ represents Laplacian coordinates of the mesh. 
 
\subsection Surface_Modeling_Overview_Laplacian_Deformation Naive Laplacian Deformation
A simple deformation system can be provided by selecting a few vertices from the mesh as handles (control vertices) 
and setting target positions for handles as deformation constrains.

The main idea behind Laplacian deformation is preservation of Laplacian coordinates under deformation constraints. 
In other words, Laplacian coordinates are treated as a representative form for the shape, and deformation
process should satisfy given constraints while causing as little distortion as possible on Laplacian coordinates.

There are different ways to incorporate deformation constraints into the system \cite Botsch2008OnLinearVariational.
We provide support for hard constraints, which means constrained positions of handles are preserved as is after deformation. 

\f[
\begin{equation}
\left[
\begin{array}{ccc}
\mathbf{L}' \\
\mathbf{I}_c
\end{array}
\right]
\mathbf{V} =
\left[
\begin{array}{ccc}
{\delta}' \\
\mathbf{C}_j
\end{array}
\right],
	\label{eq:lap_energy_system}
\end{equation}
\f]

where \f$\mathbf{L}'\f$ is Laplacian matrix of free (i.e. not constrained) vertices, \f$\mathbf{I}_c\f$ contains a row for each constrained vertex 
with one in corresponding position of the vertex and zeros elsewhere, \f${\delta}'\f$ is Laplacian coordinates of free vertices, 
and \f$\mathbf{C}_j\f$ holds the target positions of constrained vertices. Solving mentioned system under deformation constraints, 
preserves Laplacians of free vertices (upper side of the system) while satisfying the constraints (lower side of the system).

\subsection Surface_Modeling_Overview_ARAP As-Rigid-As Possible Deformation

The proposed energy function by \cite Sorkine2007AsRigidAs to be minimized under modeling constrains is:

\f[
\begin{equation}
\sum_{\mathbf{v}_i \in M}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}
\left\| (\mathbf{v}'_i - \mathbf{v}'_j) - \mathbf{R}_i(\mathbf{v}_i - \mathbf{v}_j) \right\|^2, 
  \label{eq:arap_energy}
\end{equation}
\f]

where \f$M\f$ is mesh structure, \f$N(\mathbf{v}_i)\f$ is one-ring neighbors of vertex \f$\mathbf{v}_i\f$, and \f$w_{ij}\f$ is 
the weight of the edge between \f$\mathbf{v}_i\f$ and \f$\mathbf{v}_j\f$, and \f$\mathbf{R}_i\f$ is rotation matrix for \f$\mathbf{v}_i\f$.

The intuitive idea behind the proposed energy function is allowing cells to
have individual rotations, and at the same time using overlapping nature of the
cells to prevent sharing \cgalFigureRef{Overlapping_cells}.
 
\cgalFigureBegin{Overlapping_cells,overlapping_cells.png}
Illustration of overlapping cells
\cgalFigureEnd

Minimization of the energy function in Eq.\f$\eqref{eq:arap_energy}\f$ for every vertex under deformation constraints provides
as-rigid-as possible deformation. In the equation, there are two unknowns: the new positions of vertices (\f$\mathbf{v}'_i\f$) 
and rotation matrices (\f$\mathbf{R}_i\f$). The problem is solved by using a two-step optimization approach (also called local-global approach).

In the first step, the method fixes vertex positions and treat \f$\mathbf{R}_i\f$ as only unknown. Given covariance matrix \f$S_i\f$:
\f[
\begin{equation}
\mathbf{S}_i = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} (\mathbf{v}_i - \mathbf{v}_j)(\mathbf{v}'_i - \mathbf{v}'_j)^T,
	\label{eq:cov_matrix}
\end{equation}
\f]

\f$\mathbf{R}_i\f$ which minimizes Eq.\f$\eqref{eq:arap_energy}\f$ can be found using SVD of \f$\mathbf{S}_i\f$ 
by also guaranteeing \f$det(\mathbf{R}_i)\f$ is positive by changing the sign of eigenvector in \f$\mathbf{U}_i\f$ which corresponds 
to smallest eigenvalue \cite Sorkine2009LeastSquaresRigid.

\f[
\begin{equation}
\mathbf{R}_i = \mathbf{V}_i \mathbf{U}_i^T \:where\: \mathbf{S}_i = \mathbf{U}_i\Sigma_i \mathbf{V}_i^T.
	\label{eq:optimal_rot}
\end{equation}
\f]

In the second step, the computed rotation matrices are placed into the partial derivative of Eq.\f$\eqref{eq:arap_energy}\f$ 
with respect to \f$\mathbf{v}'_i\f$. In order to find \f$\mathbf{v}'_i\f$ 
which minimizes deformation energy, setting the derivative to zero results in an equation of:

\f[
\begin{equation}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}(\mathbf{v}'_i - \mathbf{v}'_j) =
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \frac{(\mathbf{R}_i + \mathbf{R}_j)}{2} (\mathbf{v}_i - \mathbf{v}_j).
	\label{eq:lap_ber}
\end{equation}
\f]

One can see that the left-hand side of this equation corresponds to Eq.\f$\eqref{eq:lap_open}\f$,
so that we can fill \f$\delta\f$ using right-hand side of the equation which is all known in our system. 
After that, linear system in Eq. \f$\eqref{eq:lap_energy_system}\f$ can be solved in order to find \f$\mathbf{V}'\f$. 
Two-step optimization can be pursued for further refinement by altering steps.

\note For supporting asymmetric edge weights, we slightly changed the Eq. \f$\eqref{eq:lap_ber}\f$ to:
\f[
\begin{equation}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij} + w_{ji})(\mathbf{v}'_i - \mathbf{v}'_j) =
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij}\mathbf{R}_i + w_{ji}\mathbf{R}_j)(\mathbf{v}_i - \mathbf{v}_j).
	\label{eq:lap_ber_asym}
\end{equation}
\f]

\subsection Surface_Modeling_Overview_ARAP_Rims Spokes and Rims Version

\cgalFigureBegin{Spoke_and_rim_edges, spoke_and_rim_edges.png}
Considered edges \f$E(\mathbf{v}_i)\f$ in energy function for a vertex \f$\mathbf{v}_i\f$. 
\cgalFigureEnd

Modified energy function proposed by \cite Chao2010SimpleGeomModel includes all edges around facets incident to a vertex. So that the energy function becomes:

\f[
\begin{equation}
\sum_{\mathbf{v}_i \in M}
\sum_{(\mathbf{v}_j, \mathbf{v}_k) \in E(\mathbf{v}_i)} w_{jk}
\left\| (\mathbf{v}'_j - \mathbf{v}'_k) - \mathbf{R}_i(\mathbf{v}_j - \mathbf{v}_k) \right\|^2, 
  \label{eq:arap_energy_rims}
\end{equation}
\f]

where \f$E(\mathbf{v}_i)\f$ is set of edges around facets incident to \f$\mathbf{v}_i\f$ \cgalFigureRef{Spoke_and_rim_edges}. 
For the first step, corresponding Eq. \f$\eqref{eq:cov_matrix}\f$ is simply modified to include all edges in \f$E(\mathbf{v}_i)\f$. 
For the second step, setting partial derivative of Eq. \f$\eqref{eq:arap_energy_rims}\f$ zero with respect to \f$\mathbf{v}_i\f$ results in:

\f[
\begin{equation}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij} + w_{ji})(\mathbf{v}'_i - \mathbf{v}'_j) =
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} \frac{w_{ij}(\mathbf{R}_i + \mathbf{R}_j + \mathbf{R}_m) + w_{ji}(\mathbf{R}_i + \mathbf{R}_j + \mathbf{R}_n)}{3} (\mathbf{v}_i - \mathbf{v}_j).
	\label{eq:lap_ber_rims}
\end{equation}
\f]

where \f$\mathbf{R}_m\f$ and \f$\mathbf{R}_n\f$ are rotation matrices of \f$\mathbf{v}_m\f$, 
\f$\mathbf{v}_n\f$ which are opposite vertices of edge \f$\mathbf{v}_i, \mathbf{v}_j\f$.

\section Surface_Modeling_API API

\cgalFigureBegin{Flow_of_API, usage_flow_of_API.png}
Usage flow of API. 
\cgalFigureEnd

\subsection Preprocess_section Preprocess Section

While introducing the API, we would like to consider user point of view by following main steps in a deformation session \cgalFigureRef{Flow_of_API}. 
The usage of the API begins with constructing a deformation object.
  - `Deform_mesh::Deform_mesh(Polyhedron& polyhedron, VertexIndexMap vertex_index_map, EdgeIndexMap edge_index_map, unsigned int iterations = 5, double tolerance = 1e-4)`
		- Provided vertex_index_map and edge_index_map will be used for assigning indexes to required vertices and edges. 
		- Information about iterations and tolerance parameters is provided in \ref Deform_section. 

Then, the region that the algorithm operates on (i.e. region of interest -ROI) 
should be determined. The API is convenient enough for either using whole mesh or set of predefined vertices as region of interest. 
  - `Deform_mesh::insert_roi(vertex_descriptor vd)` insert vertices one by one
  - `Deform_mesh::insert_roi(InputIterator begin, InputIterator end)` insert vertices in a range

The ROI should be a connected component and should also include the handle vertices \cgalFigureRef{Simple_roi}.
Note that the algorithm automatically finds the boundary of the ROI and fix those vertices while deforming.

\cgalFigureBegin{Simple_roi, roi_example.png}
Red vertices represent handles, and yellow vertices together with red vertices represent ROI. 
\cgalFigureEnd

Similary, handle vertices which will constrain deformation should be added. 
At this point vertices should be grouped that are expected to translate or rotate together.
  - `Deform_mesh::create_handle_group()` create an empty group for vertices and return representative `Deform_mesh::Handle_group` of the group
  - `Deform_mesh::insert_handle(Handle_group handle_group, vertex_descriptor vd)` insert the vertex to the handle group
  - `Deform_mesh::insert_handle(Handle_group handle_group, InputIterator begin, InputIterator end)` insert vertices in a range to the handle group

Grouped vertices can be connected or disconnected. Previously mentioned, only reason to group handle vertices is having ability to translate and rotate them together. 

Inserted vertices can also be released from being handle or roi.
  - `Deform_mesh::erase_roi(vertex_descriptor vd)` erase the vertex from ROI
  - `Deform_mesh::erase_handle(Handle_group handle_group)` erase the whole group
  - `Deform_mesh::erase_handle(Handle_group handle_group, vertex_descriptor vd)` erase the vertex which is inside given group

After finishing ROI and handle insertion, preprocess function needs to be called.
  - `Deform_mesh::preprocess()` preprocess ROI and handles, make internal stuff ready for deformation
  
Preprocess function returns true if factorization of the linear system in Eq. \f$\eqref{eq:lap_energy_system}\f$ is successful. 
One common reason for failure is that the system is rank deficient, which happens if there is no boundary vertices for ROI 
and also there is no handle vertices (i.e. inserting whole mesh as ROI and inserting no handle vertices).
Another reason can be zero weights for edges (if you are using custom weights).

\subsection Deform_section Deform Section

Before deforming the mesh, target positions should be provided for handle vertices. A direct way to accomplish this is:
  - `Deform_mesh::assign(vertex_descriptor vd, const Point& target_position)` assign the target position for the handle vertex
  
If the target positions for the handles are planned to provide directly, then hanldles can be simply inserted into one group (also any grouping would be still valid)
and `Deform_mesh::assign` can be used for direct assignment of target positions. 

\anchor rot
The API also includes functionality for translating and rotating handle vertices. 
  - `Deform_mesh::translate(Handle_group handle_group, const Vector& translation)` translate the vertices under handle group by translation
  - `Deform_mesh::rotate(Handle_group handle_group, const Point& rotation_center, const Quaternion& quat, const Vect& translation)` 
  rotate the handle group around rotation center by quaternion then translate it by translation

Rotate and translate operate on original positions(i.e. positions of vertices at the time of the call Deform_mesh::preprocess()) of handle vertices. 

Note that changing target positions of handle vertices has no immediate effect on actual positions.
Also unconstrained handles will be constrained to their last target positions.

The last action required is invoking deformation algorithm.
  - `Deform_mesh::deform(unsigned int iterations, double tolerance)` deform mesh with instant parameters. 
  Note that if the intention is using permanent parameters, use the functions explained below
    - Each iteration consists two steps of optimization procedure explained in \ref Surface_Modeling_Overview_ARAP
    - In case of tolerance is smaller than or equal to zero, no energy based termination occurs. 
	Otherwise it is compared against \f$|energy(m_i) - energy(m_{i-1})| / energy(m_i)\f$ where \f$m_i\f$ is the resulting surface mesh at iteration \f$i\f$.  
  - `Deform_mesh::deform()` deform mesh using iterations and tolerance provided in constructor or using `Deform_mesh::set_iterations`, and `Deform_mesh::set_tolerance`

After deformation handle vertices will be placed to their target positions and free vertices will be deformed accordingly. 
The steps in \ref Deform_section can be repeated again for further deformations.

\subsection Surface_modeling_examples Examples
\subsubsection Example_1 Example 1
In our first example, we use whole mesh as ROI and add a few vertices as handles. `Deform_mesh::assign()` is used for constraining handle vertices.
\cgalExample{Surface_modeling/example_1.cpp}

\cgalFigureBegin{Example_1_results, example_1_results.png}
Deformation results from example, deform_1.off and deform_2.off. 
\cgalFigureEnd

\subsubsection Example_2 Example 2
In this example, we use handle grouping feature of the API together with `Deform_mesh::translate()` and `Deform_mesh::rotate()`. 
\todo we need to implement small quaternion class to demonstrate `Deform_mesh::rotate()`.

\cgalExample{Surface_modeling/example_2.cpp}

\cgalFigureBegin{Example_2_results, example_2_results.png}
Deformation results from example, deform_1.off and deform_2.off. 
\cgalFigureEnd

\section Surface_Modeling_Demo How to use the demo
Explain how to use the demo

\section Surface_Modeling_History Implementation History
Initial version of this package is implemented during Google Summer of Code 2011 by Yin Xu with Andreas Fabri and Olga Sorkine as mentor.
Ilker O. Yaz took over the finalization of the package.
*/

} /* namespace CGAL */

