namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_SurfaceModeling

\cgalAutoToc
\author TODO

\section Surface_Modeling_Intro Introduction
Surface modeling is 

In this package, we implement the algorithm described in \cite Sorkine2007AsRigidAs, 
where a nonlinear deformation energy is minimized under modeling constraints to preserve rigidity as much as possible. 
The proposed energy function is minimized by applying two-step optimization procedure iteratively, 
which makes the algorithm suitable for interactive applications since the... 
\todo  move this sentence somewhere else
  

\section Surface_Modeling_Overview Overview 
Since there is a close relation between differential representations and as-rigid-as possible deformation, we would like to 
start with a brief overview of related topics.

\subsection Surface_Modeling_Overview_Laplacian Laplacian Representation 
Laplacian coordinates are a way of representing the mesh differentially, which use the local coordinate of a vertex 
with respect to its one-ring neighbors (i.e. cell), rather than its global position. The Laplacian coordinate of a vertex is:

\f[
\begin{equation}
L(\mathbf{v}_i) = \mathbf{v}_i - \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \mathbf{v}_j,
  \label{eq:lap_open}
\end{equation}
\f]

where \f$\mathbf{v}_i\f$ is the current vertex, \f$N(\mathbf{v}_i)\f$ is the set of one-ring neighbor vertices 
of \f$\mathbf{v}_i\f$, and \f$w_{ij}\f$ is a weight between \f$\mathbf{v}_i\f$ and neighbor \f$\mathbf{v}_j\f$. 
A simple choice for weighting schema can be uniform weights where each neighbour vertex is weighted 
by \f$1/|N(\mathbf{v}_i)|\f$, which actually corresponds to calculating the average of neighbour vertices and 
subtracting the result from the current vertex (\cgalFigureRef{Simple_laplacian}). We use cotangent weights \cite Pinkall1993Cotangent
to eliminate the effect of non-uniform discretization of the mesh model.

\cgalFigureBegin{Simple_laplacian,simple_mesh_with_laplacian.png}
A simple mesh structure. Red square is the average of neighbours of the yellow vertex. Blue vector represents Laplacian coordinate of the yellow vertex.
\cgalFigureEnd

Considering the mesh as a whole, it is possible to generate a linear system which results in Laplacian coordinates of all vertices:

\f[
\begin{equation}
\mathbf{L}\mathbf{V} = \delta,
  \label{eq:lap_system}
\end{equation}
\f]

where \f$n\f$ is number of vertices in the mesh, \f$\mathbf{L}\f$ is an \f$n \times n\f$ matrix, called Laplacian matrix, 
in which each row is filled according to Eq.\f$\eqref{eq:lap_open}\f$ , \f$\mathbf{V}\f$ is an \f$n \times 1\f$ vector consisting of 
global positions of vertices; and \f$\delta\f$ represents Laplacian coordinates of the mesh. 
 
\subsection Surface_Modeling_Overview_Laplacian_Deformation Naive Laplacian Deformation
A simple deformation system can be provided by allowing the user to select a few vertices on the mesh (i.e. handles) 
and providing target positions as deformation constrains.

The main idea behind Laplacian deformation is preservation of Laplacian coordinates under deformation constraints. 
In other words, Laplacian coordinates are treated as a representative form for the shape, and deformation
process should satisfy given constraints while causing as little distortion as possible on Laplacian coordinates.

There are different ways to incorporate deformation constraints into the system \cite Botsch2008OnLinearVariational.
We provide support for hard constraints, which means constrained positions of handles are preserved as is after deformation. 

\f[
\begin{equation}
\left[
\begin{array}{ccc}
\mathbf{L}' \\
\mathbf{I}_c
\end{array}
\right]
\mathbf{V} =
\left[
\begin{array}{ccc}
{\delta}' \\
\mathbf{C}_j
\end{array}
\right],
	\label{eq:lap_energy_system}
\end{equation}
\f]

where \f$\mathbf{L}'\f$ is Laplacian matrix of free (i.e. not constrained) vertices, \f$\mathbf{I}_c\f$ contains a row for each constained vertex 
with one in corresponding position of the vertex and zeros elsewhere, \f${\delta}'\f$ is Laplacian coordinates of free vertices, 
and \f$\mathbf{C}_j\f$ holds the target positions of constrained vertices. Solving mentioned system under deformation constraints, 
preserves Laplacians of free vertices (upper side of the system) while satisyfing the constraints (lower side of the system).

\subsection Surface_Modeling_Overview_ARAP As-Rigid-As Possible Deformation

The proposed energy function by \cite Sorkine2007AsRigidAs to be minimized under modeling constrains is:

\f[
\begin{equation}
\sum_{\mathbf{v}_i \in M}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}
\left\| (\mathbf{v}'_i - \mathbf{v}'_j) - \mathbf{R}_i(\mathbf{v}_i - \mathbf{v}_j) \right\|^2, 
  \label{eq:arap_energy}
\end{equation}
\f]

where \f$M\f$ is mesh structure, \f$N(\mathbf{v}_i)\f$ is one-ring neighbours of vertex \f$\mathbf{v}_i\f$, and \f$w_{ij}\f$ is 
the weight of the edge between \f$\mathbf{v}_i\f$ and \f$\mathbf{v}_j\f$, and \f$\mathbf{R}_i\f$ is rotation matrix for \f$\mathbf{v}_i\f$.

The intuitive idea behind the proposed energy function is allowing cells to
have individual rotations, and at the same time using overlapping nature of the
cells to prevent sharing \cgalFigureRef{Overlapping_cells}.
 
\cgalFigureBegin{Overlapping_cells,overlapping_cells.png}
Illustration of overlapping cells
\cgalFigureEnd

Minimization of the energy function in Eq.\f$\eqref{eq:arap_energy}\f$ for every vertex under deformation constraints provides
as-rigid-as possible deformation. In the equation, there are two unknowns: the new positions of vertices (\f$\mathbf{v}'_i\f$) 
and rotation matrices (\f$\mathbf{R}_i\f$). This minimization problem is solved by developing a two-step optimization approach (also called local-global approach).

In the first step, the method fixes vertex positions and treat \f$\mathbf{R}_i\f$ as only unknown. Given covariance matrix \f$S_i\f$:
\f[
\begin{equation}
\mathbf{S}_i = \sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} (\mathbf{v}_i - \mathbf{v}_j)(\mathbf{v}'_i - \mathbf{v}'_j)^T,
	\label{eq:cov_matrix}
\end{equation}
\f]

\f$\mathbf{R}_i\f$ which minimizes Eq.\f$\eqref{eq:arap_energy}\f$ can be found using SVD of \f$\mathbf{S}_i\f$ 
by also guaranteeing \f$det(\mathbf{R}_i)\f$ is positive by changing the sign of eigenvector in \f$\mathbf{U}_i\f$ which corresponds 
to smallest eigenvalue \cite Sorkine2009LeastSquaresRigid.

\f[
\begin{equation}
\mathbf{R}_i = \mathbf{V}_i \mathbf{U}_i^T \:where\: \mathbf{S}_i = \mathbf{U}_i\Sigma_i \mathbf{V}_i^T.
	\label{eq:optimal_rot}
\end{equation}
\f]

In the second step, the computed rotation matrices are placed into the partial derivative of Eq.\f$\eqref{eq:arap_energy}\f$ 
with respect to \f$\mathbf{v}'_i\f$, by treating rotation matrices as constants. In order to find \f$\mathbf{v}'_i\f$ 
which minimizes deformation energy, setting the derivative to zero results in an equation of:

\f[
\begin{equation}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}(\mathbf{v}'_i - \mathbf{v}'_j) =
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \frac{(\mathbf{R}_i + \mathbf{R}_j)}{2} (\mathbf{v}_i - \mathbf{v}_j).
	\label{eq:lap_ber}
\end{equation}
\f]

One can see that the left-hand side of this equation corresponds to Eq.\f$\eqref{eq:lap_open}\f$,
so that we can fill \f$\delta\f$ using right-hand side of the equation which is all known in our system. 
After that, linear system in Eq. \f$\eqref{eq:lap_energy_system}\f$ can be solved in order to find \f$\mathbf{V}'\f$. 
Two-step optimization can be pursued for further refinement by altering steps.

\note For supporting asymmetric edge weights, we slightly changed the Eq. \f$\eqref{eq:lap_ber}\f$ to:
\f[
\begin{equation}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij} + w_{ji})(\mathbf{v}'_i - \mathbf{v}'_j) =
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} (w_{ij}\mathbf{R}_i + w_{ji}\mathbf{R}_j)(\mathbf{v}_i - \mathbf{v}_j).
	\label{eq:lap_ber_asym}
\end{equation}
\f]

\subsection Surface_Modeling_Overview_ARAP_Rims Spokes and Rims Version
\todo we should ask Olga to check this

Modified energy function proposed by \cite Chao2010SimpleGeomModel includes also the rim edges along with spoke edges. So that the energy function becomes:

\f[
\begin{equation}
\sum_{\mathbf{v}_i \in M}
\sum_{(\mathbf{v}_j, \mathbf{v}_k) \in E(\mathbf{v}_i)} w_{jk}
\left\| (\mathbf{v}'_j - \mathbf{v}'_k) - \mathbf{R}_i(\mathbf{v}_j - \mathbf{v}_k) \right\|^2, 
  \label{eq:arap_energy_rims}
\end{equation}
\f]

where \f$E(\mathbf{v}_i)\f$ is set of edges consisting spoke and rim edges of \f$\mathbf{v}_i\f$. 
For the first step, corresponding Eq. \f$\eqref{eq:cov_matrix}\f$ is simply modified to include all edges in \f$E(\mathbf{v}_i)\f$. 
For the second step, setting partial derivative of Eq. \f$\eqref{eq:arap_energy_rims}\f$ zero with respect to \f$\mathbf{v}_i\f$ results in:

\f[
\begin{equation}
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij}(\mathbf{v}'_i - \mathbf{v}'_j) =
\sum_{\mathbf{v}_j \in N(\mathbf{v}_i)} w_{ij} \frac{(\mathbf{R}_i + \mathbf{R}_j + \mathbf{R}_m + \mathbf{R}_n)}{4} (\mathbf{v}_i - \mathbf{v}_j).
	\label{eq:lap_ber_rims}
\end{equation}
\f]

where \f$\mathbf{R}_m\f$ and \f$\mathbf{R}_n\f$ are rotation matrices of \f$\mathbf{v}_m\f$, 
\f$\mathbf{v}_n\f$ which are opposite vertices of edge \f$\mathbf{v}_i, \mathbf{v}_j\f$.

\section Surface_Modeling_API API

\cgalFigureBegin{Flow_of_API, usage_flow_of_API.png}
Usage flow of API. 
\cgalFigureEnd

\subsection Preprocess
\todo better section name

While introducing the API, we would like to consider user point of view by following main steps in a deformation session \cgalFigureRef{Flow_of_API}. 
The usage of the API begins with constructing a deformation object.
  - `Deform_mesh::Deform_mesh`
\todo need to explain more in here

Then, the region that the algorithm operates on (i.e. region of interest -ROI) 
should be determined. The API is convenient enough for either using whole mesh or set of predefined vertices as region of interest. 
  - `Deform_mesh::insert_roi(vertex_descriptor vd)` insert vertices one by one
  - `Deform_mesh::insert_roi(InputIterator begin, InputIterator end)` insert vertices in a range

The ROI should be a connected component and should also include the handle vertices \cgalFigureRef{Simple_roi}.
Note that the algorithm automatically finds the boundary of the ROI and fix those vertices while deforming.

\cgalFigureBegin{Simple_roi, roi_example.png}
Red vertices represent handles, and yellow vertices together with red vertices represent ROI. 
\cgalFigureEnd

Similary, handle vertices which will constrain deformation should be added. 
At this point vertices should be grouped that are expected to translate or rotate together.
  - `Deform_mesh::create_handle_group()` create an empty group for vertices and return representative `Deform_mesh::Handle_group` of the group
  - `Deform_mesh::insert_handle(Handle_group handle_group, vertex_descriptor vd)` insert the vertex to the handle group
  - `Deform_mesh::insert_handle(Handle_group handle_group, InputIterator begin, InputIterator end)` insert vertices in a range to the handle group

Grouped vertices can be connected or disconnected. Previously mentioned, only reason to group handle vertices is having ability to translate and rotate them together. 

Inserted vertices can also be released from being handle or roi.
  - `Deform_mesh::erase_roi(vertex_descriptor vd)` erase the vertex from ROI
  - `Deform_mesh::erase_handle(Handle_group handle_group)` erase the whole group
  - `Deform_mesh::erase_handle(Handle_group handle_group, vertex_descriptor vd)` erase the vertex which is inside given group

After finishing ROI and handle insertion, preprocess function is need to be called.
  - `Deform_mesh::preprocess()` preprocess ROI and handles, make internal stuff ready for deformation
  
Preprocess function returns true if factorization of the linear system in Eq. \f$\eqref{eq:lap_energy_system}\f$ is successful. 
One common reason for failure is that the system is rank deficient, which happens if there is no boundary vertices for ROI 
and also there is no handle vertices (i.e. inserting whole mesh as ROI and inserting no handle vertices). 

\subsection Deform
\todo better section name

Before deforming the mesh, target positions should be provided for handle vertices. A direct way to accomplish this is:
  - `Deform_mesh::assign(vertex_descriptor vd, const Point& target_position)` assign the target position for the handle vertex
  
If the target positions for the handles are planned to provide directly, then hanldles can be simply inserted into one group (also any grouping would be still valid)
and `Deform_mesh::assign` can be used for direct assignment of target positions. 

\anchor rot
The API also includes functionality for translating and rotating handle vertices. 
  - `Deform_mesh::translate(Handle_group handle_group, const Vector& translation)` translate the vertices under handle group by translation
  - 

Note that changing target positions of handle vertices has no immediate effect on actual positions.

The last action required is invoking deformation algorithm.
  - `Deform_mesh::deform()` deform mesh using iterations and tolerance provided in constructor or using `Deform_mesh::set_iterations`, `Deform_mesh::set_tolerance`. 
  In case of tolerance is smaller than or equal to zero, no energy based termination occurs.
  - `Deform_mesh::deform(unsigned int iterations, double tolerance)`






\section Surface_Modeling_Demo How to use the demo
Explain how to use the demo

\section Surface_Modeling_History Implementation History
Initial version of this package is implemented during Google Summer of Code 2011 by Yin Xu with Andreas Fabri and Olga Sorkine as mentor.
Ilker O. Yaz took over the finalization of the package.
*/

} /* namespace CGAL */

