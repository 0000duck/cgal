namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_Point_Set_Shape_Detection
\cgalAutoToc

\authors Sven Oesau, Yannick Verdie, Cl√©ment Jamin

\section Point_set_shape_detection_3Introduction Introduction

This \cgal component implements the efficient RANSAC method for primitive shape detection contributed by Schnabel et al. in 2007 \cite cgal:-erpcsd-07. The method takes as input an unstructured point set with unoriented normals and provides as output a list of detected primitive shapes with associated point sets (see \cgalFigureRef{Point_set_shape_detection_3_overview}). The primitive shapes supported are plane, sphere, cylinder, cone and torus.

\cgalFigureBegin{Point_set_shape_detection_3_overview,overview2.png}
Left: Input point set. Right: Points colored by detected primitive. 
\cgalFigureEnd

\section Point_set_shape_detection_3Method Method
The method takes as input a point set with unoriented normals and provides as output a set of primitive shapes covering all or part of the input points. The primitive shapes are detected via a RANSAC-type approach, i.e., a random sample consensus. The basic RANSAC approach repeats the following steps: (1) Randomly select a subset of the input points. (2) Fit a primitive shape to the selected subset. (3) Count the number of inliers to the primitive, i.e., the points within a user-specified error tolerance to the primitive. Steps 1, 2  and 3 are repeated for a prescribed number of iterations and the largest primitive with highest number of inliers is kept. 

In our context the error between a point and a primitive is defined by its distance and normal deviation to the shape. A random subset corresponds to the minimal number of points (with normals) required to uniquely define a primitive.

For very large point sets however the basic RANSAC method is not practical when testing all possible primitive shape candidates against the input data in order to find the largest primitive shapes. The main idea behind the efficient RANSAC consists of testing shape candidates only against subsets of the input data. Only a subset of all possible shape candidates is constructed until the probability to miss the largest candidate is lower than a user-specified parameter. The largest primitive shape is repeatedly extracted until no more primitive shape, covering a minimum number of points, can be extracted.

The support of a primitive shape refers to the footprint of the points covered by the primitive. To avoid generating primitive shapes with fragmented support we impose a connectivity constraint by considering only the largest connected component.

The output of the shape detection algorithm is a set of primitive shapes with associated points, and all remaining points not covered by primitive shapes. Each input point can be assigned to at most one primitive shape. 

\section Point_set_shape_detection_3Parameters Parameters
The algorithm requires five parameters:
- \f$epsilon\f$ and \f$normal deviation\f$:
The support of a point to a shape is decided by a metric based on the Euclidean distance and the normal deviation from the point to its closest projection onto the shape. The epsilon parameter specifies the maximal tolerated Euclidean distance between a point and a shape. A high choice of epsilon leads to a detection of fewer larger shapes and a less detailed outcome. A low value for epsilon allows for a higher recovery of details, but may lead to an oversegmentation or lower coverage. The impact on the outcome is depicted in fig. \cgalFigureRef{Point_set_shape_detection_3_parameter_epsilon_variation}. The effect on performance is evaluated in section \ref Point_set_shape_detection_3Performance.
\cgalFigureBegin{Point_set_shape_detection_3_parameter_epsilon_variation,epsilon_variation.png}
The figure depicts the impact of a variation of epsilon on the outcome. The input point set has been sampled from a mesh shown on the left. The mid left image shows a detection of planar shapes with a more tolerant choice of 2.0 for epsilon. The color indicates the association to a shape. Most details on the roof have not been recovered. The mid right image depicts the outcome for a choice of 0.5 for epsilon. The facades are recovered correctly and some details have been recovered on the roof. The right image show an more detailed but slightly oversegmented outcome for a choice of 0.25 for epsilon.
\cgalFigureEnd

- \f$cluster_epsilon\f$:
The clustering of supporting points of a shape is controlled by a user-specified parameter, cluster_epsilon. The supporting points are transformed into a 2D parameter space of the shape. The parameter space is chosen to minimize distortion and to preserve arc-length as well as possible. A connected component search is performed in the discretized 2D parameter space to identify the largest cluster of supporting points. The cluster_epsilon specifies the discretization of the parameter space. Thus the cluster_epsilon corresponds to the Euclidean distance between points to consider them to be connected. Due to the layout of the discretization points up to a distance of \f$2\sqrt{2}\, cluster\_epsilon\f$ can still be considered connected. The impact of the choice of cluster_epsilon is depicted in fig. 
\cgalFigureRef{Point_set_shape_detection_3_parameter_connectivity}. 
\cgalFigureBegin{Point_set_shape_detection_3_parameter_connectivity,varying_connectivity.png}
The cluster_epsilon parameter impacts the connectivity of points on a shape. The synthetic data set consists of points sampled on four coplanar squares. A large cluster_epsilon leads to the extraction of all points as one shape (left). Choosing a cluster_epsilon such that the four squares get extracted separately leads also to the loss of a few points within each square due to the random sampling (mid). A small value of cluster_epsilon leads to an oversegmentation (right).
\cgalFigureEnd

- \f$search thoroughness\f$:
The search endurance is controlled by a parameter that specifies the probability to miss the largest candidate. A lower probability provides a higher reliability and determinism at the cost of longer running times.

- \f$minimum number of points\f$:
The minimum number of points for a shape is specified by the user to control the termination of the method. A shape candidate is dropped after evaluation on a subset of the input data, if the estimated support for the whole input data does not meet the specified minimum with a certain probability. However, if the final number of supporting points is only determined during extraction, even smaller shapes will get extracted.

\section Point_set_shape_detection_3Usage Usage
The main class `Shape_detection_3` takes a template parameter `Shape_detection_traits_3` where the geometric types and the input format is specified. The concept of property maps is used, as this is provides flexibility to use own data structures. The first parameter of the `Shape_detection_traits_3` class is the commonly used Kernel. For the use of property maps, an iterator type and two maps to map that iterator to a point and a normal are specified in the `Shape_detection_traits_3` class. The property maps concept is explained in detail in Chapter \ref chapterProperty_map.

Typical usage consists of four steps:

-# Provide input data via a range iterator
-# Register shape factories
-# Choose parameters 
-# Detect
-# Retrieve detected shapes

\subsection Point_set_shape_detection_3Usage_minimal Basic example

The following minimalistic example reads a point set from a file and detects only planes. The default parameters are used for detection.

\cgalExample{shape_detection_3_basic.cpp}

\subsection Point_set_shape_detection_3Usage_parameters Manual parameterization and different shape types

This example shows the user selection of parameters using the `Shape_detection::Parameters` struct. The detection has been extended to all shape types. A basic output of the detected shapes is provided after processing. The input point set is sampled on a surface mostly composed of piece-wise planar and cylindrical parts, in addition to free-form parts.

\cgalExample{shape_detection_3_parameters.cpp}

\subsection Point_set_shape_detection_3Usage_point_access Measuring mean error

This example shows how to access the points assigned to a shape. In addition, a timer measures the running performance of the method.

\cgalExample{shape_detection_3_point_access.cpp}


\section Point_set_shape_detection_3Performance Performance
 
The running time and detection performance depend on the chosen parameters. Selective error tolerance parameters lead to higher running times. It leads to smaller shapes as many shape candidates are generated to find the largest shape. We plot the detection performance against the epsilon error tolerance parameter for detecting planes in a complex scene with 5M points, see\cgalFigureRef{Point_set_shape_detection_3_performace_epsilon}. The probability parameter controls the endurance when searching for the largest candidate at each iteration. It barely impacts the number of detected shapes, has a moderate impact on the size of the detected shapes and increases the running times. We plot the performance against the probability parameter, see \cgalFigureRef{Point_set_shape_detection_3_performace_probability}.

\cgalFigureBegin{Point_set_shape_detection_3_performace_epsilon,epsilon_graph.png}
The graph depicts the number of detected shapes (purple) and the coverage (green), i.e., the ratio assignedPoints / totalPoints, depending on epsilon parameter. A higher value for epsilon, i.e., a more tolerant error, leads to fewer but larger shapes and shorter running times.
\cgalFigureEnd

\cgalFigureBegin{Point_set_shape_detection_3_performace_probability,prob_graph.png}
The graph displays as the same characteristic numbers depending on the chosen search rigorisity, i.e. probability to miss the largest primitive in an iteration. The number of shapes is stable, while the coverage increases, when the probability is lowered. However the running time increases significantly as a lot more candidates are generated during each iteration of the method.
\cgalFigureEnd

*/ 
} /* namespace CGAL */

