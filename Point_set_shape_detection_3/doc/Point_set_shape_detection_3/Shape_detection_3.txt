namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_Point_Set_Shape_Detection
\cgalAutoToc

\authors Sven Oesau, Yannick Verdie, Cl√©ment Jamin

\section Point_set_shape_detection_3Introduction Introduction

This \cgal component implements the efficient RANSAC method for primitive shape detection contributed by Schnabel et al. in 2007 \cite cgal:-erpcsd-07. From an unstructured point set with unoriented normals the algorithm detects a set of primitive shapes (see \cgalFigureRef{Point_set_shape_detection_3_overview}). The supported shapes are plane, sphere, cylinder, cone and torus.

\cgalFigureBegin{Point_set_shape_detection_3_overview,overview2.png}
Left: Input point set. Right: Points colored by detected primitive. 
\cgalFigureEnd

\section Point_set_shape_detection_3Method Method
The method takes as input a point set with unoriented normals and provides as output a set of primitive shapes covering all or part of the input points. The shapes are detected via a RANSAC-type approach, i.e., a random sample consensus. The basic RANSAC approach repeats the following steps: (1) Randomly select a subset of the input points. (2) Fit a shape to the selected subset. (3) Count the number of inliers to the shape, i.e., the points within a user-specified error tolerance to the shape. Steps 1-3 are repeated for a prescribed number of iterations and the shape with highest number of inliers, referred to as largest shape, is kept. 

In our context the error between a point and a shape is defined by its distance and normal deviation to the shape. A random subset corresponds to the minimal number of points (with normals) required to uniquely define a primitive.

For very large point sets however the basic RANSAC method is not practical when testing all possible shape candidates against the input data in order to find the largest shapes. The main idea behind the efficient RANSAC consists of testing shape candidates only against subsets of the input data. Only a subset of all possible shape candidates is constructed until the probability to miss the largest candidate is lower than a user-specified parameter. The largest shape is repeatedly extracted until no more shapes, restricted to cover a minimum number of points, can be extracted. An additional gain in efficiency is achieved through exploiting the normal attributes during initial shape construction and inlier enumeration.

The support of a shape refers to the footprint of the points covered by the primitive. To avoid generating shapes with fragmented support we impose a connectivity constraint by considering only one connected component selected as the one covering the largest number of inliers.

The output of the shape detection algorithm is a set of shapes with associated points, and all remaining points not covered by shapes. Each input point can be assigned to at most one shape. 

\section Point_set_shape_detection_3Parameters Parameters
The algorithm requires five parameters:
- \f$epsilon\f$ and \f$normal deviation\f$:
The error between a point-with-normal and a shape is defined by its Euclidean distance and normal deviation to the shape. The normal deviation is computed between the normal at the point and the normal to the shape at the closest projection onto the primitive. 

Parameter epsilon defines the maximum tolerance Euclidean distance between a point and a shape. A high value for epsilon leads to the detection of fewer large shapes and hence a less detailed detection. A low value for epsilon yields a more detailed detection, but may lead to either oversegmentation when all input points are sampled on primitive shapes, or lower coverage. The impact of this parameter is depicted by Figure \cgalFigureRef{Point_set_shape_detection_3_parameter_epsilon_variation}. Its impact on performance is evaluated in Section \ref Point_set_shape_detection_3Performance.
\cgalFigureBegin{Point_set_shape_detection_3_parameter_epsilon_variation,epsilon_variation.png}
We depict the impact of epsilon on the level of details of the detection. The input point set is sampled from the mesh shown left. Middle left: detection of planar shapes with epsilon set to 2.0 (one color per detected shape). Most details such as chimneys on the roof are not separated. Middle right:  detection with epsilon set to 0.5. The facades are correctly detected and some details of the roof are detected. Right: setting epsilon to 0.25 yields a more detailed but slightly oversegmented detection.
\cgalFigureEnd

- \f$cluster_epsilon\f$:
The clustering of supporting points of a shape is controlled by a user-specified parameter, cluster_epsilon. The supporting points are transformed into a 2D parameter space of the shape. The parameter space is chosen to minimize distortion and to preserve arc-length as well as possible. A connected component search is performed in the discretized 2D parameter space to identify the largest cluster of supporting points. The cluster_epsilon specifies the discretization of the parameter space. Thus the cluster_epsilon corresponds to the Euclidean distance between points to consider them to be connected. Due to the layout of the discretization points up to a distance of \f$2\sqrt{2}\, cluster\_epsilon\f$ can still be considered connected. The impact of the choice of cluster_epsilon is depicted in fig. 
\cgalFigureRef{Point_set_shape_detection_3_parameter_connectivity}. 
\cgalFigureBegin{Point_set_shape_detection_3_parameter_connectivity,varying_connectivity.png}
The cluster_epsilon parameter impacts the connectivity of points on a shape. The synthetic data set consists of points sampled on four coplanar squares. A large cluster_epsilon leads to the extraction of all points as one shape (left). Choosing a cluster_epsilon such that the four squares get extracted separately leads also to the loss of a few points within each square due to the random sampling (mid). A small value of cluster_epsilon leads to an oversegmentation (right).
\cgalFigureEnd

- \f$search thoroughness\f$:
The search endurance is controlled by a parameter that specifies the probability to miss the largest candidate. A lower probability provides a higher reliability and determinism at the cost of longer running times.

- \f$minimum number of points\f$:
The minimum number of points for a shape is specified by the user to control the termination of the method. A shape candidate is dropped after evaluation on a subset of the input data, if the estimated support for the whole input data does not meet the specified minimum with a certain probability. However, if the final number of supporting points is only determined during extraction, even smaller shapes will get extracted.

\section Point_set_shape_detection_3Usage Usage
The main class `Shape_detection_3` takes a template parameter `Shape_detection_traits_3` where the geometric types and the input format is specified. The concept of property maps is used, as this is provides flexibility to use own data structures. The first parameter of the `Shape_detection_traits_3` class is the commonly used Kernel. For the use of property maps, an iterator type and two maps to map that iterator to a point and a normal are specified in the `Shape_detection_traits_3` class. The property maps concept is explained in detail in Chapter \ref chapterProperty_map.

Typical usage consists of four steps:

-# Provide input data via a range iterator
-# Register shape factories
-# Choose parameters 
-# Detect
-# Retrieve detected shapes

\subsection Point_set_shape_detection_3Usage_minimal Basic example

The following minimalistic example reads a point set from a file and detects only planes. The default parameters are used for detection.

\cgalExample{shape_detection_3_basic.cpp}

\subsection Point_set_shape_detection_3Usage_parameters Manual parameterization and different shape types

This example shows the user selection of parameters using the `Shape_detection::Parameters` struct. The detection has been extended to all shape types. A basic output of the detected shapes is provided after processing. The input point set is sampled on a surface mostly composed of piece-wise planar and cylindrical parts, in addition to free-form parts.

\cgalExample{shape_detection_3_parameters.cpp}

\subsection Point_set_shape_detection_3Usage_point_access Measuring mean error

This example shows how to access the points assigned to a shape. In addition, a timer measures the running performance of the method.

\cgalExample{shape_detection_3_point_access.cpp}


\section Point_set_shape_detection_3Performance Performance
 
The running time and detection performance depend on the chosen parameters. Selective error tolerance parameters lead to higher running times. It leads to smaller shapes as many shape candidates are generated to find the largest shape. We plot the detection performance against the epsilon error tolerance parameter for detecting planes in a complex scene with 5M points, see\cgalFigureRef{Point_set_shape_detection_3_performace_epsilon}. The probability parameter controls the endurance when searching for the largest candidate at each iteration. It barely impacts the number of detected shapes, has a moderate impact on the size of the detected shapes and increases the running times. We plot the performance against the probability parameter, see \cgalFigureRef{Point_set_shape_detection_3_performace_probability}.

\cgalFigureBegin{Point_set_shape_detection_3_performace_epsilon,epsilon_graph.png}
The graph depicts the number of detected shapes (purple) and the coverage (green), i.e., the ratio assignedPoints / totalPoints, depending on epsilon parameter. A higher value for epsilon, i.e., a more tolerant error, leads to fewer but larger shapes and shorter running times.
\cgalFigureEnd

\cgalFigureBegin{Point_set_shape_detection_3_performace_probability,prob_graph.png}
The graph displays as the same characteristic numbers depending on the chosen search rigorisity, i.e. probability to miss the largest primitive in an iteration. The number of shapes is stable, while the coverage increases, when the probability is lowered. However the running time increases significantly as a lot more candidates are generated during each iteration of the method.
\cgalFigureEnd

*/ 
} /* namespace CGAL */

