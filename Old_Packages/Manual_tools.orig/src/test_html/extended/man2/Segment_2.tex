% $Id$

\begin{ccClassTemplate} {CGAL_Segment_2<R>}
\ccSection{2D Segment A}

\ccDefinition  An object $s$ of the data type \ccClassName\ is a directed
straight line segment in the two-dimensional plane $\E_2$, i.e.\ a
straight line segment $[p,q]$ connecting two points $p,q$ 
\ccTexHtml{$\in$}{in}
$\R^2$. The segment is topologically closed, i.e.\  the end
points belong to it. Point $p$ is called the {\em source} and $q$
is called the {\em target} of $s$. The length of $s$ is the
Euclidean distance between $p$ and $q$. Note that there is only a function
to compute the square of the length, because otherwise we had to
perform a square root operation which is not defined for all
number types, which is expensive and not exact.

\ccCreation
\ccCreationVariable{s}

\ccInclude{CGAL/Segment_2.h}

\ccHidden \ccConstructor{CGAL_Segment_2();}
             {introduces an uninitialized variable \ccVar.}

\ccHidden \ccConstructor{CGAL_Segment_2(const CGAL_Segment_2<R> &q);}
            {copy constructor.}

\ccConstructor{CGAL_Segment_2(const CGAL_Point_2<R> &p, const CGAL_Point_2<R> &q);}
            {introduces a segment \ccVar\ with source $p$
             and target $q$. The segment is directed from the source towards
             the target.}


\ccOperations
\ccSetTwoOfThreeColumns{5cm}{4cm}

\ccHidden \ccMethod{CGAL_Segment_2<R> & operator=(const CGAL_Segment_2<R> &q);}
        {Assignment.}

\ccMethod{bool operator==(const CGAL_Segment_2<R> &q) const;}
       {Test for equality: Two segments are equal, iff their sources and
        targets are equal.}

\ccMethod{bool operator!=(const CGAL_Segment_2<R> &q) const;}
       {Test for inequality.}


\ccMethod{CGAL_Point_2<R> source() const;}
       {returns the source of \ccVar.}

\ccMethod{CGAL_Point_2<R> target() const;}
       {returns the target of \ccVar.}

\ccMethod{CGAL_Point_2<R> min() const;}
       {returns the point of \ccVar\ with lexicographically smallest coordinate.}

\ccMethod{CGAL_Point_2<R> max() const;}
       {returns the point of \ccVar\ with lexicographically largest coordinate.}


\ccMethod{CGAL_Point_2<R> vertex(int i) const;}
       {returns source or target   of \ccVar:   \ccStyle{vertex(0)} returns
        the source of \ccVar, \ccStyle{vertex(1)} returns the target of \ccVar. 
        The parameter \ccStyle{i} is taken modulo 2, which gives 
        easy access to the other vertex. }

\ccMethod{CGAL_Point_2<R> point(int i) const;}
        {returns \ccStyle{vertex(i)}.}

\ccMethod{CGAL_Point_2<R> operator[](int i) const;}
       {returns \ccStyle{vertex(i)}.}

\ccMethod{R::FT squared_length() const;}
       {returns the squared length of \ccVar. }

\ccMethod{CGAL_Direction_2<R> direction() const;}
       {returns the direction from source to target of \ccVar.}


\ccMethod{CGAL_Segment_2<R> opposite() const; }
       {returns a segment with source and target point interchanged.}

\ccMethod{CGAL_Line_2<R> supporting_line() const;}
       {returns the line $l$ passing through \ccVar. Line $l$  has the
same orientation as segment \ccVar.}

\ccMethod{bool is_degenerate() const;}
       {segment \ccVar\ is degenerate, if source and target are equal.}

\ccMethod{bool is_horizontal() const;}
       {}

\ccMethod{bool is_vertical() const;}
       {}

\ccMethod{bool has_on(const CGAL_Point_2<R> &p) const;}
       {A point is on \ccVar, iff it is equal to the source or target 
        of \ccVar, or if it is in the interior of \ccVar.}

\ccMethod{bool collinear_has_on(const CGAL_Point_2<R> &p) const;}
       {checks if point $p$ is on segment~\ccVar. This function is faster
        than function \ccStyle{has_on()}.
        \ccPrecond $p$ is on the supporting line of \ccVar.}

\ccMethod{CGAL_Bbox_2 bbox() const;}
       {returns a bounding box containing~\ccVar.}

\ccMethod{CGAL_Segment_2<R>  transform(const CGAL_Aff_transformation_2<R> &t) const;}
       {returns the segment obtained by applying $t$ on the source
        and the target of \ccVar.}

\ccImplementation
A segment is internally represented by two points. 


\end{ccClassTemplate} 

% $Log$
% Revision 1.1  2001/08/27 18:00:36  spion
% Initial revision
%
% Revision 1.3  1996/07/08 12:19:15  fabri
% *** empty log message ***
%
% Revision 1.2  1996/03/13 15:42:07  fabri
% *** empty log message ***
%
% Revision 1.1  1995/10/19 18:22:12  fabri
% Initial revision
%
