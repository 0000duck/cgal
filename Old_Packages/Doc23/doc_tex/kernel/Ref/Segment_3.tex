\begin{ccRefClass} {Segment_3<R>}


\ccDefinition  An object $s$ of the data type \ccRefName\ is a directed
straight line segment in the three-dimensional Euclidean space $\E^3$, i.e.\ a
straight line segment $[p,q]$ connecting two points $p,q \in
\R^3$. The segment is topologically closed, i.e.\  the end
points belong to it. Point $p$ is called the {\em source} and $q$
is called the {\em target} of $s$. The length of $s$ is the
Euclidean distance between $p$ and $q$. Note that there is only a function
to compute the square of the length, because otherwise we had to
perform a square root operation which is not defined for all
number types, is expensive, and may not be exact.

\ccCreation
\ccCreationVariable{s}


\ccHidden \ccConstructor{Segment_3();}
             {introduces an uninitialized variable \ccVar.}

\ccHidden \ccConstructor{Segment_3(const Segment_3<R> &q);}
 	    {copy constructor.}

\ccConstructor{Segment_3(const Point_3<R> &p, const Point_3<R> &q);}
            {introduces a segment \ccVar\ with source $p$
             and target $q$. It is directed from the source towards
             the target.}


\ccOperations
%\ccSetTwoOfThreeColumns{5cm}{4cm}

\ccHidden \ccMethod{Segment_3<R> & operator=(const Segment_3<R> &q);}
        {Assignment.}

\ccMethod{bool operator==(const Segment_3<R> &q) const;}
       {Test for equality: Two segments are equal, iff their sources and
        targets are equal.}

\ccMethod{bool operator!=(const Segment_3<R> &q) const;}
       {Test for inequality.}

\ccMethod{Point_3<R> source() const;}
       {returns the source  of \ccVar.}
\ccGlue
\ccMethod{Point_3<R> target() const;}
       {returns the target of \ccVar.}

\ccMethod{Point_3<R> min() const;}
       {returns the point of \ccVar\ with smallest coordinate (lexicographically).}

\ccMethod{Point_3<R> max() const;}
       {returns the point of \ccVar\ with largest coordinate (lexicographically).}

\ccMethod{Point_3<R> vertex(int i) const;}
       {returns source or target of \ccVar:   \ccStyle{vertex(0)} returns
        the source, \ccStyle{vertex(1)} returns the target. 
        The parameter \ccStyle{i} is taken modulo 2, which gives 
        easy access to the other vertex.}

\ccMethod{Point_3<R> point(int i) const;}
       {returns \ccStyle{vertex(i)}.}
\ccGlue
\ccMethod{Point_3<R> operator[](int i) const;}
       {returns \ccStyle{vertex(i)}.}

\ccMethod{R::FT squared_length() const;}
       {returns the squared length of \ccVar. }

\ccMethod{Direction_3<R> direction() const;}
       {returns the direction from source to target.}


\ccMethod{Segment_3<R> opposite() const; }
       {returns a segment with source and target interchanged.}

\ccMethod{Line_3<R> supporting_line() const;}
       {returns the line $l$ passing through \ccVar. Line $l$  has the
        same orientation as segment \ccVar, that is 
        from the source to the target of \ccVar.}

\ccMethod{bool is_degenerate() const;}
       {segment \ccVar\ is degenerate, if source and target fall together.}


\ccMethod{bool has_on(const Point_3<R> &p) const;}
       {A point is on \ccVar, iff it is equal to the source or target
        of \ccVar, or if it is in the interior of \ccVar.}
% 
% \ccMethod{bool collinear_has_on(const Point_3<R> &p) const;}
%        {checks if point $p$ is on segment~\ccVar. This function is faster
%         than function \ccStyle{has_on()}.
%         \ccPrecond $p$ is collinear to \ccVar.}
% 
\ccMethod{Bbox_3 bbox() const;}
       {returns a bounding box containing~\ccVar.}

\ccMethod{Segment_3<R>  transform(const Aff_transformation_3<R> &t) const;}
       {returns the segment obtained by applying $t$ on the source
        and the target of \ccVar.}

\ccSeeAlso
\ccRefConceptPage{Kernel::Segment_3}\\

\end{ccRefClass} 
