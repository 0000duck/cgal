\begin{ccRefClass}{Aff_transformation_3<R>}

\ccDefinition
The class \ccRefName\ represents three-dimensioanl affine transformations. 
The general form of an affine transformation is based on homogeneous
representation of points. Thereby all transformations can be realized by
matrix multiplication. 

Since the general form is based on the homogeneous representation, a
transformation matrix multiplication by a scalar does not change
the represented transformation. Therefore, any transformation represented
by a matrix with rational entries can be represented by a 
transformation matrix with integer entries as well by multiplying
the matrix with the common denominator of the rational entries. 
Hence it is sufficient to have number type \ccStyle{R::RT} for the entries 
of an affine transformation.

{\cgal} offers several specialized affine transformations. 
Different constructors are provided to create them. 
They are parameterized with a symbolic name to
denote the transformation type, followed by additional parameters.
The symbolic name tags solve ambiguities in the function
overloading and they make the code more readable, i.e.\ what type
of transformation is created.

In three-dimensional space we have a $4\times 4$ matrix ($m_{ij}$).
Entries $m_{30}$, $m_{31}$, and $m_{32}$ are always zero and 
therefore do not appear in the constructors.

\ccCreation
\ccCreationVariable{t}

\ccConstructor{Aff_transformation_3(const Identity_transformation& );}
            {introduces an identity transformation.}


\ccConstructor{Aff_transformation_3(const Translation,
                                    const Vector_3<R> &v);}
            {introduces a translation by a vector $v$.}
 
\ccConstructor{Aff_transformation_3(const Scaling,
                                    const R::RT &s,
                                    const R::RT &hw = RT(1));}
            {introduces a scaling by a scale factor $s/hw$.}

\newsavebox{\arrthree}
\newsavebox{\arrlinthree}
\newsavebox{\transvecthree}

\savebox{\arrthree}{\small $\left(\begin{array}{cccc}
                 m_{00} & m_{01} & m_{02} & m_{03}\\
                 m_{10} & m_{11} & m_{12} & m_{13}\\
                 m_{20} & m_{21} & m_{22} & m_{23}\\
                  0     &  0     &      0 & hw
              \end{array}\right)$}

\savebox{\arrlinthree}{\small $\left(\begin{array}{ccc}
                 m_{00} & m_{01} & m_{02}\\
                 m_{10} & m_{11} & m_{12}\\
                 m_{20} & m_{21} & m_{22}\\
              \end{array}\right)$}

\savebox{\transvecthree}{\small $\left(\begin{array}{c}
                 m_{03}\\
                 m_{13}\\
                 m_{23}
              \end{array}\right)$}

\ccConstructor{Aff_transformation_3(
    const R::RT &m00, const R::RT &m01, const R::RT &m02, const R::RT &m03,
    const R::RT &m10, const R::RT &m11, const R::RT &m12, const R::RT &m13,
    const R::RT &m20, const R::RT &m21, const R::RT &m22, const R::RT &m23,
                const R::RT &hw = RT(1));}
            {introduces a general affine transformation of the matrix
             form \ccTexHtml{\usebox{\arrthree}.}{<IMG ALIGN=CENTER 
             SRC=arrthree.gif> .} The part \ccTexHtml{$1\over hw$
             \usebox{\arrlinthree}}{<MATH><i>hw</i><SUP>-1</SUP></MATH> 
             <IMG ALIGN=CENTER SRC=arrlinthree.gif>}
             defines the scaling and rotational part of the transformation, 
             while the vector \ccTexHtml{$1\over hw$\usebox{\transvecthree}}%
             {<MATH><i>hw</i><SUP>-1</SUP></MATH> <IMG ALIGN=CENTER 
             SRC=transvecthree.gif>} contains the translational part.}

\savebox{\arrthree}{\small $\left(\begin{array}{cccc}
                 m_{00} & m_{01} & m_{02} & 0\\
                 m_{10} & m_{11} & m_{12} & 0\\
                 m_{20} & m_{21} & m_{22} & 0\\
                  0     &  0     &  0     &hw
              \end{array}\right)$}

\ccConstructor{Aff_transformation_3(
                        const R::RT &m00, const R::RT &m01, const R::RT& m02,
                        const R::RT &m10, const R::RT &m11, const R::RT& m12,
                        const R::RT &m20, const R::RT &m21, const R::RT& m22,
                                                      const R::RT &hw = RT(1));}
            {introduces a general linear transformation of the 
             matrix form \ccTexHtml{\usebox{\arrthree},}{<IMG ALIGN=CENTER 
             SRC=arrthree2.gif> ,} i.e.\ an affine transformation without 
             translational part.}


\ccOperations

Each class \ccStyle{Class_3<R>} representing
a geometric object in 3D has a member function:

\ccStyle{Class_3<R>  transform(Aff_transformation_3<R> t)}.


The transformation classes provide a member function \ccStyle{transform()}
for points, vectors, directions, and planes:

\ccMethod{Point_3<R>  transform(const Point_3<R> &p) const;}
       {}
\ccGlue
\ccMethod{Vector_3<R>  transform(const Vector_3<R> &p) const;}
       {}
\ccGlue
\ccMethod{Direction_3<R>  transform(const Direction_3<R> &p) const;}
       {}
\ccGlue
\ccMethod{Plane_3<R>  transform(const Plane_3<R> &p) const;}
       {}

\cgal\ provides four function operators for these member functions:

\ccMethod{Point_3<R>  operator()(const Point_3<R> &p) const;}
       {}
\ccGlue
\ccMethod{Vector_3<R>  operator()(const Vector_3<R> &p) const;}
       {}
\ccGlue
\ccMethod{Direction_3<R>  operator()(const Direction_3<R> &p) const;}
       {}
\ccGlue
\ccMethod{Plane_3<R>  operator()(const Plane_3<R> &p) const;}
       {}


\ccMethod{Aff_transformation_3<R> 
          operator*(const Aff_transformation_3<R> &s) const;}
       {composes two affine transformations.}

\ccMethod{Aff_transformation_3<R>  inverse() const;}
       {gives the inverse transformation.}

%\ccMethod{Aff_transformation_3<R>  transpose() const;}
%       {returns the affine transformation defined by transposing
%       the linear transformation in \ccVar\ and setting the
%       translational part to zero.}

\ccMethod{bool                 is_even() const;}
       {returns \ccStyle{true}, if the transformation is not reflecting,
        i.e.\ the determinant of the involved linear transformation is
        non-negative.}

\ccMethod{bool                 is_odd() const;}
       {returns \ccStyle{true}, if the transformation is reflecting.}


%\ccMethod{Aff_transformation_3<R>  general_form() const;}
%       {returns the affine transformation in matrix form.}

The matrix entries of a matrix representation of a \ccStyle{Aff_transformation_3<R>}
can be accessed trough the following member functions:

\ccMethod{FT          cartesian(int i, int j) const;}
                      {}
\ccGlue
\ccMethod{FT          m(int i, int j) const;}
       {returns entry $m_{ij}$ in a matrix representation in which $m_{33}$ is 1.}

\ccMethod{RT          homogeneous(int i, int j) const;}
                      {}
\ccGlue
\ccMethod{RT          hm(int i, int j) const;}
       {returns entry $m_{ij}$ in some fixed matrix representation.} 

For affine transformations  no I/O operators are defined.

\ccSeeAlso
\ccc{Identity_transformation}, 
\ccc{Scaling},
\ccc{Translation}


\end{ccRefClass} 
