\begin{ccRefClass} {Weighted_point_2<R, Weight>}

\ccDefinition
An object of the class \ccRefName\ is a point in the two-dimensional
Euclidean plane $\E^2$ with an associated weight (and thus can also
be viewed as a circle with the point as center point and the weight
as squared radius).  The default type of \ccc{Weight} is \ccc{R::RT}, the
field type of the defining kernel.

\ccInheritsFrom
\ccc{R::Point_2}

\ccTypes

\ccNestedType{R}{the kernel in which the point lies}
\ccNestedType{Weight}{the type of the weight associated with this point}

\ccCreation
\ccCreationVariable{p}

\ccHidden \ccConstructor{Weighted_point_2();}
             {introduces an uninitialized variable \ccVar.}

\ccHidden \ccConstructor{Weighted_point_2(const Weighted_point_2<R> &q);}
 	    {copy constructor.}

\ccConstructor{Weighted_point_2(const Origin &ORIGIN, const Weight& w = 0);}
            {introduces a variable \ccVar\ with \ccHtmlNoLinksFrom{Cartesian} 
             coordinates $(0,0)$ and weight \ccc{w}.}

\ccConstructor{Weighted_point_2(const R::RT &hx, const R::RT &hy, 
                                const R::RT &hw = R::RT(1), 
                                const Weight w = 0);}
            {introduces a point \ccVar\ initialized to $(hx/hw,hy/hw)$ with 
             weight \ccc{w}.
	     \ccPrecond \ccc{hw} $\neq$ \ccc{R::RT(0)} }

\ccConstructor{Weighted_point_2(const Point_2<R> &p, const Weight& w = 0);}
            {introduces a variable \ccVar\ with \ccHtmlNoLinksFrom{Cartesian} 
             coordinates \ccc{(p.x(),p.y())} and weight \ccc{w}.}


\ccOperations
%\ccSetTwoOfThreeColumns{5cm}{4cm}

\ccHidden 
\ccMethod{Weighted_point_2<R> & operator=(const Weighted_point_2<R> &q);}
        {Assignment.}

\ccMethod{bool operator==(const Weighted_point_2<R> &q) const;}
       {Test for equality. Two points are equal, iff their $x$ and $y$ 
        coordinates are equal and their weights are equal.}

\ccMethod{bool operator!=(const Weighted_point_2<R> &q) const;}
       {Test for inequality.}

There are two sets of coordinate access functions, namely to the
homogeneous and to the \ccHtmlNoLinksFrom{Cartesian} coordinates. They can be used
independently from the chosen representation type \ccStyle{R}.

\ccMethod{R::RT hx() const;}
       {returns the homogeneous $x$ coordinate.}
\ccGlue
\ccMethod{R::RT hy() const;}
       {returns the homogeneous $y$ coordinate.}
\ccGlue
\ccMethod{R::RT hw() const;}
       {returns the homogenizing  coordinate.}

Here come the \ccHtmlNoLinksFrom{Cartesian} access functions. Note that you do 
not lose information with the homogeneous representation, because then the field
type is a quotient.

\ccMethod{R::FT x() const;}
    {returns the \ccHtmlNoLinksFrom{Cartesian} $x$ coordinate, that is $hx/hw$.}
\ccGlue
\ccMethod{R::FT y() const;}
    {returns the \ccHtmlNoLinksFrom{Cartesian} $y$ coordinate, that is $hy/hw$.}


The following operations are for convenience and for making this
point class compatible with code for higher dimensional points.
Again they come in a \ccHtmlNoLinksFrom{Cartesian} and homogeneous flavor.

\ccMethod{R::RT homogeneous(int i) const;}
       {returns the i'th homogeneous coordinate of \ccVar, starting with 0.
        \ccPrecond $0\leq i \leq 2$.}

\ccMethod{R::FT cartesian(int i) const;}
       {returns the i'th \ccHtmlNoLinksFrom{Cartesian} coordinate of \ccVar, 
        starting with 0.
        \ccPrecond $0\leq i \leq 1$.}

\ccMethod{R::FT operator[](int i) const;}
       {returns \ccStyle{cartesian(i)}.
        \ccPrecond $0\leq i \leq 1$.}

\ccMethod{int dimension() const;}
       {returns the dimension (the constant 2).}

\ccMethod{Bbox_2 bbox() const;}
       {returns a bounding box containing \ccVar.}

\ccMethod{Weighted_point_2<R>  transform(const Aff_transformation_2<R> &t) const;}
       {returns the point obtained by applying $t$ on \ccVar.}

Here are the access functions for the components of the weighted point.

\ccMethod{Weight weight() const;}
       {returns the weight associated with the point.}
\ccGlue
\ccMethod{Point_2<R> point() const;}
       {returns the unweighted point.}



\ccHeading{Operators}

The following operations can be applied on points:


\ccFunction{Weighted_point_2<R> operator+(const Weighted_point_2<R> &p,
                                 const Vector_2<R> &v);}
       {returns the point obtained by translating \ccStyle{p} by the 
        vector \ccStyle{v}.}

\ccFunction{Weighted_point_2<R> operator-(const Weighted_point_2<R> &p,
                                 const Vector_2<R> &v);}
       {returns the point obtained by translating \ccStyle{p} by the 
        vector -\ccStyle{v}.}

\ccExample

The following declaration creates two points with \ccHtmlNoLinksFrom{Cartesian} double coordinates.

\begin{cprog}

  CGAL::Weighted_point_2< CGAL::Cartesian<double> > p(1.0, 2.0), q(1.0, 2.0, 2.0), r;
\end{cprog} 

The variable \texttt{p} is a point with \ccHtmlNoLinksFrom{Cartesian}
coordinates 1.0 and 2.0 and weight 0.0 while \texttt{q} has the same 
coordiantes but weight 2.5.
The variable {\tt r} is uninitialized and should first be used on 
the left hand side of an assignment. 

\ccSeeAlso
\ccRefIdfierPage{CGAL::Point_2<R>} \\
\ccRefIdfierPage{CGAL::Weighted_point_3<R>}

\end{ccRefClass} 
