\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::CompareX_3}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::HasOn_3}

\ccCreationVariable{fo}

An object \ccVar\ of this type must provide:

\ccMemberFunction{bool 
	operator()(const Type1 &obj1, const Type2 &obj2);}
{Returns \ccc{true} when \ccc{obj1} contains \ccc{obj2},}

where \ccc{Type_1} and \ccc{Type_2} can be respectively:

\begin{itemize}
\item {}
	\begin{itemize}
	\item {} \ccc{QuadricalKernel_3::Quadric_3},
	\item {} \ccc{QuadricalKernel_3::Curve_3},
	\item {} \ccc{QuadricalKernel_3::Curve_arc_3}
	\end{itemize} 
and \ccc{QuadricalKernel_3::Curve_point_3}
\item {} 
	\begin{itemize}
	\item {} \ccc{QuadricalKernel_3::Quadric_3} 
	\end{itemize}
and \ccc{QuadricalKernel_3::Curve_3}
\item {} or
	\begin{itemize}
	\item {} \ccc{QuadricalKernel_3::Quadric_3} or
	\item {} \ccc{QuadricalKernel_3::Curve_3}
	\end{itemize}
and \ccc{QuadricalKernel_3::Curve_arc_3}.
\end{itemize} 


\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::ConstructQuadric_3}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::ConstructCurve_3}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::ArcsOfCurve_3}

\end{ccRefFunctionObjectConcept}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{ccRefFunctionObjectConcept}{QuadricalKernel_3::Intersect_3}

\ccRefines

\ccc{Kernel::Intersect_3}

\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{template < class OutputIterator >
    OutputIterator
    operator()(const Type1 &obj1, const Type2 &obj2,
	OutputIterator intersections);}
{Copies in the output iterator the intersection elements between the
two objects. \ccc{intersections} iterates on
elements of type \ccc{CGAL::Object}, in lexicographic order
(where appropriate). See below for more precisions.}

%\ccMemberFunction{template < class OutputIterator >
%    OutputIterator
%    operator()(const Type1 &obj1, const Type2 &obj2,
%	const Type3 &obj3,
%	OutputIterator intersections);}
%{Copies in the output iterator the intersection elements between the
%two objects. \ccc{intersections} iterates on
%elements of type \ccc{CGAL::Object}, in lexicographic order 
%(where appropriate). See below for more precisions.}

For the \textbf{first operator}, \ccc{Type_1} and \ccc{Type_2} can both 
be either

\begin{itemize}
\item {} \ccc{QuadricalKernel_3::Quadric_3},
\item {} \ccc{QuadricalKernel_3::Curve_3},
\item {} \ccc{QuadricalKernel_3::Curve_arc_3},
\end{itemize} 

and depending on the types \ccc{Type_1} and \ccc{Type_2}, the computed 
\ccc{CGAL::Object}s be assigned to pairs of
\ccc{Quadric_3}, \ccc{Curve_3}, \ccc{Curve_arc_3}, or \ccc{Curve_point_3}
and {\tt unsigned int} where the first part describe
one object that both input objects have in common, and the second
value gives its multiplicity. Note that, e.g., two quadrics
can intersect in a third quadric that is not equal to one of the input
quadrics. An example are plane-pairs that have one plane in common.
Similar for curves and arcs.

\end{ccRefFunctionObjectConcept}
