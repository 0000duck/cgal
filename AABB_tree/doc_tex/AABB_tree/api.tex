% API
\section{Interface}
\label{AABB_tree_section_interface}

The main entry point to the component is the class \ccc{AABB_tree} which stores a static AABB tree constructed from an iterator range of primitives. Once instantiated an AABB tree can be queried for intersection and distance queries.


\paragraph{Intersections.} Considers for the example that the tree contains triangle primitives. The tree can be queried for intersection against line objects (rays, segments or line) in various ways. We distinguish intersection \emph{tests} which do not construct any intersection objects, from \emph{intersections} which construct the intersection objects. Furthermore, we distinguish the case of transversal intersections: an intersection of a line object with a triangle is said to be transversal if the line object does not intersect the vertices or the edges of the triangle, if the line object is not contained in the plane of the triangle, and if the vertices of the line object (if any) do not belong to the triangle. Assuming that the triangles define a closed surface, the number of transversal intersections is useful for determining if the source of a ray is inside or outside of the domain bounded by the surface.\\

Intersections tests:
\begin{itemize}
\item Function \ccc{do_intersect} only tests if the input primitives are intersected by the query. This function is fast as it only involves predicates and stops at the first encountered intersection.
\item Function \ccc{number_of_intersected_primitives} counts all intersected primitives.
%\item Function \ccc{number_of_transversal_intersections} counts all transversal intersections, and returns an error code if some intersections are not transversal.
\item Function \ccc{all_intersected_primitives} enumerates all intersected primitives without constructing the corresponding intersection objects.
\item Function \ccc{any_intersected_primitive} returns the first encoutered intersecting primitive (if any) without constructing the corresponding intersection object, and stops at the first encountered intersection.
\end{itemize}

Intersections:
\begin{itemize}
\item Function \ccc{all_intersections} detects and constructs all intersection objects with the input primitives.
\item Function \ccc{any_intersection} detects and constructs the first encountered intersecting primitive and constructs the corresponding object. This function is fast as it stops at the first encountered intersection.
\end{itemize}

\paragraph{Distance.} An AABB tree can compute the closest point from a given point query to the input primitives through the function \ccc{closest_point(query,hint)}. In addition, it can compute the closest primitive from a given point query through the functions \ccc{closest_point_and_primitive(query,hint)} and \ccc{closest_primitive(query,hint)}, i.e., the primitive which realizes the minimum distance from the point query. The latter function is a loose version of the former in the sense that it does not return the point on this primitive which is the closest. This is often sufficient in some applications to know which primitive is closer. 

The hint parameter, which can be omitted, provides a way to indicate a reasonnable first guess. Although this hint can be chosen arbitrarily, the closer from the query the faster. The hint has the same type as the return type. In case a point is provided as a hint (or a point and a primitive), the point should lie on some primitive. However, this is not always possible without an exact constructions kernel, if the hint is not a vertex. It may then happen that the hint is closer to the query than any of the primitives. In such a case, the hint is returned as the final result. 

In case the hint is omitted, the AABB tree has the option of computing one by using an internal KD-tree, which contains a point sampling of the primitives. This option increases performance considerably. This option is activated if, and only if the construction of the KD-tree has been requested by a call to one of the two \ccc{construct_search_tree} methods. Note that, by default, the method \ccc{reference_point} of the primitives is used to generate the point sampling. However, the user may prefer to provide the point sampling with \ccc{construct_search_tree(InputIterator begin,InputIterator beyond)} rather than relying on the default one with one point per primitive: if some triangles are very large, it may help to insert more than one sample on these large triangles, and if many triangles are agglutinated together, one sample for the whole cluster is enough.