% API
\section{Interface}
\label{AABB_tree_section_interface}

The main entry point to the component is the class \ccc{AABB_tree} which represents a static AABB tree constructed from an iterator range of geometric data. Once instantiated an AABB tree can be queried for intersection and distance queries.\\

\paragraph{Intersections.} Assume for example that the tree contains triangle primitives. The tree can be queried for intersection against line objects (rays, segments or line) in various ways. We distinguish intersection \emph{tests} which do not construct any intersection objects, from \emph{intersections} which construct the intersection objects.\\

Intersections tests:
\begin{itemize}
\item Function \ccc{do_intersect} tests if the input primitives are intersected by the query. This function is fast as it only involves predicates and stops after the first encountered intersection.
\item Function \ccc{number_of_intersected_primitives} counts all intersected primitives.
\item Function \ccc{all_intersected_primitives} enumerates all intersected primitives ids without constructing the corresponding intersection objects.
\item Function \ccc{any_intersected_primitive} returns the first encountered intersecting primitive id (if any) without constructing the corresponding intersection object, and stops after the first encountered intersection. The traversal order of the tree is such that first herein does not refer to any particular ordering of the intersections with respect to the query.
\end{itemize}

Intersections:
\begin{itemize}
\item Function \ccc{all_intersections} detects and constructs all intersection objects with the input primitives.
\item Function \ccc{any_intersection} detects and constructs the first encountered intersection and constructs the corresponding object. This function is fast as it stops after the first encountered intersection.
\end{itemize}

\paragraph{Distance.} An AABB tree computes the closest point from a given point query to the input primitives through the function \ccc{closest_point(query)}. In addition, it can compute the id of the closest primitive from a given point query through the function \ccc{closest_point_and_primitive(query)}, i.e., the id of the primitive which realizes the minimum distance from the point query.\\ %The hint parameter, which can be omitted, provides a way to indicate an initial first guess. Although this hint can be chosen arbitrarily, the closer from the query the faster. The hint has the same type as the return type. In case a point is provided as a hint (or a point and a primitive), the point must lie on some primitive. Note that this is not always possible without an exact constructions kernel, if the hint does not coincide with a vertex. In the case where the hint is closer to the query than any of the primitives, the hint is returned.\\

The AABB tree uses a secondary search structure to speed up the distance queries. Hence, the construction of this secondary structure should be requested by the user by a call to \ccc{accelerate_distance_queries} before the first the distance computation. This data structure is not generated by default, because it is used only for distance computations.

%In case the hint is omitted, the AABB tree provides the option to compute one closest hint point by using an internal KD-tree which contains a point sampling of the primitives. This option, which increases the performances sometimes by a substantial factor, is activated if, and only if the construction of the KD-tree has been requested by a call to one of the two \ccc{accelerate_distance_queries} methods. As a rule of thumb, the user should always activate this option except if a good hint can always be provided. If the user cannot guarantee the quality of the hints he provides, letting the AABB tree compute the hints with the KD-tree is usually more efficient.

%Note that, by default, the method \ccc{reference_point} of the primitives is used to generate the point sampling. However, the user can provide instead the point sampling through the method \ccc{accelerate_distance_queries(InputIterator begin, InputIterator beyond)}. For the case where the primitives are the faces of a triangle surface mesh the specified point sampling may be provided, e.g., as the vertex points of the mesh vertices. If some triangles are very large it helps inserting more than one sample on them. Conversely, a sparser sampling with less than one point per input primitive is relevant in some cases. 



% cimetery

% Furthermore, we distinguish the case of transversal intersections: an intersection of a line object with a triangle is said to be transversal if the line object does not intersect the vertices or the edges of the triangle, if the line object is not contained in the plane of the triangle, and if the vertices of the line object (if any) do not belong to the triangle. Assuming that the triangles define a closed surface, the number of transversal intersections is useful for determining if the source of a ray is inside or outside of the domain bounded by the surface.

%\item Function \ccc{number_of_transversal_intersections} counts all transversal intersections, and returns an error code if some intersections are not transversal.
