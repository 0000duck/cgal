% API
\section{Interface}
\label{AABB_tree_section_interface}

The main entry point to the component is the class \ccc{AABB_tree} which represents a static AABB tree constructed from an iterator range of geometric data. Once instantiated an AABB tree can be queried for intersection and distance queries.\\


\paragraph{Intersections.} Considers for the example that the tree contains triangle primitives. The tree can be queried for intersection against line objects (rays, segments or line) in various ways. We distinguish intersection \emph{tests} which do not construct any intersection objects, from \emph{intersections} which construct the intersection objects.\\

% Furthermore, we distinguish the case of transversal intersections: an intersection of a line object with a triangle is said to be transversal if the line object does not intersect the vertices or the edges of the triangle, if the line object is not contained in the plane of the triangle, and if the vertices of the line object (if any) do not belong to the triangle. Assuming that the triangles define a closed surface, the number of transversal intersections is useful for determining if the source of a ray is inside or outside of the domain bounded by the surface.

Intersections tests:
\begin{itemize}
\item Function \ccc{do_intersect} tests if the input primitives are intersected by the query. This function is fast as it only involves predicates and stops after the first encountered intersection.
\item Function \ccc{number_of_intersected_primitives} counts all intersected primitives.
%\item Function \ccc{number_of_transversal_intersections} counts all transversal intersections, and returns an error code if some intersections are not transversal.
\item Function \ccc{all_intersected_primitives} enumerates all intersected primitives ids without constructing the corresponding intersection objects.
\item Function \ccc{any_intersected_primitive} returns the first encountered intersecting primitive id (if any) without constructing the corresponding intersection object, and stops after the first encountered intersection.
\end{itemize}

Intersections:
\begin{itemize}
\item Function \ccc{all_intersections} detects and constructs all intersection objects with the input primitives.
\item Function \ccc{any_intersection} detects and constructs the first encountered intersection and constructs the corresponding object. This function is fast as it stops at the first encountered intersection.
\end{itemize}

\paragraph{Distance.} An AABB tree computes the closest point from a given point query to the input primitives through the function \ccc{closest_point(query,hint)}. In addition, it can compute the id of the closest primitive from a given point query through the functions \ccc{closest_point_and_primitive(query,hint)} and \ccc{closest_primitive(query,hint)}, i.e., the id of the primitive which realizes the minimum distance from the point query. The latter function is a loose version of the former in the sense that it does not return the point on this primitive which is the closest. This is often sufficient in some applications to know which primitive is closer. The hint parameter, which can be omitted, provides a way to indicate an initial first guess. Although this hint can be chosen arbitrarily, the closer from the query the faster. The hint has the same type as the return type. In case a point is provided as a hint (or a point and a primitive), the point must lie on some primitive. Note that this is not always possible without an exact constructions kernel, if the hint is not a vertex. It may then happen that the hint is closer to the query than any of the primitives. In such a case, the hint is returned.\\

In case the hint is omitted, the AABB tree provides the option to compute one closest hint point by using an internal KD-tree which contains a point sampling of the primitives. This option, which increases the performances is activated if, and only if the construction of the KD-tree has been requested by a call to one of the two \ccc{accelerate_distance_queries} methods. Note that, by default, the method \ccc{reference_point} of the primitives is used to generate the point sampling. However, the user may prefer to provide the point sampling with \ccc{accelerate_distance_queries(InputIterator begin, InputIterator beyond)} rather than relying on the default one which takes one reference point per primitive. If some triangles are very large, it helps inserting more than one sample on these large triangles. Conversely, a sparser sampling with less than one point per primitive is relevant in some cases. For the case where the primitives are the faces of a triangle surface mesh the specified point sampling may be provided as the vertex points of the mesh vertices.