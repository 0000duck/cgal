%%
%%  *** CGAL Installation Guide ***
%%
%% file:     appendix.tex
%%
%% authors:  Michael Hoffmann, Dima Pasechnik and Wieger Wesselink
%%
%% $Id$
%%


\section{Compiler Workarounds}
\index{compilers!workarounds}\index{workaround flags}

In \cgal, a number of compiler flags is defined. All of them start
with the prefix \texttt{CGAL\_CFG}. These flags are used to work
around compiler bugs and limitations. For example, the flag
\texttt{CGAL\_CFG\_NO\_LONG\_LONG} denotes that the compiler does not
know the type \texttt{long long}.

For each compiler a file \texttt{<CGAL/compiler\_config.h>}
\index{files!\texttt{compiler\_config.h}} is defined, with the correct
settings of all flags. This file is generated automatically by 
\cmake, and it is located in the \texttt{include} directory of
where you run \cmake. For an in-source configuration this means
\texttt{CGAL-3.4/include}.

The test programs used to generate the \texttt{compiler\_config.h}
file can be found in \texttt{config/testfiles}.
\index{directories!config/testfiles@\texttt{config/testfiles}} Both
\texttt{compiler\_config.h} and the test programs contain a short
description of the problem. In case of trouble with one of the
\texttt{CGAL\_CFG} flags, it is a good idea to take a look at it.

The file \texttt{CGAL/compiler\_config.h} is included from
\texttt{<CGAL/config.h>}.\index{files!\texttt{config.h}}
which is included by all \cgal\ header files.

\subsection{Standard Header Replacements}
\index{compilers!missing standard header files} %
\index{standard header replacements} %
\index{missing standard header files}

Some compilers do still not provide a complete standard library. In
particular they fail to provide the \texttt{C++} wrappers for files
from the standard \ccc{C} library, like \texttt{cstddef} for
\texttt{stddef.h}. The \cgal\ install scripts checks for all standard
header files and generates a simple wrapper file in the \cgal\ include
directory for those that are missing. These wrapper files include the
corresponding \texttt{C} header files and add all symbols required by
the \texttt{C++} standard into namespace \ccc{std}. You can turn off
the additions to namespace \ccc{std} by defining the macro
\ccc{CGAL_NO_STDC_NAMESPACE}.
\index{CGAL\_NO\_STDC\_NAMESPACE@\texttt{CGAL\_NO\_STDC\_NAMESPACE}}

\section{Compiler Optimizations\label{sec:compiler-optimisations}}
\index{compilers!optimization}
\index{optimization compiler flags}

By default \cmake\ generates makefiles for Release mode, with 
optimization flags switched on, and vcproj files for Release
and Debug mode.

\section{Troubleshooting\label{sec:troubleshooting}}
\index{troubleshooting}

This section contains some remarks about known problems and the
solutions we propose. If your problem is not listed here, please have
a look at the bug reporting instructions from the \cgal\ homepage:
\begin{alltt}
\cgalhomepage
\end{alltt}

\subsection{Compiler Version Test Execution Failed\label{sec:compvertestfails}}
\index{Compiler version test}\index{compilers!version test}

Possibly already during the startup of the configuration, the
execution of the compiler version test might fail with the following
(or similar) error message.
\begin{verbatim}
  ld.so.1: ./tmp_test: fatal: libstdc++.so.5: 
    open failed: No such file or directory
\end{verbatim}
This means that the standard \CC\ library for your compiler is
installed in a directory that is not on your current runtime linker
path. You can solve this problem by adding the directory containing
\texttt{libstdc++.so} to your runtime linker path, usually
represented by the environment variable \texttt{LD\_LIBRARY\_PATH}.

For example, if you have a standard \texttt{gcc} installation below
\texttt{/software/gcc-3.3.2/}, you would type 
\begin{alltt}
      export LD_LIBRARY_PATH=/software/gcc-3.3.2/lib:$LD_LIBRARY_PATH
\end{alltt}
for Bourne shell alikes, while for \texttt{csh} descendants the syntax
is
\begin{alltt}
      setenv LD_LIBRARY_PATH /software/gcc-3.3.2/lib:$LD_LIBRARY_PATH
\end{alltt}
You might want to add this command to your shell startup file.

Alternatively, you can build the runtime linker path into the
executables by setting corresponding custom linker flags (cf.
Section~\ref{sec:compiler-menu}).


\subsection{The ``Long-Name-Problem'' on Solaris\label{sec:longnamesolaris}}
\index{problems with long names}\index{long name problem}

The system assembler and linker on Solaris 2.5 and 2.6 cannot handle
symbols with more than 1024 characters. But this number is quickly
exceeded where one starts nesting templates into each other. So if you
encounter strange assembler or linker errors like 
\begin{alltt}
/usr/ccs/bin/as: "/var/tmp/cc0B5iGc.s", line 24: 
error: can't compute value of an expression involving an external symbol
\end{alltt}
there is a good chance that you suffer from this ``long-name''
problem.

A solution is to install the \gnu -binutils\footnote{see
  \path'http://www.gnu.org/software/binutils/'} and to tell the
compiler that it shall use the \gnu-- instead of the native tools.
From the compiler-menu (described in section \ref{sec:compiler-menu})
you can set the corresponding option through the custom compiler
flags, i.e. for \texttt{gcc} you would add
\begin{alltt}
  -B/my/path/to/gnu/binutils/bin
\end{alltt}
assuming you installed the \gnu -binutils executables in
\texttt{/my/path/to/gnu/binutils/bin}.

If you cannot (or do not want to) install \gnu -binutils, there is a
workaround that lets you compile, link and run your programs, but it
prevents debugging, since the executables have to be stripped. In
short the workaround is to compile with \texttt{-g} and to link with
\texttt{-z nodefs -s} on Solaris, \texttt{-U -s} on IRIX,
respectively.

In order to still have portable makefiles (see
section\ref{sec:makefiles}), we define flags
\texttt{LONG\_NAME\_PROBLEM\_CXXFLAGS} and
\texttt{LONG\_NAME\_PROBLEM\_LDFLAGS} in the include makefiles which
are empty except for the Solaris platform where they are set as stated
above. In order to use these flags, edit your application makefile and
add the flags to \texttt{CXXFLAGS} resp. \texttt{LDFLAGS} as indicated
below.
\begin{alltt}
#---------------------------------------------------------------------#
#                    compiler flags
#---------------------------------------------------------------------#
# The flag CGAL_CXXFLAGS contains the path to the compiler and is defined
# in the file CGAL_MAKEFILE. You may add your own compiler flags to CXXFLAGS.

CXXFLAGS = $(LONG_NAME_PROBLEM_CXXFLAGS) $(CGAL_CXXFLAGS) 

#---------------------------------------------------------------------#
#                    linker flags
#---------------------------------------------------------------------#
# The flag CGAL_LDFLAGS contains common linker flags and is defined
# in the file CGAL_MAKEFILE. You may add your own linker flags to CXXFLAGS.

LDFLAGS = $(LONG_NAME_PROBLEM_LDFLAGS) $(CGAL_LDFLAGS) 
\end{alltt}

\subsection{LEDA and STL Conflicts\label{subs:ledastlconfl}}

If you are using an old version of \leda, the combination of \leda\ 
and \stl\ may give some problems. In order to avoid them, it is highly
recommended to use the latest \leda\ release, since this is what we
test \cgal\ with.



\section{Scripts}

\subsection{\texttt{cgal\_create\_cmake_script\label{sec:create_cgal_cmake_script}}}
\TTindex{cgal\_create\_cmake\_script}\index{scripts!\texttt{cgal\_create\_cmake\_script}}

The Bourne-shell script \texttt{cgal\_create\_cmake\_script} is contained in the
\cgaldir\texttt{/scripts} directory. It can be used to create
\texttt{CmakeLists.txt} files for compiling \cgal\ applications. Executing
\texttt{cgal\_create\_cmake\_script} in an application directory creates a
\texttt{CMakeLists.txt} containing rules for every \texttt{*.cpp} file there.


%%
%% EOF
%%


