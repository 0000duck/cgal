%%
%%  *** CGAL Installation Guide ***
%%
%% file:     appendix.tex
%%
%% authors:  Michael Hoffmann, Dima Pasechnik and Wieger Wesselink
%%
%% $Id$
%%


\section{Compiler Workarounds}
\index{compilers!workarounds}\index{workaround flags}

In \cgal, a number of compiler flags is defined. All of them start
with the prefix \texttt{CGAL\_CFG}. These flags are used to work
around compiler bugs and limitations. For example, the flag
\texttt{CGAL\_CFG\_NO\_LONG\_LONG} denotes that the compiler does not
know the type \texttt{long long}.

For each compiler a file \texttt{<CGAL/compiler\_config.h>}
\index{files!\texttt{compiler\_config.h}} is defined, with the correct
settings of all flags. This file is generated automatically by 
\cmake, and it is located in the \texttt{include} directory of
where you run \cmake. For an in-source configuration this means
\texttt{CGAL-3.4/include}.

The test programs used to generate the \texttt{compiler\_config.h}
file can be found in \texttt{config/testfiles}.
\index{directories!config/testfiles@\texttt{config/testfiles}} Both
\texttt{compiler\_config.h} and the test programs contain a short
description of the problem. In case of trouble with one of the
\texttt{CGAL\_CFG} flags, it is a good idea to take a look at it.

The file \texttt{CGAL/compiler\_config.h} is included from
\texttt{<CGAL/config.h>}.\index{files!\texttt{config.h}}
which is included by all \cgal\ header files.

\subsection{Standard Header Replacements}
\index{compilers!missing standard header files} %
\index{standard header replacements} %
\index{missing standard header files}

Some compilers do still not provide a complete standard library. In
particular they fail to provide the \texttt{C++} wrappers for files
from the standard \ccc{C} library, like \texttt{cstddef} for
\texttt{stddef.h}. The \cgal\ install scripts checks for all standard
header files and generates a simple wrapper file in the \cgal\ include
directory for those that are missing. These wrapper files include the
corresponding \texttt{C} header files and add all symbols required by
the \texttt{C++} standard into namespace \ccc{std}. You can turn off
the additions to namespace \ccc{std} by defining the macro
\ccc{CGAL_NO_STDC_NAMESPACE}.
\index{CGAL\_NO\_STDC\_NAMESPACE@\texttt{CGAL\_NO\_STDC\_NAMESPACE}}

\section{Compiler Optimizations\label{sec:compiler-optimisations}}
\index{compilers!optimization}
\index{optimization compiler flags}

By default \cmake\ generates makefiles for Release mode, with 
optimization flags switched on, and vcproj files for Release
and Debug mode.

\section{Troubleshooting\label{sec:troubleshooting}}
\index{troubleshooting}

This section contains some remarks about known problems and the
solutions we propose. If your problem is not listed here, please have
a look at the bug reporting instructions from the \cgal\ homepage:
\begin{alltt}
\cgalhomepage
\end{alltt}

\subsection{Compiler Version Test Execution Failed\label{sec:compvertestfails}}
\index{Compiler version test}\index{compilers!version test}

Possibly already during the startup of the configuration, the
execution of the compiler version test might fail with the following
(or similar) error message.
\begin{verbatim}
  ld.so.1: ./tmp_test: fatal: libstdc++.so.5: 
    open failed: No such file or directory
\end{verbatim}
This means that the standard \CC\ library for your compiler is
installed in a directory that is not on your current runtime linker
path. You can solve this problem by adding the directory containing
\texttt{libstdc++.so} to your runtime linker path, usually
represented by the environment variable \texttt{LD\_LIBRARY\_PATH}.

For example, if you have a standard \texttt{gcc} installation below
\texttt{/software/gcc-3.3.2/}, you would type 
\begin{alltt}
      export LD_LIBRARY_PATH=/software/gcc-3.3.2/lib:$LD_LIBRARY_PATH
\end{alltt}
for Bourne shell alikes, while for \texttt{csh} descendants the syntax
is
\begin{alltt}
      setenv LD_LIBRARY_PATH /software/gcc-3.3.2/lib:$LD_LIBRARY_PATH
\end{alltt}
You might want to add this command to your shell startup file.

Alternatively, you can build the runtime linker path into the
executables by setting corresponding custom linker flags (cf.
Section~\ref{sec:compiler-menu}).

\subsection{LEDA and STL Conflicts\label{subs:ledastlconfl}}

If you are using an old version of \leda, the combination of \leda\ 
and \stl\ may give some problems. In order to avoid them, it is highly
recommended to use the latest \leda\ release, since this is what we
test \cgal\ with.



\section{Scripts}

\subsection{\texttt{cgal\_create\_cmake\_script\label{sec:create_cgal_cmake_script}}}
\TTindex{cgal\_create\_cmake\_script}\index{scripts!\texttt{cgal\_create\_cmake\_script}}

The Bourne-shell script \texttt{cgal\_create\_cmake\_script} is contained in the
\cgaldir\texttt{/scripts} directory. It can be used to create
\texttt{CmakeLists.txt} files for compiling \cgal\ applications. Executing
\texttt{cgal\_create\_cmake\_script} in an application directory creates a
\texttt{CMakeLists.txt} containing rules for every \texttt{*.cpp} file there.


%%
%% EOF
%%


