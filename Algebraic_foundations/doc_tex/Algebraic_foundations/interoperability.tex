\section{Interoperability}

This section introduces two concepts for interoperability of types, 
namely \ccc{ImplicitInteroperable} and \ccc{ExplicitInteroperable}. While 
\ccc{ExplicitInteroperable} is the base concept, we start with 
\ccc{ImplicitInteroperable} since it is the more intuitive one.

In general mixed operations are provided due to overloaded operators and
functions or just due to implicit constructor calls. 
This level of interoperability is reflected by the concept 
\ccc{ImplicitInteroperable}. But within template code the result type, 
or so called coercion type, of an mixed arithmetic operation may be unclear.
Therefore, the package introduces \ccc{CGAL::Coercion_traits}
giving access to the coercion type via \ccc{CGAL::Coercion_traits<A,B>::type}
for two interoperable types \ccc{A} and \ccc{B}. 

Examples for \ccc{ImplicitInteroperable} types are: \\
\begin{tabular}{|l|l|l|}
\hline
A&B&Coercion type\\
\hline
 \ccc{int}& \ccc{double} & \ccc{double} \\
  \ccc{leda_integer}& \ccc{leda_rational}& \ccc{leda_rational}\\
  \ccc{CORE::BigInt} & \ccc{CORE::BigRat} & \ccc{CORE::BigRat}\\
  \ccc{Gmpz}& \ccc{Gmpq}& \ccc{Gmpq}\\
\hline
\end{tabular}

But it is not required that the coercion type is one of the input 
types. A simple example is a  type representing a polynomial 
with integer coefficients that is multiplied by a rational.
The result should be a polynomial with rational coefficients.

\ccc{CGAL::Coercion_traits} is also
required to provide a functor \ccc{CGAL::Coercion_traits<A,B>::Cast()}, that 
converts from an input type into the coercion type. This is in fact the core
of the more basic concept \ccc{ExplicitInteroperable}. 
\ccc{ExplicitInteroperable} has been introduced to cover more complex cases 
for which it is hard or impossible to guarantee implicit interoperability.  
Note that this functor can be useful for \ccc{ImplicitInteroperable} types 
as well, since it can be used to void redundant type conversions.  


\ignore{
A frequent problem in generic programming is how to handle mixed operations
of two types. 
In most cases it is possible to rely on implicit interoperability 
of the involved types, which is in general achieved by implicit constructors
or operator and function overloads. This level of interoperability is 
reflected by the concept \ccc{ImplicitInteroperable}.
For template code, th
But in case of template code, the
result type, or so called coercion type, of an mixed operation can be unclear. 
For these cases the package provides the class 
\ccc{CGAL::Coercion_traits}, which gives access to the coercion type via
\ccc{CGAL::Coercion_traits<A,B>::type} for two \ccc{ImplicitInteroperable} 
types \ccc{A} and \ccc{B}.


The concept \ccc{ExplicitInteroperable} has been introduced for cases in 
which is not possible or very hard to provide implicit interoperability.
\ccc{ExplicitInteroperable} is more basic than \ccc{ImplicitInteroperable} 
and  just requires \ccc{Coercion_traits}  to provide a suitable coercion 
type and a functor \ccc{Coercion_traits<A,B>::Cast()} that converts each of 
the input types into the coercion type. 
}