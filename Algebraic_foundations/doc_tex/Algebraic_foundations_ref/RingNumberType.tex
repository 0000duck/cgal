\begin{ccRefConcept}{RingNumberType}

\ccDefinition

The concept \ccRefName\ defines the syntactic requirements a number type must
meet in order to be used in \cgal\ as a ring type.  This implies that
\ccc{CGAL::Number_type_traits<RingNumberType>::Has_division} is not required
to be \ccc{CGAL::Tag_true}. Unsigned numbers are excluded due to
semantical limitations in the ordering.

\ccRefines

CopyConstructible, Assignable 


\ccSetTwoColumns{}{\hspace*{8.5cm}}
\ccCreation
\ccCreationVariable{n1}

\ccConstructor{RingNumberType();}
            {Declaration of a variable.}

\ccConstructor{RingNumberType(int i);}
            {Declaration and initialization with a small integer
constant $i$, $0 \leq i \leq 127$. The neutral elements for addition
(zero) and multiplication (one) are needed quite often, but sometimes
other small constants are useful too. The value 127 was chosen such
that even signed 8 bit number types can fulfill this condition.}

\ccSetThreeColumns{RingNumberTypeXXX}{}{\hspace*{8.5cm}}
\ccOperations

The comparison operators need to be provided.

\ccFunction{bool operator==(const RingNumberType &n1,
                            const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator!=(const RingNumberType &n1,
                            const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator<(const RingNumberType &n1,
                           const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator>(const RingNumberType &n1,
                           const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator<=(const RingNumberType &n1,
                            const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator>=(const RingNumberType &n1,
                            const RingNumberType &n2);} {}

In addition, the comparisons with small values of type \ccc{int} are also
required.

\ccFunction{bool operator==(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator!=(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator<(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator>(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator<=(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator>=(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{bool operator==(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{bool operator!=(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{bool operator<(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{bool operator>(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{bool operator<=(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{bool operator>=(const RingNumberType &n1, int n2);} {}

The arithmetic operators for the addition, subtraction and multiplication
are required as well.

\ccFunction{RingNumberType operator+(const RingNumberType &n1,
                                     const RingNumberType &n2);} {}
\ccGlue
\ccFunction{RingNumberType operator-(const RingNumberType &n1,
                                     const RingNumberType &n2);} {}
\ccGlue
\ccFunction{RingNumberType operator*(const RingNumberType &n1,
                                     const RingNumberType &n2);} {}
\ccGlue
\ccFunction{RingNumberType operator-(const RingNumberType &n);} {}
\ccGlue
\ccMethod{RingNumberType operator+=(const RingNumberType &n2) const;} {}
\ccGlue
\ccMethod{RingNumberType operator-=(const RingNumberType &n2) const;} {}
\ccGlue
\ccMethod{RingNumberType operator*=(const RingNumberType &n2) const;} {}

And similarly, the mixed operators with small values of type \ccc{int} are also
required.

\ccFunction{RingNumberType operator+(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{RingNumberType operator-(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{RingNumberType operator*(int n1, const RingNumberType &n2);} {}
\ccGlue
\ccFunction{RingNumberType operator+(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{RingNumberType operator-(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccFunction{RingNumberType operator*(const RingNumberType &n1, int n2);} {}
\ccGlue
\ccMethod{RingNumberType operator+=(int n2) const;} {}
\ccGlue
\ccMethod{RingNumberType operator-=(int n2) const;} {}
\ccGlue
\ccMethod{RingNumberType operator*=(int n2) const;} {}

The following accessory functions are needed for special purposes :

\ccFunction{bool is_valid(const RingNumberType &n);}
{Not all values of a number type need be valid. The function
\ccStyle{is_valid} checks this. For example, an expression like
\ccStyle{NT(0)/NT(0)} can result in an invalid number. Routines may
have as a precondition that all numerical values are valid.}

\ccFunction{bool is_finite(const RingNumberType &n);}
{ When two large values are multiplied, the result may not fit in a
  \ccStyle{NT}. 
  Some number types (e.g. the standard \ccc{float} and \ccc{double} types)
  have a way to represent a too big value as infinity.
  \ccStyle{is_finite} implies \ccStyle{is_valid}.}

\ccFunction{double to_double(const RingNumberType &n);}
         {gives the double value for a number type.
          This is usually an approximation for the real (stored) value.
          It can be used to send numbers to a renderer or to store them 
          in a file.}

\ccFunction{std::pair<double,double> to_interval(const RingNumberType &n);}
         {gives a double interval that encloses \ccc{n}.}

\ccHasModels

\CC\ built-in number types \\
\ccc{CGAL::Gmpq} \\
\ccc{CGAL::Gmpz} \\
\ccc{CGAL::Interval_nt} \\
\ccc{CGAL::Interval_nt_advanced} \\
\ccc{CGAL::Lazy_exact_nt<RingNumberType>} \\
\ccc{CGAL::MP_Float} \\
\ccc{CGAL::Quotient<RingNumberType>} \\
\ccc{leda_integer} \\
\ccc{leda_rational} \\
\ccc{leda_bigfloat} \\
\ccc{leda_real} \\

\ccSeeAlso
\ccRefConceptPage{EuclideanRingNumberType} \\
\ccRefConceptPage{FieldNumberType} \\
\ccRefIdfierPage{CGAL::Ring_tag} \\

\end{ccRefConcept}
