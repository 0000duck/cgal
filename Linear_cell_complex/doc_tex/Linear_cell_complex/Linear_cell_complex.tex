\def\betats{\ccTexHtml{$\beta$}{&beta;}}
\def\betazero{\ccTexHtml{$\beta_0$}{&beta;<SUB>0</SUB>}}
\def\betaun{\ccTexHtml{$\beta_1$}{&beta;<SUB>1</SUB>}}
\def\betadeux{\ccTexHtml{$\beta_2$}{&beta;<SUB>2</SUB>}}
\def\betatrois{\ccTexHtml{$\beta_3$}{&beta;<SUB>3</SUB>}}
\def\betaquatre{\ccTexHtml{$\beta_4$}{&beta;<SUB>4</SUB>}}
\def\betai{\ccTexHtml{$\beta_i$}{&beta;<SUB>i</SUB>}}
\def\betad{\ccTexHtml{$\beta_d$}{&beta;<SUB>d</SUB>}}	
\def\betadprim{\ccTexHtml{$\beta_{d'}$}{&beta;<SUB>d'</SUB>}}
\def\betaimun{\ccTexHtml{$\beta_{i-1}$}{&beta;<SUB>i-1</SUB>}}
\def\betaipun{\ccTexHtml{$\beta_{i+1}$}{&beta;<SUB>i+1</SUB>}}
\def\betaimdeux{\ccTexHtml{$\beta_{i-2}$}{&beta;<SUB>i-2</SUB>}}
\def\betaipdeux{\ccTexHtml{$\beta_{i+2}$}{&beta;<SUB>i+2</SUB>}}
\def\betaj{\ccTexHtml{$\beta_j$}{&beta;<SUB>j</SUB>}}
\def\betajmun{\ccTexHtml{$\beta_{j-1}$}{&beta;<SUB>j-1</SUB>}}
\def\betaiinv{\ccTexHtml{$\beta_i^{-1}$}{&beta;<sub>i</sub><sup>-1</sup>}}
\def\betajinv{\ccTexHtml{$\beta_j^{-1}$}{&beta;<sub>j</sub><sup>-1</sup>}}

\def\comp{\ccTexHtml{$\circ$}{&deg;}}
\def\pinv{\ccTexHtml{$p^{-1}$}{p<SUP>-1</SUP>}}
\def\myith{\ccTexHtml{$i^{\mbox{th}}$}{i<SUP>th</SUP>}}

\def\myneq{\ccTexHtml{$\neq$}{&ne;}}
\def\myleq{\ccTexHtml{$\leq$}{&le;}}
\def\mylt{\ccTexHtml{$<$}{&lt;}}
\def\mygt{\ccTexHtml{$>$}{&gt;}}
\def\mygeq{\ccTexHtml{$\geq$}{&ge;}}
\def\mysubseteq{\ccTexHtml{$\subseteq$}{&sube;}}
\def\myforall{\ccTexHtml{$\forall$}{&forall;}}
\def\myemptyset{\ccTexHtml{$\emptyset$}{&empty;}}
\def\myRightarrow{\ccTexHtml{$\Rightarrow$}{&rArr;}}
\def\myrightarrow{\ccTexHtml{$\rightarrow$}{&rarr;}}
\def\myin{\ccTexHtml{$\in$}{&isin;}}
\def\mynotin{\ccTexHtml{$\notin$}{&notin;}}
\def\mycup{\ccTexHtml{$\cup$}{&cup;}}
\def\myphi{\ccTexHtml{$\phi$}{&phi;}}
\def\mysetminus{\ccTexHtml{$\setminus$}{\ }}
\def\myldots{\ccTexHtml{$\ldots$}{&hellip;}}
\def\mytimes{\ccTexHtml{$\times$}{&times;}}

%\def\myvarnothing{\ccTexHtml{$\varnothing$}{\varnothing}}
%\ccTexHtml{$\varnothing$}{\lcRawHtml{&#8709;}}}

\newcommand{\cell}[1]{\emph{#1}-cell}
\newcommand{\cells}[1]{\emph{#1}-cells}
\newcommand{\orbit}[1]{\ccTexHtml{$\langle{}$}{&lang;}#1\ccTexHtml{$\rangle{}$}{&rang;}}

\newcommand{\mb}[1]{\beta_{#1}}
\newcommand{\orb}[1]{\langle{}#1\rangle{}}

\section{Introduction}

A \emph{d}D linear cell complex allows to represent an orientable
subdivided \emph{d}D object having linear geometry: each vertex of the
subdivision is associated with a point. The geometry of each edge is a
segment whose end points are associated with the two vertices of the
edge, the geometry of each 2-cell is obtained from all the segments
associated to the edges describing the boundary of the 2-cell and so
on.

The combinatorial part of a linear cell complex is described by using
a \emph{d}D combinatorial map (see  Chapter~\ref{ChapterCombinatorialMap}).
To add the linear geometrical embedding, a point (a model of
\ccc{CGAL::Point_2} or \ccc{CGAL::Point_3} or \ccc{CGAL::Point_d}) is
associated to each vertex of the combinatorial map.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[ht]
  \begin{ccTexOnly}
    \begin{center}
      \includegraphics[width=.3\textwidth]
      {Linear_cell_complex/fig/pdf/object2d}
      \qquad
      \includegraphics[width=.53\textwidth]
      {Linear_cell_complex/fig/pdf/intuitif-example-lcc-object}
      % \includegraphics[width=.3\textwidth]
      % {Linear_cell_complex/fig/pdf/4Dobject}
    \end{center}
  \end{ccTexOnly}
  \begin{ccHtmlOnly}
    <CENTER>
    <A HREF="fig/png/object2d.png"><img src="fig/png/object2d.png" alt=""></A>
    <A HREF="fig/png/intuitif-example-lcc-object.png"><img src="fig/png/intuitif-example-lcc-object.png" alt=""></A>
    </CENTER>
    \end{ccHtmlOnly}
    \caption{Example of objects with linear geometry. \textbf{Left}:~A
      2D object composed of three 2-cells, nine
      1-cells and seven points associated to the seven 0-cells .   
      \textbf{Right}:~A
      3D object composed of three 3-cells, twelve 2-cells, sixteen
      1-cells and eight points associated to the eight 0-cells.
      % \textbf{Right}: A 4D object (called
      % Tesseract) composed of one 4-cell, eight 3-cells, twenty-four 2-cells, 
      % thirty-two 1-cells and sixteen 0-cells.
      \label{fig-exemple-introductif}}
\end{figure}
%
If we reconsider the example introduced in the combinatorial map
package, recalled in Figure~\ref{fig-exemple-introductif} (Left), the
combinatorial part of the 3D object is described by a 3D combinatorial
map. As illustrated in Figure~\ref{fig-exemple-introductif-lcc}, the
geometrical part of the object is described by associating a point to
each vertex of the map.
%
\def\LargFig{.3\textwidth}
\begin{figure}[h]
  \begin{ccTexOnly}
    \begin{center}
      \includegraphics[width=\LargFig]{Linear_cell_complex/fig/pdf/intuitif-example-lcc}\qquad
      \includegraphics[width=\LargFig]{Linear_cell_complex/fig/pdf/intuitif-example-lcc-zoom}
      \includegraphics[width=\LargFig]{Linear_cell_complex/fig/pdf/intuitif-example-lcc-zoom2}
    \end{center}
  \end{ccTexOnly}
  \begin{ccHtmlOnly}
    <CENTER>
    <A HREF="fig/png/intuitif-example-lcc.png">
    <img src="fig/png/intuitif-example-lcc.png" alt=""></A>
    <A HREF="fig/png/intuitif-example-lcc-zoom.png">
        <img src="fig/png/intuitif-example-lcc-zoom.png" alt=""></A>
    <A HREF="fig/png/intuitif-example-lcc-zoom2.png">
        <img src="fig/png/intuitif-example-lcc-zoom2.png" alt=""></A>
    </CENTER>
    \end{ccHtmlOnly}
    \caption{Example of 3D linear cell complex describing the object
      given in Figure~\ref{fig-exemple-introductif} (Left).
      \textbf{Left}:~The 3D linear cell complex which contains 54 darts
      (18 for each 3-cell) where each vertex is associated with a
      point, here a \ccc{CGAL::Point_3}. Blue segments represent \betatrois{} relations.
      \textbf{Middle}:~Zoom around
      the central edge which details the six darts belonging to the
      edge and the associations between darts and points.
      \textbf{Right}:~Zoom around the facet between light gray and
      white 3-cells, which details the eight darts belonging to the
      facet and the associations between darts and
      points (given by red segments).\label{fig-exemple-introductif-lcc}}
\end{figure}

Note that the dimension of the combinatorial map \emph{d} is not
necessarily equal to the dimension of the ambient space
\emph{d2}. Indeed, we can use for example a 2D combinatorial map in a
2D ambient space to describe a planar graph
(\emph{d}=\emph{d2}=\emph{2}), or a 2D combinatorial map in a 3D
ambient space to describe a surface in 3D space (\emph{d}=2,
\emph{d2}=3) (case of the \ccc{Polyhedron_3} package), or a 3D
combinatorial map in a 3D ambient space (\emph{d}=\emph{d2}=3) and so
on.

\section{Software Design}

The diagram in Figure~\ref{fig-diagram_class_lcc} shows the main
classes of the package.  \ccc{CGAL::Linear_cell_complex} is the main
class (see Section~\ref{ssec-linear-cell-complex}) which inherits from
the \ccc{CGAL::Combinatorial_map} class.  Attributes can be associated
to some cells of the linear cell complex thanks to an items class (see
Section~\ref{ssec-lcc-item}), which defines the dart type and the
attribute types. These types may be different for different
dimensions, and they may also be void.  In class
\ccc{CGAL::Linear_cell_complex}, it is required that
specific attributes are associated to all vertices of the
combinatorial map. These attributes must contain a point (a model of
\ccc{CGAL::Point_2} or \ccc{CGAL::Point_3} or \ccc{CGAL::Point_d}),
and can be represented by instances of class
\ccc{CGAL::Cell_attribute_with_point} (see
Section~\ref{ssec-attribute-wp}).
%
\begin{figure}
  \begin{ccTexOnly}
    \begin{center}
      \includegraphics[width=.95\textwidth]
      {Linear_cell_complex/fig/pdf/Diagramme_class}
    \end{center}
  \end{ccTexOnly}
  \begin{ccHtmlOnly}
    <CENTER>
    <A HREF="fig/png/Diagramme_class.png">
        <img src="fig/png/Diagramme_class.png" alt=""></A>
    </CENTER>
    \end{ccHtmlOnly}
    \caption{UML diagram of the main classes of the package. Gray
      elements come from the \ccc{Combinatorial_map} package 
      (cf. Chapter~\ref{ChapterCombinatorialMap}).}
    \label{fig-diagram_class_lcc}
\end{figure}

\subsection{Linear Cell Complex}\label{ssec-linear-cell-complex}

The \ccc{CGAL::Linear_cell_complex<d,d2,Traits_,Items_,Alloc_>} class
is a model of the \ccc{CombinatorialMap} concept. It guarantees that
each vertex of the combinatorial map is associated with an attribute
containing a point. This class can be used in geometric algorithms (it
plays the same role as \ccc{Polyhedron_3} for \ccc{HalfedgeDS}).

This class has five template parameters standing for the dimension of
the combinatorial map, the dimension of the ambient space, a traits
class (a model of the \ccc{LinearCellComplexTraits} concept, see
Section~\ref{ssec-lcc-traits}), an items class (a model of the
\ccc{LinearCellComplexItems} concept, see
Section~\ref{ssec-lcc-item}), and an allocator which must be a model
of the allocator concept of {\stl}.  Default classes are provided for
the traits, items and for the allocator classes, and by default
\ccc{d2=d}.

A linear cell complex is valid, if it is a valid combinatorial map
where each dart is associated with an attribute containing a point
(i.e.  an instance of a model of the \ccc{CellAttributeWithPoint}
concept).  Note that there are no validity constraint on the geometry
(test on self intersection, planarity of 2-cells...) because these
tests are complex, too slow (for example to detect a self
intersection, we have to simulate a Boolean operation), and often
false for inexact kernels.  We can see two examples of
\ccc{CGAL::Linear_cell_complex} in
Figure~\ref{fig-combi_map_with_point}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}
\begin{ccTexOnly}
  \centerline{\includegraphics[width=.25\textwidth]
    {Linear_cell_complex/fig/pdf/plane-graph}
  \qquad
  \includegraphics[width=.45\textwidth]
  {Linear_cell_complex/fig/pdf/basic-example3D}}
\end{ccTexOnly}
\begin{ccHtmlOnly}
  <CENTER>
  <A HREF="fig/png/plane-graph.png">
      <img src="fig/png/plane-graph.png" alt=""></A>
  <A HREF="fig/png/basic-example3D.png">
      <img src="fig/png/basic-example3D.png" alt=""></A>
  </CENTER>
\end{ccHtmlOnly}
\caption{Examples of \ccc{CGAL::Linear_cell_complex}. Gray disks show the
  attributes associated to vertices. Associations between darts and
  attributes are drawn by small lines between darts and disks.
  \textbf{Left:}~Example of \ccc{CGAL::Linear_cell_complex<2,2>}.
  \textbf{Right:}~Example of \ccc{CGAL::Linear_cell_complex<3,3>}.}
\label{fig-combi_map_with_point}
\end{figure}
%
% \begin{figure}
% \begin{ccTexOnly}
%   \centerline{\includegraphics[width=.45\textwidth]
%     {Linear_cell_complex/fig/pdf/exemple-carte-with_point_3d-sew2}}
% \end{ccTexOnly}
% \begin{ccHtmlOnly}
%   <CENTER>
%   <A HREF="fig/png/exemple-carte-with_point_3d-sew2.png">
%       <img src="fig/png/exemple-carte-with_point_3d-sew2.png" alt=""></A>
%   </CENTER>
% \end{ccHtmlOnly}
% \caption{Example of \ccc{Linear_cell_complex<3,3>}. Circles show the
%   attributes associated to vertices, containing 3D
%   points. Associations between darts and attributes are drawn by small
%   lines between darts and disks.}
% \label{fig-combi_map_with_point}
% \end{figure}

\subsection{Cell Attributes}\label{ssec-attribute-wp}

The
\ccc{CGAL::Cell_attribute_with_point<LCC,Info_,Tag,OnMerge,OnSplit>}
class is a model of the \ccc{CellAttributeWithPoint} concept which is
a refinement of the \ccc{CellAttribute} concept. It represents an
attribute associated with a cell which can contain an information
(depending if \ccc{Info_==void} or not), but which always contain a
point, an instance of \ccc{LCC::Point}.
% . This
% class inherits from the type of point defined in \ccc{LCC}. Thus we
% can use an instance of \ccc{CGAL::Cell_attribute_with_point} everywhere an
% instance of \ccc{LCC::Point} is required.

% combinatorial map, see example in
% Section~\ref{ssec-exemple-color-vertices}).
% \end{enumerate}

\subsection{Linear Cell Complex Traits}\label{ssec-lcc-traits}

The \ccc{LinearCellComplexTraits} geometric traits concept defines the
required types and functors used in the \ccc{Linear_cell_complex}
class. For example it defines \ccc{Point}, the type of points used,
and \ccc{Vector}, the corresponding vector type.  It also defines all
the required functors used for contructions and operations, as for
example \ccc{Construct_translated_point} or
\ccc{Construct_sum_of_vectors}.

The class \ccc{CGAL::Linear_cell_complex_traits<d,K>} is a model of
\ccc{LinearCellComplexTraits}. It defines the different types which
are obtained from \ccc{K} which, depending on \ccc{d}, is either a model of
the concept \ccc{Kernel} if \ccc{d==2} or \ccc{d==3}; a model of the
concept \ccc{Kernel_d} otherwise.


\subsection{Linear Cell Complex Items}\label{ssec-lcc-item}

The \ccc{LinearCellComplexItems} concept refines the
\ccc{CombinatorialMapItems} concept by adding the requirement that
0-attributes are enabled, and associated with a type of attribute
being a model of the \ccc{CellAttributeWithPoint} concept.  
% In
% addition to the requirements of \ccc{CombinatorialMapItems}, the
% item class must also define the \ccc{Traits} type for the geometrical
% traits used, a model of the \ccc{Kernel} or the
% \ccc{Kernel_d} concept.

The class \ccc{CGAL::Linear_cell_complex_min_items<d>} is a
model of \ccc{LinearCellComplexItems}. It uses \ccc{CGAL::Dart<d>},
and it has instances of \ccc{CGAL::Cell_attribute_with_point}
which contain no information associated to each vertex. All other
attributes are void.  
% By default, \ccc{d2} is equal to \ccc{d}.  There
% is a default template argument for Traits class which depends on
% \ccc{d2}. This is
% \ccc{CGAL::Exact_predicates_inexact_constructions_kernel type} if
% \ccc{d2} is 2 or 3, and this is \ccc{CGAL::Cartesian_d<double>}
% otherwise.

\section{Operations}

Several operations defined in the combinatorial maps package can be
used on a linear cell complex. This is the case for all the iteration
operations that do not modify the model (see example in 
Section~\ref{ssec-3D-lcc}). This is also the case for
all the operations that do not create new 0-cells: \ccc{sew},
\ccc{unsew}, \ccc{remove_cell}, \ccc{insert_cell_1_in_cell_2},
\ccc{insert_cell_2_in_cell_3}.  Indeed, all these operations update
non void attributes, and thus update vertex attributes of a linear
cell complex. Note that some existing 0-attributes can be duplicated
by the \ccc{unsew} method, but these 0-attributes are not ``new'' but
copies of existing old 0-attributes.

However operations that create a new 0-cell can not be directly used
since the new 0-cell would not be associated with a vertex
attribute. Indeed, it is not possible for these operations to
automatically decide which point to create. These operations are:
\ccc{insert_cell_0_in_cell_1}, \ccc{insert_cell_0_in_cell_2}
\ccc{insert_dangling_cell_1_in_cell_2}, plus all the creation
operations. For these operations, refined versions are proposed taking
a point as additional parameter.  Lastly, some new operations are
defined which use the geometry (see Sections~\ref{ssec-modif-op} and
\ref{ssec-constructions-op}).

% having
% an additional information allowing to create the new vertex attribute.
% This information can either be additional parameters, or a
% specialization to be able to compute the geometry of the new points.

%   These
% operations are \ccc{barycenter}, \ccc{compute_normal_of_cell_2} and
% \ccc{compute_normal_of_cell_0} (these two last functions are defined
% only when \ccc{ambient_dimension==3}).

% Since these operations use some
% geometrical constructions, they have some specific requirements on the
% traits class used.

All the operations given in this section guarantee that given a valid
linear cell complex and a possible operation, the result is a valid
linear cell complex. As for a combinatorial map, it is also possible
to use low level operations but additional operations may be needed to
restore the validity conditions.

%\subsection{Iterating Over Orbits, Cells, and Attributes}\label{ssec-lcc-range}

\subsection{Sewing and Unsewing \label{ssec-lcc-link-darts}}

As explained in \ccc{Combinatorial_map} user manual (see
Chapter~\ref{ChapterCombinatorialMap}), it is possible to glue two
\emph{i}-cells along an (\emph{i}-1)-cell by using the \ccc{sew<i>}
method. Since this method updates non void attributes, and since
points are specific attributes, they are automatically updated during
the \ccc{sew<i>} method. Thus the sewing of two \emph{i}-cells could
deform the geometry of the concerned objects.

For example, in Figure~\ref{fig-lcc-exemple-sew}, we want to 3-sew the
two initial 3-cells. \ccc{sew<3>(1,5)} links by \betatrois{} the pairs
of darts (1,5), (2,8), (3,7) and (4,6). The eight vertex attributes
around the facet between the two 3-cells before the sew are merged by
pair during the sew operation (and the \ccc{On_merge} functor is
called four times). Thus, after the sew, there are only four
attributes around the facet. By default, the attributes associated
with the first dart of the sew operation are kept (but this can be
modified by defining your own functor in the attribute class as
explained in package \ccc{Combinatorial_map}). Intuitively, the
geometry of the second 2-cell is deformed to fit to the first 2-cell.
%
\def\LargFig{.45\textwidth}
\begin{figure}
  \begin{ccTexOnly}
    \begin{center}
      \includegraphics[width=\LargFig]{Linear_cell_complex/fig/pdf/exemple-carte-with_point_3d-sew}\qquad
      \includegraphics[width=\LargFig]{Linear_cell_complex/fig/pdf/exemple-carte-with_point_3d-sew2}
    \end{center}
  \end{ccTexOnly}
  \begin{ccHtmlOnly}
    <CENTER>
    <A HREF="fig/png/exemple-carte-with_point_3d-sew.png">
        <img src="fig/png/exemple-carte-with_point_3d-sew.png" alt=""></A>
    <A HREF="fig/png/exemple-carte-with_point_3d-sew2.png">
        <img src="fig/png/exemple-carte-with_point_3d-sew2.png" alt=""></A>
    </CENTER>
    \end{ccHtmlOnly}
    \caption{Example of 3-sew operation for linear cell complex.
      \textbf{Left}: A 3D linear cell complex containing two 3-cells
      that are not connected. Vertex attributes are drawn with circles
      containing point coordinates.  Associations between darts and
      attributes are drawn with small lines between darts and
      disks. \textbf{Right}: The 3D linear cell complex obtained as
      result of \ccc{sew<3>(1,5)} (or \ccc{sew<3>(2,8)}, or
      \ccc{sew<3>(3,7)}, or \ccc{sew<3>(4,6)}).  The eight
      0-attributes around the facet between the two 3-cells before the
      sew operation, are merged into four 0-attributes after. The
      geometry of the pyramid is deformed since its base is fitted on
      the 2-cell of the cube.}
    \label{fig-lcc-exemple-sew}
\end{figure} 

This is similar for the unsew operation, which removes \betai{} links
of all the darts in
\orbit{\betaun{},\myldots{},\betaimdeux{},\betaipdeux{},\myldots{},\betad{}}(\emph{d0}), 
and updates
non void attributes which are no more associated to a same cell due to
the unlinks.  If we take the linear cell complex given in
Figure~\ref{fig-lcc-exemple-sew} (Right), and we call
\ccc{unsew<3>(2)}, we obtain the linear cell complex in
Figure~\ref{fig-lcc-exemple-sew} (Left) (except for the coordinates of
the new four vertices, which by default are copies of original
vertices. This behavior can be modified thanks to the functor
\ccc{On_split} in the attribute class).  The \ccc{unsew<3>} operation
has removed the four \betatrois{} links, and has duplicated the attributes
since vertices are cut in two after the unsew operation.

\subsection{Construction Operations}\label{ssec-constructions-op}

There are several member functions allowing to insert specific
configurations of darts into a linear cell complex. These functions
%  take an instance of a model of \ccc{LinearCellComplex} as first parameter, and 
return a \ccc{Dart_handle} to the new object.  Note
that the dimension of the linear cell complex must be large enough:
darts must contain all the \betats{} used by the operation.  All these
method add new darts in the current linear cell complex, existing
darts are not modified. The existing functions
are \ccc{make_segment}, \ccc{make_triangle}, % \ccc{make_rectangle},
\ccc{make_tetrahedron}, and \ccc{make_hexahedron}. % and \ccc{make_isocuboid}.
% \begin{figure}
% \begin{ccTexOnly}
%   \centerline{\includegraphics[width=.75\textwidth]
%     {Linear_cell_complex/fig/pdf/creations}}
% \end{ccTexOnly}
% \begin{ccHtmlOnly}
%   <CENTER>
%   <A HREF="fig/png/creations.png">
%       <img src="fig/png/creations.png" alt=""></A>
%   </CENTER>
% \end{ccHtmlOnly}
% \caption{Example of basic objets creation: \ccc{make_segment}, 
%   \ccc{make_triangle}, \ccc{make_rectangle}, 
%   \ccc{make_tetrahedron} and \ccc{make_iso_cuboid}.}
% \label{fig-basic-creation}
% \end{figure}

% \begin{itemize}
% \item \ccc{make_segment(lcc,p1,p2)}: creates an isolated segment in 
%   \ccc{lcc} between points \ccc{p1} and \ccc{p2};
% \item \ccc{make_triangle(lcc,p1,p2,p3)}: creates an isolated
%   triangle in \ccc{lcc} having points \ccc{p1}, \ccc{p2}, \ccc{p3} as geometry;
% \item \ccc{make_quadrangle(lcc,p1,p2,p3,p4)}: creates an isolated
%   quadrangle in \ccc{lcc} having points \ccc{p1}, \ccc{p2}, \ccc{p3},
%   \ccc{p4} as geometry;
% \item \ccc{make_rectangle(lcc,p1,p2)}: creates an isolated
%   rectangle in \ccc{lcc} having points \ccc{p1}, \ccc{p2} as extreme points;
% \item \ccc{make_rectangle(lcc,r)}:  creates an isolated
%   rectangle in \ccc{lcc} having rectangle \ccc{r} as geometry;
% \item \ccc{make_rectangle(lcc,p,l1,l2)}: creates an isolated
%   rectangle in \ccc{lcc} having points \ccc{p} as based point and
%   \ccc{l1} and \ccc{l2} as width and height;
% \item \ccc{make_square(lcc,p,l)}: creates an isolated
%   square in \ccc{lcc} having points \ccc{p} as based point 
%   and \ccc{l} as size,
% \item \ccc{make_tetrahedron(lcc,p1,p2,p3,p4)}: creates a tetrahedron
%   having points \ccc{p1}, \ccc{p2}, \ccc{p3}, \ccc{p4} as geometry;
% \item \ccc{make_hexahedron(lcc,p1,p2,p3,p4,p5,p6,p7,p8)}: creates an
%   hexahedron having points \ccc{p1}, \ccc{p2}, \ccc{p3}, \ccc{p4},
%   \ccc{p5}, \ccc{p6}, \ccc{p7}, \ccc{p8} as geometry;
% \item \ccc{make_iso_cuboid(lcc,p1,p2)}: creates an isolated isocuboid
%   having points \ccc{p1} and \ccc{p2} as extreme points;
% \item \ccc{make_iso_cuboid(lcc,ic)}: creates an isolated isocuboid
%   having \ccc{ic} as geometry.
% \item \ccc{make_cube(lcc,p,l)}: creates an isolated cube
%   having point \ccc{p} as based point and \ccc{l} as size.
%\end{itemize} 

There are two functions allowing to build a linear cell complex
from two other \cgal\ data types:
\begin{itemize}
\item \ccc{import_from_triangulation_3(lcc,atr)}: adds in \ccc{lcc} all 
  the tetrahedra present in \ccc{atr}, a \ccc{CGAL::Triangulation_3};
\item \ccc{import_from_polyhedron(lcc,ap)}: adds in \ccc{lcc} all 
  the cells present in \ccc{ap}, a \ccc{CGAL::Polyhedron_3}.
\end{itemize}

Lastly, the function \ccc{import_from_plane_graph(lcc,ais)} adds in
\ccc{lcc} all the cells reconstructed from the planar graph read in
\ccc{ais}, a \ccc{std::istream}.

\subsection{Modification Operations}\label{ssec-modif-op}

Some methods are defined in \ccc{Linear_cell_complex} class and allow
to modify a linear cell complex and updating the vertex attributes.  The
following versions exist.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[htb]
  \begin{ccTexOnly}
    \begin{center}
      \includegraphics[width=.75\textwidth]{Linear_cell_complex/fig/pdf/insert-vertex}
    \end{center}
  \end{ccTexOnly}
  \begin{ccHtmlOnly}
    <CENTER> <A HREF="fig/png/insert-vertex.png"><img
    src="fig/png/insert-vertex.png" alt=""></A> </CENTER>
  \end{ccHtmlOnly}
  \caption{Example of \ccc{insert_barycenter_in_cell<1>} and
    \ccc{remove_cell<0>} operations. \textbf{Left}: Initial linear
    cell complex.  \textbf{Right}: After the insertion of a 0-cell in
    the barycenter of the 1-cell containing dart \emph{d1}.  Now if we
    remove the 0-cell containing dart \emph{d2}, we obtain a linear
    cell complex isomorphic to the initial one.}
  \label{fig-lcc-insert-vertex}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ccc{lcc.insert_barycenter_in_cell<unsigned int i>(dh0)} adds a point
in the middle of the \emph{i}-cell containing dart \ccc{d0}. This
operation is possible if \ccc{d0}\myin{}\ccc{lcc.darts()} (see example
on Figure~\ref{fig-lcc-insert-vertex} and
Figure~\ref{fig-lcc-triangulate}).  
\ccc{lcc.insert_point_in_cell<unsigned int i>(dh0,p)} is an 
operation similar to the previous operation, the only difference being
that the coordinates of the new point is here given by \ccc{p} instead
of being computed as the barycenter of the \emph{i}-cell.  Currently,
these two operations are only defined for \ccc{i=1} to insert a point
in an edge, or \ccc{i=2} to insert a point in a facet.
%
% \ccc{insert_center_cell_0_in_cell_2(lcc,dh0)} adds a 0-cell in the
% barycenter of the 2-cell containing dart \ccc{d0}. The 2-cell is
% split in triangles, one for each initial edge of the 2-cell. This
% operation is possible if \ccc{d0}\myin{}\ccc{lcc.darts()} (see example
% on Figure~\ref{fig-lcc-triangulate}).
\begin{figure}[htb]
  \begin{ccTexOnly}
    \centerline{\includegraphics[width=.85\textwidth]
      {Linear_cell_complex/fig/pdf/triangulation}}
  \end{ccTexOnly}
  \begin{ccHtmlOnly}
    <CENTER> <A HREF="fig/png/triangulation.png"> <img
    src="fig/png/triangulation.png" alt=""></A> </CENTER>
  \end{ccHtmlOnly}
  \caption{Example of \ccc{insert_barycenter_in_cell<2>} operation.}
  \label{fig-lcc-triangulate}
\end{figure}
%

\ccc{lcc.insert_dangling_cell_1_in_cell_2(dh0,p)} adds a 1-cell in
the 2-cell containing dart \ccc{d0}, the 1-cell being attached by only
one of its vertex to the 0-cell containing dart \ccc{d0}.  The second
vertex of the new edge is associated with a new 0-attribute containing
a copy of \ccc{p} as point. This operation is possible if
\ccc{d0}\myin{}\ccc{lcc.darts()} (see example on
Figure~\ref{fig-lcc-insert-dangling-edge}).
  \begin{figure}[htb]
    \begin{ccTexOnly}
      \begin{center}
        \includegraphics[width=.72\textwidth]{Linear_cell_complex/fig/pdf/insert-edge}
      \end{center}
    \end{ccTexOnly}
    \begin{ccHtmlOnly}
      <CENTER> <A HREF="fig/png/insert-edge.png"><img
      src="fig/png/insert-edge.png" alt=""></A> </CENTER>
    \end{ccHtmlOnly}
    \caption{Example of \ccc{insert_dangling_cell_1_in_cell_2} and
      \ccc{remove_cell<1>} operations. \textbf{Left}: Initial linear
      cell complex.  \textbf{Right}: After the insertion of a dangling
      1-cell in the 2-cell containing dart \emph{d1}. Now if we remove
      the 1-cells containing dart \emph{d4} and \emph{d5},
      we obtain a linear cell complex isomorphic to the initial one.}
    \label{fig-lcc-insert-dangling-edge}
  \end{figure}
% \end{itemize}
% \end{itemize}

  Some examples of use of these operations are given in
  Section~\ref{ssec-5dexample}.

% The operations defined on combinatorial maps can be used on linear
% cell complexes.  However, only operations which does not create a new
% vertex ensure the validity of enabled cells: \ccc{remove_cell<i>},
% \ccc{insert_cell_1_in_cell_2}, \ccc{insert_cell_2_in_cell_3}.

% For other operations, you need to create 0-attributes and associate
% them to new vertices.

\section{Examples}

\subsection{A 3D Linear Cell Complex}\label{ssec-3D-lcc}

This example uses a 3-dimensional linear cell complex. It creates two
tetrahedra and displays all the points of the linear cell complex
thanks to a \ccc{Vertex_attribute_const_range}. Then, the two
tetrahedra are 3-sewn and we translate all the points of the second
tetrahedron along vector \ccc{v(3,1,1)}.  Since the two tetrahedron
are 3-sewn, this translation moves also the 2-cell of the first
tetrahedron shared with the second one.  This is illustrated by
displaying all the points of each 3-cell. For that we use a
\ccc{std::for_each} and the \ccc{Display_vol_vertices} functor.

%\ccIncludeExampleCode{Linear_cell_complex/map_3_with_points.cpp}
% TODO update the code to reflect the last modifs of the doc.
\begin{ccExampleCode}
typedef CGAL::Linear_cell_complex<3> LCC_3;
typedef LCC_3::Dart_handle           Dart_handle;
typedef LCC_3::Point                 Point;
typedef LCC_3::FT                    FT;

// Functor used to display all the vertices of a given volume
template<class LCC> 
struct Display_vol_vertices : public std::unary_function<LCC, void>
{
  Display_vol_vertices(const LCC& alcc) : 
    lcc(alcc), 
    nb_volume(0)
  {}

  void operator() (typename LCC::Dart& d) 
  { 
    std::cout<<"Volume "<<++nb_volume<<" : ";
    for (typename LCC::template One_dart_per_incident_cell_range<0,3>::
         const_iterator it=lcc.template 
         one_dart_per_incident_cell<0,3>(lcc.dart_handle(d)).begin(),
         itend=lcc.template one_dart_per_incident_cell<0,3>
         (lcc.dart_handle(d)).end(); it!=itend; ++it)
      {
        std::cout << LCC_3::point(it) << "; ";
      }
    std::cout<<std::endl;
  }
private:
  const LCC& lcc;
  unsigned int nb_volume;
};

int main()
{
  LCC_3 lcc;

  // Create two tetrahedra.
  Dart_handle d1 = lcc.make_tetrahedron(Point(-1, 0, 0), 
                                       Point(0, 2, 0), 
                                       Point(1, 0, 0), 
                                       Point(1, 1, 2));
  Dart_handle d2 = lcc.make_tetrahedron(Point(0, 2, -1), 
                                       Point(-1, 0, -1),
                                       Point(1, 0, -1), 
                                       Point(1, 1, -3));

  // Display all the vertices of the lcc by iterating on the 
  // vertex_attribute container.
  CGAL::set_ascii_mode(std::cout);
  std::cout<<"Vertices: ";
  for (LCC_3::Vertex_attribute_const_range::iterator 
       v=lcc.vertex_attributes().begin(), 
       vend=lcc.vertex_attributes().end(); v!=vend; ++v)
    std::cout << *v << "; ";
  std::cout<<std::endl;

  // Display the vertices of each volume by iterating on darts.
  std::for_each(lcc.one_dart_per_cell<3>().begin(),
                lcc.one_dart_per_cell<3>().end(),
                Display_vol_vertices<LCC_3>(lcc));  

  // 3-Sew the 2 tetrahedra along one facet
  lcc.sew<3>(d1, d2);

  // Display the vertices of each volume by iterating on darts.
  std::for_each(lcc.one_dart_per_cell<3>().begin(),
                lcc.one_dart_per_cell<3>().end(),
                Display_vol_vertices<LCC_3>(lcc));  

  // Translate the second tetrahedra by a given vector
  LCC_3::Vector v(3,1,1);
  for (LCC_3::One_dart_per_incident_cell_range<0,3>::iterator 
       it=lcc.one_dart_per_incident_cell<0,3>(d2).begin(),
       itend=lcc.one_dart_per_incident_cell<0,3>(d2).end();
       it!=itend; ++it)
    {
      LCC_3::point(it)=LCC_3::Traits::Construct_translated_point_3()
          (LCC_3::point(it),v);
    }

  // Display the vertices of each volume by iterating on darts.
  std::for_each(lcc.one_dart_per_cell<3>().begin(),
                lcc.one_dart_per_cell<3>().end(),
                Display_vol_vertices<LCC_3>(lcc));  

  // We display the lcc characteristics.
  std::cout<<"LCC characteristics: ";
  lcc.display_characteristics(std::cout) << ", valid=" 
                 << lcc.is_valid() << std::endl;

  return EXIT_SUCCESS;
}
\end{ccExampleCode}

The output is:
\begin{verbatim}
Vertices: 1 1 2; 1 0 0; 0 2 0; -1 0 0; 1 1 -3; 1 0 -1; -1 0 -1; 0 2 -1; 
Volume 1 : -1 0 0; 0 2 0; 1 0 0; 1 1 2; 
Volume 2 : 0 2 -1; -1 0 -1; 1 0 -1; 1 1 -3; 
Volume 1 : -1 0 0; 0 2 0; 1 0 0; 1 1 2; 
Volume 2 : 0 2 0; -1 0 0; 1 0 0; 1 1 -3; 
Volume 1 : 2 1 1; 3 3 1; 4 1 1; 1 1 2; 
Volume 2 : 3 3 1; 2 1 1; 4 1 1; 4 2 -2; 
LCC characteristics: #Darts=24, #0-cells=5, #1-cells=9, #2-cells=7, #3-cells=2, #ccs=1, valid=1
\end{verbatim}

The first line gives the points of the linear cell complex before the
\ccc{sew<3>}. There are eight points, four for each tetrahedron.
After the sew, six vertices are merged two by two, thus there are five
vertices. We can see the points of each 3-cell (lines Volume 1 and
Volume 2) before the sew, after the sew and after the translation of
the second volume.  We can see that this translation has also modified
the three common points between the two 3-cells.  The last line shows
the number of cells of the linear cell complex, the number of
connected components, and finally a Boolean to show the validity of
the linear cell complex.

\subsection{A 4D Linear Cell Complex}\label{ssec-5dexample}

This example uses a 4-dimensional linear cell complex embedded in a
5-dimensional ambient space.  It creates two tetrahedra having 5D
points and sews the two tetrahedra by \betaquatre{}. Then we use some high
level operations, displays the number of cells of the linear cell
complex, and checks its validity.  Last we use the reverse operations
to get back to the initial configuration.

\begin{ccExampleCode}
typedef CGAL::Linear_cell_complex<4,5> LCC_4;
typedef LCC_4::Dart_handle Dart_handle;
typedef LCC_4::Point Point;
typedef LCC_4::Vector Vector;
typedef LCC_4::FT FT;

int main()
{
  LCC_4 lcc;
	
  // Create two tetrahedra.
  FT p1[5]={ 0, 0, 0, 0, 0}; std::vector<FT> v1(p1,p1+5);
  FT p2[5]={ 0, 2, 0, 0, 0}; std::vector<FT> v2(p2,p2+5);
  FT p3[5]={ 0, 1, 2, 0, 0}; std::vector<FT> v3(p3,p3+5);
  FT p4[5]={ 2, 1, 0, 0, 0}; std::vector<FT> v4(p4,p4+5);
  FT p5[5]={-1, 0, 0, 0, 0}; std::vector<FT> v5(p5,p5+5);
  FT p6[5]={-1, 2, 0, 0, 0}; std::vector<FT> v6(p6,p6+5);
  FT p7[5]={-1, 1, 2, 0, 0}; std::vector<FT> v7(p7,p7+5);
  FT p8[5]={-3, 1, 2, 0, 0}; std::vector<FT> v8(p8,p8+5);
  
  Dart_handle d1 = lcc.make_tetrahedron(
                      Point(5, v1.begin(), v1.end()),
                      Point(5, v2.begin(), v2.end()),
                      Point(5, v3.begin(), v3.end()),
                      Point(5, v4.begin(), v4.end()));  
  
  Dart_handle d2 = lcc.make_tetrahedron(
                      Point(5, v5.begin(), v5.end()),
                      Point(5, v6.begin(), v6.end()),
                      Point(5, v7.begin(), v7.end()),
                      Point(5, v8.begin(), v8.end()));

  lcc.display_characteristics(std::cout);
  std::cout<<", valid="<<lcc.is_valid()<<std::endl;

  lcc.sew<4>(d1,d2);
  
  lcc.display_characteristics(std::cout);
  std::cout<<", valid="<<lcc.is_valid()<<std::endl;

  // Add one vertex on the middle of an edge.
  Dart_handle d3 = lcc.insert_barycenter_in_cell<1>(lcc,d1);
  CGAL_assertion( lcc.is_valid() );

  lcc.display_characteristics(std::cout);
  std::cout<<", valid="<<lcc.is_valid()<<std::endl;

  // Add one edge to cut the face in two.
  Dart_handle d4 = CGAL::insert_cell_1_in_cell_2(lcc,d3,d1->beta(0));
  CGAL_assertion( lcc.is_valid() );
	
  lcc.display_characteristics(std::cout);
  std::cout<<", valid="<<lcc.is_valid()<<std::endl;
  
  // We use the removal operations to get back to the initial cube.
  CGAL::remove_cell<LCC_5,1>(lcc,d4);
  CGAL_assertion( lcc.is_valid() );

  CGAL::remove_cell<LCC_5,0>(lcc,d3);
  CGAL_assertion( lcc.is_valid() );

  lcc.unsew<4>(d1);

  lcc.display_characteristics(std::cout);
  std::cout<<", valid="<<lcc.is_valid()<<std::endl;

  return EXIT_SUCCESS;
}
\end{ccExampleCode}

The output is:
\begin{verbatim}
#Darts=24, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #4-cells=2, #ccs=2, valid=1
#Darts=24, #0-cells=4, #1-cells=6, #2-cells=4, #3-cells=1, #4-cells=2, #ccs=1, valid=1
#Darts=32, #0-cells=5, #1-cells=8, #2-cells=5, #3-cells=1, #4-cells=2, #ccs=1, valid=1
#Darts=24, #0-cells=8, #1-cells=12, #2-cells=8, #3-cells=2, #4-cells=2, #ccs=2, valid=1
\end{verbatim}

\subsection{A 3D Linear Cell Complex with Colored Vertices}
\label{ssec-exemple-color-vertices}

This example illustrates the way to use a 3D linear cell complex by
adding another information to vertices. For that, we need to define
our own items class.  The difference with the
\ccc{CGAL::Linear_cell_complex_min_items} class is about the definition of
the vertex attribute where we use a \ccc{CGAL::Cell_attribute_with_point}
with a non void info. In this example, the ``vextex color'' is just
given by an \ccc{int} (the second template parameter of the
\ccc{CGAL::Cell_attribute_with_point}).  Lastly, we define the
\ccc{Average_functor} class in order to set the color of a vertex
resulting of the merging of two vertices to the average of the two
initial values. This functor is associated with the vertex attribute
by passing it as template parameter.  Using this items class instead of
the default one is chosen during the instantiation of template
parameters of the \ccc{CGAL::Linear_cell_complex} class.

Now we can use \ccc{LCC_3} in which each vertex is associated with an
attribute containing both a point and an information. In the following
example, we create two cubes, and set the color of the vertices of the
first cube to 1 and of the second cube to 19 (by iterating through two
\ccc{Cell_of_cell_range<0, 3>} ranges). Then we \emph{3-sew} the two
cubes along one facet. This operation merges some vertices (as in the
example of Figure~\ref{fig-lcc-exemple-sew}).  We insert a vertex in
the common 2-cell between the two cubes, and set the information of
the new 0-attribute to 5.  In the last loop, we display the point and
the information of each vertex of the linear cell complex.

\begin{ccExampleCode}
struct Average_functor
{
  template<class CellAttribute>
  void operator()(CellAttribute& ca1,CellAttribute& ca2)
  { ca1.info()=(ca1.info()+ ca2.info())/2; }
};

struct Myitem
{
  template<class Refs>
  struct Dart_wrapper
  {
    typedef CGAL::Dart<3, Refs > Dart;
    
    typedef CGAL::Cell_attribute_with_point< Refs, int, CGAL::Tag_true, 
                                   Average_functor > Vertex_attribute;
    
    typedef CGAL::cpp0x::tuple<Vertex_attribute> Attributes;
  };
};

typedef CGAL::Linear_cell_complex_traits<3,
         CGAL::Exact_predicates_inexact_constructions_kernel> Traits;
typedef CGAL::Linear_cell_complex<3,3,Traits,Myitem> LCC_3;
typedef LCC_3::Dart_handle                           Dart_handle;
typedef LCC_3::Point                                 Point;
typedef LCC_3::FT                                    FT;

Dart_handle make_iso_cuboid(LCC_3& lcc, const Point& basepoint, FT lg)
{
	return lcc.make_hexahedron(basepoint,
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(lg,0,0)),
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(lg,lg,0)),
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(0,lg,0)),
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(0,lg,lg)),
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(0,0,lg)),
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(lg,0,lg)),
             LCC_3::Construct_translated_point()
                (basepoint,LCC_3::Vector(lg,lg,lg)));
}

int main()
{
  LCC_3 lcc;
  
  // Create 2 cubes.
  Dart_handle d1 = make_iso_cuboid(lcc, Point(-2, 0, 0), 1);
  Dart_handle d2 = make_iso_cuboid(lcc, Point(0, 0, 0), 1);

  // Set the color of all vertices of the first cube to 1
  for (LCC_3::One_dart_per_incident_cell_range<0, 3>::iterator 
       it=lcc.one_dart_per_incident_cell<0,3>(d1).begin(), 
       itend=lcc.one_dart_per_incident_cell<0,3>(d1).end(); 
       it!=itend; ++it)
    { LCC_3::vertex_attribute(it)->info()=1; }
  
  // Set the color of all vertices of the second cube to 19
  for (LCC_3::One_dart_per_incident_cell_range<0, 3>::iterator it=
       lcc.one_dart_per_incident_cell<0,3>(d2).begin(),
       itend=lcc.one_dart_per_incident_cell<0,3>(d2).end(); 
       it!=itend; ++it)
    { LCC_3::vertex_attribute(it)->info()=19; }
  
  // 3-Sew the two cubes along one facet
  lcc.sew<3>(d1->beta(1)->beta(1)->beta(2), d2->beta(2));

  // Barycentric triangulation of the facet between the two cubes.
  Dart_handle d3=lcc.insert_barycenter_in_cell<2>(d2->beta(2));

  // Set the color of the new vertex to 5.
  LCC_3::vertex_attribute(d3)->info()=5;
  
  // Display all the vertices of the map.
  for (LCC_3::One_dart_per_cell_range<0>::iterator 
       it=lcc.one_dart_per_cell<0>().begin(), 
       itend=lcc.one_dart_per_cell<0>().end(); 
       it!=itend; ++it)
    {
      std::cout<<"point: "<<LCC_3::point(it)<<", "
               <<"color: "<<LCC_3::vertex_attribute(it)->info()
               <<std::endl;
    }

  return EXIT_SUCCESS;
}
\end{ccExampleCode}

The output is:
\begin{verbatim}
point: -2 0 0, color: 1
point: -2 0 1, color: 1
point: -1 0 1, color: 10
point: -1 0 0, color: 10
point: -1 1 1, color: 10
point: -1 1 0, color: 10
point: -2 1 1, color: 1
point: -2 1 0, color: 1
point: 1 0 1, color: 19
point: 1 0 0, color: 19
point: 1 1 1, color: 19
point: 1 1 0, color: 19
point: -1 0.5 0.5, color: 5
\end{verbatim}

Before applying the sew operation, the eight vertices of the first
cube are colored by 1, and the eight vertices of the second cube by
19. After the sew operation, there are eight vertices which are merged
two by two, and due to the average functor, the color of the four
resulting vertices are now 10. Then we insert a vertex in the center
of the common 2-cell between the two cubes.  The coordinates of this
vertex are initialized with the barycenter of the 2-cell
(-1,0.5,0.5), and its color is not initialize by the method, thus we
set its color manually by using the result of
\ccc{insert_barycenter_in_cell<2>} which is a dart incident to the
new vertex.

\section{Design and Implementation History}
%
This package was develloped by Guillaume Damiand, with the help of
Andreas Fabri, S\'ebastien Loriot and Laurent Rineau.  Monique
Teillaud and Bernd G{\"a}rtner contributed to the manual.
