namespace CGAL {
/*!

\mainpage Surface Reconstruction from Point Sets
\anchor Chapter_Surface_Reconstruction_from_Point_Sets
\anchor chapsurface_reconstruction_points_3

\authors Pierre Alliez, Laurent Saboret, Ga&euml;l Guennebaud

# Introduction #

This \cgal component implements a surface reconstruction method which
takes as input point sets with oriented normals and computes an
implicit function. We assume that the input points contain no outliers
and little noise. The output surface mesh is generated by extracting
an isosurface of this function with the \cgal Surface Mesh Generator
\cite cgal:ry-gsddrm-06 or potentially with any other surface
contouring algorithm.

\anchor Surface_reconstruction_points_3figintroduction
\image html introduction.jpg "Poisson surface reconstruction. Left: 17K points sampled on the statue of an elephant with a Minolta laser scanner. Right: reconstructed surface mesh."

More specifically, the core surface reconstruction algorithm consists
of computing an implicit function which is an approximate indicator
function of the inferred solid (Poisson Surface Reconstruction -
referred to as Poisson). Poisson is a two steps process: it requires
solving for the implicit function before function evaluation.

# Common Reconstruction Pipeline #

Surface reconstruction from point sets is often a sequential process
with the following steps: 1) Scanning and scan alignment produce a set
of points or points with normals; 2) Outlier removal; 3)
Simplification to reduce the number of input points; 4) Smoothing to
reduce noise in the input data; 5) Normal estimation and orientation
when the normals are not already provided by the acquisition device;
and 6) Surface reconstruction.

\cgal provides algorithms for all steps listed above except alignment. 

Chapter \ref chappoint_set_processing_3 Point_set_processing_3
describes algorithms to pre-process the point set before
reconstruction with functions devoted to the simplification, outlier
removal, smoothing, normal estimation and normal orientation.

\anchor Surface_reconstruction_points_3figpipeline
\image html pipeline.jpg "Common surface reconstruction pipeline."

# Poisson #

Given a set of 3D points with oriented normals (denoted oriented
points in the sequel) sampled on the boundary of a 3D solid, the
Poisson Surface Reconstruction method \cite Kazhdan06 solves for an
approximate indicator function of the inferred solid, whose gradient
best matches the input normals. The output scalar function,
represented in an adaptive octree, is then iso-contoured using an
adaptive marching cubes.

\cgal implements a variant of this algorithm which solves for a
piecewise linear function on a 3D Delaunay triangulation instead of an
adaptive octree. The algorithm takes as input a set of 3D oriented
points. It builds a 3D Delaunay triangulation from these points and
refines it by Delaunay refinement so as to remove all badly shaped
(non isotropic) tetrahedra and to tessellate a loose bounding box of
the input oriented points. The normal of each Steiner point added
during refinement is set to zero. It then solves for a scalar
indicator function \f$ f\f$ represented as a piecewise linear function
over the refined triangulation. More specifically, it solves for the
Poisson equation \f$ \Delta f = div(\mathbf{n})\f$ at each vertex of
the triangulation using a sparse linear solver. Eventually, the \cgal
surface mesh generator extracts an isosurface with function value set
by default to be the median value of \f$ f\f$ at all input points.

## Interface ##

The class template declaration is:

\code{.cpp}

template < 
    class Gt // geometric traits class
    >
class Poisson_reconstruction_function {
  // Creation
  template<typename InputIterator, typename PointPMap, typename NormalPMap> 
  Poisson_reconstruction_function::Poisson_reconstruction_function(InputIterator first, InputIterator beyond, PointPMap point_pmap, NormalPMap normal_pmap);

  // Main Operations
  Sphere bounding_sphere() const;

  bool compute_implicit_function();

  FT value(const Point& p) const;
  Point get_inner_point() const;
};
\endcode

For details see: `CGAL::Poisson_reconstruction_function<GeomTraits>`

## Example ##

`poisson_reconstruction_example.cpp` reads a point set, creates a Poisson implicit function and reconstructs a surface.

\cgalexample{Surface_reconstruction_points_3/poisson_reconstruction_example.cpp}

# Contouring #


The computed implicit functions can be iso-contoured to reconstruct a
surface by using the \cgal surface mesh generator 
\cite cgal:ry-gsddrm-06 \cite cgal:bo-pgsms-05:

`CGAL::make_surface_mesh` 

The parameter `Tag` affects the behavior of `make_surface_mesh()`: 
- `Manifold_tag`: the output mesh is guaranteed to be a manifold surface without boundary.
- `Manifold_with_boundary_tag`: the output mesh is guaranteed to be manifold and may have boundaries.
- `Non_manifold_tag`: the output mesh has no guarantee and hence is outputted as a polygon soup.

# Output #

The surface reconstructed by `make_surface_mesh()` is required to be a
model of the concept `SurfaceMeshComplex_2InTriangulation_3`, a data
structure devised to represent a two dimensional complex embedded into
a three dimensional triangulation.

`SurfaceMeshComplex_2InTriangulation_3` defines the methods to traverse the reconstructed surface, and e.g. convert it to a triangle soup.

Other \cgal components provide functions to write the reconstructed
surface mesh to the Object File Format (OFF) \cite cgal:p-gmgv16-96
and to convert it to a polyhedron (when it is manifold):
- `CGAL::output_surface_facets_to_off` 
- `CGAL::output_surface_facets_to_polyhedron` 

See `poisson_reconstruction_example.cpp` example above.

# Case Studies #

\anchor surface_reconstruction_section_case_studies

The surface reconstruction problem being inherently ill-posed, the
proposed algorithm does not pretend to reconstruct all kinds of
surfaces with arbitrary sampling conditions. This section provides the
user with some hints about the ideal sampling and contouring
conditions, and depicts some failure cases when these conditions are
not matched.

## Ideal Conditions ##

The user must keep in mind that the poisson surface reconstruction
algorithm comprises two phases (computing the implicit function from
the input point set and contouring an iso-surface of this
function). Both require some care in terms of sampling conditions and
parameter tuning.

## Point Set ##

Ideally the current implementation of the Poisson surface
reconstruction method expects a dense 3D oriented point set (typically
matching the epsilon-sampling condition \cite cgal:bo-pgsms-05) and
sampled over a closed, smooth surface. Oriented herein means that all
3D points must come with consistently oriented normals to the inferred
surface. Figures \ref Surface_reconstruction_points_3figbimba and \ref Surface_reconstruction_points_3figeros 
illustrate cases where these ideal conditions are met.

\anchor Surface_reconstruction_points_3figbimba
\image html bimba.jpg "Poisson reconstruction. Left: 120K points sampled on a statue (Minolta laser scanner). Right: reconstructed surface mesh."
\anchor Surface_reconstruction_points_3figeros
\image html eros.jpg "Left: 120K points sampled on a statue (Minolta laser scanner). Right: reconstructed surface mesh."

The algorithm is fairly robust to anisotropic sampling and to
noise. It is also robust to missing data through filling the
corresponding holes as the algorithm is designed to reconstruct the
indicator function of an inferred solid (see Figure 
\ref Surface_reconstruction_points_3figholes_good).

\anchor Surface_reconstruction_points_3figholes_good
\image html holes_good.jpg "Top left: 65K points sampled on a hand (Kreon laser scanner). Bottom left: the point set is highly anisotropic due to the scanning technology. Right: reconstructed surface mesh and closeup. The holes are properly closed."

The algorithm is in general not robust to outliers, although a few
outliers do not always create a failure, see Figure 
\ref Surface_reconstruction_points_3figoutliers.

\anchor Surface_reconstruction_points_3figoutliers
\image html outliers.jpg "Left: 70K points sampled on an elephant with few outliers emphasized with disks. Right: reconstructed surface mesh."

The algorithm works well even when the inferred surface is composed of
several connected components, provided that both all normals are
properly estimated and oriented (the current \cgal normal orienter
algorithm may fail in some cases, see `CGAL::mst_orient_normals()`),
and that the final contouring algorithm is properly seeded for each
component. When the inferred surface is composed of several nested
connected components care should be taken to orient the normals of
each component in alternation (inward/outward) so that the final
contouring stage picks a proper contouring value.

## Contouring Parameters ##

Our implementation of the Poisson surface reconstruction algorithm
computes an implicit function represented as a piecewise linear
function over the tetrahedra of a 3D Delaunay triangulation
constructed from the input points then refined through Delaunay
refinement. For this reason, any iso-surface is also piecewise linear
and hence may contain sharp creases. As the contouring algorithm
`CGAL::make_surface_mesh()` expects a smooth implicit function these
sharp creases may create spurious clusters of vertices in the final
reconstructed surface mesh when setting a small mesh sizing or surface
approximation error parameter (see Figure
\ref Surface_reconstruction_points_3figcontouring_bad).

One way to avoid these spurious clusters consists of adjusting the
mesh sizing and surface approximation parameters large enough compared
to the average sampling density (obtained through
`CGAL::compute_average_spacing()`) so that the contouring algorithm
"perceives" a smooth iso-surface. We recommend to use the following
contouring parameters:

- Max triangle radius: at least 100 times the average spacing.
- Approximation distance: at least 0.25 times the average spacing.

\anchor Surface_reconstruction_points_3figcontouring_bad
\image html contouring_bad.jpg "Left: surface reconstructed with approximation distance = 0.25 * average spacing. Right: surface reconstructed with approximation distance = 0.15 * average spacing. Notice the spurious cluster on the chick."

## Degraded Conditions ##

The conditions listed above are rather restrictive and in practice not
all of them are met in the applications. We now illustrates the
behavior of the algorithm when the conditions are not met in terms of
sampling, wrongly oriented normals, noise and sharp creases.

## Sparse Sampling ##

The reconstruction algorithm expects a sufficiently dense point
set. Although there is no formal proof of correctness of the algorithm
under certain density conditions due to its variational nature, our
experiments show that the algorithm reconstructs well all thin
features when the local spacing is at most one tenth of the local
feature size (the distance to the medial axis, which captures
altogether curvature, thickness and separation). When this condition
is not met the reconstruction does not reconstruct the thin
undersampled features (see Figure 
\ref Surface_reconstruction_points_3figsampling).

\anchor Surface_reconstruction_points_3figsampling
\image html sampling.jpg "Left: 50K points sampled on the Neptune trident. The reconstruction (not shown) is successful in this case. Right: point set simplified to 1K points then reconstructed (all input points are depicted with normals). The thin feature is not reconstructed."

## Large Holes ##

The reconstruction is devised to solve for an implicit function which
is an approximate indicator function of an inferred solid. For this
reason the contouring algorithm always extracts a closed surface mesh
and hence is able to fill the small holes where data are missing due,
e.g., to occlusions during acquisition. In case of large holes the
algorithm still closes them all but sometimes in an unexpected
manner. In addition the resulting piecewise linear implicit function
may exhibit large triangle patches and sharp creases as the 3D
Delaunay triangulation used for solving is very coarse where the holes
are filled (see Figure 
\ref Surface_reconstruction_points_3figholes_bad).

\anchor Surface_reconstruction_points_3figholes_bad
\image html holes_bad.jpg "Left: 65K points sampled on a hand with no data captured at the wrist base. Right: reconstructed surface mesh. The surface is properly closed on the fingers and also closed at the wrist but in a less plausible manner."

## Wrongly Oriented Normals ##

The Poisson surface reconstruction approaches solves for an implicit
function whose gradient best matches a set of input normals. Because
it solves this problem in the least squares sense, it is robust to few
isolated wrongly oriented (flipped) normals. Nevertheless a cluster of
wrongly oriented normals leads to an incorrect implicit function and
hence to spurious geometric or even topological distortion (see Figure
\ref Surface_reconstruction_points_3figflipped_normals).

\anchor Surface_reconstruction_points_3figflipped_normals
\image html flipped_normals.jpg "Left: points sampled on a sphere with a cluster of wrongly oriented normals. Right: reconstructed surface mesh with a spurious bump."

## Noise and Outliers ##

A large amount of noise inevitably impacts on the reconstruction (see
Figure \ref Surface_reconstruction_points_3fignoise, top) and the
current implementation does not provide any mean to trade data fitting
for smoothness. Nevertheless if the signal-to-noise ratio is
sufficiently high and/or the surface approximation and sizing
parameters set for contouring the iso-surface is large with respect to
the noise level the output surface mesh will appear smooth (not
shown). If the user wants to produce a smooth and detailed output
surface mesh, we recommend to apply smoothing through
`CGAL::jet_smooth_point_set()` ((see Figure 
\ref Surface_reconstruction_points_3fignoise, bottom).

\anchor Surface_reconstruction_points_3fignoise
\image html noise.jpg "Top-left: points sampled on a sphere and corrupted with a lot of noise. Top-right: reconstructed surface mesh. Bottom-left: smoothed point set. Bottom-right: reconstructed surface mesh."

For a large number of outliers the failure cases (not shown) translate
into spurious small connected components and massive distortion near
the inferred surface. In this case the outliers must be removed
through `CGAL::remove_outliers()`.

## Sharp Creases ##

The current reconstruction algorithm is not able to recover the sharp
creases and corners present in the inferred surface. This translates
into smoothed sharp creases.

\anchor Surface_reconstruction_points_3figsharp_features
\image html sharp_features.jpg "Left: 5K points sampled on a mechanical piece with sharp features (creases, darts and corners). Right: reconstructed surface mesh with smoothed creases."

# Performances #

\anchor surface_reconstruction_section_performances

We provide some performance numbers for scanning data. We measure the
Poisson implicit function computation time, the contouring time for a
range of approximation distances, the memory occupancy as well as the
influence of the point set simplification. The machine used is a PC
running Linux 32 bits with an Intel CPU Core 2 processor clocked at 3
GHz and with 3 GB of RAM. The software is compiled with g++ 4.3.1
compiler with the 03 option which maximizes speed. All measurements
were done using the \ref thirdpartyTaucs library even if we now
recommend to use the \ref thirdpartyEigen library.

## Poisson implicit function ##

The point set chosen for benchmarking the Poisson implicit function is
the Bimba con Nastrino point set (1.6 million points) depicted by
Figure \ref Surface_reconstruction_points_3figpoisson_bench. We
measure the Poisson implicit function computation (i.e., the call to
`Poisson_reconstruction_function::compute_implicit_function()` denoted
by Poisson solve hereafter) for this point set as well as for
simplified versions obtained through random simplification. The
following table provides Poisson solve computation times in seconds
for an increasing number of points.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
Number of points (x1000) 
<TD ALIGN=CENTER NOWRAP>
Poisson solve duration (in s) 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
60 
<TD ALIGN=CENTER NOWRAP>
65 
<TR>
<TD ALIGN=CENTER NOWRAP>
120 
<TD ALIGN=CENTER NOWRAP>
137 
<TR>
<TD ALIGN=CENTER NOWRAP>
250 
<TD ALIGN=CENTER NOWRAP>
282 
<TR>
<TD ALIGN=CENTER NOWRAP>
500 
<TD ALIGN=CENTER NOWRAP>
566 
<TR>
<TD ALIGN=CENTER NOWRAP>
1,000 
<TD ALIGN=CENTER NOWRAP>
1,130 
<TR>
<TD ALIGN=CENTER NOWRAP>
1,500 
<TD ALIGN=CENTER NOWRAP>
1,777 
<TR>
<TD ALIGN=CENTER NOWRAP>
1,600 
<TD ALIGN=CENTER NOWRAP>
1,919 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
</TABLE>

\anchor Surface_reconstruction_points_3figpoisson_bench
\image html poisson_bench.jpg "Poisson implicit function computation duration (in s) against the number of points for the Bimba con Nastrino point set with 1.6M points (shown) as well as for simplified versions."

## Contouring ##

The point set chosen for benchmarking the contouring stage is the Bimba con Nastrino point set simplified to 120k points. We measure the contouring (i.e. the call to `make_surface_mesh()`) duration and the reconstruction error for a range of approximation distances.
The reconstruction error is expressed as the average distance from input points to the reconstructed surface in mm (the Bimba con Nastrino statue is 324 mm tall).

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=3><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
Approx. distance (*average spacing) 
<TD ALIGN=CENTER NOWRAP>
Contouring duration (in s) 
<TD ALIGN=CENTER NOWRAP>
Reconstruction error (mm) 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=3><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
0.1 
<TD ALIGN=CENTER NOWRAP>
177 
<TD ALIGN=CENTER NOWRAP>
0.13 
<TR>
<TD ALIGN=CENTER NOWRAP>
0.25 
<TD ALIGN=CENTER NOWRAP>
47 
<TD ALIGN=CENTER NOWRAP>
0.155 
<TR>
<TD ALIGN=CENTER NOWRAP>
0.5 
<TD ALIGN=CENTER NOWRAP>
21 
<TD ALIGN=CENTER NOWRAP>
0.23 
<TR>
<TD ALIGN=CENTER NOWRAP>
1 
<TD ALIGN=CENTER NOWRAP>
10 
<TD ALIGN=CENTER NOWRAP>
0.4 
<TR>
<TD ALIGN=CENTER NOWRAP>
2 
<TD ALIGN=CENTER NOWRAP>
5 
<TD ALIGN=CENTER NOWRAP>
0.78 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=3><HR>
</TABLE>

\anchor Surface_reconstruction_points_3figcontouring_bench
\image html contouring_bench.jpg "Contouring duration (in s) and reconstruction error (mm) against several approximation distance parameters for the Bimba con Nastrino point set simplified to 120k points."

## Memory ##

We measure the memory occupancy for the reconstruction of the full
Bimba con Nastrino point set (3.8 millions points) as well as for
simplified versions.

The Poisson implicit function computation has a memory peak when
solving the Poisson linear system using the \sc{Taucs} sparse linear
solver. For large point sets, it may fail to allocate big chunks of
memory due to memory fragmentation.

The exact limit depends of the allocation scheme used by the
compiler. In our experiments, a PC running Linux 32 bits can
reconstruct the Bimba con Nastrino point set up to 1.6M points while
Windows 32 bits is limited to 1.3M points.

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
Number of points (x1000) 
<TD ALIGN=CENTER NOWRAP>
Memory occupancy (MBytes) 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
60 
<TD ALIGN=CENTER NOWRAP>
330 
<TR>
<TD ALIGN=CENTER NOWRAP>
120 
<TD ALIGN=CENTER NOWRAP>
660 
<TR>
<TD ALIGN=CENTER NOWRAP>
250 
<TD ALIGN=CENTER NOWRAP>
630 
<TR>
<TD ALIGN=CENTER NOWRAP>
500 
<TD ALIGN=CENTER NOWRAP>
980 
<TR>
<TD ALIGN=CENTER NOWRAP>
1000 
<TD ALIGN=CENTER NOWRAP>
1570 
<TR>
<TD ALIGN=CENTER NOWRAP>
1200 
<TD ALIGN=CENTER NOWRAP>
1939 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
</TABLE>

\anchor Surface_reconstruction_points_3figmemory_bench
\image html memory_bench.jpg "Memory occupancy (in MBytes) against number of points for the Bimba con Nastrino point set with 1.2M points as well as for simplified versions. The best fitting line is shown."

## Point Set Simplification ##

Due to the memory limitations described above, we recommend to
simplify the point sets captured by laser scanners.

We measure the reconstruction error for the Bimba con Nastrino point
set (1.6M points) as well as for simplified versions. All
reconstructions use the recommended contouring parameter approximation
distance = 0.25 * the input point set's average spacing.  The
reconstruction error is expressed as the average distance from input
points to the reconstructed surface in mm (the Bimba con Nastrino
statue is 324 mm tall).

<TABLE CELLSPACING=5 >
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
Number of points (x1000) 
<TD ALIGN=CENTER NOWRAP>
Reconstruction error (mm) 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
<TR>
<TD ALIGN=CENTER NOWRAP>
60 
<TD ALIGN=CENTER NOWRAP>
0.27 
<TR>
<TD ALIGN=CENTER NOWRAP>
120 
<TD ALIGN=CENTER NOWRAP>
0.15 
<TR>
<TD ALIGN=CENTER NOWRAP>
250 
<TD ALIGN=CENTER NOWRAP>
0.11 
<TR>
<TD ALIGN=CENTER NOWRAP>
500 
<TD ALIGN=CENTER NOWRAP>
0.079 
<TR>
<TD ALIGN=CENTER NOWRAP>
1,000 
<TD ALIGN=CENTER NOWRAP>
0.066 
<TR>
<TD ALIGN=CENTER NOWRAP>
1,500 
<TD ALIGN=CENTER NOWRAP>
0.061 
<TR>
<TD ALIGN=CENTER NOWRAP>
1,600 
<TD ALIGN=CENTER NOWRAP>
0.06 
<TR><TD ALIGN=LEFT NOWRAP COLSPAN=2><HR>
</TABLE>

\anchor Surface_reconstruction_points_3figsimplification_bench
\image html simplification_bench.jpg "Reconstruction error (mm) against number of points for the Bimba con Nastrino point set with 1.6M points as well as for simplified versions."

*/ 
} /* namespace CGAL */

