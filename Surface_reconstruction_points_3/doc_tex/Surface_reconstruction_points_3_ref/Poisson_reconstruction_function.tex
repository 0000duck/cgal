% +------------------------------------------------------------------------+
% | Reference manual page: Poisson_reconstruction_function.tex
% +------------------------------------------------------------------------+
% | 07.09.2007   Pierre Alliez, Laurent Saboret, Gael Guennebaud
% | Package: Surface_reconstruction_points_3
% |
\RCSdef{\RCSPoissonreconstructionfunctionRev}{$Id$}
\RCSdefDate{\RCSPoissonreconstructionfunctionDate}{$Date$}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Poisson_reconstruction_function<GeomTraits, ReconstructionTriangulation_3>}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

Kazhdan, Bolitho and Hoppe introduced the Poisson Surface Reconstruction algorithm \cite{Kazhdan06}. Given a set of 3D points with oriented normals sampled on the boundary of a 3D solid, this method solves for an approximate indicator function of the inferred solid, whose gradient best matches the input normals. The output scalar function, represented in an adaptive octree, is then iso-contoured using an adaptive marching cubes.

\ccc{Poisson_reconstruction_function} implements a variant of this algorithm which solves for a piecewise linear function on a 3D Delaunay triangulation instead of an adaptive octree the TAUCS sparse linear solver. In order to get a unique solution, one vertex outside of the surface is constrained to a value of 0.0.

%END-AUTO(\ccDefinition)

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccInclude)

\ccInclude{CGAL/Poisson_reconstruction_function.h}

%END-AUTO(\ccInclude)

\ccParameters

The class template declaration is:

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccParameters)

template$<$  \\
class Gt,   \\
class \ccc{ReconstructionTriangulation_3}$>$   \\
class \ccc{Poisson_reconstruction_function};

\ccCommentHeading{Parameters}
\begin{description}
\item \ccc{Gt}: Geometric traits class. \item \ccc{ReconstructionTriangulation_3}: 3D Delaunay triangulation, model of \ccc{ReconstructionTriangulation_3} concept. \end{description}

%END-AUTO(\ccParameters)

\ccIsModel

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccIsModel)

Model of the \ccc{ImplicitFunction} concept.

%END-AUTO(\ccIsModel)

\ccTypes

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\ccNestedType{Triangulation}
{
}
\ccGlue
\ccNestedType{Geom_traits}
{
Kernel's geometric traits.
}
\ccGlue
\ccNestedType{FT}
{
}
\ccGlue
\ccNestedType{Point}
{
== \ccc{Point_3<Gt>}
}
\ccGlue
\ccNestedType{Vector}
{
== \ccc{Vector_3<Gt>}
}
\ccGlue
\ccNestedType{Sphere}
{
}
\ccGlue
\ccNestedType{Point_with_normal}
{
Model of \ccc{PointWithNormal_3}.
}
\ccGlue
\ccNestedType{Normal}
{
Model of \ccc{Kernel::Vector_3} concept.
}
\ccGlue

%END-AUTO(\ccTypes)

\ccCreation
\ccCreationVariable{fct}  %% variable name for \ccMethod below

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\ccConstructor{Poisson_reconstruction_function(ReconstructionTriangulation_3& tr);}
{
Creates a scalar function from a set of oriented points. Inserts the iterator range [first, beyond) into the triangulation \ccc{tr}, refines it and solves for a piecewise linear scalar function which gradient best matches the input normals.
If \ccc{tr} is empty, this method creates an empty implicit function.
\ccCommentHeading{Parameters}
\ccc{tr}: \ccc{ReconstructionTriangulation_3} base of the Poisson indicator function. 
}
\ccGlue
\ccConstructor{template<class InputIterator> Poisson_reconstruction_function(ReconstructionTriangulation_3& tr, InputIterator first, InputIterator beyond);}
{
Creates a scalar function from a set of oriented points. Inserts the iterator range [first, beyond) into the triangulation \ccc{tr}, refines it and solves for a piecewise linear scalar function which gradient best matches the input normals.
\ccPrecond InputIterator \ccc{value_type} must be convertible to \ccc{Point_with_normal}.
\ccCommentHeading{Parameters}
\begin{description}
\item \ccc{tr}: \ccc{ReconstructionTriangulation_3} base of the Poisson indicator function. \item \ccc{first}: Iterator over first point to add. \item \ccc{beyond}: Past-the-end iterator to add. \end{description}
}
\ccGlue

%END-AUTO(\ccCreation)

\ccOperations

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccOperations)

\ccMethod{template<class InputIterator> int insert(InputIterator first, InputIterator beyond);}
{
Insert points.
\ccPrecond InputIterator \ccc{value_type} must be convertible to \ccc{Point_with_normal}.
\ccCommentHeading{Parameters}
\begin{description}
\item \ccc{first}: Iterator over first point to add. \item \ccc{beyond}: Past-the-end iterator to add. \end{description}
\ccCommentHeading{Returns} the number of inserted points.
}
\ccGlue
\ccMethod{void clear();}
{
Remove all points.
}
\ccGlue
\ccMethod{ReconstructionTriangulation_3& triangulation();}
{
Get embedded triangulation.
}
\ccGlue
\ccMethod{const ReconstructionTriangulation_3& triangulation() const;}
{
}
\ccGlue
\ccMethod{Sphere bounding_sphere() const;}
{
Returns a sphere bounding the inferred surface.
}
\ccGlue
\ccMethod{bool compute_implicit_function();}
{
The function \ccc{compute_implicit_function}() must be called after each insertion of oriented points. It computes the piecewise linear scalar function \ccc{f} by:\begin{itemize}
\item applying Delaunay refinement.\item solving for \ccc{f} at each vertex of the triangulation with a sparse linear solver.\item shifting and orienting \ccc{f} such that 'f = 0' at all input points and 'f$<$0' inside the inferred surface.\end{itemize}
Returns false if the linear solver fails.
}
\ccGlue
\ccMethod{FT f(const Point& p) const;}
{
Evaluates the implicit function at a given 3D query point.
}
\ccGlue
\ccMethod{FT operator()(const Point& p) const;}
{
\ccc{ImplicitFunction} interface: evaluate implicit function for any 3D point.
}
\ccGlue
\ccMethod{Point get_inner_point() const;}
{
Returns a point located inside the inferred surface.
}
\ccGlue

%END-AUTO(\ccOperations)

\ccSeeAlso

\ccRefIdfierPage{CGAL::Reconstruction_triangulation_3<GeomTraits, TriangulationDataStructure_3>}  \\
\ccRefIdfierPage{CGAL::Reconstruction_vertex_base_3<GeomTraits, TriangulationVertexBase_3>}  \\
\ccRefIdfierPage{CGAL::APSS_reconstruction_function<GeomTraits>}  \\

\ccExample

\ccIncludeExampleCode{Surface_reconstruction_points_3/poisson_reconstruction_example.cpp}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

