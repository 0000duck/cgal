\section{Poisson}

Given a set of 3D points with oriented normals (denoted oriented points in the sequel) sampled on the boundary of a 3D solid, the Poisson Surface Reconstruction method \cite{Kazhdan06} solves for an approximate indicator function of the inferred solid, whose gradient best matches the input normals. The output scalar function, represented in an adaptive octree, is then iso-contoured using an adaptive marching cubes.

\cgal\ implements a variant of this algorithm which solves for a piecewise linear function on a 3D Delaunay triangulation instead of an adaptive octree. The algorithm takes as input a set of 3D oriented points. It builds a 3D Delaunay triangulation from these points and refines it by Delaunay refinement so as to remove all badly shaped (non isotropic) tetrahedra and to tessellate a loose bounding box of the input oriented points. The normal of each Steiner point added during refinement is set to zero. It then solves for a scalar indicator function $f$ represented as a piecewise linear function over the refined triangulation. More specifically, it solves for the Poisson equation  $\Delta f = div(\mathbf{n})$ at each vertex of the triangulation using a sparse linear solver. Eventually, the \cgal\ surface mesh generator extracts an isosurface with function value set by default to be the median value of $f$ at all input points.

\subsection{Interface}

The class template declaration is:

template$<$  \\
class Gt,   \\
class \ccc{ReconstructionTriangulation_3} = \ccc{Reconstruction_triangulation_3<Gt>}$>$   \\
class \ccc{Poisson_reconstruction_function};
\ccGlue
\ccCommentHeading{Parameters}
\begin{description}
\item \ccc{Gt}: Geometric traits class. \item \ccc{ReconstructionTriangulation_3}: 3D Delaunay triangulation class derived from \ccc{Reconstruction_triangulation_3}. \end{description}

The main constructor is:

\ccFunction{template<typename InputIterator, typename PointPMap, typename NormalPMap> Poisson_reconstruction_function(InputIterator first, InputIterator beyond, PointPMap point_pmap, NormalPMap normal_pmap);}
{
Creates a Poisson implicit function from the [first, beyond) range of vertices.
\ccCommentHeading{Template Parameters}
\begin{description}
\item \ccc{InputIterator}: iterator over input points. \item \ccc{PointPMap}: is a model of \ccc{boost::ReadablePropertyMap} with a \ccc{value_type} = \ccc{Point_3<Gt>}. It can be omitted if InputIterator \ccc{value_type} is convertible to \ccc{Point_3<Gt>}. \item \ccc{NormalPMap}: is a model of \ccc{boost::ReadablePropertyMap} with a \ccc{value_type} = \ccc{Vector_3<Gt>}. \end{description}
\ccCommentHeading{Parameters}
\begin{description}
\item \ccc{first}: iterator over the first input point. \item \ccc{beyond}: past-the-end iterator. \item \ccc{point_pmap}: property map InputIterator -$>$ \ccc{Point_3}. \item \ccc{normal_pmap}: property map InputIterator -$>$ \ccc{Vector_3}. \end{description}
}

The main methods are:

\ccFunction{bool compute_implicit_function();}
{
The function \ccc{compute_implicit_function}() must be called after each insertion of oriented points. It computes the piecewise linear scalar function \ccc{f} by:\begin{itemize}
\item applying Delaunay refinement.\item solving for \ccc{f} at each vertex of the triangulation with a sparse linear solver.\item shifting and orienting \ccc{f} such that 'f = 0' at all input points and 'f$<$0' inside the inferred surface.\end{itemize}
Returns false if the linear solver fails.
}
\ccGlue
\ccFunction{FT value(const Point& p) const;}
{
Evaluates the implicit function at a given 3D query point.
}
\ccGlue
\ccFunction{Point get_inner_point() const;}
{
Returns a point located inside the inferred surface.
}
\ccFunction{Sphere bounding_sphere() const;}
{
Returns a sphere bounding the inferred surface.
}

See details in \\
\ccRefIdfierPage{CGAL::Poisson_reconstruction_function<GeomTraits, ReconstructionTriangulation_3>}


\subsection{Example}

\ccc{poisson_reconstruction_example.cpp} reads a point set, creates a Poisson implicit function and reconstructs a surface.

% I feel like we should further simplify it by providing
% just a list of oriented points.
\ccIncludeExampleCode{Surface_reconstruction_points_3/poisson_reconstruction_example.cpp}


