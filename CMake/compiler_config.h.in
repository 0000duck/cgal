//
// compiler_config.h is included by CGAL headers to load the needed compiler settings.
//
// DO NOT EDIT compiler_config.h. It is generated by CMake from compiler_config.h.in.
//

//+--------------------------------------------------------------------------
//| This flag is set, if the compiler ICEs on some combination of boolean
//| and (&&) within template boolean arguments. (e.g. g++ 3.3).
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_BOOL_IN_TEMPLATE_BUG

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_CCTYPE_MACRO_BUG is set, if a compiler defines the
//| standard C library functions in cctype (isdigit etc.) as macros.
//| According to the standard they have to be functions.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_CCTYPE_MACRO_BUG

//+--------------------------------------------------------------------------
//| This flag is set, if the compiler does not properly parse comma separated
//| expressions in a base constructor call. (e.g. g++ 3.3).
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_COMMA_BUG

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_CONVERSION_OPERATOR_BUG is set, if a compiler
//| crashes with some conversion operators.  G++ 3.3.0 is affected by
//| this bug (it hits Darwin severely since it is the system compiler).
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_CONVERSION_OPERATOR_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler wants you to remove the word
//| template in some complicated dependent types.
//| Any error with the message "Unexpected type name" is likely to be
//| related to this bug in sunpro.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_DEEP_DEPENDENT_TEMPLATE_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler bugs when handling denormal values at
//| compile time.  At least PGCC 5.1-3 has the bug.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_DENORMALS_COMPILE_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler bugs with special features with IEEE 754
//| handling, concerning is_valid() and is_finite() testing of infinity and
//| nans.  The workaround is to use bitfield operations.
//| At least VC++, Borland and PGCC have the bug.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_IEEE_754_BUG

//+--------------------------------------------------------------------------
//| This flag is set, if the executable does not properly parse an int followed by a comma
//| Can you believe it!!!
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_ISTREAM_INT_BUG

//+--------------------------------------------------------------------------
//| If a compiler (or assembler or linker) has problems with long names
//| CGAL_CFG_LONGNAME_BUG is set.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_LONGNAME_BUG

//+--------------------------------------------------------------------------
//| This flag is set, if the compiler does not match function arguments
//| of pointer type correctly, when the return type depends on
//| the parameter's type. (e.g. sun C++ 5.3)
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_MATCHING_BUG_3

//+--------------------------------------------------------------------------
//| This flag is set, if a compiler cannot distinguish the signature
//| of overloaded function templates, which have arguments whose type
//| depends on the template parameter.
//| This bug appears for example on Sunpro 5.3 and 5.4.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_MATCHING_BUG_4

//+--------------------------------------------------------------------------
//| This flag is set, if a compiler cannot distinguish the signature
//| of overloaded function templates, which have one template parameter
//| to be passed explicitely when being called.
//| This bug appears for example on g++ 3.3 and 3.4.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_MATCHING_BUG_5

//+--------------------------------------------------------------------------
//| VC 7.3 does not recognize when an operator in a class
//| redefines the operator with the same signature in a base class
//| It happens with the regular triangulation.
//| No minimal testcase yet
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_MATCHING_BUG_6

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_MISSING_TEMPLATE_VECTOR_CONSTRUCTORS_BUG is set,
//| if the std::vector class does not have defined template constructors.
//| This is a feature of SunPro 5.5.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_MISSING_TEMPLATE_VECTOR_CONSTRUCTORS_BUG

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_NESTED_CLASS_FRIEND_DECLARATION_BUG.C is set
//| if the compiler cannot recognize the declaration of a nested
//| class as friend.
//| Compilers such as the Intel compiler 8.x (for linux or windows),
//| MSVC 7.1 or pgCC have this "bug". It should be noted that the C++
//| standard is a bit vague on this issue, in other words what is referred
//| to as "bug" above, may not really be a bug. Hopefully, the next standard
//| will resolve this issue.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NESTED_CLASS_FRIEND_DECLARATION_BUG

//+--------------------------------------------------------------------------
//| This flag is set, if the compiler does not match a member
//| definition to an existing declaration (eg., cl1310 Beta).
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NET2003_MATCHING_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler doesn't support the operator Koenig
//| lookup. That is, it does not search in the namespace of the arguments for
//| the function.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_KOENIG_LOOKUP

//+--------------------------------------------------------------------------
//| If a compiler doesn't know <limits> (g++-2.95)
//| or has a bug in the implementation (Sun CC 5.4, MipsPro CC)
//| CGAL_CFG_NO_LIMITS is set.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_LIMITS

//+--------------------------------------------------------------------------
//| If a compiler doesn't know the locale classic
//| CGAL_CFG_NO_LOCALE is set.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_LOCALE

//+--------------------------------------------------------------------------
//| Tests if std::cout supports long double IO.
//| pgCC 5.2-2 has this bug (only has for double and float).
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_LONG_DOUBLE_IO

//+--------------------------------------------------------------------------
//| The long long built-in integral type is not part of the ISO C++ standard,
//| but many compilers support it nevertheless since it's part of the ISO
//| C standard.
//| The following definition is set if it is supported.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_LONG_LONG

//+--------------------------------------------------------------------------
//| If a compiler doesn't know nextafter() (or only knows _nextafter as VC++ 7.1).
//| nextafter() is part of ISO C99, but not ISO C++98 (hence <math.h> instead of <cmath>).
//| CGAL_CFG_NO_NEXTAFTER is set.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_NEXTAFTER

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_NO_STDC_NAMESPACE is set, if a compiler does not
//| put the parts of the standard library inherited from the standard
//| C library in namespace std. (only tests for the symbols used in CGAL)
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_STDC_NAMESPACE

//+--------------------------------------------------------------------------
//| A basic test for the STL.
//| If it fails, it probably means a bad CGAL installation.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_STL

//+--------------------------------------------------------------------------
//| G++ 2.95.2 has problems with member functions implemented outside of
//| the class body if this member function has a parameter type that is
//| dependant on a template in the template parameter list of the class. A
//| workaround would be to implement the member function inline in the class.
//| The following definition is set if this error error occurs.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_TMPL_IN_TMPL_DEPENDING_FUNCTION_PARAM

//+--------------------------------------------------------------------------
//| Nested templates in template parameter, such as 'template <
//| template <class T> class A>' are not supported by any compiler.
//| The following definition is set if they are not supported.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_TMPL_IN_TMPL_PARAM

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_NO_TWO_STAGE_NAME_LOOKUP is set,
//| if a compiler does not support the two stage name lookup.
//| This is a bug of G++ < 3.4 for example.
//| Note that the program fails when the feature works,
//| which is different from the other test programs.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_TWO_STAGE_NAME_LOOKUP

//+--------------------------------------------------------------------------
//| This flag is set if the compiler bugs with std::numeric_limits
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NUMERIC_LIMITS_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler complains about an ambiguity between
//| a type and itself when some members are defined out of line. This is
//| a Sun CC bug.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_OUTOFLINE_MEMBER_DEFINITION_BUG

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_OUTOFLINE_TEMPLATE_MEMBER_DEFINITION_BUG_2 is set,
//| if a compiler does not support the definition of member templates
//| out of line, i.e. outside class scope. The solution is to put the
//| definition inside the class.
//| The difference with CGAL_CFG_OUTOFLINE_TEMPLATE_MEMBER_DEFINITION_BUG
//| is the return type of the member template.SunPro 5.5 should be OK with
//| this code.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_OUTOFLINE_TEMPLATE_MEMBER_DEFINITION_BUG_2

//+--------------------------------------------------------------------------
//| The flag CGAL_CFG_OUTOFLINE_TEMPLATE_MEMBER_DEFINITION_BUG is set,
//| if a compiler does not support the definition of member templates
//| out of line, i.e. outside class scope. The solution is to put the
//| definition inside the class. This is a feature of SunPro 5.5.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_OUTOFLINE_TEMPLATE_MEMBER_DEFINITION_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler is Sun's compiler and it uses the
//| old Rogue Wave STL.
//| The workarounds consist in faking iterator_traits and using a wrapper
//| to reverse_iterator
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_SUNPRO_RWSTD

//+--------------------------------------------------------------------------
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_TYPENAME_BEFORE_DEFAULT_ARGUMENT_BUG

//+--------------------------------------------------------------------------
//| This flag is set if the compiler bugs with some "using Base::Member;" in
//| a derived class.  The workaround is to write a forwarder or not use using.
//| At least SunPro CC 5.3 has this bug where the typical error message is :
//| "Error: The function B<int>::g() has not had a body defined."
//| Note that the subtlely is that the error message does not mention
//| "Member"...
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_USING_BASE_MEMBER_BUG_2

//+--------------------------------------------------------------------------
//| This flag is set if the compiler bugs with some "using Base::Member;" in
//| a derived class, when there is a typedef of the base class.
//| The workaround is to write a forwarder or not use using.
//| At least MipsPRO CC 7.4 has this bug.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_USING_BASE_MEMBER_BUG_3

//+--------------------------------------------------------------------------
//| This flag is set if the compiler doesn't support "using Base::Member;" in
//| a derived class.  The workaround is to write a forwarder.
//| At least g++ 2.95 and SunPro CC 5.3 have this bug.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_USING_BASE_MEMBER_BUG

//+--------------------------------------------------------------------------
//| Tests if the input stream operator<< is correct with long long.
//| pgCC 6.2 has this bug.
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_LONG_LONG_IO_BUG

//+--------------------------------------------------------------------------
//| If a compiler does not support delegating constructors (from C++0x)
//| CGAL_CFG_NO_DELEGATING_CONSTRUCTORS is set. 
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_DELEGATING_CONSTRUCTORS

//+--------------------------------------------------------------------------
//| If a compiler does not support variadic templates (from C++0x)
//| CGAL_CFG_NO_VARIADIC_TEMPLATES is set. 
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_VARIADIC_TEMPLATES

//+--------------------------------------------------------------------------
//| If a compiler does not support rvalue references (from C++0x)
//| CGAL_CFG_NO_RVALUE_REFERENCE is set. 
//+--------------------------------------------------------------------------
#cmakedefine CGAL_CFG_NO_RVALUE_REFERENCE

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for BOOST?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_BOOST
    #cmakedefine CGAL_USE_BOOST

    // TODO: set CGAL_BOOST_VERSION
/*    #ifdef CGAL_USE_BOOST
        #include <boost/version.hpp>
        #define CGAL_BOOST_VERSION BOOST_VERSION/100000 \
                                   ## . ## (BOOST_VERSION/100)%100 \
                                   ## . ## BOOST_VERSION%100
    #endif*/
#endif // ! CGAL_NO_BOOST

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for BOOST_PROGRAM_OPTIONS?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_BOOST_PROGRAM_OPTIONS
    #cmakedefine CGAL_USE_BOOST_PROGRAM_OPTIONS
    // TODO: set CGAL_BOOST_PROGRAM_OPTIONS_VERSION
#endif // ! CGAL_NO_BOOST_PROGRAM_OPTIONS

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for X11?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_X11
    #cmakedefine CGAL_USE_X11

    // TODO: set CGAL_X11_VERSION
/*    #ifdef CGAL_USE_X11
        #include <X11/Xlib.h>
        #define CGAL_X11_VERSION X_PROTOCOL ## . ## X_PROTOCOL_REVISION
    #endif*/
#endif // ! CGAL_NO_X11

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for GMP?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_GMP
    #cmakedefine CGAL_USE_GMP

    // TODO: set CGAL_GMP_VERSION
/*    #ifdef CGAL_USE_GMP
        #include "gmp.h"
        #define CGAL_GMP_VERSION __GNU_MP_VERSION \
                                 ## . ## __GNU_MP_VERSION_MINOR \
                                 ## . ## __GNU_MP_VERSION_PATCHLEVEL
    #endif*/
#endif // ! CGAL_NO_GMP

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for GMPXX?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_GMPXX
    #cmakedefine CGAL_USE_GMPXX

    // TODO: set CGAL_GMPXX_VERSION
/*    #ifdef CGAL_USE_GMPXX
        #include <gmpxx.h>
        #define CGAL_GMPXX_VERSION __GNU_MP_VERSION \
                                   ## . ## __GNU_MP_VERSION_MINOR \
                                   ## . ## __GNU_MP_VERSION_PATCHLEVEL
    #endif*/
#endif // ! CGAL_NO_GMPXX

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for MPFR?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_MPFR
    #cmakedefine CGAL_USE_MPFR

    // TODO: set CGAL_MPFR_VERSION
/*    #ifdef CGAL_USE_MPFR
        #include "mpfr.h"
        #ifdef MPFR_VERSION
            #define CGAL_MPFR_VERSION MPFR_VERSION_MAJOR \
                                      ## . ## MPFR_VERSION_MINOR \
                                      ## . ## MPFR_VERSION_PATCHLEVEL
        #else
            #define CGAL_MPFR_VERSION unknown
        #endif
    #endif*/
#endif // ! CGAL_NO_MPFR

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for CORE?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_CORE
    #cmakedefine CGAL_USE_CORE
    // CORE does not have VERSION macros yet (as of december 2005).
    #define CGAL_CORE_VERSION unknown
#endif // ! CGAL_NO_CORE

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for ZLIB?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_ZLIB
    #cmakedefine CGAL_USE_ZLIB

    // TODO: set CGAL_ZLIB_VERSION
/*    #ifdef CGAL_USE_ZLIB
        #include <zlib.h>
        #define CGAL_ZLIB_VERSION zlibVersion()
    #endif*/
#endif // ! CGAL_NO_ZLIB

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for LIDIA?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_LIDIA
    #cmakedefine CGAL_USE_LIDIA
    // TODO: set CGAL_LIDIA_VERSION
#endif // ! CGAL_NO_LIDIA

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for LEDA?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_LEDA
    #cmakedefine CGAL_USE_LEDA

    // TODO: set CGAL_LEDA_VERSION
/*    #ifdef CGAL_USE_LEDA
        #ifdef HAVE_LEDA5X
            #include <LEDA/system/basic.h>
        #else
            #include <LEDA/basic.h>
        #endif
        #define CGAL_LEDA_VERSION __LEDA__
    #endif*/
#endif // ! CGAL_NO_LEDA

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for LEDAWIN?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_LEDAWIN
    #cmakedefine CGAL_USE_LEDAWIN
    // TODO: set CGAL_LEDAWIN_VERSION
#endif // ! CGAL_NO_LEDAWIN

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for QT?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_QT
    #cmakedefine CGAL_USE_QT

    // TODO: set CGAL_QT_VERSION
/*    #ifdef CGAL_USE_QT
        #include <qglobal.h>
        #define CGAL_QT_VERSION QT_VERSION_STR
    #endif*/
#endif // ! CGAL_NO_QT

//+--------------------------------------------------------------------------
//| Is CGAL compiled with support for TAUCS?
//+--------------------------------------------------------------------------
#ifndef CGAL_NO_TAUCS
    #cmakedefine CGAL_USE_TAUCS

    #ifdef CGAL_USE_TAUCS
        // TAUCS provides no version number :-(
        // Version 1 is obsolete, thus we assume version 2 (latest is 2.2 on 03/2006)
        #define CGAL_TAUCS_VERSION 2.x
    #endif
#endif // ! CGAL_NO_TAUCS

