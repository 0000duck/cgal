% +------------------------------------------------------------------------+
% | Reference manual page: shortest_path_2.tex
% +------------------------------------------------------------------------+
% | Package: Visibility_complex
% +------------------------------------------------------------------------+

\begin{ccRefClass}{Shortest_path_2<VC2GeomTraits,VC2Items>}

\ccDefinition

A class that computes the shortest path between points in a planar scene
made of convex objects and constraints. The first template parameter is a
geometric traits class, model of \ccc{VC2GeomTraits} (the class
\ccc{Visibility_complex_circle_traits} is not powerful enough to be used
here, but the other traits classes are). The second template parameter,
defaulting to \ccc{Shortest_path_2_items} is an items class used to define
the vertices, edges and faces of the complex.

\ccInclude{CGAL/Shortest_path_2.h}


\ccTypes
\ccTwo{VisibilityComplex::Vertex_iterator}{}

\ccNestedType{Gt} {the geometric traits class.}
\ccGlue
\ccNestedType{Visibility_complex_2}
{Defined as \ccc{Visibility_complex_2<Gt,It>}.}
\ccNestedType{Items}{items class, model of the \ccc{VC2Items}
		      concept.}
\ccGlue
\ccNestedType{Vertex}{Vertex type. Forwarded from \ccc{Visibility_complex_2}.}
\ccGlue
\ccNestedType{Edge}{Edge type. Forwarded from \ccc{Visibility_complex_2}.}
\ccGlue
\ccNestedType{Face}{Face type. Forwarded from \ccc{Visibility_complex_2}.}

\ccCreation
\ccCreationVariable{sp}
\ccConstructor{Shortest_path_2();}{Default constructor}
\ccConstructor{Shortest_path_2(Visibility_complex_2);}{Build over a
visibility complex previously built. The set of disks of this complex should
contain the points between which shortest paths are to be computed,
converted into disks using the functor \ccc{Gt::Make_disk_from_point}.}

\ccOperations

\ccMethod{void compute_shortest_paths(const Disk& d);}{\ccc{d} should be
a reference to a point-disk from the scene, copied into the underlying
complex. This method computes the shortest path from
\ccc{d} to the other point-disks in the scene. It can be called multiple
times.}
\ccMethod{template <class OutputIterator>
std::pair<GT::Distance_NT,OutputIterator>
get_path_vertices(Disk_handle t, OutputIterator result); const}
{\ccc{t} should be a point-disk, and \ccc{compute_shortest_paths} should
already have been called upon a point-disk. Let \ccc{s} be the point disk
passed to the latest call of \ccc{compute_shortest_paths}. This method returns
through \ccc{result} the shortest path from \ccc{s} to \ccc{t}, given as a
sequence of handles from type \ccc{Visibility_complex_2::Vertex_handle}
to the vertices in the underlying complex. 
The result of the function call is a pair made of the
length of the path, and last value of the iterator.}
\ccMethod{template <class OutputIterator>
std::pair<GT::Distance_NT,OutputIterator>
get_path_bitangents(Disk_handle t, OutputIterator result);const}
{The same, except \ccc{result} receives copies of bitangents instead of
handles to vertices.}


\ccSeeAlso

\ccRefIdfierPage{CGAL::Visibility_complex_2<VC2GeomTraits,VC2Items>}\\
\ccRefIdfierPage{CGAL::Shortest_path_2_items}

\ccImplementation

The visibility graph of the input scene plus the two points is computed in
time $O(k + n \log n)$ and $O(k)$ space where $n$ and $k$ are respectively
the size of the input and output.  A Dijsktra algorithm is then applied to
get the shortest path. We have implemented the Dijsktra algorithm using a
\ccc{stl::set} thus resulting in a $O(k \log n)$ time complexity.


\ccTagDefaults
\end{ccRefClass}
\ccRefPageEnd
