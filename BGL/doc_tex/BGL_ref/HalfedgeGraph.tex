%% Copyright (c) 2004  SciSoft.  All rights reserved.
%%
%% This file is part of CGAL (www.cgal.org); you may redistribute it under
%% the terms of the Q Public License version 1.0.
%% See the file LICENSE.QPL distributed with CGAL.
%%
%% Licensees holding a valid commercial license may use this file in
%% accordance with the commercial license agreement provided with the software.
%%
%% This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
%% WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
%%
%% 
%%
%% Author(s)     : Fernando Cacciola <fernando_cacciola@hotmail.com>

\begin{ccRefConcept}{HalfedgeGraph}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition

The concept \ccRefName\ describes the requirements of a basic
\ccAnchor{http://www.boost.org/libs/graph/doc/graph_concepts.html}{Bgl Graph}
commonly found associated to many geometric data structures.

\ccHeading{Requirements}

Vertices and edges are required to have a distinguishable \ccc{null} state 
such that any default constructed vertex or edge descriptor is formally
referring to a non-existing vertex or edge.

All edges are {\em directed}, that is, they are defined as an {\em ordered pair} 
of vertices, and for each directed edge $\overrightarrow{st}$
it's opposite edge $\overrightarrow{ts}$ is part of the graph.

Because (directed) edges must come in pairs, there is the additional
notion of an {\em undirected} edge for a pair of opposing edges.
The number of undirected edges is exactly half the number of directed edges.

The directed edges are not called \ccc{halfedges} (as in a
\ccc{HalfedgeDS}) because from the point of view of this graph, being
a refinement of a {\sc Bgl} graph, each directed edge is an
edge in itself. In other words, the unqualified term edge
refers to one and only one directed edge and not to a pair. The
pair of opposite edges, seen as a unity, is an {\em undirected edge}.
 
Note that this concept does not imply the existence of two different types
for directed and undirected edges. Instead, if specifies that there is only one type of edge,
hence only one \ccc{edge_descriptor}, which refers to the directed edge.\\
An undirected edge must be implicitely addressed by a single \ccc{edge_descriptor},
and there is no requirement about which of the directed edges of the pair must
be used to refer to an undirected edge.

All edges are {\em cyclically connected} and each cycle implicitely
corresponds to a \ccc{facet} (or \ccc{face} or \ccc{cell}) of the
underlying data structure (with the exception of the cycle(s)
corresponding to the border(s) of the underlying DS, which might not
have an associated facet).

Edges in this graph are {\em ordered} according to the following relations:

\begin{description}

\item[Opposite] 
An edge $'v: x->y'$ is said to be the {\em opposite} of edge $'u: a->b'$ 
iff $a==y$ and $b==c$.

\item[Rotational Successor] 
An edge $'v: s->q'$ is said to be the {\em rotational successor} 
of edge $'u: s->p'$ iff $v$ is the {\em first} edge with source vertex $s$
found by a {\em counter-clockwise} rotation of $u$ around its source 
vertex $s$ such that $u!=v$.
 
\item[Rotational Predecessor] 
An edge $'v: s->q'$ is said to be the {\em rotational predecessor}
of edge $'u: s->p'$ iff $v$ is the {\em first} edge with source vertex $s$
found by a {\em clockwise} rotation of $u$ around its source vertex $s$
such that $u!=v$.

\item[Linear Successor] 
An edge $'v: b->c'$ is said to be the {\em linear successor} of edge 
$'u:a->b'$ iff $v$ is the {\em rotational successor} of the 
{\em opposite} of $v$.
 
\item[Linear Predecessor] 
An edge $'v: b->c'$ is said to be the {\em linear predecessor} of edge 
$'u:a->b'$ iff $v$ is the {\em opposite} of the {\em rotational predecessor}
of $v$.

\end{description}

\ccRefines
\ccAnchor{http://www.boost.org/libs/graph/doc/PropertyGraph.html}{PropertyGraph}

A model of this graph is required to have the {\em interior properties} \ccc{edge_is_border} and \ccc{vertex_is_border} attached to its edges and vertices.

\ccTypes
  \ccNestedType{undirected_edge_iterator}
  {An iterator that iterates over one and only one of the directed edges
  in each opposing pair. This iterator accesses a directed edge 
  (as represented by an \ccc{edge_descriptor}) and not an undirected edge 
  since there is no type explicitely representing it}{}

\ccOperations

Following the {\sc Bgl} design, the following graph operations are defined as free rather than member functions.

All overloads have a non-const version (ommited here for brevity).

  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  opposite_edge(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em opposite} of \ccc{e}.}
  
  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  next_edge_ccw(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em rotational successor} of \ccc{e}.\\
  If the resulting edge does not belong to \ccc{g} the result is a \ccc{null} (default constructed) edge.}
  
  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  next_edge_cw(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em rotational predecessor} of \ccc{e}.\\
  If the resulting edge does not belong to \ccc{g} the result is a \ccc{null} (default constructed) edge.}
  
  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  next_edge(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em linear successor} of \ccc{e}.\\
  If the resulting edge does not belong to \ccc{g} the result is a \ccc{null} (default constructed) edge. }
  
  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  prev_edge(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em linear predecessor} of \ccc{e}.\\
  If the resulting edge does not belong to \ccc{g} the result is a \ccc{null} (default constructed) edge. }

\ccHasModels
\ccRefIdfierPage{boost::graph_traits< CGAL::Polyhedron_3<Traits> > }\\
\ccRefIdfierPage{CGAL::halfedge_graph_traits< CGAL::Polyhedron_3<Traits> > }

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+
