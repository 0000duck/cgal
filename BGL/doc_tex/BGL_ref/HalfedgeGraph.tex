%% Copyright (c) 2004  SciSoft.  All rights reserved.
%%
%% This file is part of CGAL (www.cgal.org); you may redistribute it under
%% the terms of the Q Public License version 1.0.
%% See the file LICENSE.QPL distributed with CGAL.
%%
%% Licensees holding a valid commercial license may use this file in
%% accordance with the commercial license agreement provided with the software.
%%
%% This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
%% WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
%%
%% 
%%
%% Author(s)     : Fernando Cacciola <fernando_cacciola@hotmail.com>

\begin{ccRefConcept}{HalfedgeGraph}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition

The concept \ccRefName\ describes the requirements and constrians of a \ccc{Boost Graph} representing a subset of a \ccc{HalfedgeDS}.

This is a \ccc{ConnectedPlanarDirectedGeometricGraph} with the added requirement that for each directed edge \ccc{s->t} it's opposite edge \ccc{t->s} is part of the graph, that is, the directed edges are neccesarily symmetric. Furthermore, becasue the symmetry is mandatory, there is the added concept of an {\em undirected} edge which corresponds to both symmetric edges as a whole.
 
The graph is strictly {\em 4-connected}, that is, each vertex has exactly 4 incident edges. Furthermore, it is strictly {\em 2-connected} in each direction, that is, each vertex has 2 {\em incoming} and 2 {\em outgoing} edges, and each incoming edge is followed by one outgoing edge.\\
For every vertex \ccc{b} there are exactly 4 incident edges: \ccc{a->b}, \ccc{b->a}, \ccc{b->c} and \ccc{c->b} with \ccc{c!=a}. Edge \ccc{b->c} is called the {\em successor} of edge \ccc{a->b}, while edge \ccc{a->b} is called the {\em predeccesor} of edge \ccc{b->c}. Each and every edge is required to have a successor and a predecessor, hence the graph must have at least 3 vertices and 6 edges. 

For each pair of {\em symmetric directed edges} \ccc{s->t} and \ccc{t->s}, there is a correspoding {\em undirected} edge \ccc{s-t}. Therefore, the number of undirected edges is exactly half the number of directed edges.

{\em Symmetric directed edges} are NOT called \ccc{halfedges} (as in a \ccc{HalfedgeDS}) because from the point of view of this graph, being a refinement of a BGL graph, each symmetric directed edge is a {\em whole} edge in itself. In other words, the unqualified term edge refers to one and only one symmetric directed edge and not both. The pair of opposing edges, seen as a unity, is an {\em undirected edge}. Such an undirected edge refers to the pair of opposing edges and this concept does not require the existence of a texplicit ype representing that. In other words, there is only one type of edge, hence only one \ccc{edge\_descriptor}, which refers to the directed edge. An undirected edge is implicitely addressed by an edge\_descriptor. There is no requirement about which of the directed edges of the pair must be used to refer to an undirected edge.

All edges are {\em cyclically connected} and each cycle implicitely corresponds to a \ccc{facet} (or \ccc{face} or \ccc{cell}) of the underlying data structure (with the exception of the cycle(s) corresponding to the border(s) of the underlying DS, which might not have an associated facet).


\ccRefines
\ccc{ConnectedPlanarDirectedGeometricGraph}

\ccTypes
  \ccNestedType{undirected_edge_iterator}{An iterator that iterates over one and only one of the directed edges
  in each opposing pair. This iterator accesses a directed edge (as represented by an \ccc{edge_descriptor})
  and not an undirected edge since there is no such kind of edge explicitely}{}
  
\ccOperations

Following the BGL interface, the following graph operations are defined as free rather than member functions.

  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  next_edge(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em successor} of \ccc{e}.
  That is, given the edge \ccc{a->b} returns \ccc{b->c} such that \ccc{c != a}.\\
  [non-const version ommited]
  }
  
  \ccFunction
  {template<class Graph>
  typename boost::graph_traits<Graph const>::edge_descriptor 
  prev_edge(typename boost::graph_traits<Graph const>::edge_descriptor e, Graph const& g );
  }
  {Returns the {\em predecessor} of \ccc{e}.
  That is, given the edge \ccc{b->c} returns \ccc{a->b} such that \ccc{c != a}\\
  [non-const version ommited]
  }
  
  \ccFunction
  {template<class Graph>
  std::pair < typename boost::halfedge_graph_traits<Graph const>::edge_descriptor
             ,typename boost::halfedge_graph_traits<Graph const>::edge_descriptor
             >   
  undirected_edges(Graph const& g );
  }
  {Returns a pair of iterators representing the range [begin,end) of undirected edges in this graph.
  [non-const version ommited]
  }

\ccHasModels
\ccRefIdfierPage{CGAL::halfedge_graph_traits< CGAL::Polyhedron_3<Traits> const > }\\
\ccRefIdfierPage{CGAL::halfedge_graph_traits< CGAL::Polyhedron_3<Traits> > }\\

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+
