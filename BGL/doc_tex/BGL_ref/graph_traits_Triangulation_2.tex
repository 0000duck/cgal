

 \ccDefGlobalScope{boost::}
\begin{ccRefClass}{graph_traits< CGAL::Triangulation_2<GT, TDS> >}

\ccDefinition
  
The triangulations of \cgal\ are all models of the concepts \ccc{BidirectionalGraph} and 
\ccc{VertexAndEdgeListGraph}  of the Boost Graph Library \cite{cgal:sll-bgl-02}.

The class \ccRefName\ is a partial specialization of the class 
\ccAnchor{http://www.boost.org/libs/graph/doc/graph_traits.html}
{\ccc{boost::graph_traits<G>}}.


The mapping between vertices and edges of the triangulation and the
graph is rather straightforward, but there are some subtleties. The
value type of the {\sc Bgl} iterators is the vertex or edge descriptor,
whereas in \cgal\ all iterators and circulators are also handles and
hence have as value type Vertex or Edge.

The graph traits class for triangulations does not distinguish between
finite and infinite vertices and edges. As the edge weight computed
with the default property map of {\sc Bgl}\ algorithms (obtained with
\ccc{boost::get(t, boost::edge_weight)}) is the length of the edge, 
the edge weight is not well defined for infinite edges. For algorithms 
that make use of the edge weight the user must therefore
define a \ccAnchor{http://www.boost.org/libs/graph/doc/filtered_graph.html}
{\ccc{boost::filtered_graph}} or pass a property map to the
algorithm that returns ``infinity'' for infinite edges. 


Note also that when you derive from the class \ccc{CGAL::Triangulation_2}
you must upcast the object in order to use this partial specialization.

For the user convenience, \cgal\ provides the partial specializations
for all 2D triangulation classes.





\ccInclude{CGAL/boost/graph/graph_traits_Triangulation_2.h}

\ccTypes

\ccTypedef{typedef Triangulation::Vertex_handle vertex_descriptor;}{The vertex descriptor.}
\ccNestedType{edge_descriptor}{The edge descriptor. It is constructible from and convertible to \ccc{Triangulation::Edge}.
              The edge descriptor is not a simple typedef, but a proper class, 
              because in an undirected graph
              the  edges \ccc{(u,v)} and \ccc{(v,u)} must be equal. This is not the case
              for the Edge type of the triangulation.}


\ccNestedType{vertex_iterator}{The vertex iterator type. Its value type is \ccc{vertex_descriptor}.}
\ccNestedType{edge_iterator}{The edge iterator type, Its value type is \ccc{edge_descriptor}.}

\ccNestedType{out_edge_iterator}{An iterator for the outgoing edges incident to a vertex. 
Its value type is \ccc{edge_descriptor}.}
\ccNestedType{in_edge_iterator}{An iterator for the incoming edges incident to a vertex. 
Its value type is \ccc{edge_descriptor}.}
\ccNestedType{adjacency_iterator}{An iterator for the vertices adjacent to a vertex.
 Its value type is \ccc{vertex_descriptor}.}


\ccTypedef{typedef boost::undirected_tag directed_category;}{}
\ccTypedef{typedef boost::disallow_parallel_edge_tag edge_parallel_category;}{}

%\ccSeeAlso

%\ccRefIdfierPage{Error}  

\end{ccRefClass}
 \ccDefGlobalScope{CGAL::} % empty global scope
% EOF





