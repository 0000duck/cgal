\begin{ccRefClass} {Residue}
\label{Residue}

\def\ccTagOperatorLayout{\ccFalse}

\ccDefinition

The class \ccRefName\ represents a finite field $\Z{/p\Z}$, 
for some prime number $p$. \\

The prime number $p$ is stored in a static member variable. 
The class provides static member functions to change this value. 
{\bf Note that changing the prime invalidates already existing objects 
of this type.}
However, already existing objects do not lose their value with respect to the 
old prime and can be reused after restoring the old prime. 
Since the type is based on double 
arithmetic the prime is restricted to values less than $2^{26}$. 
The initial value of $p$ is 67111067. 

In case the flag \ccc{CGAL_HAS_THREADS} 
is undefined the prime is just stored in a static member 
of the class, that is, \ccRefName\ is not thread-safe in this case.  
In case \ccc{CGAL_HAS_THREADS}
the implementation of the class is thread safe using 
\ccc{boost::thread_specific_ptr}. However, this may cause some performance 
penalty. Hence, it may be advisable to configure \ccc{CGAL} with 
\ccc{CGAL_HAS_NO_THREADS}. 

\ccInclude{CGAL/Residue.h}

\ccIsModel
\ccc{Field}\\


\ccCreation
\ccCreationVariable{x}

\ccConstructor{Residue();}
{introduces a variable \ccVar, which is initialized with zero;}
\ccGlue
\ccConstructor{Residue(const Residue& m);}
{copy constructor;}
\ccGlue
\ccConstructor{Residue(int i);}
{introduces a variable \ccVar, which is initialized with $i \%  p$;}
\ccGlue
\ccConstructor{Residue(long i);}
{introduces a variable \ccVar, which is initialized with $i \%  p$;}

\ccOperations

\ccMethod{static int set_current_prime(int p);}{ 
        Static member function;\\
        sets current prime to the given value and returns the old prime. }
\ccGlue
\ccMethod{static int get_current_prime();}{
        Static member function;\\
        returns the value of the current prime.      
    }
\ccGlue
\ccMethod{int  get_value() const;}{
        Returns the value of \ccVar. 
    }


\ccFunction{Residue operator+(const Residue&a);}{}\ccGlue
\ccFunction{Residue operator-(const Residue&a);}{}\ccGlue

\ccFunction{Residue operator+(const Residue&a,const Residue& b);}{}\ccGlue
\ccFunction{Residue operator-(const Residue&a,const Residue& b);}{}\ccGlue
\ccFunction{Residue operator*(const Residue&a,const Residue& b);}{}\ccGlue
\ccFunction{Residue operator/(const Residue&a,const Residue& b);}{}\ccGlue

\ccMethod{Residue & operator+=(const Residue& a);}{}\ccGlue
\ccMethod{Residue & operator-=(const Residue& a);}{}\ccGlue
\ccMethod{Residue & operator*=(const Residue& a);}{}\ccGlue
\ccMethod{Residue & operator/=(const Residue& a);}{}\ccGlue

\end{ccRefClass} 
