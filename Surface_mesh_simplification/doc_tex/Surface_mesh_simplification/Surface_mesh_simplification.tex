%% Copyright (c) 2004  SciSoft.  All rights reserved.
%%
%% This file is part of CGAL (www.cgal.org); you may redistribute it under
%% the terms of the Q Public License version 1.0.
%% See the file LICENSE.QPL distributed with CGAL.
%%
%% Licensees holding a valid commercial license may use this file in
%% accordance with the commercial license agreement provided with the software.
%%
%% This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
%% WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
%%
%% 
%%
%% Author(s)     : Fernando Cacciola <fernando_cacciola@hotmail.com>

\section{Introduction}

This \cgal\ package provides an algorithm for the simplification of triangulated surface meshes.

Simplification is the process of reducing the number of triangles used in the surface but keeping the overall shape, volumen and boundaries preserved as much as possible. It is the opposite of subdivision.

%% figures of simplified surfaces

The algorithm presented here can simplify any {\em 2-manifold surface with borders} (that is closed or open), and of arbitrary genus (with holes), using a method known as {\em edge collapse}. Roughly speaking, the method consist of iteratively replacing an edge with a single vertex, removing 2 triangles per collapse.

%% figure of edge collapse

Edges are collapsed according to a priority given by a user-supplied {\em cost} function, and the coordinates of the replacing vertex is determined by another user-supplied {\em placement} function. The algorithm terminates when a user-supplied {\em stop condition} is met, such as reaching the desired number of edges.

The algorithm implemented here is generic in the sense that it doesn't require the surface to be of any concrete type. Instead, it defines the concept of a {\em Triangulated Surface Mesh} (\ccc{TSM}), and any surface that is a model of that concept can be simplified. Furthermore, the concept is defined not in terms of a monolithic class, but in terms of a set of functions and traits making it easy to adapt any concrete surface type without much work. In particular, the concept definition is based on the well known {\em Boost Graph Library ({\sc Bgl})}.

The design is {\em policy-based}, meaning that you can customize some aspects of the process by passing a set of {\em policy objects}. Each policy object specifies a particular aspect of the algorithm, such as how edges are selected and where the replacement vertex is placed. All policies have a sensible default so you don't need to learn about them unless you need a non-default behaviour.

\section{Definitions\label{SurfaceMeshSimplification:SecDefinitions}}

\subsection{TSM - Triangulated Surface Mesh}

Informally speaking, a {\em triangulated surface mesh} is a set of triangles pasted together along their edges.

Formally speaking, a {\em triangulated surface mesh} (of the kind used in this \cgal\ package), often called a {\em simplicial mesh}, is an {\em Euclidean Simplicial Complex} of topological dimension 3, that is, a set of connected {\em vertices}, {\em edges} and {\em facets}.\\
Vertices embedding points (in 2 or 3 geometric dimensions), are the most primitive element in the mesh, and are called 0-simplicies.\\
Edges connect 2 vertices (are a subset of 2 points), and are called 1-simplicies.\\
Facets connect 3 edges in a cycle (are a subset of 3 points), and are called 2-simplicies.

Vertices, edges and facets are necessarily subsets of 1, 2 and 3 points, respectively. Some meshes might embed other geometric objects in the edges (a straight line segment for example), or the facets (a plane); however, in this \cgal\ package we are only concerned about the points embedded in the vertices.

The 2 vertices connected by an edge are said to be {\em incident} on the edge and the edge is said to be {\em incident} on the two vertices it connects. Likewise, the 3 edges connected by a facet are said to be {\em incident} on the facet and the facet {\em incident} on the 3 edges.

Any two vertices/edges incident upon the same edge/facet are said to be {\em adjacent}.

Any sequence of pairwise adjacent vertices or edges is a {\em path}.

Any two vertices or edges are connected if there is a {\em path} from one to the other.

A path that connects a vertex/edge with itself is a {\em cycle}.

An edge which is incident upon only one facet is said to be a {\em border} edge. 

A surface is {\em closed} if none of it edges are border edges, {\em open} otherwise.

The edges in the border (often called boundary) of an open surface with more than one single facet are not adjacent because they are incident upon different facets. From the definition of incidence, adjacency and connectivity, it can be shown that all the edges incident upon a facet are cyclically connected and all cyclically connected edges are incident upon a common facet. Such a cycle of edges around a common facet is said to be the {\em boundary} of the facet (which is not the same as the surface-border, also called surface-boundary).

Edges in the border of an open surface can be considered to be cyclically connected if they are considered to be ALL  incident upon an hypotetical pseudo-facet on the outside of the surface (and each on a normal facet of course).

A triangular surface mesh is said to be an {\em open 2-manifold} if every edge is incident upon 1 or 2 facets, but no more.

The topology and geometry (points embedded in the vertices) of the 1-simplices (vertices and edges only, without considering the facets) in a surface is represented by the concept \ccc{HalfedgeGraph}.

Even though a \ccc{HalfedgeGraph} indirectly represents a facet (by means of its boundary), it fails to distinguish a true facet from a pseudo-facet outside the surface (the way a \ccc{HalfedgeDS} does). Thus, the halfedge graph alone cannot be used to determine whether an edge is a border or not. In order to allow the algorithm to identify border edges, an {\sc Bgl} \ccc{EdgeIsBorderPropertyMap} associating a \ccc{bool} flag to each ({\em directed}) edge is used.

Operations in a \ccc{TSM} are defined in terms of free (non-member) operator objects. Currently, only one operator is defined since only one operation is needed in the algorithm: the \ccc{TriangulationEdgeCollapseOperator}
 
This operator, which must be specialized for the concrete surface type, performs the actual edge collapse by replacing the edge by one if its vertices. It is required to remove from the surface one of the vertices, the facets incident to the collapsed edge (which it turn removes the other two edges incident upon those facets), and nothing else.

A Triangulated Surface Mesh, \ccc{TSM}, is a composition of a \ccc{HalfedgeGraph}, a \ccc{EdgeIsBorderPropertyMap}, and a
\ccc{TriangulationEdgeCollapseOperator}.

\subsubsection{TSM Models}

A \ccc{Polyhedron_3} is a valid \ccc{TSM} model as long as its facets are only triangles. A polyhedron is represented as a \ccc{HalfedgeDS},and the vertices and edges of any halfedge data structure correspond exactly to a \ccc{HalfedgeGraph}. The \ccc{undirected_edge_iterator} of the halfedge graph concept is trivially obtained by iterating over one out of two halfedges.

Any \ccc{Triangulation}, whether in 2 or 3 dimensions, is also a valid \ccc{TSM} model. A triangulation edge is defined as a cell plus 2 vertex indices: \ccc{cell(c)(i,j)}. Such edge is inherently directed since the vertex indices are lexicographically ordered in the edge. Furthermore, for any triangulation directed edge \ccc{cell(c)(i,j)}, the opposite directed edge, \ccc{cell(c)(j,i)}, is always well defined and belongs to the triangulation. Thus, any \ccc{TriangulationDS} can be trivially adapted to be a \ccc{HalfedgeGraph}. 

Throughout this documentation, the unqualified term {\em edge} refers to an undirected edge (even though in a \ccc{HalfedgeGraph} the term edge alone refers to the directed edge).

This \cgal\ package provides the {\sc Bgl} specializations for a \ccc{Polyhedron_3}.

\section{Overview of the Simplification Process}

The free function that implements the simplifcation algorithm takes not only the surface and the desired stop condition but a number of additional parameters which control and monitor the simplification process. This section briefly describes the process in order to set the background for the discussion of algorithm parameters.

An edge collapse operation replaces the edge with a vertex, removing the two incident triangles (hence two additional edges, one from each triangle). Therefore, each edge collapse decreases the number of triangles, edges, and vertices by 2, 3, and 1, respectively (if the collapsed edge is a border, by 1,2, and 1, respectively, since only one triangle is removed).

Naturally, the surface that results from an edge collapse deviates from the initial surface by some amount, and since the goal of simplification is to reduce the number of triangles while retaining the overall look of the surface as much as possible, it is necessary to measure such deviation. Some methods attempt to measure the total deviation from the initial surface to the completely simplified surface, for example, by tracking an accumulated error keeping a history of the simplification changes. Other methods, like the one implemented in this package, attempt to measure only the local deviation introduced by a single simplification step, that is, a step {\em cost}, and plan the entire process as a sequence of steps of increasing cost. 

Global error tracking methods produce highly accurate simplifications but take up a lot of additional space. Cost-driven methods, like the one in this package, produce slightly less accurate simplifications but take up much less additional space, even none in some cases.

The cost-driven method implemented in this package, mainly based on the so-called "memoryless simplification", by Lindstrom and Turk \cite{a}, proceeds in two stages. In the collection stage, an initial {\em collapse cost} is assigned to each and every edge in the surface. In the collapsing stage, edges are {\em processed} in order of increasing cost. Some processed edges are {\em collapsed} while some are just discarded. Collapsed edges are replaced by a vertex and the collapse cost of all the edges now incident on the replacement vertex is recalculated, affecting the order of the edges left to process.

Not all edges selected for processing are collapsed. A processed edge can be discarded without being collapsed for one of three reasons: its cost could not be computed (for whatever reason), collapsing the edge would result in an inconsistent surface, or the edge is incident upon a vertex which the user marked as fixed.

If an edge is effecitively collapsed, is replaced by a vertex whose position, called {\em placement}, must be choosen carefully to avoid too much deviation from the initial surface. In many cases, the collapse cost is a function of the vertex position, so the placement might be calculated each time the cost is calculated and not just when an edge is effectively collapsed.

\section{Overview of the Algorithm Parameters}

The algorithm parameters are divided in four groups.

\subsection{Main Parameters}

There are two main parameters to the algorithm: the surface to be simplified (in-place) and the stop condition.

The surface must correspond to a valid \ccc{TSM} model, for example a \ccc{Polyhedron_3}. The argument itself is the surface object and the algorithm does not handle the concrete argument type directly, instead, it internally instantiates and uses the matching specializations and overloads of the {\sc Bgl} graphs traits, functions and property maps defined in Section~\ref{SurfaceMeshSimplification:SecDefinitions}. Such traits and property maps are implict, i.e., not passed as arguments to the algorithm.

The stop condition is a Boolean predicate called after each edge is selected for processing, {\em before} it is classfied as collapsable or not (thus before it is collapsed). If the stop condition returns true the algorithm terminates.

\subsection{Additional Surface Properties}

The algorithm needs to associate with each edge an implementation-specific internal record. It could do that unintrusively with an internal map, but that would incurr the additional overhead of a lookup. To avoid that inefficieny (which could be significant, if the surface had millions of edges) the algorithm requires the user to pass in a {\sc Bgl} \ccc{PropertyMap}, \ccc{EdgeExtraPointerMap}, associating a modifiable void pointer (that is, a \ccc{"void*\&"}) to each {\em undirected} edge. The map must be initialized with null pointers for all undirected edges in the surface (or all directed edges if the concrete surface internally distinguishes between the two). 

Sometimes it is desirable to keep some edges uncollapsed. This can be controlled by fixing vertices in the surface: any edge incident upon a fixed vertex will be left uncollapsed. A {\sc BGL} \ccc{PropertyMap}, \ccc{VertexIsFixedMap}, associating a bool with every vertex is passed to indicate that.

\subsection{Cost Strategy}

The specific way in which the collapse cost and vertex placement is calculated is called the {\em cost strategy}.
The user can choose different strategies in the form of function objects and related parameters, passed to the algorithm.
In the current package version, for instance, one can choose between the Lindstrom-Turk strategy (the default) or an edge-length cost with a midpoint placement (much faster but less accurate).

\subsubsection{Cache Level}

The cost for each edge is initially fixed and changes only in those edges affected by a neighboring collapse. A given edge can be expected to be affected by a neighboring collapse only a small number of times (in the order of the average vertex degree), so the total number of cost computations and recomputations is a small factor of the total number of edges. On the other hand, edges are processed in order of increasing cost, and as is the case with any sorting situation, the cost of any given edge must be accessed several times while it is compared against the cost of other edges, even if it remains constant. That is, costs are queried several times more than are computed and updated, so it make sense to cache the cost of an edge to avoid recomputing it.

The placement for each edge is queried only when the edge is effectively collapsed, however, most cost strategies are based on the placement, so each cost computation typically involves a hidden placement computation. Therefore, it might also make sense to cache not only the cost by also the placement (which is a Point object).

The cost for all edges are computed at least once, and on avergage updated a few times, but the placement is queried only when the edge is effectively collapsed. Caching only the cost as opposed to caching both the cost and the placement makes a small difference in the total running time, while, not caching the cost at all causes a significant slowdown. Still, caching the cost and/or placement in the edge adds to the size of the surface a significant number. For example, if the cost is of type {\tt double}, each million edges require about 7Mb of additional storage for the cost, and 30Mb for the cost and placement. It might be better in a specific context to avoid any caching altoghether, even at the expense of increased running time.

The most sensible default choice is to cache only the cost.

For each edge, a record of information called \ccc{CollapseData} is associated with it (through the edge extra pointer map). Such data can be empty (\ccc{EmptyCollapseData}), store the cost of the collapse but not the placement(\ccc{PartialCollapseData}), or both (\ccc{FullCollapseData)}.

Each time the algorithm needs to access the cost or placement for an edge it calls the \ccc{GetCost} and \ccc{GetPlacement} function objects passed as argument. If an empty collapse data is used, these functions must effectively calculate the values and return it.

On the other hand, if a partial or full collapse data is used, meaning that the cost and/or placement is cached, the \ccc{GetCost} and/or \ccc{GetPlacement} function objects must simply extract the cached value and return it. In this case, however, the actual cost and placement must somwhow still be computed and stored in the collapse data. This is the role of the \ccc{SetCollapseData} function object passed as argument.

In conjunction, the three parameters: \ccc{SetCollapseData}, \ccc{GetCost} and \ccc{GetPlacement} specify the cost and placement strategy. They are related in that if \ccc{SetCollapseData} sets an \ccc{EmptyCollapseData}, the \ccc{GetCost} and \ccc{GetPlacement} policies must be actually computing the values, while if \ccc{SetCollapseData} sets a \ccc{PartialCollapseData} or a \ccc{FullCollapseData}, the policies would just return the cached value.

\subsection{Visitor}

Simplifying a large surface with millions of edges can take up a lot of time (several minutes). Thus, it is important to be able to monitor the simplification progress. This can be achieved passing a visitor function object. The information passed to the visitor at each step can be used to track statistics such as the number of edges that couldn't be collapsed. The requirements of the visitor object are specified in the \ccc{TSMEdgeCollapseVisitor} concept.

\section{API}

\subsection{API Overview}

The simplification algorithm is implemented as a free template function taking several parameters. The following sample code illustrates the general form of the function call:

\begin{cprog}
int r = edge_collapse(surface
                     ,stop_condition
                     ,edge_extra_ptr_map
                     ,vertex_is_fixed_map
                     ,set_collapse_data
                     ,get_cost
                     ,get_placement
                     ,cost_params
                     ,placement_params
                     ,visitor 
                     );
\end{cprog}

Only the first 2 parameters are required. All other parameters have default values corresponding to the {\em Lindstrom-Turk} cost strategy, with no fixed vertices and assuming the surface edges store room for an extra pointer default initialized to \ccc{NULL}.

\subsection{Examples}

These examples present, progressively, the varying choices of policies. It is better to read them one after the other.
Some lines are marked with \ccc{<==== NOTICE THIS} to drive the attention to an important difference with respect to the previous example which can be lost in the context.

\subsubsection{Example Using Defaults}

This example illustrates the simplest of the cases using an ordinary polyhedron as surface and all default policies.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_polyhedron_example.cpp}


\subsubsection{Example Using Enriched Polyhedron}

This example shows how to use an enriched polyhedron which stores the extra pointer in the halfedges.
\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_enriched_polyhedron_example.cpp}


\subsubsection{Example using Non-Default Cost Strategy}

This example shows how to use a cost strategy other than the default.

\ccIncludeExampleCode{Surface_mesh_simplification/MP_edge_collapse_polyhedron_example.cpp}


\subsubsection{Example using a full cache for the Collapse Data}

This example shows how to use a full collapse-data cache for efficiency. The setup in this case is slightly different for the default cost-strategy (Lindstrom-Turk) than for alternative strategies, so both cases are shown.

\ccIncludeExampleCode{Surface_mesh_simplification/Edge_collapse_fully_cached_polyhedron_example.cpp}


\subsubsection{Example using a Visitor}

This example shows how to use a visitor to track the simplification process. It also shows how to setup the Lindstrom-Turk cost strategy but with a partial case (unlike a full cache as in the previous example).

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_visited_polyhedron_example.cpp}


\subsubsection{Example using Fixed Vertices via an external Property Map}

This example shows how to fix vertices to prevent edges from being collapsed, using an ordinary polyhedron and external maps.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_with_fixed_vertices_polyhedron_example.cpp}


\subsubsection{Example using Fixed Vertices via an Enriched Polyhedron}

This example shows how to fix vertices to prevent edges from being collapsed using an enriched polyhedron.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_with_fixed_vertices_enriched_polyhedron_example.cpp}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of sfsooter
% EOF
% +------------------------------------------------------------------------+


