%% Copyright (c) 2004  SciSoft.  All rights reserved.
%%
%% This file is part of CGAL (www.cgal.org); you may redistribute it under
%% the terms of the Q Public License version 1.0.
%% See the file LICENSE.QPL distributed with CGAL.
%%
%% Licensees holding a valid commercial license may use this file in
%% accordance with the commercial license agreement provided with the software.
%%
%% This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
%% WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
%%
%% 
%%
%% Author(s)     : Fernando Cacciola <fernando_cacciola@hotmail.com>

\section{Introduction}

This \cgal\ package provides an algorithm for the simplification of triangulated surface meshes.

Simplification is the process of reducing the number of triangles used in the surface but keeping the overall shape, volumen and boundaries preserved as much as possible. It is the opposite of subdivision.

%% figures of simplified surfaces

The algorithm presented here can simplify any {\em 2-manifold surface with borders} (that is closed or open), and of arbitrary genus (with holes), using a method known as {\em edge collapse}. Roughly speaking, the method consist of iteratively replacing an edge with a single vertex, removing 2 triangles per collapse.

%% figure of edge collapse

Edges are collapsed according to a priority given by a user-supplied {\em cost} function, and the coordinates of the replacing vertex are determined by another user-supplied {\em placement} function. The algorithm terminates when a user-supplied {\em stop predicate} is met, such as reaching the desired number of edges.

The algorithm implemented here is generic in the sense that it does not require the surface to be of a particular type. Instead, it defines the concept of a \ccc{TriangulatedSurfaceMesh} and any surface that is a model of that concept can be simplified. Furthermore, the concept is defined not in terms of a monolithic class, but in terms of a set of functions and traits making it easy to adapt any concrete surface type without much work. In particular, the concept definition follows the design of the 
 \ccAnchor{http://www.boost.org/libs/graph/doc/index.html}{ Boost Graph Library ({\sc Bgl})}.

The design is \ccAnchor{http://en.wikipedia.org/wiki/Policy-based_design}{{\em policy-based}},
meaning that you can customize some aspects of the process by passing a set of {\em policy objects}. Each policy object specifies a particular aspect of the algorithm, such as how edges are selected and where the replacement vertex is placed. All policies have a sensible default so you don't need to learn about them unless you need a non-default behaviour.

\section{Definitions\label{SurfaceMeshSimplification:SecDefinitions}}

\subsection{Triangulated Surface Mesh}

A \ccc{TriangulatedSurfaceMesh} is structuraly equivalent to a \ccc{CGAL::Polyhedron_3} whose facets are only triangles.

Conceptually, is similar to a \ccc{HalfedgeDS} with the restriction that all facets are triangular. In order to simplify the {\em efficient} adaptation of concrete surface types, it is {\em not} modeled exactly as a \ccc{HalfedgeDS} but as a directed graph, with its related functions and associated properties, as explained below:

A \ccc{TriangulatedSurfaceMesh} refines the \ccc{HalfedgeGraph} concept which describes only the vertices and edges of a \ccc{HalfedgeDS}. The triangular facets are not explicitely modeled. 

An edge is normally considered to be in the boundary of the surface when it is incident upon only one facet instead of two. The algorithm here needs to indentify border edges, but the incidence between triangles and edges is not represented explicitely, so the {\em properties} \ccc{Edge_is_border} and \ccc{Vertex_is_border} are associated with the edges and vertices of a surface.

Following the {\sc Bgl} design, operations in a \ccc{TriangulatedSurfaceMesh} are defined in terms of free (non-member) functions.

\subsubsection{Valid Models}

A \ccc{CGAL::Polyhedron_3} is a valid \ccc{TriangulatedSurfaceMesh} model as long as its facets are only triangles. A polyhedron is represented as a \ccc{HalfedgeDS}, and the vertices and edges of any halfedge data structure correspond exactly to a \ccc{HalfedgeGraph}. The \ccc{HalfedgeGraph::undirected_edge_iterator} of the halfedge graph concept is trivially obtained by iterating over one out of two halfedges.

Any \ccc{TriangulationDataStructure_2} is also a valid \ccc{TriangulatedSurfaceMesh} model. A triangulation edge is given as a triangular face  plus the index of the edge: \ccc{(f,i)}. Such edge is inherently directed since the vertices of the faces are oriented counterclockwise. Furthermore, for any triangulation directed edge \ccc{(f,i)}, the opposite directed edge, \ccc{f->neighbor(i), f->neighbor(i)->index(f)}, is always well defined and belongs to the triangulation. Thus, any \ccc{TriangulationDataStructure_2} can be trivially adapted to be a \ccc{HalfedgeGraph}. 

Throughout this documentation, the unqualified term {\em edge} refers to an undirected edge (even though in a \ccc{HalfedgeGraph} the term edge alone refers to the directed edge).

This \cgal\ package provides the adaptation for a \ccc{CGAL::Polyhedron_3}.

\section{Overview of the Simplification Process}

The free function that implements the simplifcation algorithm takes not only the surface and the desired stop predicate but a number of additional parameters which control and monitor the simplification process. This section briefly describes the process in order to set the background for the discussion of algorithm parameters.

An edge collapse operation replaces the edge with a vertex, removing the two incident triangles (hence two additional edges, one from each triangle). Therefore, each edge collapse decreases the number of triangles, edges, and vertices by 2, 3, and 1, respectively (if the collapsed edge is a border, by 1,2, and 1, respectively, since only one triangle is removed).

Naturally, the surface that results from an edge collapse deviates from the initial surface by some amount, and since the goal of simplification is to reduce the number of triangles while retaining the overall look of the surface as much as possible, it is necessary to measure such deviation. Some methods attempt to measure the total deviation from the initial surface to the completely simplified surface, for example, by tracking an accumulated error keeping a history of the simplification changes. Other methods, like the one implemented in this package, attempt to measure only the local deviation introduced by a single simplification step, that is, a step {\em cost}, and plan the entire process as a sequence of steps of increasing cost. 

Global error tracking methods produce highly accurate simplifications but take up a lot of additional space. Cost-driven methods, like the one in this package, produce slightly less accurate simplifications but take up much less additional space, even none in some cases.

The cost-driven method implemented in this package, mainly based on the so-called "memoryless simplification", by Lindstrom and Turk \cite{cgal:lt-fmeps-98,cgal:lt-ems-99}, proceeds in two stages. In the collection stage, an initial {\em collapse cost} is assigned to each and every edge in the surface. In the collapsing stage, edges are {\em processed} in order of increasing cost. Some processed edges are {\em collapsed} while some are just discarded. Collapsed edges are replaced by a vertex and the collapse cost of all the edges now incident on the replacement vertex is recalculated, affecting the order of the edges left to process.

Not all edges selected for processing are collapsed. A processed edge can be discarded without being collapsed for one of three reasons: its cost could not be computed (for whatever reason), collapsing the edge would result in an inconsistent surface, or the edge is incident upon a vertex which the user marked as fixed.

If an edge is effecitively collapsed, is replaced by a vertex whose position, called {\em placement}, must be choosen carefully to avoid too much deviation from the initial surface. In many cases, the collapse cost is a function of the vertex position, so the placement might be calculated each time the cost is calculated and not just when an edge is effectively collapsed.

\section{Overview of the Algorithm Parameters}

The algorithm parameters are divided in four groups.

\subsection{Main Parameters}

There are two main parameters to the algorithm: the surface to be simplified (in-place) and the stop predicate.

The surface must correspond to a valid \ccc{TSM} model, for example a \ccc{Polyhedron_3}. The argument itself is the surface object and the algorithm does not handle the concrete argument type directly, instead, it internally instantiates and uses the matching specializations and overloads of the {\sc Bgl} graphs traits, functions and property maps defined in Section~\ref{SurfaceMeshSimplification:SecDefinitions}. Such traits and property maps are implict, i.e., not passed as arguments to the algorithm.

The stop predicate is called after each edge is selected for processing, {\em before} it is classfied as collapsable or not (thus before it is collapsed). If the stop predicate returns true the algorithm terminates.

\subsection{Additional Surface Properties}

The algorithm needs to associate with each edge an implementation-specific internal record.
To do that efficiently, the surfaces edges must be propery indexed, so
a \ccAnchor{http://www.boost.org/libs/property_map/ReadablePropertyMap.html}{ReadablePropertyMap} 
corresponding to the \ccc{Edge_index} property must be passed.

Sometimes it is desirable to keep some edges uncollapsed. This can be controlled by fixing vertices in the surface: any edge incident upon a fixed vertex will be left uncollapsed. Again
\ccAnchor{http://www.boost.org/libs/property_map/ReadablePropertyMap.html}{ReadablePropertyMap} 
associating a bool to each vertx is passed to indicate that.

\subsection{Cost Strategy}

The specific way in which the collapse cost and vertex placement is
calculated is called the {\em cost strategy}. The user can choose 
different strategies in the form of policies and related parameters,
passed to the algorithm. In the current package version, for instance,
one can choose between the Lindstrom-Turk strategy 
(the default) or an edge-length cost with a midpoint 
placement (much faster but less accurate).

\subsubsection{Lindstrom-Turk cost and placement strategy\label{SurfaceMeshSimplification:LindstromTurkStrategy}}

\subsubsection{Cache Level}

The cost for each edge is initially fixed and changes only in those edges affected by a neighboring collapse. A given edge can be expected to be affected by a neighboring collapse only a small number of times (in the order of the average vertex degree), so the total number of cost computations and recomputations is a small factor of the total number of edges. On the other hand, edges are processed in order of increasing cost, and as is the case with any sorting situation, the cost of any given edge must be accessed several times while it is compared against the cost of other edges, even if it remains constant. That is, costs are queried several times more than are computed and updated, so it make sense to cache the cost of an edge to avoid recomputing it.

The placement for each edge is queried only when the edge is effectively collapsed, however, most cost strategies are based on the placement, so each cost computation typically involves a hidden placement computation. Therefore, it might also make sense to cache not only the cost by also the placement (which is a Point object).

The cost for all edges are computed at least once, and on avergage updated a few times, but the placement is queried only when the edge is effectively collapsed. Caching only the cost as opposed to caching both the cost and the placement makes a small difference in the total running time, while, not caching the cost at all causes a significant slowdown. Still, caching the cost and/or placement in the edge adds to the size of the surface a significant number. For example, if the cost is of type {\tt double}, each million edges require about 7Mb of additional storage for the cost, and 30Mb for the cost and placement. It might be better in a specific context to avoid any caching altoghether, even at the expense of increased running time.

The most sensible default choice is to cache only the cost.

For each edge, a record of information called \ccc{CollapseData} is associated with it (through the edge extra pointer map). Such data can be empty (\ccc{EmptyCollapseData}), store the cost of the collapse but not the placement(\ccc{PartialCollapseData}), or both (\ccc{FullCollapseData)}.

Each time the algorithm needs to access the cost or placement for an edge it calls the \ccc{GetCost} and \ccc{GetPlacement} function objects passed as argument. If an empty collapse data is used, these functions must effectively calculate the values and return it.

On the other hand, if a partial or full collapse data is used, meaning that the cost and/or placement is cached, the \ccc{GetCost} and/or \ccc{GetPlacement} function objects must simply extract the cached value and return it. In this case, however, the actual cost and placement must somwhow still be computed and stored in the collapse data. This is the role of the \ccc{SetCollapseData} function object passed as argument.

In conjunction, the three parameters: \ccc{SetCollapseData}, \ccc{GetCost} and \ccc{GetPlacement} specify the cost and placement strategy. They are related in that if \ccc{SetCollapseData} sets an \ccc{EmptyCollapseData}, the \ccc{GetCost} and \ccc{GetPlacement} policies must be actually computing the values, while if \ccc{SetCollapseData} sets a \ccc{PartialCollapseData} or a \ccc{FullCollapseData}, the policies would just return the cached value.

\subsection{Visitor}

Simplifying a large surface with millions of edges can take up a lot of time (several minutes). Thus, it is important to be able to monitor the simplification progress. This can be achieved passing a visitor function object. The information passed to the visitor at each step can be used to track statistics such as the number of edges that couldn't be collapsed. The requirements of the visitor object are specified in the \ccc{EdgeCollapseSimplificationVisitor} concept.

\section{API}

\subsection{API Overview}

The simplification algorithm is implemented as a free template function taking several parameters. The following sample code illustrates the general form of the function call:

\begin{cprog}
int r = edge_collapse(surface
                     ,stop_condition
                     ,edge_index_map
                     ,vertex_is_fixed_map
                     ,set_collapse_data
                     ,get_cost
                     ,get_placement
                     ,cost_params
                     ,placement_params
                     ,visitor 
                     );
\end{cprog}

Only the first 2 parameters are required. All other parameters have default values corresponding to the {\em Lindstrom-Turk} cost strategy, with no fixed vertices and assuming the surface edges store room for an extra pointer default initialized to \ccc{NULL}.

\subsection{Examples}

The following examples introduce the API in increasing complexity. All the examples follow this general structure:

\ccIncludeExampleCode{Surface_mesh_simplification/general_form.cpp}

As you can see, each example varies from this general form in the code sections between the marks.
Each example is coded to be compilable so some neccessary parts are repeated in many of them. To simplify the exposition, repeated parts are described in detail only in the first example they appear.

\subsubsection{Example Using Default Parameters}

The following example illustrates the simplest of the cases.\\
It uses an {\em ordinary} Polyhedron, that is, a polyhedron without any special provision 
for the sake of the algorithm (which is possible as illustrated in the next example).\\
Many parameters are ommited, causing the algorithm to run in default mode:

\begin{enumerate}
\item \ccc{There are no fixed vertices in the surface.}
\item \ccc{The cost strategy is that of Lindstrom-Turk, computed with default parameters and caching only the cost (partial cache).}
\item \ccc{No visitor is used to track the algorithm progress.}
\end{enumerate}

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_polyhedron.cpp}

\subsubsection{Example Using Enriched Polyhedron}

The following example is equivalent to the previous example but instead of using an external map to associate the extra pointer to each edge, it directly stores the pointer in the edge by enriching the polyhedron definition.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_enriched_polyhedron.cpp}

\subsubsection{Example using Non-Default Cost Strategy}

The following example shows how to use non-default cost strategy: the edge length as cost and the edge
midpoint as placement. It also shows how to specify that neither the cost nor the placement should be cached (to save memory).

\ccIncludeExampleCode{Surface_mesh_simplification/MP_edge_collapse_polyhedron.cpp}

\subsubsection{Example using a full cache for the Collapse Data}

The following example shows how to use a full collapse-data cache for efficiency. Using a full collapse data is slightly different for the default cost-strategy (Lindstrom-Turk) than for alternative strategies, so both cases are shown in the same example.

\ccIncludeExampleCode{Surface_mesh_simplification/Edge_collapse_fully_cached_polyhedron.cpp}

\subsubsection{Example using a Visitor}

The following example shows how to use a visitor to track the simplification process. It also shows how to setup the Lindstrom-Turk cost strategy but with a partial case (unlike a full cache as in the previous example). A partial cache is the default policy so you don't need to explicitely specify it unless, as in this case, you have to pass an argument further up in the list.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_visited_polyhedron.cpp}


\subsubsection{Example using Fixed Vertices via an external Property Map}

The following example shows how to fix vertices to prevent edges from being collapsed. In this case, an ordinary polyhedron is used so the is-fixed vertex flags are stored in an external map.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_with_fixed_vertices_polyhedron.cpp}

\subsubsection{Example using Fixed Vertices via an Enriched Polyhedron}

The following example, just like the previous example, shows how to fix vertices to prevent edges from being collapsed. In this case, however, an enriched polyhedron is defined which stores the is-fixed flag right in the vertex.

\ccIncludeExampleCode{Surface_mesh_simplification/LT_edge_collapse_with_fixed_vertices_enriched_polyhedron.cpp}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of sfsooter
% EOF
% +------------------------------------------------------------------------+


