\chapter{Surface mesher}
\label{chapter_SurfaceMesher}
\ccChapterAuthor{Andreas Fabri, Steve Oudot, David Rey, Laurent Rineau
and Mariette Yvinec}

\vspace*{-15mm}
\minitoc
\vspace*{30mm}

\section{Introduction}
\label{SurfaceMesher_section_intro}

This package provides a global function
to compute a triangular mesh approximating a surface.

The meshing algorithm requires to know the surface to be meshed
only  through an oracle able to  tell whether a
given segment, line or ray intersects the surface or not
and to compute an intersection point if any.
This feature makes the package generic enough to be
applied in a wide variety of situations. For instance it can be
used to mesh implicit surfaces described as the zero level set
of some function. It may also be used in the field of medical imaging
to mesh surfaces described as a gray
level set in a three dimensional image.


The meshing algorithm is based on the notion of the restricted
Delaunay triangulation. Basically the algorithm  computes a set of
sample points on the surface and extract an interpolating 
surface mesh  from the three dimensional triangulation of these 
sample points. Points are iteratively added to the sample,
as in a Delaunay refinement process, until some size and shape
criteria on mesh elements are satisfied. 


The size and shape criteria guide the  behaviour of
the refinement process and control its termination.
They also condition  the size and shape of the elements in the final
mesh. Of course those criteria can be customized to satisfy
the user needs. The \ccc{Surface mesher} package offers
a set of standard criteria that can be scaled through
three numerical values. Also the user can plug in its own 
set of refinement criteria.

There is no restriction on the topology and number of components
of the surface provided that the oracle (or the user)
is able to provide one initial sample point on each connected component.
If the surface is smooth enough and the size criteria
small enough, the algorithm guarantees 
that the output mesh is homeomorphic to the
surface and within a small bounded distance
(Hausdorff or even Frechet distance) from the surface.
The algorithm can also be used for non smooth surfaces
but then there is no guarantee. 




\section{The surface mesher interface}
\label{SurfaceMesher_section_interface}

The meshing process is launched through a call to a global function.
There are two overloaded versions of the meshing function
whose signatures are the following:

\ccGlobalFunction{template <class C2T3,
                            class Surface,
                            class Criteria,
                            class Tag >
void make_surface_mesh(C2T3& c2t3,
                       Surface surface,
                       Criteria criteria,
                       Tag ) ;}


\ccGlobalFunction{template <class C2T3,
                            class SurfaceMeshTraits,
                            class Criteria,
                            class Tag >
void make_surface_mesh(C2T3& c2t3,
                       SurfaceMeshTraits::Surface_3  surface,
		       SurfaceMeshTraits traits,
                       Criteria criteria,
                       Tag );}



The template parameter \ccc{C2T3} describes 
the data structure
used to store  the surface mesh. This data structure
has a pointer to a three dimensional triangulation and encodes
the surface mesh as a subset of facets in this triangulation.
The data structure is described in the concept
\ccc{SurfaceMeshComplex_2InTriangulation_3} which is a specialized version
of a more general concept called  \ccc{Complex_2InTriangulation_3}.
%More precisely, the concept \ccc{Complex_2InTriangulation_3}
%encodes a two dimensional complex embedded  in a three dimensional
%triangulation, which means that the faces of the complex form a subset
%of the triangulation faces. The concept \ccc{PureComplex_2InTriangulation_3} is 
%specialized to the case where the complex is pure which means that it
%is a set of facets (i.e., two dimensional faces) with  their subfaces.
An object of this class is passed by reference to the meshing
function. This object holds the output mesh at the end of the
process.

The required knowledge on the surface is encapsulated in a
traits class. The mesher accesses the surface to be meshed
through this traits class only. 
The traits class is required to be a model
of the concept \ccc{SurfaceMeshTraits_3}. \\
In the first  overloaded version of
of \ccc{make_surface_mesh}, the surface type is a template paramater  (\ccc{Surface})
and the surface mesher traits type 
is  automatically generated form the surface type.  
%through
%the class 
%\ccc{Surface_mesh_traits_generator_3<Surface>}.
(This mechanism is similar to the 
\ccc{Kernel_traits}  mechanism.) \\
In the second overloaded version of \ccc{make_surface_mesh}, the surface mesher traits type is provided
as a template parameter 
and the surface type is deduced from this traits type.
Both the surface and the traits 
are passed to the mesher as parameters. \\
The first version is simpler and can be used,
whenever the surface type either provides  a nested type
\ccc{Surface::Surface_mesher_traits_3} 
that is  a model of \ccc{SurfaceMeshTraits_3}
or is a surface type for which a specialization
of the traits generator \ccc{Surface_mesh_traits_generator_3<Surface>}
is provided.
Currently, the library provides partial specializations
of  \ccc{Surface_mesher_traits_generator_3<Surface>}
for implicit surfaces (\ccc{Implicit_surface_3<Traits, Function> }) and 
grey level images (\ccc{Gray_level_image_3<FT> }).



The parameter \ccc{criteria} handles the description of the size and shape
criteria driving the meshing process. The template parameter \ccc{Criteria}
has to be instantiated by a model of the concept \ccc{MeshCriteria}.


The parameter \ccc{Tag}  is a tag 
whose type influences the behavior of the
meshing algorithm. For instance, this parameter
can be used to enforce the manifold property
of the output mesh while avoiding 
an over-refinement of the mesh. Further details on this
subject are given in 
Section~\ref{SurfaceMesher_section_variations}.

A call to 
\ccc{surface_mesher(c2t3,surf,criteria) } launches 
the meshing process with an initial 
set of points which is the union of two subsets:
the set of vertices in the  initial triangulation pointed to by \ccc{c2t3},
and a set of points provided by the \ccc{Compute_initial_points()} functor 
of the traits class. This initial set of points is required 
to include at least one point on each connected component of the surface
to be meshed.


\section{Example}
\label{SurfaceMesher_section_example}

The following code meshes a sphere 
given as the zero level set of a function $\R^3 \longrightarrow \R$
coded in the procedure \ccc{sphere_function}.
More precisely, 
the surface to be meshed is created 
by the constructor
of the class \ccc{Implicit_surface_3<Kernel, Function>}
from a pointer to the function \ccc{sphere_function}.

The default meshing criteria are determined  by three numerical
values: \\ 
\ccc{angular_bound} is a lower bound in degrees for the angles 
     of mesh facets.\\
\ccc{radius_bound} is an upper bound on the radii of surface Delaunay
balls. A surface Delaunay ball is ball circumscribing a mesh facet
and centered on the surface. \\
\ccc{distance_bound} is an upper bound for the distance 
between the circumcenter of a mesh facet and the center of a surface
Delaunay ball of this facet.

Given this surface type, the surface mesher will use
the automatically generated traits class
\ccc{Surface_mesh_traits_generator_3<Surface>}.

\ccIncludeExampleCode{Surface_mesher/implicit_surface_mesher.C}

\section{Meshing criteria, guarantees and variations}
\label{SurfaceMesher_section_criteria}
\label{SurfaceMesher_section_variations}

The guarantees on the output mesh depend on the mesh criteria.
Theoretical guarantees are given in \cite{cgal:sry-mvbss-05}.
First, the meshing algorithm is proved to terminate 
if the angular bound is
not smaller than $20,7^o$. 
Furthermore, the output mesh 
is guaranteed to be homeomorphic to the surface
and  there is a guaranteed bound 
on the  distance (Hausdorff and even Frechet distance)
between the mesh and the surface
if the radius bound is everywhere smaller than 
the $\epsilon$ times the local feature size. 
Here $\epsilon$ is a constant whish has to be
less than 0.16, and the local feature size 
$lfs(x)$ is defined on each point $x$ of the surface
as the distance from $x$ to the medial axis.  
Note that the radius bound need not be uniform,
although it is a uniform bound in the default criteria.

Of course, such a theoretical guarantee can be only achieved
for smooth surfaces which have a finite, non zero
reach value. (The reach of a surface is the minimum value 
of local feature size on
this surface).

The value of the local feature size on any point of the surface
or its minimum on the surface it usually not known
although it can sometimes be guessed. Also it happens frequently
that setting the meshing criteria so as to fulfill the theoretical
conditions yield an over refined mesh.
On the other hand, when the size criteria are relaxed,
no homeomorphism with the input surface is guaranteed
and the output mesh is not even guaranteed to be manifold.
To remedy this problem and give a more flexible
meshing algorithm, the global function 
\ccc{make_surface_mesh} has a tag template parameter
allowing to slightly change the behavior of the refinement process.
This feature allows for instance to run the meshing
algorithm with a relaxed size criteria, more coherent
with the size of the mesh expected by the user,
and still have a guarantee that
the output mesh forms a manifold surface.
The function \ccc{make_surface_mesh} has specialized versions
for the following  tag types: \\
\ccc{Manifold_tag}: the output mesh is guaranteed to be a manifold
surface without boundary.\\
\ccc{Manifold_with_boundary_tag}: the output mesh is guaranteed to be
manifold but may have boundaries.\\
\ccc{Non_manifold_tag}: the algorithm relies on the given criteria and
guarantees nothing else.

\section{Implementation}
% TODO: rename it "Design and Implementation History"
The meshing algorithm is implemented using the design of mesher levels
described in \cite{cgal:ry-gsddrm-06}. 




