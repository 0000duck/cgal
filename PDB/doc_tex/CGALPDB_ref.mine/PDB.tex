% +------------------------------------------------------------------------+
% | Reference manual page: PDB.tex
% +------------------------------------------------------------------------+
% | 10.04.2009   Author
% | Package: PDB
% |
\RCSdef{\RCSPDBRev}{$Id: header.tex 40270 2007-09-07 15:29:10Z lsaboret $}
\RCSdefDate{\RCSPDBDate}{$Date: 2007-09-07 08:29:10 -0700 (Fri, 07 Sep 2007) $}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}[PDB::]{PDB}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

A class for representing a whole PDB file with possibly several models.

See \ccc{pdb_split}.cpp for an example manipulating a PDB by splitting it into parts.

%END-AUTO(\ccDefinition)
  
% The section below is automatically generated. Do not edit!
%START-AUTO(\ccInclude)

\ccInclude{CGAL/PDB/PDB.h}

%END-AUTO(\ccInclude)

\ccIsModel

\ccTypes

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\paragraph[{\ccc{Model_key}}]{typedef Label$<$PDB$>$ \ccc{Model_key}}
\paragraph[{Headers}]{typedef \ccc{boost::iterator_range<std::vector<std::string>::const_iterator} $>$ Headers}
An iterator through the unparsed \ccc{std::string} lines of the header of the PDB.
\paragraph[{Models}]{typedef \ccc{boost::iterator_range<ModelsMap::iterator>} Models}
An iterator through the Model objects in the PDB.
\paragraph[{\ccc{Model_consts}}]{typedef \ccc{boost::iterator_range<ModelsMap::const_iterator>} \ccc{Model_consts}}
\paragraph[{Chains}]{typedef \ccc{boost::iterator_range<internal::Nested_iterator<Iterator_traits>} $>$ Chains}
An iterator through the \ccc{PDB::Chain} objects contained in the PDB.
\paragraph[{\ccc{Chain_consts}}]{typedef \ccc{boost::iterator_range<internal::Nested_iterator<Iterator_const_traits>} $>$ \ccc{Chain_consts}}

%END-AUTO(\ccTypes)

\ccCreation
\ccCreationVariable{a}  %% choose variable name

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\paragraph[{PDB}]{PDB (\ccc{std::istream}\& in, bool \ccc{print_errors} = false)}
Read a pdb file from the stream.
The optional bool controls whether errors (such as unparsable PDB lines). Set it to false to disable printing errors.
\paragraph[{PDB}]{PDB ()}
Construct a empty PDB.
\paragraph[{$\sim$PDB}]{$\sim$PDB ()}

%END-AUTO(\ccCreation)

\ccOperations

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccOperations)

\paragraph[{write}]{\ccc{std::ostream}\& write (\ccc{std::ostream}\& out) const}
Write a pdb file to the stream.
\paragraph[{\ccc{push_back}}]{\ccc{Model_key} \ccc{push_back} (const Model\& m)}
add a model with an automatically chosen number
\paragraph[{empty}]{bool empty () const}
check if there are no models
\paragraph[{\ccc{swap_with}}]{void \ccc{swap_with} (PDB\& o)}
\paragraph[{\ccc{set_header}}]{void \ccc{set_header} (It b, It e)}
Set the header.
\paragraph[{headers}]{Headers headers () const}
\paragraph[{models}]{Models models ()}
\paragraph[{models}]{\ccc{Model_consts} models () const}
\paragraph[{contains}]{bool contains (\ccc{Model_key} k) const}
Find a Model with the given key, return \ccc{models_end}() if none is found.
\paragraph[{get}]{\ccc{Models::iterator::reference} get (\ccc{Model_key} k)}
\paragraph[{find}]{\ccc{Models::iterator} find (\ccc{Model_key} k)}
\paragraph[{get}]{\ccc{Model_consts::const_iterator::value_type} get (\ccc{Model_key} k) const}
\paragraph[{find}]{\ccc{Model_consts::const_iterator} find (\ccc{Model_key} k) const}
\paragraph[{insert}]{void insert (\ccc{Model_key} k, const Model\& m)}
Add a model (or change an existing one).
\paragraph[{chains}]{Chains chains ()}
\paragraph[{chains}]{\ccc{Chain_consts} chains () const}

%END-AUTO(\ccOperations)

\ccSeeAlso

\ccExample

A short example program.
Instead of a short program fragment, a full running program can be
included using the 
\verb|\ccIncludeExampleCode{PDB/PDB.C}| 
macro. The program example would be part of the source code distribution and
also part of the automatic test suite.

\begin{ccExampleCode}
void your_example_code() {
}
\end{ccExampleCode}

%% \ccIncludeExampleCode{PDB/PDB.C}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

