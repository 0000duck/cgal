#include <iostream>
#include <CGAL/basic.h>

#include <CGAL/Arithmetic_kernel.h>
#include <CGAL/Sqrt_extension.h>
#include <CGAL/_test_algebraic_structure.h>
#include <CGAL/_test_real_embeddable.h>

#include <cstdlib>
#include <sstream>

// TODO: Included from EXACUS/NumeriX/include/NiX/number_type_utils.h
CGAL_BEGIN_NAMESPACE
template <class NT , class RT>
inline 
void convert_to(const NT& x, RT& r){ 
    typedef CGAL::Coercion_traits<NT,RT> CT;
    typedef typename CT::Type Type;
    BOOST_STATIC_ASSERT((::boost::is_same<Type,RT>::value));
    r = typename CT::Cast()(x);
}
CGAL_END_NAMESPACE
// end included from number_type_utils.h

template <class NT>
void test_io(const NT& x){
    NT tmp;
    std::ostringstream os;  
    os << x;
    std::istringstream is(os.str()); 
    is >> tmp;
    CGAL_test_assert_msg( x == tmp, "IO_TEST failed");
}

template <class EXT> 
void constructor_test(){
    typedef typename EXT::NT NT;
    typedef typename EXT::ROOT ROOT;
    CGAL_test_assert(EXT()==EXT((NT)0));
    CGAL_test_assert(EXT()==EXT((NT)0,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT().is_extended()==false);
    // from int
    CGAL_test_assert(EXT( 1)==EXT((NT) 1,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT(-1)==EXT((NT)-1,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT( 7)==EXT((NT) 7,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT(-7)==EXT((NT)-7,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT( 1)+EXT(-1)==EXT());
    CGAL_test_assert(EXT(1).is_extended()==false);
    // from NT
    CGAL_test_assert(EXT((NT) 1)==EXT((NT) 1,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT((NT)-1)==EXT((NT)-1,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT((NT) 7)==EXT((NT) 7,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT((NT)-7)==EXT((NT)-7,(NT)0,(ROOT)7));
    CGAL_test_assert(EXT((NT) 1)+EXT((NT)-1)==EXT());
    CGAL_test_assert(EXT((NT)1).is_extended()==false);
    // general constructor 
    const EXT x(NT(3),NT(4),ROOT(17));
    CGAL_test_assert(x.a0()==NT(3));
    CGAL_test_assert(x.a1()==NT(4));
    CGAL_test_assert(x.root()==ROOT(17));
    CGAL_test_assert(x.is_extended()==true);
}

template <class EXT> 
void other_functions_test(){
    typedef typename EXT::NT NT;
    typedef typename EXT::ROOT ROOT;

    // is_zero
    CGAL_test_assert( EXT(NT( 0),NT( 0),ROOT(17)).is_zero());
    CGAL_test_assert(!EXT(NT( 3),NT( 0),ROOT(17)).is_zero());
    CGAL_test_assert(!EXT(NT(-3),NT( 0),ROOT(17)).is_zero());
    CGAL_test_assert(!EXT(NT( 0),NT( 3),ROOT(17)).is_zero());
    CGAL_test_assert(!EXT(NT( 0),NT(-3),ROOT(17)).is_zero());
    CGAL_test_assert(!EXT(NT(-3),NT(-3),ROOT(17)).is_zero());
    CGAL_test_assert( EXT(NT( 0)).is_zero());
    CGAL_test_assert(!EXT(NT(-5)).is_zero());
    CGAL_test_assert(!EXT(NT( 5)).is_zero());
    CGAL_test_assert( EXT(NT( 0),NT( 0),ROOT(4)).is_zero());
    CGAL_test_assert(!EXT(NT( 6),NT( 3),ROOT(4)).is_zero());
    CGAL_test_assert( EXT(NT( 6),NT(-3),ROOT(4)).is_zero());
  
    // abs 
    {
        EXT x  = EXT(NT(-3),NT(-3),ROOT(17));
        EXT ax = EXT(NT( 3),NT( 3),ROOT(17));
        CGAL_test_assert(x.abs() == ax);    
    }{
        EXT x  = EXT(NT( 3),NT(-3),ROOT(17));
        EXT ax = EXT(NT(-3),NT( 3),ROOT(17));
        CGAL_test_assert(x.abs() == ax);        
    }{
        EXT x  = EXT(NT(-3),NT( 3),ROOT(17));
        EXT ax = EXT(NT(-3),NT( 3),ROOT(17));
        CGAL_test_assert(x.abs() == ax);        
    }{
        EXT x  = EXT(NT( 3),NT( 3),ROOT(17));
        EXT ax = EXT(NT( 3),NT( 3),ROOT(17));
        CGAL_test_assert(x.abs() == ax);        
    }
    // division / integral division in case root is a square
    {
        EXT x(4,6,4);
        EXT y(2,1,4);
        CGAL_test_assert(x/y ==EXT(4));
    }{
        EXT x(4);
        EXT y(2,1,4);
        CGAL_test_assert(x/y ==EXT(1));
    }
}

// TODO: No Modular_traits available yet.
/*template <class EXT> 
void modular_traits_test(){
    typedef typename EXT::NT NT;
    typedef typename EXT::ROOT ROOT;
    typedef NiX::Modular_traits<EXT> MTraits;    
    typedef typename MTraits::Modular_NT EXT_MOD;

    NiX::Modular::set_current_prime(7);
    typename MTraits::Modular_image modular_image;
    {
        EXT a1(13,-10,4);
        EXT_MOD a1_mod= modular_image(a1);
        CGAL_test_assert(a1_mod==EXT_MOD(6,4,4));    
        CGAL_test_assert(a1_mod.is_zero()); 
    }{
        EXT a1(13);
        EXT_MOD a1_mod= modular_image(a1);
        CGAL_test_assert(a1_mod==EXT_MOD(6));    
        CGAL_test_assert(!a1_mod.is_extended());  
    }
}*/

template <class EXT> 
void io_test(){
    typedef typename EXT::NT NT;
    typedef typename EXT::ROOT ROOT;

    test_io(EXT(0,0,5));     
    test_io(EXT(0,2,5));     
    test_io(EXT(4,0,5));  
    test_io(EXT(-4,2,5));
    test_io(EXT(4,-2,5));     
    test_io(EXT(-4,-2,5));   
    test_io(EXT(5));   
    
    std::ostringstream os;
    EXT(0).output_maple(os); // no real test just to instantiate code  
}

void is_exact_test(){
 
    typedef CGAL::Tag_true  T;
    typedef CGAL::Tag_false F;
        
    {
        typedef CGAL::Sqrt_extension<int,int> NT;
            
        CGAL_test_assert((boost::is_same< CGAL::Algebraic_structure_traits< NT >::Is_exact, 
                  CGAL::Tag_true >::value));
            
    }
    {
        typedef CGAL::Sqrt_extension<int,double > NT;
            
        CGAL_test_assert((boost::is_same< CGAL::Algebraic_structure_traits< NT >::Is_exact, 
                  CGAL::Tag_false >::value));
    }
    {
        typedef CGAL::Sqrt_extension<double,int > NT;
            
        CGAL_test_assert((boost::is_same< CGAL::Algebraic_structure_traits< NT >::Is_exact, 
                  CGAL::Tag_false >::value));
    }
    {
        typedef CGAL::Sqrt_extension<double,double> NT;
            
        CGAL_test_assert((boost::is_same< CGAL::Algebraic_structure_traits< NT >::Is_exact, 
                  CGAL::Tag_false >::value));
    }
}

template<class NT, class ROOT,class REAL>
void convert_to_real(){
    typedef CGAL::Sqrt_extension<NT,ROOT> EXT1;
   
    {
        EXT1 ext((NT)3 ,(NT)5  ,(ROOT)17);
        REAL real= REAL(3)+REAL(5)*CGAL_NTS sqrt(REAL(17));
        REAL tmp;
        CGAL::convert_to(ext,tmp);
        CGAL_test_assert(tmp==real);
    }{
        EXT1 ext((NT)3);
        REAL real= REAL(3);
        REAL tmp;
        CGAL::convert_to(ext,tmp);
        CGAL_test_assert(tmp==real);
    }
    
}

/*template<class NT, class ROOT>
void convert_to_polynomial(){
    typedef CGAL::Sqrt_extension<NT,ROOT> EXT1;
    typedef CGAL::Polynomial<EXT1> POLY;
    
    EXT1 ext((NT)3 ,(NT)5  ,(ROOT)17);
    POLY p(ext);
    POLY tmp;
    CGAL::convert_to(ext,tmp);
    CGAL_test_assert(tmp==p);
}*/

template < class AT> 
void sqrt_ext_pretty_output_test(){
    typedef typename AT::Integer Integer;
    typedef CGAL::Sqrt_extension<Integer,Integer>  EXT1;
    typedef CGAL::Sqrt_extension<EXT1,Integer> EXT2;
    // TEST without Parens_as_product_tag
    {
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(-1,0,2);
        CGAL_test_assert( ss.str()=="-1"); 
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(0,0,2);
        CGAL_test_assert( ss.str() == "0");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(1,0,2);
        CGAL_test_assert( ss.str() == "1");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(1,2,2);
        CGAL_test_assert( ss.str() == "1+2*sqrt(2)");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(1,-2,2);
        CGAL_test_assert( ss.str() == "1+(-2)*sqrt(2)");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(-1,2,2);
        CGAL_test_assert( ss.str() == "-1+2*sqrt(2)");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(-1,-2,2);
        CGAL_test_assert( ss.str() == "-1+(-2)*sqrt(2)");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(0,2,2);
        CGAL_test_assert( ss.str()=="2*sqrt(2)");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << EXT1(0,-2,2);
        CGAL_test_assert( ss.str()=="(-2)*sqrt(2)");
    }
// TEST with Parens_as_product_tag
    {
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(-1,0,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str()=="(-1)"); 
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(0,0,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str() == "0");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(1,0,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str() == "1");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(1,2,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str() == "(1+2*sqrt(2))");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(1,-2,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str() == "(1+(-2)*sqrt(2))");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(-1,2,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str() == "(-1+2*sqrt(2))");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(-1,-2,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str() == "(-1+(-2)*sqrt(2))");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(0,2,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str()=="2*sqrt(2)");
    }{
        std::stringstream ss;
        CGAL::set_pretty_mode(ss);
        ss << oformat(EXT1(0,-2,2),CGAL::Parens_as_product_tag());
        CGAL_test_assert( ss.str()=="(-2)*sqrt(2)");
    }
}


template <class EXT>
void to_double_test(){
    typedef typename EXT::NT NT;
    typedef typename EXT::ROOT ROOT;
    typedef CGAL::Real_embeddable_traits<EXT> NTT;

    typename NTT::To_double to_double;
    typename NTT::To_interval to_interval; 

    {
    NT a0(1);
    NT a1(2);
    ROOT root(4);
    EXT ext(a0,a1,root);

    CGAL_test_assert(to_double(ext)==5.0);
    CGAL_test_assert(to_interval(ext)==CGAL_NTS to_interval(5.0) );
    }{
    NT a0(1);
    NT a1(-2);
    ROOT root(4);
    EXT ext(a0,a1,root);

    CGAL_test_assert(to_double(ext)==-3.0);
    CGAL_test_assert(to_interval(ext)==CGAL_NTS to_interval(-3.0) );
    }
}
template <class NT, class ROOT, class Algebraic_type>
void general_test(){
    typedef CGAL::Sqrt_extension<NT,ROOT> EXT1;
    EXT1 a1((NT)3 ,(NT)5  ,(ROOT)17);
    EXT1 b1((NT)-2,(NT)3  ,(ROOT)17);
    EXT1 c1((NT)7 ,(NT)-11,(ROOT)17);
    CGAL::test_algebraic_structure_without_exactness_check<EXT1,Algebraic_type>(a1,b1,c1);
    CGAL::test_real_embeddable<EXT1>();

    typedef CGAL::Sqrt_extension<EXT1,ROOT> EXT2;
    EXT2 a2(b1 ,a1  ,(ROOT)19);
    EXT2 b2(c1,(EXT1)0 ,(ROOT)19);
    EXT2 c2((EXT1)0 ,(EXT1)-11,(ROOT)19);
    CGAL::test_algebraic_structure_without_exactness_check<EXT2,Algebraic_type>(a2,b2,c2);
    CGAL::test_real_embeddable<EXT2>();
 
    typedef CGAL::Sqrt_extension<EXT2,ROOT> EXT3;
    EXT3 a3(b2 ,a2  ,(ROOT)23);
    EXT3 b3(c2,(EXT2)0 ,(ROOT)23);
    EXT3 c3((EXT2)0 ,(EXT2)-11,(ROOT)23);
    CGAL::test_algebraic_structure_without_exactness_check<EXT3,Algebraic_type>(a3,b3,c3);
    CGAL::test_real_embeddable<EXT3>();

    constructor_test<EXT1>();
    constructor_test<EXT2>();
    constructor_test<EXT3>();

    other_functions_test<EXT1>();
    other_functions_test<EXT2>();
    other_functions_test<EXT3>();
 
    // TODO: No modular traits available
//    modular_traits_test<EXT1>();
//    modular_traits_test<EXT2>();
//    modular_traits_test<EXT3>();

    io_test<EXT1>();
    io_test<EXT2>();
    io_test<EXT3>();  
   
    to_double_test<EXT1>();
}

/*
template <class AT>
void scalar_factor_traits_test(){
    {
        typedef typename AT::Integer Integer;
        typedef CGAL::Sqrt_extension<Integer,Integer> EXT1;
        typedef CGAL::Sqrt_extension<EXT1,Integer>    EXT2;

        {
            typedef CGAL::Scalar_factor_traits<EXT1> SFT;
            typedef typename SFT::Scalar Scalar;
            typename SFT::Scalar_factor sfac;            
            typename SFT::Scalar_div    sdiv;

            CGAL_test_assert( (boost::is_same<Scalar, Integer>::value) );
            
            CGAL_test_assert((sfac(EXT1(0)))==Integer(0));
            CGAL_test_assert((sfac(EXT1(3)))==Integer(3));
            CGAL_test_assert((sfac(EXT1(0,3,2)))==Integer(3));
            CGAL_test_assert((sfac(EXT1(6,9,2)))==Integer(3));
            EXT1 tmp;
            tmp = EXT1(3); sdiv(tmp,sfac(tmp));  CGAL_test_assert(tmp==EXT1(1));
            tmp = EXT1(0,3,2); sdiv(tmp,sfac(tmp));  CGAL_test_assert(tmp==EXT1(0,1,2));
            tmp = EXT1(6,9,2); sdiv(tmp,sfac(tmp));  CGAL_test_assert(tmp==EXT1(2,3,2));
        }
        {
            typedef CGAL::Scalar_factor_traits<EXT2> SFT;
            typedef typename SFT::Scalar Scalar;
            typename SFT::Scalar_factor sfac;            
            typename SFT::Scalar_div    sdiv;

            CGAL_test_assert( (boost::is_same<Scalar, Integer>::value) );
            
            CGAL_test_assert((sfac(EXT2(0)))==Integer(0));
            CGAL_test_assert((sfac(EXT2(3)))==Integer(3));
            CGAL_test_assert((sfac(EXT2(EXT1(0),EXT1(3),2)))==Integer(3));
            CGAL_test_assert((sfac(EXT2(EXT1(6),EXT1(9),2)))==Integer(3));
            EXT2 tmp;
            tmp = EXT2(3); sdiv(tmp,sfac(tmp));  CGAL_test_assert(tmp==EXT2(1));
            tmp = EXT2(0,3,2); sdiv(tmp,sfac(tmp));  CGAL_test_assert(tmp==EXT2(0,1,2));
            tmp = EXT2(6,9,2); sdiv(tmp,sfac(tmp));  CGAL_test_assert(tmp==EXT2(2,3,2));    
        }
        {
            typedef CGAL::Scalar_factor_traits<EXT1> SFT;
            typedef typename SFT::Scalar Scalar;
            typename SFT::Scalar_factor sfac;      
  
            CGAL_test_assert( (boost::is_same<Scalar, Integer>::value) );
  
            CGAL_test_assert((sfac(EXT1(0)))                 ==Integer(0));
            CGAL_test_assert((sfac(EXT1(9),Integer(15)))     ==Integer(3));
            CGAL_test_assert((sfac(EXT1(0,9,2),Integer(15))) ==Integer(3));
            CGAL_test_assert((sfac(EXT1(18,9,2),Integer(15)))==Integer(3));
        }
    }
    }*/

// TODO: No to_Sqrt_extension available in CGAL.
/*template <class AT>
void to_Sqrt_extension_test() {
//    CGAL_SNAP_ARITHMETIC_KERNEL_TYPEDEFS(AT);
    typedef leda_integer Integer;
    typedef leda_rational Rational;
    typedef CGAL::Sqrt_extension<Rational,Integer> EXT;
    
    EXT e1(4);
    
    CGAL_test_assert(e1 == CGAL::to_Sqrt_extension< EXT >(ar1,true));
    
    Poly_int1 p2(Integer(-2), Integer(0), Integer(1));
    Algebraic_real ar2m(p2, Rational(-2), Rational(0));
    Algebraic_real ar2p(p2, Rational(0), Rational(2));
    
    EXT e2m(0,-1,2);
    EXT e2p(0, 1,2);
    
    CGAL_test_assert(e2m == CGAL::to_Sqrt_extension< EXT >(ar2m, true));
    CGAL_test_assert(e2p == CGAL::to_Sqrt_extension< EXT >(ar2p, true));

    Poly_int1 p3(Integer(-1), Integer(4), Integer(5));
    Algebraic_real arat1(p3, Rational(-2), Rational(0));
    Algebraic_real arat2(p3, Rational(0), Rational(1));
                       
    EXT erat1(Rational(-1));
    EXT erat2((Rational(1)/Rational(5)));
    
    CGAL_test_assert(erat1 == CGAL::to_Sqrt_extension< EXT >(arat1,true));
    CGAL_test_assert(erat2 == CGAL::to_Sqrt_extension< EXT >(arat2,true));
}*/


// TODO: Adapt when fraction_traits are available
/*template <class AT>
void fraction_traits_test(){
    //TEST Type traits ROOT of type INT 
    typedef typename AT::Integer  INT;
    typedef typename AT::Rational RAT;
    
    typedef CGAL::Sqrt_extension<RAT     ,INT> RAT1_EXT;
    typedef CGAL::Sqrt_extension<INT     ,INT> INT1_EXT;
    typedef CGAL::Sqrt_extension<RAT1_EXT,INT> RAT2_EXT;
    typedef CGAL::Sqrt_extension<INT1_EXT,INT> INT2_EXT;
    typedef CGAL::Sqrt_extension<RAT2_EXT,INT> RAT3_EXT;
    typedef CGAL::Sqrt_extension<INT2_EXT,INT> INT3_EXT;
    
    typedef CGAL::Fraction_traits<RAT1_EXT> RAT_FT1;
    typedef CGAL::Fraction_traits<RAT2_EXT> RAT_FT2;
    typedef CGAL::Fraction_traits<RAT3_EXT> RAT_FT3;
        
    typedef CGAL::Fraction_traits<INT1_EXT> INT_FT1;
    typedef CGAL::Fraction_traits<INT2_EXT> INT_FT2;
    typedef CGAL::Fraction_traits<INT3_EXT> INT_FT3;
        
    // RAT_FTs decomposable
    CGAL_test_assert((boost::is_same< typename RAT_FT1::Is_decomposable, 
              CGAL::Tag_true>::value)); 
    CGAL_test_assert((boost::is_same< typename RAT_FT2::Is_decomposable, 
              CGAL::Tag_true>::value));
    CGAL_test_assert((boost::is_same< typename RAT_FT3::Is_decomposable, 
              CGAL::Tag_true>::value));  
    // RAT_FTi Numerator_type == INTi_EXT
    CGAL_test_assert((boost::is_same< typename RAT_FT1::Numerator_type, 
              INT1_EXT>::value));
    CGAL_test_assert((boost::is_same< typename RAT_FT2::Numerator_type, 
              INT2_EXT>::value));
    CGAL_test_assert((boost::is_same< typename RAT_FT3::Numerator_type, 
               INT3_EXT>::value));
    // RAT_FTi Denomiantor == INT
    CGAL_test_assert((boost::is_same< typename RAT_FT1::Denominator_type, 
              INT>::value));
    CGAL_test_assert((boost::is_same< typename RAT_FT2::Denominator_type, 
              INT>::value));
    CGAL_test_assert((boost::is_same< typename RAT_FT3::Denominator_type, 
              INT>::value));
 
    // INT_FTs not decomposable 
    CGAL_test_assert((boost::is_same< typename INT_FT1::Is_decomposable, 
              CGAL::Tag_false>::value));  
    CGAL_test_assert((boost::is_same< typename INT_FT2::Is_decomposable, 
              CGAL::Tag_false>::value));    
    CGAL_test_assert((boost::is_same< typename INT_FT2::Is_decomposable, 
              CGAL::Tag_false>::value)); 
    {
        typedef CGAL::Sqrt_extension<RAT,RAT>   RAT_RAT_EXT;
        typedef CGAL::Fraction_traits<RAT_RAT_EXT> RAT_RAT_FT;
        CGAL_test_assert((boost::is_same< typename RAT_RAT_FT::Is_decomposable, 
                  CGAL::Tag_false>::value));  
    }{
        typedef CGAL::Sqrt_extension<INT1_EXT,INT1_EXT> INT_nEXT; 
        typedef CGAL::Fraction_traits<INT_nEXT> INT_nEXT_FT;
        CGAL_test_assert((boost::is_same< typename INT_nEXT_FT::Is_decomposable, 
                  CGAL::Tag_false>::value));     
    } 
  
    {
        // Semantic for RAT1_EXT
        RAT1_EXT a(RAT(3)/RAT(10),RAT(4)/RAT(15),INT(5));
        typename RAT_FT1::Decompose decompose;
        typename RAT_FT1::Numerator_type  num;
        typename RAT_FT1::Denominator_type den;
        decompose(a,num,den);
        CGAL_test_assert(num==typename RAT_FT1::Numerator_type(INT(9),INT(8),INT(5)));
        CGAL_test_assert(den==typename RAT_FT1::Denominator_type(INT(30)));
        typename RAT_FT1::Compose compose;
        CGAL_test_assert(a==compose(num,den));
        {
            RAT1_EXT a(RAT(3)/RAT(10));
            decompose(a,num,den);
            CGAL_test_assert(num==typename RAT_FT1::Numerator_type(INT(3)));
            CGAL_test_assert(den==typename RAT_FT1::Denominator_type(INT(10)));
            CGAL_test_assert(!num.is_extended());
        }
    }
    {
        // Semantic RAT2_EXT
        RAT1_EXT a0(RAT(3)/RAT(10),RAT(4)/RAT(15),INT(5));
        RAT1_EXT a1(RAT(7)/RAT(3),RAT(5)/RAT(7),INT(5));
        RAT2_EXT a(a0,a1,INT(7));
        typename RAT_FT2::Decompose decompose;
        typename RAT_FT2::Numerator_type   num;
        typename RAT_FT2::Denominator_type den;
        decompose(a,num,den);
        CGAL_test_assert(num==INT2_EXT(INT1_EXT(INT(63),INT(56),INT(5)),
                               INT1_EXT(INT(490),INT(150),INT(5)),
                               INT(7)));
        CGAL_test_assert(den==typename RAT_FT2::Denominator_type(INT(210)));
        typename RAT_FT2::Compose compose;
        CGAL_test_assert(a==compose(num,den));
    }    
    

}*/

/*
template <class AT>
void test_algebraic_number_traits(){
    typedef typename AT::Integer  INT;
    typedef typename AT::Rational RAT;
    
    typedef CGAL::Sqrt_extension<RAT     ,INT> RAT1_EXT;
    typedef CGAL::Sqrt_extension<INT     ,INT> INT1_EXT;
    typedef CGAL::Sqrt_extension<RAT1_EXT,INT> RAT2_EXT;
    typedef CGAL::Sqrt_extension<INT1_EXT,INT> INT2_EXT;
    
    // normalisation factor
    typedef CGAL::Algebraic_number_traits<RAT1_EXT> RAT1_EXT_ANT;
    typedef CGAL::Algebraic_number_traits<INT1_EXT> INT1_EXT_ANT;
    typedef CGAL::Algebraic_number_traits<RAT2_EXT> RAT2_EXT_ANT;
    typedef CGAL::Algebraic_number_traits<INT2_EXT> INT2_EXT_ANT;
    
    {
        INT1_EXT a(INT(3),INT(5),INT(7));
        typename INT1_EXT_ANT::Normalization_factor normalization_factor;
        INT1_EXT r=normalization_factor(a);
        CGAL_test_assert(r.a0()    ==INT( 3));
        CGAL_test_assert(r.a1()    ==INT(-5));
        CGAL_test_assert(r.root()  ==INT( 7));
        CGAL_test_assert((r*a).a1()==INT( 0));
    }{
        RAT1_EXT a(RAT(3)/RAT(5),RAT(5)/RAT(11),INT(7));
        typename RAT1_EXT_ANT::Normalization_factor normalization_factor;
        RAT1_EXT r=normalization_factor(a);
        CGAL_test_assert((r*a).a1()==RAT( 0));
    }{
        INT1_EXT a0(4,3,7);
        INT1_EXT a1(8,9,7);
        INT      root(5);
        INT2_EXT a(a0,a1,root);
        typename INT2_EXT_ANT::Normalization_factor normalization_factor;
        INT2_EXT r=normalization_factor(a);
        
        CGAL_test_assert((r*a).a1()==INT1_EXT(0));
        CGAL_test_assert((r*a).a0().a1()==INT(0));
    }{
        RAT1_EXT a0(4,3,7);
        RAT1_EXT a1(8,9,7);
        INT      root(5);
        RAT2_EXT a(a0,a1,root);
        typename RAT2_EXT_ANT::Normalization_factor normalization_factor;
        RAT2_EXT r=normalization_factor(a);
        CGAL_test_assert((r*a).a1()==   RAT1_EXT(0));
        CGAL_test_assert((r*a).a0().a1()==RAT(0));
    }{
       INT1_EXT a(INT(3));
       typename INT1_EXT_ANT::Normalization_factor normalization_factor;
       INT1_EXT r=normalization_factor(a);
       CGAL_test_assert(r.a0()    ==INT(1));
       CGAL_test_assert(r.a1()    ==INT(0));
       CGAL_test_assert(r.root()  ==INT(0));
       CGAL_test_assert(!(r*a).is_extended()); 
    }

    // denomiantor for algebraic integers
    {
        typedef typename AT::Integer  Integer;
        typedef CGAL::Sqrt_extension<Integer,Integer> Extn_1;
        typedef CGAL::Algebraic_number_traits<Extn_1> ANT;
        typename ANT::Denominator_type_for_algebraic_integers dfai;
        Extn_1 ext(1,2,5);
        CGAL_test_assert(dfai(ext)==Extn_1(20));
    }{
        typedef typename AT::Integer  Integer;
        typedef CGAL::Sqrt_extension<Integer,Integer> Extn_1;
        typedef CGAL::Sqrt_extension<Extn_1, Integer> Extn_2;
        typedef CGAL::Algebraic_number_traits<Extn_2> ANT;
        typename ANT::Denominator_type_for_algebraic_integers dfai;
        {
            Extn_1 a0(1);
            Extn_1 a1(2);
            Integer root(5);
            Extn_2 ext(a0,a1,root);
            CGAL_test_assert(dfai(ext)==Extn_2(20));
            
        }{
            Extn_1 a0(1,2,5);
            Extn_1 a1(2,3,5);
            Integer root(7);
            Extn_2 ext(a0,a1,root);
            CGAL_test_assert(dfai(ext)==Extn_2(20 *28));
        }
    }{
        typedef typename AT::Integer  Integer;
        typedef CGAL::Sqrt_extension<Integer,Integer>  Extn_1;
        typedef CGAL::Sqrt_extension<Extn_1, Extn_1>   Extn_2;
        typedef CGAL::Algebraic_number_traits<Extn_2> ANT;
        typename ANT::Denominator_type_for_algebraic_integers dfai;
        {
            Extn_1 a0(1);
            Extn_1 a1(2);
            Extn_1 root(5);
            Extn_2 ext(a0,a1,root);
            CGAL_test_assert(dfai(ext)==Extn_2(20));
            
        }{
            Extn_1 a0(1,2,5);
            Extn_1 a1(2,3,5);
            Extn_1 root(7);
            Extn_2 ext(a0,a1,root);
            CGAL_test_assert(dfai(ext)==Extn_2(20 *28));
        }{
            Extn_1 a0(1,2,5);
            Extn_1 a1(2,3,5);
            Extn_1 root(4,5,5);
            Extn_2 ext(a0,a1,root);
            CGAL_test_assert(dfai(ext)==Extn_2(20)*Extn_2(4)*Extn_2(Extn_1(4,5,5)));
        }
        {
            
            std::vector<Extn_2> vec;
            Extn_1 root(Extn_1(2,3,5));
            vec.push_back(Extn_2(0));
            CGAL_test_assert(dfai(vec.begin(),vec.end())== Extn_2(1));
            vec.push_back(Extn_2(root));
            CGAL_test_assert(dfai(vec.begin(),vec.end())== Extn_2(20));
            vec.push_back(Extn_2(Extn_1(1),Extn_1(3),root));
            CGAL_test_assert(dfai(vec.begin(),vec.end())== Extn_2(20)*Extn_2(root)*Extn_2(4));
        }
        
    }
    
    }*/

/*template <class AT>
void polynom_test(){
    typedef typename AT::Integer Integer;
    typedef CGAL::Sqrt_extension<Integer,Integer> EXT;
    typedef CGAL::Polynomial<EXT> Poly_extn1;
    {
    Poly_extn1 pr1=Poly_extn1(EXT(3),EXT(2),EXT(1));
    Poly_extn1 pr2=Poly_extn1(EXT(-3),EXT(-2),EXT(-1));
   
    Poly_extn1 pr3 = Poly_extn1(0);

    CGAL_test_assert(pr1+pr2 == pr3);
    CGAL_test_assert(pr1+pr3 == pr1);
    CGAL_test_assert(pr2+pr3 == pr2);

    // here pr3==0 !!!
   // if (pr1==pr3)
//    {
//        if (pr2!=pr3)
//            pr3 = pr2;
//    }
//    else if (pr2==pr3)
//        pr3 = pr1;
//    else
//    pr3 = pr1 + pr2;
    // canonicalize_polynomial
    }{
        Poly_extn1 p1(EXT(3),EXT(2),EXT(1));
        Poly_extn1 p3(CGAL::canonicalize_polynomial((p1 *EXT(4,5,7))));
        CGAL_test_assert(p1==p3);
    }
}*/
template <class AT>
void sqrt_extension_test(){
    CGAL_SNAP_ARITHMETIC_KERNEL_TYPEDEFS(AT);
   
    general_test<Integer,Integer,CGAL::Integral_domain_tag>();        
    general_test<Rational,Integer,CGAL::Field_tag>(); 
 
    is_exact_test();    
    convert_to_real<Integer,Integer,Field_with_sqrt>();

// TODO: Polynomial number type is not available
//    convert_to_polynomial<Integer,Integer>();
 
    sqrt_ext_pretty_output_test<AT>();

// TODO: No Scalar_factor_traits available
//    scalar_factor_traits_test<AT>();

// TODO: No CGAL::to_sqrt_extension() available
//    to_Sqrt_extension_test<AT>();

// TODO: No Fraction_traits available yet.
//    fraction_traits_test<AT>();

// TODO: No Algebraic_number_traits available.
//test_algebraic_number_traits<AT>();

// TODO: Polynomials not working yet.
//    polynom_test<AT>();
}

int main(){ 
#ifdef CGAL_USE_LEDA
    sqrt_extension_test<CGAL::LEDA_arithmetic_kernel>();
#endif // CGAL_USE_LEDA
#ifdef CGAL_USE_CORE
    sqrt_extension_test<CGAL::CORE_arithmetic_kernel>();
#endif // CGAL_USE_CORE    
  return 0;
}


