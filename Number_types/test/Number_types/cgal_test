#! /bin/sh

# This is a script for the CGAL test suite. Such a script must obey
# the following rules:
#
# - the name of the script is cgal_test
# - for every target two one line messages are written to the file 'error.txt'
#     the first one indicates if the compilation was successful
#     the second one indicates if the execution was successful
#   if one of the two was not successful, the line should start with 'ERROR:'
# - running the script should not require any user interaction
# - the script should clean up object files and executables

ERRORFILE=error.txt

#---------------------------------------------------------------------#
#                    compile_and_run <target>
#---------------------------------------------------------------------#

compile_and_run()
{
  echo "Compiling $1 ... "
  SUCCES="y"
  if eval 'make CGAL_MAKEFILE=$CGAL_MAKEFILE \
           TESTSUITE_CXXFLAGS="$TESTSUITE_CXXFLAGS" \
           TESTSUITE_LDFLAGS="$TESTSUITE_LDFLAGS" $1' ; then
    echo "   succesful compilation of $1" >> $ERRORFILE
  else
    echo "   ERROR:    compilation of $1" >> $ERRORFILE
    SUCCES=""
  fi

  if [ -n "${SUCCES}" ] ; then
     OUTPUTFILE=ProgramOutput.$1.$PLATFORM
    rm -f $OUTPUTFILE
    COMMAND="./$1"
    if [ -f $1.cmd ] ; then
      COMMAND="$COMMAND `cat $1.cmd`"
    fi
    if [ -f $1.cin ] ; then
      COMMAND="cat $1.cin | $COMMAND"
    fi
    echo "Executing $1 ... "
    echo
    ulimit -t 3600
    if eval $COMMAND > $OUTPUTFILE 2>&1 ; then
      echo "   succesful execution   of $1" >> $ERRORFILE
    else
      echo "   ERROR:    execution   of $1" >> $ERRORFILE
    fi
  else
    echo   "   ERROR:    not executed   $1" >> $ERRORFILE
  fi

  eval "make CGAL_MAKEFILE=$CGAL_MAKEFILE clean > /dev/null 2>&1 "
}

#---------------------------------------------------------------------#
#                    remove the previous error file
#---------------------------------------------------------------------#

rm -f $ERRORFILE
touch $ERRORFILE

#---------------------------------------------------------------------#
#                    compile and run the tests
#---------------------------------------------------------------------#

if [ $# -ne 0 ] ; then
  for file in $* ; do
    compile_and_run $file
  done
else
  compile_and_run bench_interval
  compile_and_run Coercion_traits
  compile_and_run constant
  compile_and_run CORE_BigFloat
  compile_and_run CORE_BigInt
  compile_and_run CORE_BigRat
  compile_and_run CORE_Expr
  compile_and_run Counted_number
  compile_and_run double
  compile_and_run doubletst
  compile_and_run EPoint-test
  compile_and_run float
  compile_and_run floattst
  compile_and_run Gmpq
  compile_and_run Gmpq_new
  compile_and_run Gmpz
  compile_and_run int
  compile_and_run Interval_nt
  compile_and_run Interval_nt_new
  compile_and_run known_bit_size_integers
  compile_and_run Lazy_exact_nt
  compile_and_run Lazy_exact_nt_new
  compile_and_run leda_bigfloat
  compile_and_run leda_integer
  compile_and_run leda_rational
  compile_and_run leda_real
  compile_and_run long_double
  compile_and_run long_doubletst
  compile_and_run long_long
  compile_and_run MP_Float
  compile_and_run MP_Float_new
  compile_and_run mpq_class
  compile_and_run mpz_class
  compile_and_run NT_checker
  compile_and_run Quotient
  compile_and_run quotient_io
  compile_and_run Quotient_new
  compile_and_run root_of_2
  compile_and_run rounding_modes
  compile_and_run simplest_rational
  compile_and_run Sqrt_extension
  compile_and_run _test_valid_finite_double
  compile_and_run _test_valid_finite_float
  compile_and_run to_interval_test
  compile_and_run utilities
fi

