% $Id$
% $Date$
% author : Sylvain Pion

\begin{ccRefClass} {MP_Float}
%\subsection{Multi Precision Floats}
%\label{mpfloat}

\ccDefinition
An object of the class \ccc{MP_Float} is able to represent a floating point
value with arbitrary precision, that is numbers of the form $m2^e$ where
$m$ and $e$ are integers.  This number type has the property that
additions, subtractions and multiplications are computed exactly, as well as
the construction from \ccc{float}, \ccc{double} and \ccc{long double}.
It also provides integral divisions related operations.

Square root and (field) division are not enabled by default since
\cgal\ release 3.2, since they are computed approximately.  We suggest that you
use rationals like \ccc{Quotient<MP_Float>} when you need exact (rational)
divisions.  To enable division and square root, you have to define the
preprocessor macro \ccc{CGAL_MP_FLOAT_ALLOW_INEXACT}.

Note on the implementation : although the mantissa length is basically only
limited by the available memory, the exponent is currently represented by a
(integral valued) \ccc{double}, which can overflow in some circumstances.  We
plan to also have a multiprecision exponent to fix this issue.

\ccInclude{CGAL/MP_Float.h}

\ccIsModel
\ccc{EuclideanRingNumberType}

\ccCreation
\ccCreationVariable{m}

\ccConstructor{MP_Float();}
{introduces an uninitialized variable \ccVar.}
\ccGlue
\ccConstructor{MP_Float(const MP_Float &);}
{copy constructor.}
\ccGlue
\ccConstructor{MP_Float(int i)}
{introduces the integral value i.}
\ccGlue
\ccConstructor{MP_Float(float d)}
{introduces the floating point value d (exact conversion).}
\ccGlue
\ccConstructor{MP_Float(double d)}
{introduces the floating point value d (exact conversion).}
\ccGlue
\ccConstructor{MP_Float(long double d)}
{introduces the floating point value d (exact conversion).}

\ccOperations

\ccFunction{std::ostream& operator<<(std::ostream& out, const MP_Float& m);}
{writes a double approximation of \ccc{m} to the ostream \ccc{out}.}

\ccFunction{std::istream& operator>>(std::istream& in, MP_Float& m);}
{reads a \ccc{double} from \ccc{in}, then converts it to an \ccc{MP_Float}.}

\ccFunction{bool divides(const MP_Float &a, const MP_Float &b);}
{returns true iff \ccc{b} divides \ccc{a}.}

\ccFunction{MP_Float exact_division(const MP_Float &a, const MP_Float &b);}
{computes the result of the division of \ccc{a} by \ccc{b}.
\ccPrecond{divides(a, b)}.}

\ccFunction{MP_Float div(const MP_Float &a, const MP_Float &b);}
{returns the result of the integral division of \ccc{a} by \ccc{b}.
For \ccc{MP_Float}, this is not uniquely defined, but this function
guarantees that the remainder has a smaller bitlength than \ccc{b}
(considering the bitlength of the odd mantissa).}

\ccFunction{MP_Float operator%(const MP_Float &a, const MP_Float &b);}
{returns the remainder of the integral division of \ccc{a} by \ccc{b}.
For \ccc{MP_Float}, this is not uniquely defined, but this function
guarantees that the remainder has a smaller bitlength than \ccc{b}
(considering the bitlength of the odd mantissa).}

\ccFunction{MP_Float gcd(const MP_Float &a, const MP_Float &b);}
{returns the greatest common divisor of \ccc{a} and \ccc{b}.
For \ccc{MP_Float}, this is defined up to a power of 2.}
\ccPrecond{\ccc{a} and \ccc{b} are non zero.}}

\ccFunction{MP_Float approximate_division(const MP_Float &a, const MP_Float &b);}
{computes an approximation of the (field) division by converting the operands
to \ccc{double}, performing the division on \ccc{double}, and converting back
to \ccc{MP_Float}.}

\ccFunction{MP_Float approximate_sqrt(const MP_Float &a);}
{computes an approximation of the square root by converting the operand to
\ccc{double}, performing the square root on \ccc{double}, and converting back
to \ccc{MP_Float}.}


\ccImplementation 
The implementation of \ccc{MP_Float} is simple but provides a quadratic
complexity for multiplications.  This can be a problem for large operands.
For faster implementations of the same functionality with large integral
values, you may want to consider using \ccc{GMP} or \ccc{LEDA} instead.

\end{ccRefClass} 
