\begin{ccRefClass} {Gmpz}
\label{Gmpz}

\ccDefinition

An object of the class \ccStyle{Gmpz} is an arbitrary precision integer 
based on the {\sc Gnu} Multiple Precision Arithmetic Library. 

\ccInclude{CGAL/Gmpz.h}

\ccIsModel
\ccc{EuclideanRing}\\
\ccc{RealEmbeddable}

\ccCreation
\ccCreationVariable{z}

\ccTwo{xxxxxxxxxxxxxxxxxxxxx}{}

\ccConstructor{Gmpz();}
             {creates an uninitialized multiple precision integer \ccVar.}\ccGlue

\ccHidden \ccConstructor{Gmpz(const Gmpz& q);}
            {copy constructor.}

\ccConstructor{Gmpz(int i)}
            {creates a multiple-precision integer initialized with
             \ccStyle{i}.}\ccGlue

\ccConstructor{Gmpz(double d)}
            {creates a multiple-precision integer initialized with
             the integral part of \ccStyle{d}.}\ccGlue

\ccOperations

\ccThree{xxxxxxxxxxxxxx}{xxxxxxxxxxxxxxxxxxxxxxx}{}

\ccMethod{Gmpz & operator++();}{prefix increment.}\ccGlue
\ccMethod{Gmpz   operator++(int);}{postfix increment.}\ccGlue
\ccMethod{Gmpz & operator--();}{prefix decrement.}\ccGlue
\ccMethod{Gmpz   operator--(int);}{postfix decrement.}

\ccFunction{Gmpz operator>>(const Gmpz& a, long i);}{rightshift by i, where $i>=0$.}\ccGlue
\ccFunction{Gmpz operator<<(const Gmpz& a, long i);}{leftshift by i, where $i>=0$.}\ccGlue
\ccMethod{Gmpz & operator>>=(const long& i);}{rightshift by i, where $i>=0$.}\ccGlue
\ccMethod{Gmpz & operator<<=(const long& i);}{leftshift by i, where $i>=0$.}


\ccFunction{Gmpz operator&(const Gmpz& a, const Gmpz& b);}{bitwise AND.}\ccGlue
\ccFunction{Gmpz operator|(const Gmpz& a, const Gmpz& b);}{bitwise IOR.}\ccGlue
\ccFunction{Gmpz operator^(const Gmpz& a, const Gmpz& b);}{bitwise XOR.}\ccGlue
\ccMethod{Gmpz & operator&=(const Gmpz& b);}{bitwise AND.}\ccGlue
\ccMethod{Gmpz & operator|=(const Gmpz& b);}{bitwise IOR.}\ccGlue
\ccMethod{Gmpz & operator^=(const Gmpz& b);}{bitwise XOR.}


\ccFunction{std::ostream& operator<<(std::ostream& out, const Gmpz& z);}
{writes \ccc{z} to the ostream \ccc{out}.}\ccGlue

\ccFunction{std::istream& operator>>(std::istream& in, Gmpz& z);}
{reads an integer from \ccc{in}, then converts it to a \ccc{Gmpz}.}

\ccImplementation
\ccc{Gmpz}s are reference counted.

\end{ccRefClass} 
\ccDefGlobalScope{CGAL::}
