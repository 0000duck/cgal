%%%%%%%%%%%%%% predicates

\begin{ccRefFunction}{compare_x}

\ccFunction{template < class AlgebraicKernelForCircles_2_2>
	Comparison_result compare_x
	(const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r1,
	const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r2);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Compare_X}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernelForCircles_2_2::CompareX}

\end{ccRefFunction}

\begin{ccRefFunction}{compare_y}

\ccFunction{template < class AlgebraicKernelForCircles_2_2>
	Comparison_result compare_y
	(const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r1,
	const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r2);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Compare_Y}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernelForCircles_2_2::CompareY}

\end{ccRefFunction}

\begin{ccRefFunction}{compare_xy}

\ccFunction{template < class AlgebraicKernelForCircles_2_2>
	Comparison_result compare_xy
	(const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r1,
	const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r2);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Compare_XY}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernelForCircles_2_2::CompareXY}

\end{ccRefFunction}

\begin{ccRefFunction}{sign_at}

\ccFunction{template < class AlgebraicKernelForCircles_2_2, class OutputIterator >
	OutputIterator sign_at
	(const AlgebraicKernelForCircles_2_2::Polynomial_for_circles_2_2 &p,
	const AlgebraicKernelForCircles_2_2::Root_for_circles_2_2 &r);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Sign_at}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernelForCircles_2_2::SignAt}

\end{ccRefFunction}

%%%%%%%%%%%%%%%%%%%%%%%% constructions
\begin{ccRefFunction}{construct_polynomial_1_2}

\ccDefinition

\ccFunction{template < class AlgebraicKernelForCircles_2_2>
	AlgebraicKernelForCircles_2_2::Polynomial_1_2
	construct_polynomial_1_2
	(AlgebraicKernelForCircles_2_2::RT a,
	 AlgebraicKernelForCircles_2_2::RT b,
	 AlgebraicKernelForCircles_2_2::RT c);}
{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::ConstructPolynomial_1_2}.}

\end{ccRefFunction}

\begin{ccRefFunction}{construct_polynomial_for_circles_2_2}

\ccDefinition

\ccFunction{template < class AlgebraicKernelForCircles_2_2>
	AlgebraicKernelForCircles_2_2::PolynomialForCircles_2_2
	construct_polynomial_for_circles_2_2
	(AlgebraicKernelForCircles_2_2::RT a,
	 AlgebraicKernelForCircles_2_2::RT b,
	 AlgebraicKernelForCircles_2_2::RT c);}
{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::ConstructPolynomialForCircles_2_2}.}

\end{ccRefFunction}

\begin{ccRefFunction}{solve}

\ccDefinition

\ccFunction{template < class AlgebraicKernelForCircles_2_2, class OutputIterator >
	OutputIterator solve
	(const AlgebraicKernelForCircles_2_2::Polynomial_1_2 &p1,
	const AlgebraicKernelForCircles_2_2::Polynomial_1_2 &p2,
	OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Solve}.}

\ccFunction{template < class AlgebraicKernelForCircles_2_2, class OutputIterator >
	OutputIterator solve
	(const AlgebraicKernelForCircles_2_2::Polynomial_1_2 &p1,
	const AlgebraicKernelForCircles_2_2::Polynomial_for_circles_2_2 &p2,
	OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Solve}.}

\ccFunction{template < class AlgebraicKernelForCircles_2_2, class OutputIterator >
	OutputIterator solve
	(const AlgebraicKernelForCircles_2_2::Polynomial_for_circles_2_2 &p1,
	const AlgebraicKernelForCircles_2_2::Polynomial_for_circles_2_2 &p2,
	OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::Solve}.}
\ccSeeAlso

\ccRefConceptPage{AlgebraicKernelForCircles_2_2::Solve}

\end{ccRefFunction}

\begin{ccRefFunction}{x_critical_points}

\ccFunction{template < class AlgebraicKernelForCircles_2_2, class OutputIterator >
	OutputIterator
	x_critical_points
	(const typename AlgebraicKernelForCircles_2_2::Polynomial_for_circles_2_2 & c, 
	           OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::XCriticalPoints}.}

\end{ccRefFunction}

\begin{ccRefFunction}{x_critical_point}

\ccFunction{template < class AlgebraicKernelForCircles_2_2 >
	AlgebraicKernelForCircles_2_2::Root_for_circles_2_2
	x_critical_points(const typename AK::Polynomial_for_circles_2_2 & c,
	bool i);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::XCriticalPoints}.}

\end{ccRefFunction}

\begin{ccRefFunction}{y_critical_points}

\ccFunction{template < class AlgebraicKernelForCircles_2_2, class OutputIterator >
	OutputIterator
	y_critical_points
	(const typename AlgebraicKernelForCircles_2_2::Polynomial_for_circles_2_2 & c, 
	           OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::YCriticalPoints}.}

\end{ccRefFunction}

\begin{ccRefFunction}{y_critical_point}

\ccFunction{template < class AlgebraicKernelForCircles_2_2 >
	AlgebraicKernelForCircles_2_2::Root_for_circles_2_2
	x_critical_point(const typename AK::Polynomial_for_circles_2_2 & c,
	bool i);}
	{Calls the operator() of \ccc{AlgebraicKernelForCircles_2_2::YCriticalPoints}.}

\end{ccRefFunction}

\begin{ccRefFunction}{make_root_of_2}

\ccFunction{template < class RT >
	Root_of_2<RT>
	make_root_of_2(RT a, RT b, RT c, bool s);}
	{Returns the smaller (resp. larger) root of equation $aX^2+bX+c=0$
if \ccc{s} is true (resp. false).
\ccc{RT} is supposed to be a \ccc{RingNumberType}, and \ccc{Root_of_2<RT>} is
the type given by \ccc{Root_of_traits_2<RT>}.}

\ccFunction{template < class RT >
	Root_of_2<RT>
	make_root_of_2(FT a, FT b, FT c, bool s);}
	{.}

\footnote{groumpf. \ccc{Root_of_taits} is templated by RT but we also need (do we?) make-root-of with FT. Relation between RT and FT...?}

\ccSeeAlso

\ccRefIdfierPage{CGAL::Root_of_2<RT>}\\
\ccRefIdfierPage{CGAL::Root_of_traits_2<RT>}

\end{ccRefFunction}

