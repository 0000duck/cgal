
\ccChapterAuthor{Michael Hemmer}

\section{Introduction}

This package introduces a concept \ccc{Polynomial_d}, a concept for multivariate 
polynomials in $d$ variables. Though the concept is written for an arbitrary 
number of variables, the number of variables is considered as fixed for a particular
model of \ccc{Polynomial_d}. The concept also allows univariate polynomials, in which case 
the variable $d$ is just one. 

First of all a model of \ccc{Polynomial_d} is considered as an algebraic structure, that 
is, the usual arithmetic operations like +,-,* etc. are provided due to the fact that 
\ccc{Polynomial_d} refines at least the concept \ccc{IntegralDomainWithoutDivision}. 
However, a model of \ccc{Polynomial_d} has to be accompanied by a traits class 
\ccc{CGAL::Polynomial_traits_d<Polynomial_d>} being a model of \ccc{PolynomialTraits_d}. 
In principal this traits class provides all further functionalities on polynomials.

Given a multivariate polynomial over some base ring $R$ in $d$ variables there are at least 
two different possible views on such a polynomial.
\begin{itemize}
\item The recursive or univariate view:  In this view, a polynomial is considered as 
an element of $R[x_0,\dots,x_{d-2}][x_{d-1}]$. That is, the polynomial 
is treated as a univariate polynomial over the ring $R[x_0,\dots,x_{d-2}]$. 
\item The symmetric or multivariate view: This view is symmetric 
with respect to all variables, considering the polynomials as element of $R [x_0,\dots,x_{d-1}]$.
\end{itemize}

According to these two different views the traits class provides two different coefficients types:
\begin{itemize}
\item \ccc{CGAL::Polynomial_traits_d<Polynomial_d>::Coefficient} representing $R[x_0,\dots,x_{d-2}]$.
\item \ccc{CGAL::Polynomial_traits_d<Polynomial_d>::Innermost_coefficient} representing the base ring $R$.
\end{itemize}

Another important type which is introduced by this package is the so called \ccc{CGAL::Exponent_vector}. 
In principal this is just an \ccc{std::vector<int>} which is used to identify monomials. 
For instance the exponent vector containing the sequence $[3,2,4]$ corresponds to the 
trivariate monomial $x_0^3x_1^2x_2^4$. 


% ###########################
\section{Constructing a multivariate polynomial}

First of all the concept \ccc{Polynomial_d} requires that the model is constructible from int. 
This is due to the fact that \ccc{Polynomial_d} refines \ccc{IntegralDomainWithoutDivision} 
which in turn refines \ccc{FromIntConstructible}. Of course this allows only the construction of 
constant polynomials. 

Hence, in general a polynomial is constructed using the functor 
\ccc{CGAL::Polynomial_traits_d<Polynomial_d>::Construct_polynomial} a model of 
\ccc{PolynomialTraits_d::ConstructPolynomial}.  Basically there are two options:
\begin{itemize}
\item The polynomial is constructed from an iterator range with value type 
\ccc{CGAL::Polynomial_traits_d<Polynomial_d>::Coefficient}, where begin refers to 
the constant term (constant with respect to the outermost variable). 
\item The polynomial is constructed from an iterator range with value type 
\ccc{std::pair< CGAL::Exponent_vector, CGAL::Polynomial_traits_d<Polynomial_d>::Innermost_coefficient>},
where each pair defines the coefficient for the monomial defined by the exponent vector. 
\end{itemize}

However, in some cases it might be more convenient to just construct the polynomials 
representing the different variables and to obtain the final polynomial using 
algebraic expressions. The most elegant way to construct a certain variable is 
\ccc{CGAL::Polynomial_traits_d<Polynomial_d>::Shift} being a model of 
\ccc{PolynomialTraits_d::Shift}. 

\subsection{Examples}

The following example illustrates different ways to construct a bivariate polynomial:
\ccIncludeExampleCode{Polynomial/construction.cpp}



% ###########################
\section{Coefficient Access}
 
In order to obtain a certain coefficient the traits class provides several functors. 
Note that the functors do not allow a write access to the coefficients. 
\begin{itemize}
\item \ccc{PolynomialTraits_d::GetCoefficient}: 
a model of this concept provides access to a coefficient in the univariate view. 
\item \ccc{PolynomialTraits_d::GetInnermostCoefficient}: 
a model of this concept provides access to a coefficient in the multivariate view.
\item \ccc{PolynomialTraits_d::LeadingCoefficient}: 
a model of this concept provides access to the leading coefficient in the univariate view. 
\item \ccc{PolynomialTraits_d::InnermostLeadingCoefficient}: 
a model of this concept provides access to the leading coefficient in the multivariate view, that is,
it returns the (innermost) coefficient of the leading multivariate monomial. 
See also  \ccc{PolynomialTraits_d::DegreeVector}.          
\end{itemize}

\subsection{Examples}
The following example illustrates the application of the functors discussed above:
\ccIncludeExampleCode{Polynomial/coefficient_access.cpp}


\section{Degree, total degree and degree vector}

Currently there are three functors in \ccc{PolynomialTraits_d} related to the degree of 
a polynomial. 
\begin{itemize}
\item \ccc{PolynomialTraits_d::Degree}: 
a model of this concept returns the degree of the polynomial in the univariate view. 
By default this is the degree with respect to the outermost variable, 
but it is also possible to select another variable. 
\item \ccc{PolynomialTraits_d::TotalDegree}: 
a model of this concept returns the so total degree of a polynomial. The polynomial
is considered as a multivariate polynomial. The total degree is the maximum over 
the sums of the exponents of each multivariate monomial. 
\item \ccc{PolynomialTraits_d::DegreeVector}:
a model of this concept returns the exponent vector of the leading monomial.  where the 
monomial order is lexicographic and starts with the outermost variable. 
See also  \ccc{PolynomialTraits_d::InnermostLeadingCoefficient}. 
\end{itemize}

\subsection{Examples}
The following example illustrates the application of the functors discussed above:
\ccIncludeExampleCode{Polynomial/degree.cpp}

\section{Changing the order of variables}

Given for instance a bivariate polynomial it is conceivable that one once to 
interchange the role of $x$ and $y$. That is one wants to interpret the $x$ as $y$ 
and vice versa. For such a case the polynomial traits provides \ccc{PolynomialTraits_d::Swap}. 
Given a polynomial $p$ and to two indices $i$ and $j$, the functor returns the polynomial 
in which $x_i$ is substituted by $x_j$ and vice versa, that is, the variables swap their positions.
The order of the other variables remains untouched. 

Another scenario is, that a particular variable should be moved to another position, 
for instance, it should become the 
outermost variable while the relative order of the other variables remains unchanged. 
For such a case the polynomial traits provides \ccc{PolynomialTraits_d::Move}.

\subsection{Examples}
The following example illustrates the application of the functors discussed above:
\ccIncludeExampleCode{Polynomial/swap_move.cpp}


\section{GCD and more}

Since the concept \ccc{PolynomialTraits_d} refines the concept \ccc{AlgebraicStructureTraits} the polynomial 
traits provides functors for integral division, division with remainder, greatest common divisor, etc.
But note that the algebraic structure of a polynomial depends on the algebraic structure of the innermost
coefficient, for instance, a gcd is only available if and only if the innermost coefficient is a \ccc{Field} or 
a \ccc{UniqueFactorizationDomain}. Hence, we can not provide a $gcd$ if the innermost coefficient is just an
\ccc{IntegralDomain} since it is not well defined\footnote{%
An example for such a number type is the template \ccc{CGAL::Sqrt_extension<NT,ROOT>} representing an 
algebraic extension of degree 2. This is just an \ccc{IntegralDomain} if NT is not a \ccc{Field}. }.
% 
However, in general this is just due to the fact that (for efficiency reasons) we do not want to represent 
the polynomials over the quotient field of the ring. In this case the $gcd$ would be well defined. 
Hence, the only problem is that the result can not be represented over the ring 
since it contains denominators.  
Therefore, the \ccc{PolynomialTraits_d} requires functors such as 
\ccc{PolynomialTraits_d::GcdUpToConstantFactor}. 
This functor computes the gcd of two polynomials up to a constant factor (utcf).  
That is, it returns the correct gcd for polynomials over the quotient field, 
but multiplied by some constant such that the result is representable with coefficients in the ring. 

However, note that these 'utcf' functions are usually a bit faster than their counter parts. 
This is due to the fact that the 'utcf' functions can skip the computation of the correct constant factor.
Note that in many cases this constant factors is in fact not needed, 
for instance, if the polynomials are supposed to represent some vanishing set, 
that is, an algebraic curve or surface.  

The concepts for the related functors are: 
\begin{itemize}
\item \ccc{AlgebraicStructureTraits::Gcd}\\     
      \ccc{PolynomialTraits_d::GcdUpToConstantFactor}

\item \ccc{AlgebraicStructureTraits::IntegralDivision}\\        
      \ccc{PolynomialTraits_d::IntegralDivisionUpToConstantFactor}

\item \ccc{PolynomialTraits_d::UnivariateContent}
      \ccc{PolynomialTraits_d::UnivariateContentUpToConstantFactor}\\
       
\item \ccc{PolynomialTraits_d::SquareFreeFactorize}\\
      \ccc{PolynomialTraits_d::SquareFreeFactorizeUpToConstantFactor}
\end{itemize}

In case of \ccc{PolynomialTraits_d::MultivariateContent} a counter part does 
not make sense, since it is defined as the gcd of all innermost coefficients. 
There is also no counterpart to \ccc{PolynomialTraits_d::MakeSquareFree}, since 
the result is canonicalized, which is supposed to remove superfluous constant factors 
anyway. (See also \ccc{PolynomialTraits_d::Canonicalize}.)


Another analog functionality is the pseudo division. The related functors replace 
the usual division with remainder in case the Polynomial is not a \ccc{EuclideanRing}. \\
The concepts for the related functors are: 
\begin{itemize}
\item \ccc{AlgebraicStructureTraits::Div_mod}
\item \ccc{PolynomialTraits_d::PseudoDivision}
\item \ccc{AlgebraicStructureTraits::Div}
\item \ccc{PolynomialTraits_d::PseudoDivisionQuotient}
\item \ccc{AlgebraicStructureTraits::Mod}
\item \ccc{PolynomialTraits_d::PseudoDivisionRemainder}
\end{itemize}


\subsection{Examples}
The following example illustrates the application of some functors discussed above:
\ccIncludeExampleCode{Polynomial/gcd_up_to_constant_factor.cpp}

\section{Evaluation and Substitution}

Of it should also be possible to evaluate a polynomial or substitute its variables.
We also require a special functor to determine whether a polynomial is zero at a given point. 
In case the inner most coefficient is \ccc{RealEmbeddable} the traits also must provide 
a function to compute the sign at a given point. \\
The concepts for the related functors are:
\begin{itemize}
\item \ccc{PolynomialTraits_d::Substitute}
\item \ccc{PolynomialTraits_d::Evaluate}
\item \ccc{PolynomialTraits_d::IsZeroAt}
\item \ccc{PolynomialTraits_d::SignAt}
\end{itemize}

The traits is also required to provide variants of these functors that interpret the 
polynomial as a homogeneous polynomial. For instance, these functors can be useful 
to determine the sign of a polynomial at a rational point although the polynomial is defined 
over integer coefficients. \\
For more details have a look at the following concepts:
\begin{itemize}
\item \ccc{PolynomialTraits_d::SubstituteHomogeneous}
\item \ccc{PolynomialTraits_d::EvaluateHomogeneous}
\item \ccc{PolynomialTraits_d::IsZeroAtHomogeneous}
\item \ccc{PolynomialTraits_d::SignAtHomogeneous}
\end{itemize}

Note that substitute allows the substitution of the variables by any type that 
is \ccc{ExplicitInteroperable} with the innermost coefficient type. 
This is a very powerful tool since it allows the substitution of the variables by polynomials
However, for some standard manipulations such as translation or scaling we require 
special functors since they are expected to be faster than there equivalent implementation using 
substitution: \\

\begin{itemize}
\item \ccc{PolynomialTraits_d::Shift}
\item \ccc{PolynomialTraits_d::Negate}
\item \ccc{PolynomialTraits_d::Invert}
\item \ccc{PolynomialTraits_d::Translate}
\item \ccc{PolynomialTraits_d::TranslateHomogeneous}
\item \ccc{PolynomialTraits_d::Scale}
\item \ccc{PolynomialTraits_d::ScaleHomogeneous}
\end{itemize}

\subsection{Examples}   
The following example illustrates the application of some functors discussed above:
\ccIncludeExampleCode{Polynomial/substitute.cpp}