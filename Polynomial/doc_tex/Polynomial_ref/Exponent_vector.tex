\begin{ccRefClass}{Exponent_vector}

\ccDefinition

For a given monomial the vector of its exponents is called the 
exponent vector. The class \ccClassName\ is meant to represent 
such a vector.

A vector is considered as valid, in case it represents a valid monomial. 
In particular, it should not contain negative exponents. 
\footnote{We choose value type int, since negative exponents may appear in intermediate results. }

Note that the set of exponent vectors with element vise 
addition forms an {\em Abelian Group}. 
\footnote{Should we add a scalar multiplication? }


\ccInclude{CGAL/Exponent_vector.h}

\ccInheritsFrom
\ccc{std::vector<int>}

\ccIsModel

\ccc{Random Access Container}\\
\ccc{Back Insertion Sequence}\\

\ccc{DefaultConstructible}\\
\ccc{Assignable}\\
\ccc{CopyConstructible}\\

\ccc{EqualityComparable}\\
\ccc{LessThanComparable}\\

\ccCreation
\ccCreationVariable{ev}

%\ccc{DefaultConstructible}\\
\ccConstructor{Exponent_vector();}
        {introduces an uninitialized variable \ccVar.
        }\ccGlue
%\ccc{CopyConstructible}\\
\ccConstructor{Exponent_vector(const Exponent_vector & ev_);} 
        {The copy constructor
        }\ccGlue

\ccConstructor{Exponent_vector(size_type n);} 
        {Creates a vector with \ccc{n} elements.
        }\ccGlue
\ccConstructor{Exponent_vector(size_type n, int i);} 
        {Creates a vector with \ccc{n} copies of \ccc{i}. 
        }\ccGlue

\ccConstructor{        
        template < class InputIterator >         
        Exponent_vector(InputIterator begin, InputIterator end);}{
        Creates a vector with a copy of the given range.         
        \ccPrecond \ccc{InputIterator} must allow the value type \ccc{int}. \\
        }\ccGlue

\ccOperations

\ccGlue
\ccFunction{bool is_valid(ev);}        
       { Returns true if all entries of ev are not negative. }        

\ccOperations

Group Operation: 

\ccFunction{Exponent_vector operator+(const Exponent_vector &ev1);}{}\ccGlue
\ccFunction{Exponent_vector operator-(const Exponent_vector &ev1);}{}\ccGlue

\ccFunction{Exponent_vector 
        operator+(const Exponent_vector &ev1, 
                  const Exponent_vector &ev2);}{
                \ccPrecond ev1.size() == ev2.size()
        }
\ccGlue
\ccFunction{Exponent_vector 
            operator-(const Exponent_vector &ev1, 
                      const Exponent_vector &ev2);}{
                \ccPrecond ev1.size() == ev2.size()
        }
\ccGlue
\ccMethod{Exponent_vector 
            operator+=(const Exponent_vector &ev2);}{
                \ccPrecond \ccVar.size() == ev2.size()
        }
\ccGlue
\ccMethod{Exponent_vector 
            operator-=(const Exponent_vector &ev2);}{
                \ccPrecond \ccVar.size() == ev2.size()
        }

\begin{ccAdvanced}
TODO: Should we add these functions? what about operator $/$ ? 
\ccMethod{Exponent_vector operator*=(int i);}{}
\ccGlue
\ccFunction{Exponent_vector operator*(const Exponent_vector &ev, int i);}{}
\ccGlue
\ccFunction{Exponent_vector operator*(int i ,const Exponent_vector &ev);}{}
\end{ccAdvanced}

\ccc{EqualityComparable}: 
\ccFunction{bool 
            operator==(const Exponent_vector &ev1, 
                       const Exponent_vector &ev2);}{}
\ccGlue
\ccFunction{bool 
            operator!=(const Exponent_vector &ev1, 
                       const Exponent_vector &ev2);}{}

\ccc{LessThanComparable}: 
\ccFunction{bool 
            operator<(const Exponent_vector &ev1, 
                      const Exponent_vector &ev2);}{ 
        Lexicographic compare, starting with the {\em last} variable.  }
\ccGlue

\ccSeeAlso

\ccRefIdfierPage{Polynomial_d}\\
\ccRefIdfierPage{PolynomialTraits_d}\\

\end{ccRefClass} 