\begin{ccRefConcept}{CurveAnalysis_2::StatusLine_1}

\ccDefinition

The \ccc{StatusLine_1} concept is meant to provide information
about the intersections of a curve with a vertical line at a given 
finite $x$-coordinate. Note that a curve can have a vertical line component 
at this coordinate and non-vertical components may intersect 
the status line respectively. 
With the help of the concept's methods one is able
to compute the local topology of the curve 
at the given vertical line $x = x_0$ for some finite $x_0$.
A status line at any $x_0$ smaller than any $x$-coordinate of a curve's 
$x$-critical points captures the topology of the curve when 
approaching $x = -\infty$.
An analogue argument holds for $x_0$ larger than any $x$-coordinate
of a curve's status lines and $x = +\infty$.
%at the given vertical line.
%Note that vertical lines at $x = \pm\infty$ are not allowed, since different 
%events (curve ends going to infinity with different non-horizontal asymptotes)
%would have equal $y$-coordinate ($\pm\infty$), which confuses more than it
%helps. 

%Note in addition that curve ends approaching the vertical asymptote 
%introduce an event (depending on whether approaching $+\infty$ or $-\infty$ -
%but the event with coordinates $(x,-\infty)$, resp. $(x,+\infty)$, occur
%only once, if they occur, and they imply not to be associated with
%an instance of \ccc{Algebraic_real_2}.

\ccTypes

\ccNestedType{size_type}{A instance of a size type, e.g., \ccc{int}}

\ccNestedType{Algebraic_real_1}{A model of the concept
  \ccc{AlgebraicKernel_d_1::AlgebraicReal_1}.}

\ccNestedType{Algebraic_real_2}{A model of the concept
  \ccc{AlgebraicKernel_d_2::Algebraic_real_2}.}

\ccCreationVariable{sl}
\ccAccessFunctions

\ccMethod{Algebraic_real_1 x();}{
  returns the $x$-coordinate of the vertical line (always a finite value).
}

\ccMethod{bool covers_line();}{
  returns \ccc{true} in case the given curve contains the vertical line as
  a component
}

\ccMethod{size_type number_of_events();}{
  returns number of distinct and finite intersections of a curve with a 
  the vertical line $x = x_0$ ignoring a real vertical line component 
  of the curve at $x_0$.
}

\ccMethod{Algebraic_real_2 algebraic_real_2(size_type j);}{
  returns an object of type \ccc{Algebraic_real_2} for the $j$-th event
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}.
}

\ccMethod{std::pair< size_type, size_type > 
  number_of_incident_branches(size_type j);}{
  returns the number of branches of the curve connected to $j$-th event
  immediately to the left,
  to the right, respectively, as a pair of \ccc{size_type} ignoring 
  vertical curve components at the given $x$-coordinate.
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

\ccMethod{std::pair< size_type, size_type > 
  number_of_branches_approaching_minus_infinity();}{
  returns the number of vertical asymptotes at $x$ 
  of the curve approaching $y=-\infty$
  from left and right. A vertical line being component of the curve is ignored.
}

\ccMethod{std::pair< size_type, size_type > 
  number_of_branches_approaching_plus_infinity();}{
  returns the number of vertical asymptotes at $x$ 
  of the curve approaching $y=+\infty$
  from left and right. A vertical line being component of the curve is ignored.
}

\ccMethod{bool has_x_critical_point();}{
  returns \ccc{true} if the curve $f$ has an intersection with $f_y$ at $x$
}

\ccMethod{bool is_event();}{
  returns \ccc{true} if one of \ccc{has_x_critical_point()} or 
  \ccc{covers_line()} evaluates to \ccc{true}.
}

\end{ccRefConcept}

\begin{ccRefConcept}{AlgebraicKernelWithAnalysis_d_2::CurveAnalysis_2}
\footnote{There is no need
for curves to be algebraic, hence the generic name. Only the number
of events must be finite.}

\ccDefinition

The \ccc{AlgebraicKernel_d_2::CurveAnalysis_2} 
concept is meant to provide tools to analyze a single
curve. An analysis is meant to describe the curve's interesting points and how 
they are connected. The analysis searches for {\it events}. Events only
occur at a finite number of $x$-coordinates. Each such coordinate defines
a \ccc{StatusLine_1} of an event. These coordinates also define open 
{\it intervals} on the $x$-axis. Different 
\ccc{StatusLine_1} at values within one 
such interval only differ in the values of the \ccc{Algebraic_real_2} entries. 
Topological information is equal for all $x$-coordinate inside such an
open interval. If there a $n$ $x$-coordinate that have an event point, we 
see at most $2n+1$ topologically different status lines, that is, $n$ for 
the events, and $n+1$ for the intervals between events (and before the 
first, and after the last event).

\ccRefines{
  \ccc{DefaultConstructible, CopyConstructible, Assignable}
}

\ccTypes

\ccNestedType{size_type}{A instance of a size type, e.g., \ccc{int}}

\ccNestedType{Algebraic_real_1}{A model of the concept
  \ccc{AlgebraicKernel_d_1::AlgebraicReal_1}.}

\ccNestedType{Algebraic_real_2}{A model of the concept
  \ccc{AlgebraicKernel_d_2::Algebraic_real_2}.}

\ccNestedType{Polynomial_2}{A model of the concept 
  \ccc{AlgebraicKernel_d_2::Polynomial_2}.}

\ccNestedType{Curve_vertical_line_1}{A model of the concept
\ccc{CurveAnalysis_2::StatusLine_1}.}

\ccCreation
\ccCreationVariable{ca}
        
\ccConstructor{CurveAnalysis_2(Polynomial_2 p);}
    {constructs an analysis for the curve defined by p. 
\ccPrecond{The polynomial must be square free.}
}

\begin{ccAdvanced}

\ccConstructor{template < class InputIterator >
  CurveAnalysis_2(Polynomial_2 p, InputIterator begin, InputIterator end);}{
  constructs an analysis for the curve defined by p. The iterator range 
  [begin,end) contains factors of $\mbox{resultant}(p,p_y,y)$ 
  i.e., their roots define $x$-coordinates of events, 
  which allows to simplify the real root isolation within this layer.
  The \ccc{value_type} of InputIterator is \ccc{Polynomial_1}. 
\ccPrecond{The polynomial must be square free.}
}
  This constructor has been introduced to enable an upper layer 
(geometric curved kernel) to propagate additional knowledge on the problem.
If the signature is not provided by a model, a compile error occurs.
\end{ccAdvanced}

\ccAccessFunctions

\ccMethod{Polynomial_2 polynomial_2();}{
  returns the defining polynomial of the analysis
}

\ccMethod{size_type number_of_status_lines_with_event();}{
  returns number of vertical lines that encode an event
}

\ccMethod{Status_line_1 status_line_at_event(size_type i);}{
  returns an instance of \ccc{StatusLine_1} at the $i$-th event
 \ccPrecond{$0 \leq i < $ \ccc{number_of_status_lines_with_event()}}
}

\ccMethod{Status_line_1 status_line_of_interval(size_type i);}{
  returns an instance of \ccc{StatusLine_1} of the $i$-th interval
  between $x$-events.
 \ccPrecond{$0 \leq i \leq $ \ccc{number_of_status_lines_with_event()}}
}

\ccMethod{Status_line_1 status_line_for_x(Algebraic_real_1 x, 
  CGAL::Sign perturb = CGAL::ZERO);}{
 returns status\_line\_at\_event(i), if $x$ hits $i$-th event, otherwise
 returns status\_line\_of\_interval(i), where $i$ is the id of the interval
  $x$ lies in. If $pertub$ is CGAL::NEGATIVE (CGAL::POSITIVE) and $x$ states
  an event, then status\_line\_of\_interval(i) 
  (status\_line\_of\_interval(i+1)) is returned.
  \ccPrecond{$x$ is finite}
}

\ccMethod{Status_line_1 status_line_at_exact_x(Algebraic_real_1 x);}{
  returns an instance of \ccc{StatusLine_1} at the given $x$.
  \ccPrecond{$x$ is finite}
}

Note that the access methods to status lines are not redundant! The ones
using an id-value are efficient for speed-ups (caching, avoids to search for
some $x$, or the unique representative status line for an interval),
while the ones with given $x$ still perform a look-up. There is also a 
difference between \ccc{ status_line_for_x(x0,CGAL::ZERO)} and 
\ccc{status_line_at_exact_x(x0)} in the case \ccc{x0} is contained 
in an interval between events. Namely, the former is allowed to return a
precomputed representative for the interval, while the later enforces
a status line exactly at the given \ccc{x0} which implies that the 
$y$-coordinates are with respect to the given \ccc{x0}. In the first case,
the accesible $y$-coordinates are with respect to the representative's 
$x$-coordinate only.

%\begin{ccAdvanced}
%
%\ccMethod{size_type find(Algebraic_real_2 s);}{
%  returns the index of the event at the status line defined by 
%  $s$'s $x$-coordinate, or -1 if $s$ is does not lie on the curve.
%}
%
%\end{ccAdvanced}

\ccMethod{CGAL::Object asymptotic_value_of_arc(CGAL::Arr_parameter_space loc, 
  size_type arcno);}{
  returns a CGAL::Object that encodes the asymptotic value of a curve-arc 
  approaching the left or the right boundary ($loc$) of the underlying
  parameter space. Allowed instantiations of the CGAL::Object are 
  \ccc{Algebraic_real_1}, in case the x-asympote of the arc is finite,
  or \ccc{CGAL::ARR_BOTTOM_BOUNDARY} and \ccc{CGAL::ARR_TOP_BOUNDARY} in case
  the defined arc approaches the respective corners of the parameter space.
  \ccPrecond{$loc$ is either \ccc{CGAL::ARR_LEFT_BOUNDARY} or 
    \ccc{CGAL::ARR_RIGHT_BOUNDARY}}
}

In our $y$-per-$x$-view we imagine the parameter space to be slightly 
``heigher'' than ``width'' and so we distinguish three aymptotic behaviors
of arcs. Horizontal, vertical, and none of them. This member covers 
all non-vertical asymptotic values. We do not introduce a special one
for vertical asympototes as the respective $x$-coordinates are already defined
by proper status lines.

In addition, by using the parameter space locations, 
we decouple the interface from the unbounded plane. An example is a 
two-dimensional arrangement embedded on a torus.

\end{ccRefConcept}
