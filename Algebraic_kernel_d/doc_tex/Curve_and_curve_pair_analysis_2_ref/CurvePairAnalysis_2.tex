\begin{ccRefConcept}{CurvePairVerticalLine}

\ccDefinition

The \ccc{CurvePairVerticalLine} concept is meant to provide information
about the intersections of a pair of curves with a (fictious) vertical line 
(ignoring vertical lines of the curves themselves). Each intersection of a 
curve with the vertical line defined by some given $x$ induces an event. 
An event can be asked for its coordinates (\ccc{Solution_2}) and the involved 
curve(s). Note that the involvment also holds for curve ends approaching the 
vertical asymptote. Again CurvePairVerticalLines at $x = \pm\infty$ are 
not allowed. 

\ccTypes

\ccNestedType{Solution_1}{
  Is a model of the \ccc{AlgebraicCurveKernel_2::Solution_1} concept
}
  
\ccNestedType{Solution_2}{
  Is a model of the \ccc{AlgebraicCurveKernel_2::Solution_2} concept
}

\ccCreationVariable{cpvl}
\ccAccessFunctions

\ccMethod{Solution_1 x();}{
  returns the $x$-coordinate of the vertical line (always a finite value).
}

\ccMethod{unsigned int num_events();}{
  returns number of distinct intersections of a pair of curves with a 
  (fictious) vertical line ignoring a real vertical line component 
  of the curves at the given $x$-coordinate.
}

\ccMethod{int get_y_position_of_event(int k, bool c);}{
  returns the $y$-position of the $k$-th arc of the $c$-''th''
  (0 or 1) curve in the sequence of events. Note that each event
  is formed by the first, the second, or both curves.
  \ccPrecond{$0 \leq j < \mbox{number of arcs defined for the curve at x()}$}
}

\ccMethod{int get_multiplicity_of_intersection_event(int j);}{
  returns the multiplicity of intersection defined at event with position $j$ 
  \ccPrecond{Both curves form event $j$}
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

\ccMethod{std::pair< int, int > curve_arcs_at_event(int j);}{
  returns a pair of int indicating whether event $j$ is formed by 
  which arc numbers of the first and the second curve, or $-1$, if the 
  corresponding curve is not involved. 
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

\ccMethod{Solution_2 get_solution_2(int j);}{
  returns an object of type \ccc{Solution_2} for the $j$-the event
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

Note that this interface mainly rewrites $\{f,g,x\}^n$ in a different way - 
using ints. Actually the CPVL has to compute this sequence, but for
the interface it is nicer to have it already here to avoid conversion objects
(introducing additional constructor calls, cache-misses, lookup and so on) in
the next layer on top (CK). Obviously, the ints can be computed in a generic
way from a sequence, so that it makes sense to offer a default implementation
providing such conversion. There is no need to document this fact on the 
conceptual view.

\ccMethod{bool has_event_of_curve();}{
  returns \ccc{true} if curve has vertical line component or
  curve $f$ has intersection with $f_y$ at $x$
}

\end{ccRefConcept}

\begin{ccRefConcept}{CurvePairAnalysis_2}

\ccDefinition

The \ccc{CurvePairAnalysis_2} concept is meant to provide tools to analyse 
a pair of curves. An analysis is meant to describe the curve pair's 
interesting points and how they are connected. 
The analysis searches for {\it events}. Events only
occur at a finite number of $x$-coordinate. Each such coordinate is
covered by a CurvePairVerticalLine, originated by the events of a single curve
and also the intersections of two curves.
These coordinates also define open {\it intervals}
on the $x$-axis. CurvePairVerticalLines at values in between one such interval
differ only in the values of the Solution\_2 entries. Topological 
information are equal. 

\ccRefines{
  \ccc{DefaultConstructible, CopyConstructible, Assignable}
}

\ccTypes

\ccNestedType{Solution_1}{
  Is a model of the \ccc{AlgebraicCurveKernel_2::Solution_1} concept
}
  
\ccNestedType{Solution_2}{
  Is a model of the \ccc{AlgebraicCurveKernel_2::Solution_2} concept
}

\ccNestedType{Polynomial_2}{
  Is a model of \ccc{AlgebraicCurveKernel_2::Polynomial_2} 
  concept.\\
  Especially needed: Canonicalize, GcdUpToConstantFactor, 
  IntegralDivUpToConstantFactor, 
  MakeSquareFreeUpToConstantFactor, and 
  SquareFreeFactorizationUpToConstantFactor
}

\ccNestedType{Curve_pair_vertical_line}
{Is a model of the \ccc{CurvePairAnalysis_2::CurvePairVerticalLine} concept}

\ccNestedType{Curve_analysis_2}
{Is a model of the \ccc{CurvePairAnalysis::CurveAnalysis_2} concept}

\ccCreation
\ccCreationVariable{cp}

\ccConstructor{CurvePairAnalysis_2(Curve_analysis_2 p1, Curve_analysis_2 p2);}
{constructs an analysis for the curve-pair defined by analyses given by 
p1 and p2. The polynomials defining the analyses must be squarefree and 
coprime.
}

\begin{ccAdvanced}

\ccConstructor{template < class InputIterator >
  CurvePairAnalysis_2(Curve_analysis_2 p1, Curve_analysis_2 p2, 
  InputIterator begin, InputIterator end);}{
  constructs an analysis for the pair of curves defined by $p1$ and $p2$. 
  The polynomials definining the analyses must be squarefree and coprime. 
  The iterator range [begin,end) contains factors of $\mbox{resultant}(p,q,y)$,
  i.e., define $x$-coordinates, 
  which allows to simplify the real root isolation within this layer.
  The \ccc{value_type} of InputIterator is \ccc{Polynomial_1}. 
  This constructor has been introduced to enable an upper layer (CK) to use
  additional knowledge on the problem.
}

\end{ccAdvanced}

\ccAccessFunctions

\ccMethod{Curve_analysis_2 get_curve_analysis(bool c);}{
  returns curve analyis for $c$-''th'' curve (0 or 1)
}

\ccMethod{unsigned int num_vertical_lines_with_event();}{
  returns number of vertical lines that encode an event
}

%\ccMethod{void x_to_id(Solution_1 x, bool\& is_event, unsigned int\& i);}{
%  For a given $x$, this method computes whether the vertical line at this $x$
%  contains an event (\ccc{is_event} == \ccc{true}) and returns the id $i$
%  of it. Otherwise, $i$ returns the id of the interval $x$ lies in.
%}

\ccMethod{int event_of_curve_analysis(unsigned int i, bool c);}{
  Given the $i$-th event,
  this method returns the id of the event of the corresponding curve
  analysis $c$ (0 or 1), or $-1$, if the curve has no event at this coordinate.
}

\ccMethod{Curve_pair_vertical_line vertical_line_at_event(int i);}{
  returns an instance of \ccc{CurvePairVerticalLine} at the $i$-th event
}

\ccMethod{Curve_pair_vertical_line vertical_line_of_interval(int i);}{
  returns an instance of \ccc{CurvePairVerticalLine} of the $i$-th interval
  between $x$-events.
}

\ccMethod{Curve_pair_vertical_line vertical_line_for_x(Solution_1 x,
  CGAL::Sign perturb = CGAL::ZERO);}{
  returns vertical\_line\_at\_event(i), if $x$ hits $i$-th event, otherwise
  returns vertical\_line\_of\_interval(i), where $i$ is the id of the interval
  $x$ lies in. If $pertub$ is CGAL::POSITIVE/CGAL::NEGATIVE, then a slighty 
  perturbed x is used (adding $\pm\epsilon$).
  \ccPrecond{$x$ is finite}
}

\ccMethod{Curve_pair_vertical_line vertical_line_at_exact_x(Solution_1 x);}{
  returns an instance of \ccc{CurvePairVerticalLine} at the given $x$
  \ccPrecond{$x$ is finite}
}

Note that the access methods to vertical lines are not redundant! The ones
using an id-value are efficient for speed-ups (caching, avoids to search some
$x$, just one representative vertical line for an interval). The others 
enables a user to compute vertical lines for given $x$, i.e. also to 
$y$-coordinates at given $x$.

\ccMethod{Solution_2_const_iterator solve_begin();}{
  returns iterator running over all intersection of the two curves
}

\ccMethod{Solution_2_const_iterator solve_end();}{
  returns past-end-value for all intersections of the two curves
}

\ccMethod{int find(Solution_2 s);}{
  returns the index of the event at the vertical line defined by 
  $s$'s $x$-coordinate, or -1 if $s$ is does not lie on any curve.
}

%Additionally note that we talk about 4 sequences of $x$-critical lines here. 
%
%\begin{itemize}
%\item The sequence of CurveVerticalLines of $p$ where each CVL has been 
%converted and merged with $q$ to a CVPL.
%\item The sequence of CurveVerticalLines of $q$ where each CVL has been 
%converted and merged with $p$ to a CPVL.
%\item The sequence of CurvePairVerticalLines of the intersections of 
%$p$ and $q$
%\item The merged sequence of CurvePairVerticalLines of the former three 
%sequences. The method event\_id\_of\_x helps to find indeces in the first 
%three sequences starting from an index in this sequence!
%\end{itemize}

\end{ccRefConcept}
