\begin{ccRefConcept}{CurveVerticalLine}

\ccDefinition

The \ccc{CurveVerticalLine} concept is meant to provide information
about the intersections of a curve with a vertical line at a given 
finite $x$-coordinate. Note that a curve can have a vertical line component 
at this coordinate and/or also non-vertical components intersecting
this vertical line. With the help of the concept's methods one is able
to compute the local topology of the curve at the given vertical line.
Note that vertical lines at $x = \pm\infty$ are not allowed, since different 
events (curve end going to infinity with different non-horizontal asympotes)
would have equal $y$-coordinate ($\pm\infty$), which confuses more than it
helps. Note in addition that curve ends approaching the vertical asymptote 
introduce an event (depending on whether approaching $+\infty$ or $-\infty$ -
but the event with coordinates $(x,-\infty)$, resp. $(x,+\infty)$, occur
only once, if they occur)

\ccTypes

\ccNestedType{Solution_1}{
  Is a model of the \ccc{AlgebraicCurveKernel_2::Solution_1} concept
}
  
\ccNestedType{Solution_2}{
  Is a model of the \ccc{AlgebraicCurveKernel_2::Solution_2} concept
}

\ccCreationVariable{cvl}
\ccAccessFunctions

\ccMethod{Solution_1 x();}{
  returns the $x$-coordinate of the vertical line (always a finite value).
}

\ccMethod{bool covers_line();}{
  returns \ccc{true} in case the given curve contains the vertical line as
  a component
}

\ccMethod{unsigned int num_events();}{
  returns number of distinct intersection of a curve with a 
  (fictious) vertical line ignoring a real vertical line component 
  of the curve at the given $x$-coordinate.
}

\ccMethod{Solution_2 get_solution_2(int j);}{
  returns an object of type \ccc{Solution_2} for the $j$-th event
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

\ccMethod{std::pair< unsigned int, unsigned int > get_num_branches(int j);}{
  returns the number of branches of the curve connected to $j$-th event
  immediately to the left,
  to the right, respectively, as a pair of \ccc{unsigned int} ignoring 
  vertical curve components at the given $x$-coordinate.
  \ccPrecond{$0 \leq j < \mbox{num\_events()}$}
}

\ccMethod{bool has_event_of_curve();}{
  returns \ccc{true} if curve has vertical line component or
  curve $f$ has intersection with $f_y$ at $x$
}

%
%TODO: Do we want to have CVLs for minus and plus infinity as additional
%events? For the sake of a nice interface
%(see CurveAnalysis\_2) we want to have it: A user can then just ask for the 
%behavior of the curve at $x = \pm\infty$. On the other side counting 
%the number of intersection points is not well-defined: Consider several 
%curve end with the same horizontal asymptote - are they equal or not? 
%It's unsure whether one can compute the $y$-coordinates of these points - 
%maybe even not the ``sign of infinity''. One solution is to forbid access
%to get\_solution\_2 for CurveVerticalLines with $x = \pm\infty$.
%

\end{ccRefConcept}

\begin{ccRefConcept}{CurveAnalysis_2}\footnote{There is no need
for curves to be algebraic, hence the generic name. Only the number
of events must be finite.}

\ccDefinition

The \ccc{CurveAnalysis_2} concept is meant to provide tools to analyse a single
curve. An analysis is meant to describe the curve's interesting points and how 
they are connected. The analysis searches for {\it events}. Events only
occur at a finite number of $x$-coordinates. Each such coordinate defines
a CurveVerticalLine of an event. These coordinates also define open 
{\it intervals} on the $x$-axis. CurveVerticalLines at values within one 
such interval only differ in the values of the Solution\_2 entries. 
Topological information are equal. 

\ccRefines{
  \ccc{DefaultConstructible, CopyConstructible, Assignable}
}

\ccTypes

\ccNestedType{Solution_1}
{Is a model of \ccc{AlgebraicCurveKernel_2::Solution_1} concept}

\ccNestedType{Solution_2}
{Is a model of \ccc{AlgebraicCurveKernel_2::Solution_2} concept}

\ccNestedType{Polynomial_2}{
  Is a model of \ccc{AlgebraicCurveKernel_2::Polynomial_2} 
  concept.\\
  Especially needed: Canonicalize, GcdUpToConstantFactor, 
  IntegralDivUpToConstantFactor, 
  MakeSquareFreeUpToConstantFactor, and 
  SquareFreeFactorizationUpToConstantFactor
}

\ccNestedType{Curve_vertical_ine}
{Is a model of the \ccc{CurveAnalysis_2::CurveVerticalLine} concept}

\ccCreation
\ccCreationVariable{ca}
        
\ccConstructor{CurveAnalysis_2(Polynomial_2 p);}
    {constructs an analysis for the curve defined by p. The polynomial must
      be squarefree.}

\begin{ccAdvanced}
\ccConstructor{template < class InputIterator >
  CurveAnalysis_2(Polynomial_2 p, InputIterator begin, InputIterator end);}{
  constructs an analysis for the curve defined by p. The polynomial must
  be squarefree. The iterator range [begin,end) contains factors of 
  $\mbox{resultant}(p,p_y,y)$, i.e., define $x$-coordinates, 
  which allows to simplify the real root isolation within this layer.
  The \ccc{value_type} of InputIterator is \ccc{Polynomial_2}. 
  This constructor has been introduced to enable an upper layer (CK) to use
  additional knowledge on the problem.
}
\end{ccAdvanced}

\ccAccessFunctions

\ccMethod{Polynomial_2 get_polynomial_2();}{
  returns the defining polynomial of the anyalsis
}

\ccMethod{unsigned int num_vertical_lines_with_event();}{
  returns number of vertical lines that encode an event
}

%\ccMethod{void x_to_id(Solution_1 x, bool\& is_event, unsigned int\& i);}{
%  For a given $x$, this method computes whether the vertical line at this $x$
%  contains an event (\ccc{is_event} == \ccc{true}) and returns the id $i$
%  of it. Otherwise, $i$ returns the id of the interval $x$ lies in.
%}

\ccMethod{Curve_vertical_line vertical_line_at_event(int i);}{
  returns an instance of \ccc{CurveVerticalLine} at the $i$-th event
}

\ccMethod{Curve_vertical_line vertical_line_of_interval(int i);}{
  returns an instance of \ccc{CurveVerticalLine} of the $i$-th interval
  between $x$-events.
}

\ccMethod{Curve_vertical_line vertical_line_for_x(Solution_1 x, 
  CGAL::Sign perturb = CGAL::ZERO);}{
 returns vertical\_line\_at\_event(i), if $x$ hits $i$-th event, otherwise
 returns vertical\_line\_of\_interval(i), where $i$ is the id of the interval
  $x$ lies in. If $pertub$ is CGAL::POSITIVE/CGAL::NEGATIVE, then a slighty 
  perturbed x is used (adding $\pm\epsilon$).
  \ccPrecond{$x$ is finite}
}

\ccMethod{Curve_vertical_line vertical_line_at_exact_x(Solution_1 x);}{
  returns an instance of \ccc{CurveVerticalLine} at the given $x$.
  \ccPrecond{$x$ is finite}
}

Note that the access methods to vertical lines are not redundant! The ones
using an id-value are efficient for speed-ups (caching, avoids to search some
$x$, just one representative vertical line for an interval). The others 
enables a user to compute vertical lines for given $x$, i.e. also to 
$y$-coordinates at given $x$.

\ccMethod{int find(Solution_2 s);}{
  returns the index of the event at the vertical line defined by 
  $s$'s $x$-coordinate, or -1 if $s$ is does not lie on the curve.
}


\end{ccRefConcept}

