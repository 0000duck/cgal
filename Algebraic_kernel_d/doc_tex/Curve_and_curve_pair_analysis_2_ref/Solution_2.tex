\begin{ccRefConcept}{Solution_2}

\ccDefinition

The concept \ccc{Solution_2} is meant to be a object that represents
a finite point on a curve.

%There are reasons why we introduce \ccc{Solution_2} over 
%\ccc{AlgebraicReal_2}:
%\begin{itemize}
%\item \ccc{AlgebraicReal_2} seems to be pair of \ccc{AlgebraicReal_1}, while
%\ccc{Solution_2} has members to access \ccc{Solution_1} for $x$ and $y$. 
%With the name we state better to be more generic.
%\item Keep concept minimal, in contrast to \ccc{AlgebraicReal_2} that
%seems to be quite powerful.
%\end{itemize}

\ccCreationVariable{sol2}

\ccAccessFunctions

\ccMethod{Solution_1 x();}{
  returns $x$-coordinate. 
  May throw some exception if algebraic degree becomes to large.
  Usual always computed and therefore easy to access.
}

\ccMethod{Solution_1 y();}{
  returns $y$-coordinate.
  May throw some exception if algebraic degree becomes to large.
  Note that it can be costly to compute this value, so accessing it
  should be handled with care. 
}

\begin{ccAdvanced}

The following methods can be useful.

\ccMethod{std::pair<Boundary,Boundary> s1.approximate_x(int prec);}{
  Refines the representation of $x$ to the given precision 
  (binary digits after point).
  Internally the precision can already be higher. Note that it can just
  refer to x().approximate(), but it can be more efficient or just possible
  to compute it without constructing the exact value.
} 

\ccMethod{std::pair<Boundary,Boundary> s1.approximate_y(int prec);}{
  Refines the representation of $y$ to the given precision 
  (binary digits after point).
  Internally the precision can already be higher. Note that it can just
  refer to y().approximate(), but it can be more efficient or just possible
  to compute it without constructing the exact value.
} 

\end{ccAdvanced}


\end{ccRefConcept}

