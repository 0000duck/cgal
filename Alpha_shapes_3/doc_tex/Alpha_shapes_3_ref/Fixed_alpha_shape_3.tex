%----------------------------------------------------------------------

\begin{ccRefClass} {Fixed_alpha_shape_3<Dt>}

\ccDefinition

The class \ccClassTemplateName\ represents one (fixed)
alpha shape of points in the 3D space for a real
$\alpha$. It maintains an  underlying triangulation 
of the class \ccc{Dt} which
represents connectivity and order among its faces. Each
$k$-dimensional face of the \ccc{Dt} is associated with
a classification that specifies its status in the alpha complex, alpha being fixed.

Note that this class can be used at the same time to build a {\em basic} or
a {\em weighted} Alpha Shape\ccIndexMainItem[C]{Weighted_alpha_shapes_3}.


\ccInclude{CGAL/Fixed_alpha_shape_3.h}

\ccInheritsFrom

\ccc{Dt}

This class is the underlying triangulation class.

The modifying functions \ccc{insert} and \ccc{remove} will overwrite
the inherited functions.

\ccTypes
\ccSetThreeColumns{Oriented_side}{}{\hspace*{10cm}}
\ccThreeToTwo

\ccNestedType{Gt}{the alpha shape traits type.}
it has to derive from a triangulation traits class.  
For example \ccc{Dt::Point} is a Point class. 

\ccTypedef{typedef Gt::FT FT;}{the number type of alpha.}

%\ccNestedType{Alpha_shape_vertices_iterator}{A bidirectional and non-mutable iterator that allow to traverse 
%the vertices which belongs to the alpha shape for a fixed $\alpha$. 
%\ccPrecond{Its \ccc{value_type} is \ccc{Dt::Vertex_handle}}}

%\ccNestedType{Alpha_shape_facets_iterator}{A bidirectional and non-mutable iterator that allow to traverse 
%the facets which belongs to the alpha shape for a fixed $\alpha$. 
%\ccPrecond{Its \ccc{value_type} is \ccc{Dt::Facet}}}

\ccEnum{enum Classification_type {EXTERIOR, SINGULAR, REGULAR, INTERIOR};}
{Enum to classify the simplices of the underlying 
triangulation with respect to a given alpha value.\\ 
Each k-dimensional simplex of the triangulation
can be classified as EXTERIOR, SINGULAR, REGULAR
or INTERIOR.
A $k$ simplex is REGULAR if it is on the boundary
of the alpha complex and belongs to a $k+1$ simplex in this complex
and it is SINGULAR  if it is  a boundary simplex that is not included in a $k+1$ simplex of the complex. \\  
}




\ccCreation
\ccCreationVariable{A}

\ccConstructor{Alpha_shape_3(FT alpha = 0);}
{Introduces an empty alpha shape data structure
\ccVar\ and set the alpha value to \ccc{alpha}.}

\ccConstructor{ Alpha_shape_3(Dt& dt,FT alpha = 0);}
{Builds an alpha shape from the triangulation \ccc{dt},
and set the alpha value to \ccc{alpha}.
Be careful that this operation destroys the triangulation.}

\ccConstructor{template < class InputIterator >
		Alpha_shape_3(
			InputIterator first,
			InputIterator last,
                const FT& alpha = 0);}
{Builds an alpha shape data structure
for the points in the range
$\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$ and 
set the alpha value to \ccc{alpha}.
\ccRequire{ The \ccc{value_type} of \ccc{first} and
\ccc{last} is \ccc{Point} (the type point of the underlying 
triangulation.)}}


\ccModifiers

\ccMethod{Vertex_handle insert (Point p,Cell_handle start = Cell_handle());}
{
Inserts point p in the underlying triangulation and returns the corresponding vertex.
The optional argument \ccc{start} is used as a starting place for the search.
The classification types of the new simplices are computed and that of the simplices incident 
to the new ones are updated.
}

\ccMethod{void remove (Vertex_handle v);}
{
Removes the vertex v from the underlying triangulation.
The classification types of new simplices and their incident faces are set or reset
}

\ccMethod{void
	clear();}
{Clears the structure.}


\ccHeading{Query Functions}


\ccMethod{const FT&
	get_alpha(void) const;}
{Returns the $\alpha$-value.}

\ccMethod{Classification_type
           classify(Cell_handle c) const;}
{Classifies the cell \ccc{c} of the underlying triangulation in the alpha complex.}

\ccMethod{Classification_type  classify(Facet f) const;}
{Classifies the facet \ccc{f} of the underlying triangulation in the alpha complex.}

\ccMethod{Classification_type classify(Cell_handle f, int i) const;}
{Classifies the facet of the cell \ccc{f} opposite to the vertex with index
\ccc{i} of the underlying triangulation in the alpha complex.}

\ccMethod{Classification_type classify(const Edge& e) const;}
{Classifies the edge \ccc{e} of the underlying triangulation in the alpha complex. }

\ccMethod{Classification_type classify(Vertex_handle v) const;}
{Classifies the vertex \ccc{v} of the underlying triangulation in the alpha complex.}



\ccMethod {template<class OutputIterator>
  OutputIterator get_alpha_shape_cells(OutputIterator it, Classification_type type);}
{Writes the cells which are of type \ccc{type} in the alpha complex
to the sequence
pointed to by the output iterator \ccc{it}. Returns past the end
of the output sequence.}


\ccMethod {
template<class OutputIterator>
  OutputIterator get_alpha_shape_facets(OutputIterator it, Classification_type type);}
{Writes the facets which are of type \ccc{type} in the alpha complex
to the sequence pointed to by the output iterator \ccc{it}. Returns past the end
of the output sequence.}

\ccMethod {
template<class OutputIterator>
  OutputIterator get_alpha_shape_edges(OutputIterator it, Classification_type type);}
{Writes the edges which are of type \ccc{type} in the alpha complex 
to the sequence
pointed to by the output iterator \ccc{it}. Returns past the end
of the output sequence.}

\ccMethod {
 template<class OutputIterator>
   OutputIterator get_alpha_shape_vertices(OutputIterator it, Classification_type type);} 
{Writes the vertices which are of type \ccc{type} in the alpha complex
to the sequence pointed to by the output iterator \ccc{it}. Returns past the end
of the output sequence.}

\ccHeading{I/O}

The I/O operators are defined for \ccc{iostream}, and for
the window stream provided by \cgal. The format for the iostream
is an internal format. 

\ccInclude{CGAL/IO/io.h}

\ccFunction{ostream& operator<<(ostream& os,
                  const Fixed_alpha_shape_3<Dt>& A);}
{Inserts the alpha shape \ccVar\ into the stream \ccc{os}.
\ccRequire{ The insert operator must be defined for \ccc{GT::Point}.}}



\end{ccRefClass}

