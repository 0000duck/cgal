% +========================================================================+
\section{Introduction}

Given two planar subdivisions $R$ and $B$, 
the overlay of $R$ and $B$, 
denoted by $O(R,B)$, is the subdivision of the plane 
induced by the edges of $R$ and $B$.
We refer to the components of $R$ as red, 
and to the components of $B$ as blue.
$R$ and $B$ are also called the {\em creators} of $O(R,B)$.
The overlay $O(R,B)$ consists of all non-empty sets $r \cap b$, 
such that $r \in R$ and $b \in B$. 
Every such non-empty set in $O(R,B)$ maintains 
pointers to the components $r \in R$ and $b \in B$ that created it.
More specifically, if a component $o \in O(R,B)$ points 
to the respective components $r \in R$ and $b \in B$, 
we say that $r$ and $b$ lie {\em above} $o$, 
alternatively, we say that $o$ lies {\em below} $r$ and $b$.
Figure~\ref{fig:overlay_example} displays an overlay 
of two given rectangles.

We can divide the problem of computing $O(R,B)$ into two subproblems:
\begin{itemize}
\item reporting all intersections between $R$ and $B$.
This subproblem is related to the red-blue curve intersection 
problem: Given a set of non-intersecting red curves and a 
set of non-intersecting blue curves in the plane, 
with a total of $N$ curves, report all $k$ intersections of 
red curves and blue curves.
In our implementation we construct the arrangement of the 
red and the blue curves by two possible algorithms:
the {\it incremental} algorithm and the {\it sweep-line} 
algorithm (See section~\ref{sec:algorithms}. 
In the implementation of the incremental algorithm 
we use the \ccStyle{Planar_Map_with_Intersections} class 
in order to represent the arrangement in construction,
and in our implementation to the sweep-line algorithm 
we simply use the \ccc{Sweep_Line_2} package.
In the latter case we use a \ccStyle{Planar_map_2} class
in order to represent the arrangement in construction.

\item updating each component $o \in O(R,B)$ to point to the 
respective components of $R$ and $B$ that created it.
This subproblem is easier than the former one,
and can be solved by a single pass on the arrangement 
constructed in the former stage.
In our implementation, we define a special \ccStyle{DCEL}
for the \ccc{Map_Overlay_2} package,
which is the data structure representing the constructed arrangement 
induced by the overlay (see Section~\ref{sec:dcel}).
In addition, we use the \ccStyle{Map Overlay Notifier} 
(see Section\ref{sec:notifier}), which is 
a newly defined class containing methods for updating the pointers 
in each component of the DCEL representing the 
constructed arrangement.
\end{itemize}

\begin{ccTexOnly}

\subsection*{Concepts}
\ccRefConceptPage{MapOverlayDcel_2}\\
\ccRefConceptPage{MapOverlayDcelVertex_2}\\
\ccRefConceptPage{MapOverlayDcelHalfedge_2}\\
\ccRefConceptPage{MapOverlayDcelFace_2}\\
\ccRefConceptPage{MapOverlayAlgorithm_2}\\
\ccRefConceptPage{MapOverlayNotifier_2}\\
\ccRefConceptPage{PolygonBopsTraits_2}\\

\subsection*{Classes}
\ccRefIdfierPage{CGAL::Map_overlay_2<Subdivision,Notifier>}\\
\ccRefIdfierPage{CGAL::Map_overlay_default_dcel<Traits,V,H,F>}\\
\ccRefIdfierPage{CGAL::Map_overlay_incremental<Subdivision,Notifier>}\\
\ccRefIdfierPage{CGAL::Map_overlay_sweep<Subdivision,Notifier>}\\
\ccRefIdfierPage{CGAL::Map_overlay_default_notifier<Subdivision>}\\
\ccRefIdfierPage{CGAL::Boolean_operations_2<Map_overlay>}\\
\ccRefIdfierPage{CGAL::Polygons_do_intersect_2<Traits>}\\
\ccRefIdfierPage{CGAL::Polygons_intersection_2<Traits>}\\
\ccRefIdfierPage{CGAL::Polygons_union_2<Traits>}\\
\ccRefIdfierPage{CGAL::Polygons_difference_2<Traits>}\\
\ccRefIdfierPage{CGAL::Polygons_symmetric_difference_2<Traits>}\\
\end{ccTexOnly}    







