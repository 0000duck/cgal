% +------------------------------------------------------------------------+
% | Reference manual page: Arr_rational_arc_traits.tex
% +------------------------------------------------------------------------+
% | 
% | Package: Arrangement_2
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin
\begin{ccRefClass}{Arr_rational_arc_traits_2<AlgKernel,NtTraits>}

\ccDefinition
%============

The traits class \ccRefName\ is a model of the \ccc{ArrangementTraits_2}
concept. It handles bounded or unbounded segments of rational functions,
referred to as {\sl rational arcs} (in particular, a rational arc may
correspond to the entire graph of a rational function), and enables the
construction and maintenance of arrangements of such arcs. Rational
functions, and polynomial functions in particular, are not only interesting
in their own right, they are also very useful for approximating or
interpolating more complicated curves.

A rational function $y = \frac{P(x)}{Q(x)}$
is defined by two polynomials $P$ and $Q$ of arbitrary degrees. In
particular, if $Q(x) = 1$ then the function is a simple polynomial
function. A bounded rational arc is defined by the graph of a rational
function over some internal $[x_{\rm min}, x_{\rm max}]$, where $Q$
does not have any real roots in this interval (thus the arc does not
contain any poles). However, our traits class is also capable of
representing functions defined over an unbounded $x$-range, namely
a ``ray'' defined on $(-\infty, x_{\rm max}]$ or on $[x_{\rm min}, \infty)$,
or an entire function defined for all real $x$ values. Note that a
rational arc is unbounded even if it is defined over some bounded interval,
yet $Q$ has zeros in this interval.

In our representation, all polynomial coefficients (the coefficients of $P$
and $Q$) must be rational numbers. This guarantees that the
$x$-coordinates of all arrangement vertices (in particular, those
representing intersection points) can be represented as roots of
polynomials with integer coefficients --- namely, algebraic numbers.
The $y$-coordinates can be obtained by simple arithmetic operations on
the $x$-coordinates, hence they are also algebraic numbers.

We therefore require separate representations of the curve coefficients and
the point coordinates. The \ccc{NtTraits} should be instantiated with a class
that defines nested \ccc{Integer}, \ccc{Rational} and \ccc{Algebraic} number
types and supports various operations on them, yielding certified computation
results (for example, in can convert rational numbers to algebraic numbers
and can compute roots of polynomials with integer coefficients).
The \ccc{AlgKernel} template-parameter should be a geometric kernel templated
with the \ccc{NtTraits::Algebraic} number-type. It is recommended to
instantiate the \ccc{CORE_algebraic_number_traits} class as the \ccc{NtTraits}
parameter, with \ccc{Cartesian<NtTraits::Algebraic>} instantiating the kernel.
The number types in this case are provided by the {\sc core} library, with its
ability to exactly represent simple algebraic numbers.

The traits class defined its point type to be \ccc{AlgKernel::Point_2},
and defines a curve type (and an identical $x$-monotone curve type, as 
a rational arc is always $x$-monotone by definition) as detailed below.

\ccInclude{CGAL/Arr_rational_arc_traits_2.h}

\ccIsModel
  \ccc{ArrangementTraits_2}

\subsection*{Class
         Arr\_rational\_arc\_traits\_2$<$AlgKernel,NtTraits$>$::Curve\_2}
%========================================================================

The \ccc{Curve_2} class nested within the rational-arc traits is used
to represent rational arcs and support their construction from a
single polynomial and an $x$-definition range or from a pair of polynomials
and an $x$-definition range. The copy and default constructor as well as the
assignment operator are provided for rational arcs. In addition, an
\ccc{operator<<} for the arcs is defined for standard output streams.

\begin{ccClass}{Arr_rational_arc_traits_2<AlgKernel,NtTraits>::Curve_2}
%======================================================================

\ccTypes
%-------

\ccNestedType{Rat_vector}{A vector of rational numbers (equivalent to
                          \ccc{std::vector<typename NtTraits::Rational}).}

\ccNestedType{Polynomial}{the \ccc{NtTraits::Polynomial} type
                          (a polynomial with integer coefficients).}

\ccCreation
\ccCreationVariable{a}
%---------------------

\ccConstructor{Curve_2 ();}
  {default constructor.}

\ccConstructor{Curve_2 (const Rat_vector& p_coeffs);}
  {constructs an arc that corresponds to the polynomial $y = P(x)$, defined
   for every real $x$. The vector \ccc{p_coeffs} specifies the coefficients
   of $P(x)$, where the polynomial degree is \ccc{p_coeffs.size() - 1} and
   \ccc{p[k]} is the coefficient of $x^k$ in $P$.}

\ccConstructor{Curve_2 (const Rat_vector& p_coeffs,
                        const typename NtTraits::Algebraic& s_x,
                        bool dir_right);}
  {constructs an arc supported by the polynomial $y = P(x)$. If
   \ccc{dir_right} is \ccc{true}, the arc is defined over the interval
   $[s_x, \infty)$, otherwise it is defined over $(-\infty, s_x]$.
   The vector \ccc{p_coeffs} specifies the coefficients of $P(x)$ as above.
   \ccPrecond{\ccc{s_x != t_x}.}}

\ccConstructor{Curve_2 (const Rat_vector& p_coeffs,
                        const typename NtTraits::Algebraic& s_x,
                        const typename NtTraits::Algebraic& t_x);}
  {constructs an arc supported by the polynomial $y = P(x)$, defined over
   the interval $[s_x, t_x]$, given by the $x$-coordinates of the arc's
   source and target. The vector \ccc{p_coeffs} specifies the coefficients
   of $P(x)$ as above.
   \ccPrecond{\ccc{s_x != t_x}.}}

\ccConstructor{Curve_2 (const Rat_vector& p_coeffs,
                        const Rat_vector& q_coeffs);}
  {constructs an arc supported by the rational function
   $y = \frac{P(x)}{Q(x)}$,  defined for every real $x$.
   The vectors \ccc{p_coeffs} and \ccc{q_coeffs} specify the coefficients
   of $P(x)$ and $Q(x)$, respectively (see above).}


\ccConstructor{Curve_2 (const Rat_vector& p_coeffs,
                        const Rat_vector& q_coeffs,
                        const typename NtTraits::Algebraic& s_x,
                        bool dir_right);}
  {constructs an arc supported by the rational function
   $y = \frac{P(x)}{Q(x)}$. If \ccc{dir_right} is \ccc{true}, the arc is
   defined over the interval $[s_x, \infty)$, otherwise it is defined
   over $(-\infty, s_x]$.
   The vectors \ccc{p_coeffs} and \ccc{q_coeffs} specify the coefficients
   of $P(x)$ and $Q(x)$, respectively (see above).}

\ccConstructor{Curve_2 (const Rat_vector& p_coeffs,
                        const Rat_vector& q_coeffs,
                        const typename NtTraits::Algebraic& s_x,
                        const typename NtTraits::Algebraic& t_x);}
  {constructs an arc supported by the rational function
   $y = \frac{P(x)}{Q(x)}$, defined over the internal $[s_x, t_x]$,
   given by the $x$-coordinates of the arc's source and target.
   The vectors \ccc{p_coeffs} and \ccc{q_coeffs} specify the coefficients
   of $P(x)$ and $Q(x)$, respectively (see above).
   \ccPrecond{\ccc{s_x != t_x}.}}

\ccAccessFunctions
%-----------------

\ccMethod{bool is_continuous() const;}
  {returns whether \ccVar\ is continuous, namely whether it does not
   contain any poles in its interior. $x$-monotone curves are always
   continuous.}

\ccMethod{const Polynomial& numerator () const;}
  {returns a polynomial with integer coefficients equivalent to $P(x)$.}

\ccMethod{const Polynomial& denominator () const;}
  {returns a polynomial with integer coefficients equivalent to $Q(x)$.}

\ccMethod{Arr_parameter_space source_boundary_in_x () const;}
  {returns whether the $x$-coordinate of the source is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{Arr_parameter_space source_boundary_in_y () const;}
  {returns whether the $y$-coordinate of the source is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{const Point_2& source() const;}
  {returns the source point of the arc.
   \ccPrecond{The source is finite in both $x$ and $y$.}}
\ccGlue
\ccMethod{typename NtTraits::Algebraic source_x() const;}
  {Get the $x$-coordinate of the source point.
   \ccPrecond{The source point is finite in $x$.}}
\ccGlue
\ccMethod{typename NtTraits::Algebraic source_y() const;}
  {Get the $y$-coordinate of the source point.
   \ccPrecond{The source point is finite in $y$.}}

\ccMethod{Arr_parameter_space target_boundary_in_x () const;}
  {returns whether the $x$-coordinate of the target is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{Arr_parameter_space target_boundary_in_y () const;}
  {returns whether the $y$-coordinate of the target is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{const Point_2& target() const;}
  {returns the target point of the arc.
   \ccPrecond{The target is finite in both $x$ and $y$.}}
\ccGlue
\ccMethod{typename NtTraits::Algebraic target_x() const;}
  {Get the $x$-coordinate of the target point.
   \ccPrecond{The target point is finite in $x$.}}
\ccGlue
\ccMethod{typename NtTraits::Algebraic target_y() const;}
  {Get the $y$-coordinate of the target point.
   \ccPrecond{The target point is finite in $y$.}}

\ccMethod{Arr_parameter_space left_boundary_in_x () const;}
  {returns whether the $x$-coordinate of \ccVar's left end is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{Arr_parameter_space left_boundary_in_y () const;}
  {returns whether the $y$-coordinate of \ccVar's left end is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{const Point_2& left() const;}
  {returns the left (lexicographically smaller) endpoint of \ccVar{}.
   \ccPrecond{The left end is finite in both $x$ and $y$.}}

\ccMethod{Arr_parameter_space right_boundary_in_x () const;}
  {returns whether the $x$-coordinate of \ccVar's right end is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{Arr_parameter_space right_boundary_in_y () const;}
  {returns whether the $y$-coordinate of \ccVar's right end is finite or
   whether it is $\pm\infty$.}
\ccGlue
\ccMethod{const Point_2& right() const;}
  {returns the right (lexicographically larger) endpoint of \ccVar{}.
   \ccPrecond{The right end is finite in both $x$ and $y$.}}

\end{ccClass}

\end{ccRefClass}
\ccRefPageEnd
