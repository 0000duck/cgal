% +------------------------------------------------------------------------+
% | Reference manual page: Arr_observer.tex
% +------------------------------------------------------------------------+
% | 
% | Package: Arrangement_2
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

\begin{ccRefClass}{Arr_observer<Arrangement>}
\label{arr_ref:arr_obs}

\ccDefinition
%============

\ccClassTemplateName{} serves as an abstract base class for all observer
classes that are attached to an arrangement instance of type \ccc{Arrangement}
and recieve notifications from the arrangement.
This base class handles the attachment of the
observer to a given arrangement instance or to the detachment of the
observer from this arrangement instance. It also gives a default empty
implementation to all notification functions that are invoked by the
arrangement to notify the observer on local or global changes it undergoes.
The notification functions are all virtual functions, so they can be
overridden by the concrete observer classes that inherit from
\ccClassTemplateName.

In order to implement a concrete arrangement observer-class, one simply
needs to derive from \ccClassTemplateName{} and override the relevant
notification functions. For example, if only face-split events are of
interest, it is sufficient to override just \ccc{before_split_face()} 
(or just \ccc{after_split_face()}).

\ccInclude{CGAL/Arr_observer.h}

\ccTypes
%=======

\ccNestedType{Arrangement_2}{the type of the associated arrangement.}

\ccTypedef{typedef typename Arrangement_2::Point_2 Point_2;}
    {the point type.}
\ccGlue
\ccTypedef{typedef typename Arrangement_2::X_monotone_curve_2 X_monotone_curve_2;}
    {the $x$-monotone curve type.}

\ccTypedef{typedef typename Arrangement_2::Vertex_handle Vertex_handle;}{}
\ccGlue
\ccTypedef{typedef typename Arrangement_2::Halfedge_handle Halfedge_handle;}{}
\ccGlue
\ccTypedef{typedef typename Arrangement_2::Face_handle Face_handle;}{}
\ccGlue
\ccTypedef{typedef typename Arrangement_2::Ccb_halfedge_circulator Ccb_halfedge_circulator;}
    {represents the boundary of a connected component (CCB).
     In particular, holes are represented by a circulator for their outer CCB.}

\ccCreation
\ccCreationVariable{obs}
%=======================

\ccConstructor{Arr_observer();} 
    {constructs an observer that is unattached to any arrangement instance.}
 
\ccConstructor{Arr_observer(Arrangement_2& arr);} 
    {constructs an observer and attaches it to the given arrangement 
     \ccc{arr}.}

\ccModifiers
%===========

\ccMethod{void attach (Arrangement_2& arr);}
    {attaches the observer to the given arrangement \ccc{arr}.}

\ccMethod{void detach ();}
    {detaches the observer from its arrangement.}


\ccHeading{Notifications on Global Arrangement Operations}
%=========================================================

\ccMethod{virtual void before_assign (const Arrangement_2& arr);}
    {issued just before the attached arrangement is assigned with the contents
     of another arrangement \ccc{arr}.}
\ccGlue
\ccMethod{virtual void after_assign ();}
    {issued immediately after the attached arrangement has been assigned with
     the contents of another arrangement.}

\ccMethod{virtual void before_clear ();}
    {issued just before the attached arrangement is cleared.}
\ccGlue
\ccMethod{virtual void after_clear (Face_handle uf);}
    {issued immediately after the attached arrangement has been cleared, so it
     now consists only of a the unbounded face \ccc{uf}.}

\ccMethod{virtual void before_global_change ();}
    {issued just before a global function starts to modify the attached
     arrangement. It is guaranteed that no queries (especially no 
     point-location queries) are issued until the termination of the global
     function is indicated by \ccc{after_global_change()}.}
\ccGlue
\ccMethod{virtual void after_global_change ();}
    {issued immediately after a global function has stopped modifying the
     attached arrangement.}

\ccHeading{Notifications on Attachment or Detachment}
%====================================================

\ccMethod{virtual void before_attach (const Arrangement_2& arr);}
    {issued just before the observer is attached to the arrangement instance
     \ccc{arr}.}
\ccGlue
\ccMethod{virtual void after_attach ();}
    {issued immediately after the observer has been attached to an
     arrangement instance.}

\ccMethod{virtual void before_detach ();}
    {issued just before the observer is detached from its arrangement instance.}
\ccGlue
\ccMethod{virtual void after_attach ();}
    {issued immediately after the observer has been detached from its
     arrangement instance.}

\ccHeading{Notifications on Local Changes in the Arrangement}
%============================================================


\ccMethod{virtual void before_create_vertex (const Point_2& p);}
    {issued just before a new vertex that corresponds to the point \ccc{p}
     is created.}
\ccGlue
\ccMethod{virtual void after_create_vertex (Vertex_handle v);}
    {issued immediately after a new vertex \ccc{v} has been created.
     Note that the vertex still has no incident edges and is not connected
     to any other vertex.}

\ccMethod{virtual void before_create_boundary_vertex (const X_monotone_curve_2& cv ,
                                                      Arr_curve_end ind ,
                                                      Arr_parameter_space ps_x ,
                                                      Arr_parameter_space ps_y );}
    {issued just before a new vertex at infinity is created, \ccc{cv} is the
    curve incident to the surface boundary, \ccc{ind} is the relevant curve-end,
    \ccc{ps_x} is the boundary condition of the vertex in $x$ and \ccc{ps_y}
     is the boundary condition of the vertex in $y$.}
\ccGlue
\ccMethod{virtual void after_create_boundary_vertex (Vertex_handle v);}
    {issued immediately after a new vertex \ccc{v} has been created.
     Note that the vertex still has no incident edges and is not connected
     to any other vertex.}

\ccMethod{virtual void before_create_edge (const X_monotone_curve_2& c,
                                           Vertex_handle v1,
                                           Vertex_handle v2);}
    {issued just before a new edge that corresponds to the $x$-monotone curve 
     \ccc{c} and connects the vertices \ccc{v1} and \ccc{v2} is created.}
\ccGlue
\ccMethod{virtual void after_create_edge (Halfedge_handle e);}
    {issued immediately after a new edge \ccc{e} has been created.
     The halfedge that is sent to this function is always directed from 
     \ccc{v1} to \ccc{v2} (see above).}

\ccMethod{virtual void before_modify_vertex (Vertex_handle v,
                                             const Point_2& p);}
    {issued just before a vertex \ccc{v} is modified to be associated with
     the point \ccc{p}.}
\ccGlue
\ccMethod{virtual void after_modify_vertex (Vertex_handle v);}
    {issued immediately after an existing vertex \ccc{v} has been modified.}

\ccMethod{virtual void before_modify_edge (Halfedge_handle e,
                                           const X_monotone_curve_2& c);}
    {issued just before an edge \ccc{e} is modified to be associated with
     the $x$-monotone curve \ccc{c}.}
\ccGlue
\ccMethod{virtual void after_modify_edge (Halfedge_handle e);}
    {issued immediately after an existing edge \ccc{e} has been modified.}

\ccMethod{virtual void before_split_edge (Halfedge_handle e,
                                          Vertex_handle v,
                                          const X_monotone_curve_2& c1,
                                          const X_monotone_curve_2& c2);}
    {issued just before an edge \ccc{e} is split into two edges that should
     be associated with the $x$-monotone curves \ccc{c1} and \ccc{c2}. The
     vertex \ccc{v} corresponds to the split point, and will be used to
     separate the two resulting edges.}
\ccGlue
\ccMethod{virtual void after_split_edge (Halfedge_handle e1,
                                         Halfedge_handle e2);}
    {issued immediately after an existing edge has been split into the two
     given edges \ccc{e1} and \ccc{e2}.}

\ccMethod{virtual void before_split_fictitious_edge (Halfedge_handle e,
                                                     Vertex_handle v);}
    {issued just before a fictitious edge \ccc{e} is split into two. The
     vertex at infinity \ccc{v} corresponds to the split point, and will be
     used to separate the two resulting edges.}
\ccGlue
\ccMethod{virtual void after_split_fictitious_edge (Halfedge_handle e1,
                                                    Halfedge_handle e2);}
    {issued immediately after an existing fictitious edge has been split into
     the two given fictitious edges \ccc{e1} and \ccc{e2}.}

\ccMethod{virtual void before_split_face (Face_handle f,
                                          Halfedge_handle e);}
    {issued just before a face \ccc{f} is split into two, as a result of
     the insertion of the edge \ccc{e} into the arrangement.}
\ccGlue
\ccMethod{virtual void after_split_face (Face_handle f1,
                                         Face_handle f2,
                                         bool is_hole);}
    {issued immediately after the existing face \ccc{f1} has been split,
     such that a portion of it now forms a new face \ccc{f2}. The flag
     \ccc{is_hole} designates whether \ccc{f2} forms a hole inside \ccc{f1}.}

\ccMethod{virtual void before_split_outer_ccb (Face_handle f,
                                               Ccb_halfedge_circulator h,
                                               Halfedge_handle e);}
    {issued just before outer ccb \ccc{h} inside a face \ccc{f} is split into
     two, as a result of the removal of the edge \ccc{e} from the arrangement.}
\ccGlue
\ccMethod{virtual void after_split_outer_ccb (Face_handle f,
                                              Ccb_halfedge_circulator h1,
                                              Ccb_halfedge_circulator h2);}
    {issued immediately after outer ccb the face \ccc{f} has been split,
     resulting in the two holes \ccc{h1} and \ccc{h2}.}

\ccMethod{virtual void before_split_inner_ccb (Face_handle f,
                                               Ccb_halfedge_circulator h,
                                               Halfedge_handle e);}
    {issued just before inner ccb \ccc{h} inside a face \ccc{f} is split into
     two, as a result of the removal of the edge \ccc{e} from the arrangement.}
\ccGlue
\ccMethod{virtual void after_split_inner_ccb (Face_handle f,
                                              Ccb_halfedge_circulator h1,
                                              Ccb_halfedge_circulator h2);}
    {issued immediately after inner ccb the face \ccc{f} has been split,
     resulting in the two holes \ccc{h1} and \ccc{h2}.}

\ccMethod{virtual void before_add_outer_ccb (Face_handle f,
                                             Halfedge_handle e);}
    {issued just before the edge \ccc{e} is inserted as a new outer ccb inside
     the face \ccc{f}.}
\ccGlue
\ccMethod{virtual void after_add_outer_ccb (Ccb_halfedge_circulator h);}
    {issued immediately after a new outer ccb \ccc{h} has been created. The
     outer ccb always consists of a single pair of twin halfedges.}

\ccMethod{virtual void before_add_inner_ccb (Face_handle f,
                                             Halfedge_handle e);}
    {issued just before the edge \ccc{e} is inserted as a new inner ccb inside
     the face \ccc{f}.}
\ccGlue
\ccMethod{virtual void after_add_inner_ccb (Ccb_halfedge_circulator h);}
    {issued immediately after a new inner ccb \ccc{h} has been created. The
     inner ccb always consists of a single pair of twin halfedges.}

\ccMethod{virtual void before_add_isolated_vertex (Face_handle f,
                                                   Vertex_handle v);}
    {issued just before the vertex \ccc{v} is inserted as an isolated
     vertex inside the face \ccc{f}.}
\ccGlue
\ccMethod{virtual void after_add_isolated_vertex (Vertex_handle v);}
    {issued immediately after the vertex \ccc{v} has been set as an
     isolated vertex.}

\ccMethod{virtual void before_merge_edge (Halfedge_handle e1,
                                          Halfedge_handle e2,
                                          const X_monotone_curve_2& c);}
    {issued just before the two edges \ccc{e1} and \ccc{e2} are merged to
     form a single edge that will be associated with the $x$-monotone curve
     \ccc{c}.}
\ccGlue
\ccMethod{virtual void after_merge_edge (Halfedge_handle e);}
    {issued immediately after two edges have been merged to form the edge
     \ccc{e}.}

\ccMethod{virtual void before_merge_fictitious_edge (Halfedge_handle e1,
                                                     Halfedge_handle e2);}
    {issued just before the two fictitious edges \ccc{e1} and \ccc{e2} are
     merged to form a single fictitious edge.}
\ccGlue
\ccMethod{virtual void after_merge_fictitious_edge (Halfedge_handle e);}
    {issued immediately after two fictitious edges have been merged to form
     the fictitious edge \ccc{e}.}

\ccMethod{virtual void before_merge_face (Face_handle f1,
                                          Face_handle f2,
                                          Halfedge_handle e);}
    {issued just before the two edges \ccc{f1} and \ccc{f2} are merged to
     form a single face, following the removal of the edge \ccc{e} from the
     arrangement.}
\ccGlue
\ccMethod{virtual void after_merge_face (Face_handle f);}
    {issued immediately after two faces have been merged to form the face
     \ccc{f}.}

\ccMethod{virtual void before_merge_outer_ccb (Face_handle f,
                                               Ccb_halfedge_circulator h1,
                                               Ccb_halfedge_circulator h2,
                                               Halfedge_handle e);}
    {issued just before two outer ccbs \ccc{h1} and \ccc{h2} inside the face 
     \ccc{f} are merged to form a single connected component, following the
     insertion of the edge \ccc{e} into the arrangement.}
\ccGlue
\ccMethod{virtual void after_merge_outer_ccb (Face_handle f,
                                              Ccb_halfedge_circulator h);}
    {issued immediately after two outer ccbs have been merged to form a single
     outer ccb \ccc{h} inside the face \ccc{f}.}

\ccMethod{virtual void before_merge_inner_ccb (Face_handle f,
                                               Ccb_halfedge_circulator h1,
                                               Ccb_halfedge_circulator h2,
                                               Halfedge_handle e);}
    {issued just before two inner ccbs \ccc{h1} and \ccc{h2} inside the face 
     \ccc{f} are merged to form a single connected component, following the
     insertion of the edge \ccc{e} into the arrangement.}
\ccGlue
\ccMethod{virtual void after_merge_inner_ccb (Face_handle f,
                                              Ccb_halfedge_circulator h);}
    {issued immediately after two inner ccbs have been merged to form a single
     inner ccb \ccc{h} inside the face \ccc{f}.}

\ccMethod{virtual void before_move_outer_ccb (Face_handle from_f,
                                              Face_handle to_f,
                                              Ccb_halfedge_circulator h);}
    {issued just before the outer ccb \ccc{h} is moved from one face to another.
     This can happen if the face \ccc{to_f} containing the outer ccb has just
     been split from \ccc{from_f}.}
\ccGlue
\ccMethod{virtual void after_move_outer_ccb (Ccb_halfedge_circulator h);}
    {issued immediately after the outer ccb \ccc{h} has been moved to a new face.}

\ccMethod{virtual void before_move_inner_ccb (Face_handle from_f,
                                              Face_handle to_f,
                                              Ccb_halfedge_circulator h);}
    {issued just before the inner ccb \ccc{h} is moved from one face to another.
     This can happen if the face \ccc{to_f} containing the inner ccb has just
     been split from \ccc{from_f}.}
\ccGlue
\ccMethod{virtual void after_move_inner_ccb (Ccb_halfedge_circulator h);}
    {issued immediately after the inner ccb \ccc{h} has been moved to a new face.}

\ccMethod{virtual void before_move_isolated_vertex (Face_handle from_f,
                                                    Face_handle to_f,
                                                    Vertex_handle v);}
    {issued just before the isolated vertex \ccc{v} is moved from one face
     to another.
     This can happen if the face \ccc{to_f} containing the isolated vertex
     has just been split from \ccc{from_f}.}
\ccGlue
\ccMethod{virtual void after_move_isolated_vertex (Vertex_handle v);}
    {issued immediately after the isolated vertex \ccc{v} has been moved to a 
     new face.}

\ccMethod{virtual void before_remove_vertex (Vertex_handle v);}
    {issued just before the vertex \ccc{v} is removed from the arrangement.}
\ccGlue
\ccMethod{virtual void after_remove_vertex ();}
    {issued immediately after a vertex has been removed (and deleted)
     from the arrangement.}
%
%\ccMethod{virtual void before_remove_vertex_at_infinity (Vertex_handle v);}
%    {issued just before the vertex at infinity \ccc{v} is removed from the
%     arrangement.}
%\ccGlue
%\ccMethod{virtual void after_remove_vertex_at_infinity ();}
%    {issued immediately after a vertex at infinity has been removed
%     (and deleted) from the arrangement.}

\ccMethod{virtual void before_remove_edge (Halfedge_handle e);}
    {issued just before the edge \ccc{e} is removed from the arrangement.}
\ccGlue
\ccMethod{virtual void after_remove_edge ();}
    {issued immediately after an edge has been removed (and deleted)
     from the arrangement.}

\ccMethod{virtual void before_remove_outer_ccb (Face_handle f,
                                           Ccb_halfedge_circulator h);}
    {issued just before the outer ccb \ccc{f} is removed from inside the
     face \ccc{f}.}
\ccGlue
\ccMethod{virtual void after_remove_outer_ccb (Face_handle f);}
    {issued immediately after a outer ccb has been removed (and deleted)
     from inside the face \ccc{f}.}

\ccMethod{virtual void before_remove_inner_ccb (Face_handle f,
                                           Ccb_halfedge_circulator h);}
    {issued just before the inner ccb \ccc{f} is removed from inside the
     face \ccc{f}.}
\ccGlue
\ccMethod{virtual void after_remove_inner_ccb (Face_handle f);}
    {issued immediately after a inner ccb has been removed (and deleted)
     from inside the face \ccc{f}.}

\end{ccRefClass}

\ccRefPageEnd
