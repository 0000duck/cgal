/*!
\page usage Usage
\cgalAutoToc

<b>Since \cgal version 5.0, \cgal is header-only be default, which means
that there is no need to compile and install anything before it can be
used. However, some dependencies of \cgal might still need to be installed.</b>

\section usage_introduction Quick Start

Ideally, compiling an example shipped with \cgal is as simple as:

    cd examples/Triangulation_2 # go to an example directory
    cmake -DCGAL_DIR=$HOME/CGAL-\cgalReleaseNumber -DCMAKE_BUILD_TYPE=Release . # configure the examples
    make # build the examples

Compiling your own program is similar:

    cd /path/to/your/program
    cgal_create_CMakeLists -s executable
    cmake -DCGAL_DIR=$HOME/CGAL-\cgalReleaseNumber -DCMAKE_BUILD_TYPE=Release .
    make

The script `cgal_create_CMakeLists` and its options are detailed in Section \ref manual_create_cgal_CMakeLists.

\cgalModifBegin
Something about Windows?
\cgalModifEnd

In a less ideal world, you might have to install the required tools and third party libraries.
This is what this page is about.

\section secprerequisites Prerequisites 

Using \cgal requires a few core components to be previously installed:
<ul>
<li> a supported compiler (see Section \ref seccompilers), </li>
<li> \ref seccmake </li>
<li> \ref thirdpartyBoost, </li>
<li> \ref thirdpartyMPFR. </li>
</ul>

Optional third-party software might be required to build examples and demos shipped with \cgal,
or to build your own project using \cgal, see Section \ref secoptional3rdpartysoftware.

\section secgettingcgal Downloading CGAL

You can obtain the \cgal library from
<A HREF="https://www.cgal.org/download.html">https://www.cgal.org/download.html</A>.

Once you have downloaded the file `CGAL-\cgalReleaseNumber``.tar.gz` containing the
\cgal sources, you have to unpack it. Under a Unix-like shell, use the
command:

    tar xzf CGAL-\cgalReleaseNumber.tar.gz

In both cases the directory `CGAL-\cgalReleaseNumber` will be created. This directory
contains the following subdirectories:

| Directory                  | Contents   |
| :------------------------- | :----------|
| `auxiliary` (Windows only) | precompiled \sc{Gmp} and \sc{Mpfr} for Windows |
| `cmake/modules`            | modules for finding and using libraries |
| `config`                   | configuration files for install script |
| `demo`                     | demo programs (most of them need \sc{Qt}, geomview or other third-party products) |
| `doc_html`                 | documentation (HTML) |
| `examples`                 | example programs |
| `include`                  | header files |
| `scripts`                  | some useful scripts (e.g. for creating CMakeLists.txt files) |
| `src`                      | source files |

The directories `include/CGAL/CORE` and `src/CGALCore` contain a
distribution of the <a href="https://cs.nyu.edu/exact/">\sc{Core} library</a> version 1.7 for
dealing with algebraic numbers. Note that \sc{Core} is not part of \cgal and has its
own license.

The directory `include/CGAL/OpenNL` contains a distribution of the
<a href="http://alice.loria.fr/index.php/software/4-library/23-opennl.html">Open Numerical Library</a>,
which provides solvers for sparse linear systems, especially designed for the Computer Graphics community.
\sc{OpenNL} is not part of \cgal and has its own license.

The only documentation shipped within \cgal sources is the present
installation manual. The \cgal manual can be accessed online at
<A HREF="https://doc.cgal.org/latest/Manual/index.html">`https://doc.cgal.org`</A>
or downloaded separately at
<A HREF="https://github.com/CGAL/cgal/releases">`https://github.com/CGAL/cgal/releases`</A>.

\section section_headeronly Header-only Usage

Since \cgal 4.12, it has been possible to use \cgal in <a href="https://en.wikipedia.org/wiki/Header-only">header-only mode</a>,
without even configuring \cgal\. Programs using \cgal (examples, tests, demos, etc.)
are instead configured using CMake and \cgal will be configured at the same time.

Note that even though \cgal can be used as a header-only library, not all its dependencies
are header-only. The libraries \sc{Gmp} and \sc{Mpfr}, for example, are not
header-only. As such, these dependencies must be built or installed independently.

\subsection subsection_headeronly_pbonwindows Potential Issue on Windows

\cgalModifBegin
(RE)MOVE THAT?
\cgalModifEnd

A potential issue when using \cgal in header-only mode on a Windows operating system can arise
when compiling a program using several modules (executable programs or dynamic-link libraries DLL).
If two different modules use the same static variable, this variable is defined independently
in each of these modules. If one module modifies the value of this variable, it will not be modified
in the other module, which could induce an unexpected behavior. In \cgal, this concerns only
a few specific variables: the <A HREF="https://doc.cgal.org/latest/Generator/classCGAL_1_1Random.html">default random</A>,
the <A HREF="https://doc.cgal.org/latest/STL_Extension/group__PkgSTLExtensionAssertions.html">failure behavior</A>,
`CGAL::IO::Mode`. One example is the following: if you change the default random in one DLL, then
if you use the default random in another DLL, you will not obtain the modified default random but the original one.

\subsection usage_installingcgal Building and Installing CGAL

Although using the header-only mode makes building and installing \cgal obsolete, it is still possible
to configure, build, and install \cgal. Head over to \ref installation for more information. It is
however advised by the \cgal project to use the much simpler header-only mode, and the present page
assumes that this configuration is being used.

\section usage_configuring_cgal Configuring your Program

Before building anything using \cgal you have to choose the compiler/linker, set compiler
and linker flags, specify which third-party libraries you want to use and where they can be found.
Gathering all this information is called <I>configuration</I>. The end of the process is marked
by the generation of a makefile or a Visual \cpp solution and project file that you can use
to build your program. Configuring a program such as a \cgal example amounts to:

    cd CGAL-\cgalReleaseNumber/examples/Triangulation_2
    cmake -DCGAL_DIR=$HOME/CGAL-\cgalReleaseNumber .

The required `CMakeLists.txt` is already provided for all shipped examples and demos of \cgal.
For other programs, CMake can also be used to configure and build user programs,
but one has to provide the `CMakeLists.txt` script either manually, or with the help of a
shell-script that is described in Section \ref manual_create_cgal_CMakeLists. For a user program
`executable.cpp`, this then ideally resumes to:

    cd /path/to/your/program
    cgal_create_CMakeLists -s executable
    cmake -DCGAL_DIR=$HOME/CGAL-\cgalReleaseNumber .

Note that in both examples we have specified the `CGAL_DIR` variable, which must point
to the root directory of the \cgal source code (either the root of the unpacked release tarball,
or the root of the Git working directory).

\cgalModifBegin
TMP
Note that in both examples we have specified the `CGAL_DIR` variable: during configuration
of the \cgal libraries a file named `CGALConfig.cmake` is generated in \cgal's root directory
(in contrast to \cgal's source directory that has been used for installation).
This file contains the definitions of several CMake variables that summarize the
configuration of \cgal.
In order to configure a program, you need to indicate the location of this config file
in the CMake variable `CGAL_DIR` (as indicated in the example above).
`CGAL_DIR` can also be an environment variable.

Setting `CGAL_DIR` makes particular sense if having multiple
out-of-source builds of \cgal as in Section \ref seccmakeoutofsource.

TMP If you have installed \cgal, `CGAL_DIR` must afterwards be set to
`$CMAKE_INSTALLED_PREFIX/lib/CGAL`. Note that \cgal is
recommended to be installed in release mode when using it to build programs.
\cgalModifEnd

\subsection usage_configuring_gui Configuring CGAL with the CMake GUI

The simplest way to start the configuration is to run the graphical
user interface of CMake. We recommend to use `cmake-gui`. You must pass as
argument the root directory of \cgal. For example:

    cd CGAL-\cgalReleaseNumber
    cmake-gui . # Notice the dot to indicate the current directory.

After `cmake-gui` opens, press 'Configure'.
A dialog will pop up and you will have to choose what shall be generated.
After you have made your choice and pressed 'Finish', you will see
the output of configuration tests in the lower portion of the application.
When these tests are done, you will see many
red entries in the upper portion of the application. Just ignore them and press 'Configure'.
By now CMake should have found many libraries and have initialized variables.
If you still find red entries, you have to provide the necessary information.
This typically happens if you have installed software at non-standard locations.
Providing information and pressing 'Configure' goes on until
all entries are grayed. You are now ready to press 'Generate'. Once this is
done, you can quit `cmake-gui`.

\subsection usage_configuring_cmd Configuring CGAL with the cmake Command-Line Tool

\cgalModifBegin
MERGE THAT WITH ABOVE, ADAPT TO FIT EXAMPLE CONFIG RATHER THAN CGAL CONFIG, TRIM IT
\cgalModifEnd

Alternatively, you can run the command-line tool called
`cmake`. You pass as argument the root directory of
\cgal. For example:

    cd CGAL-\cgalReleaseNumber
    cmake . # Notice the dot to indicate the current directory.

The very first thing CMake does is to detect the compiler to use. This
detection is performed by a special CMake module called a
<I>generator</I>.
A CMake generator understands the build requirements for a
particular compiler/linker and generates the necessary files for that. For
example, the <I>UNIX Makefiles</I> generator understands the GNU chain
of tools (\gcc, ld etc.) and produces makefiles, which can be used to build a
target by a simple call to `make`. Likewise, the <I>Visual Studio
2010</I> generator produces solution and project files and can be manually
launched in the VS IDE to build the target.

Each platform has a default generator, so you only need to select one when
the default is not what you want. For example, under Windows, it is
possible to generate <I>NMakefiles</I> instead of Visual Studio project
files in order to build the library with `nmake`. Running
`cmake` with no parameters in a command-line prints the list of
available generators supported by your platform and CMake version. If the
generator you need is not listed there, you can try a newer
CMake version, as generators are hardcoded into CMake, and additional
generators are added with each release.

Since the choice of the generator determines the type of build files to generate, in some cases
you choose a particular generator as a mean to choose a specific compiler (because they use different
build files). For example, the following generates solution files for
use in Visual \cpp 15.0 on a 64bit machine:

    cd CGAL-\cgalReleaseNumber
    cmake -G"Visual Studio 15 2017 Win64" .

In other cases, however, the generator doesn't directly identify a
specific compiler but a chain of tools.
For example, the `UNIX Makefiles` generator produces `makefiles` that call some auto-detected
command-line compiler, like \gcc. If you need the makefiles to use a different compiler, you need to
specify the desired compiler in the call to CMake, as in this example:

    cd CGAL-\cgalReleaseNumber
    cmake -DCMAKE_CXX_COMPILER:FILEPATH=g++-4.7 .

CMake maintains configuration parameters in so-called <I>cmake variables</I>, like the `CMAKE_CXX_COMPILER`
in the example above. These variables <I>are not environment variables</I> but <I>CMake variables</I>. Some of the CMake
variables represent user choices, such as `WITH_examples` or `CMAKE_BUILD_TYPE=Release`, while others
indicate the details of a third-party library, such as `Boost_INCLUDE_DIR` or the compiler flags to use,
such as `CMAKE_CXX_FLAGS`.

The command line tool `cmake` accepts CMake variables as arguments of the form `-D<VAR>:<TYPE>=<VALUE>`, as
in the example above, but this is only useful if you already know which variables need to be explicitly defined.

\cgalAdvancedBegin
CMake keeps the variables that a user can manipulate in a
so-called <I>CMake cache</I>, a simple text file named
`CMakeCache.txt`, whose entries are of the form
`VARIABLE:TYPE=VALUE`. Advanced users can manually edit this file,
instead of going through the interactive configuration session.
\cgalAdvancedEnd

The configuration process not only determines the location of the required dependencies, it also dynamically generates a
`compiler_config.h` file, which encodes the properties of your system and a special file named
`CGALConfig.cmake`, which is used to build programs using \cgal. The
purpose of this file is explained below.

\section usage_building_program Building your Program

The results of a successful configuration are build files that control the build step.
The nature of the build files depends on the generator used during configuration, but in most cases
they contain several <I>targets</I>, such as all the examples of the Triangulation_2 package.

In a \sc{Unix}-like environment the default generator produces makefiles.
You can use the `make` command-line tool for the succeeding build step as follows:

    cd CGAL-\cgalReleaseNumber/examples/Triangulation_2
    make # build all the examples of the Triangulation_2 package

With generators other than `UNIX Makefiles` the resulting build files are solution and project files
which should be launched in an \sc{Ide}, such as Visual Studio or KDevelop3. They will contain the targets described
above, which you can manually build as with any other solution/project within your \sc{Ide}.

Alternatively, you can build it with the command line version of the \sc{Visual Studio Ide}:

    devenv CGAL.sln /Build Release

The "Release" argument is needed because CMake creates solution files for
all four configurations, and you need to explicitly choose one when building
(the other choices are `Debug`, `RelWithDebInfo`, and `MinSizeRel`).

\cgalAdvancedBegin
The build files produced by CMake are autoconfigured. That is, if you change any of the dependencies,
the build step automatically goes all the way back to the configuration step. This way, once the target
has been configured the very first time by invoking cmake, you don't necessarily need to invoke `cmake`
again. Rebuilding will call itself `cmake` and re-generate the build file whenever needed.
\cgalAdvancedEnd

*/
