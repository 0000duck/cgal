% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  Subdivision_method_3
% +------------------------------------------------------------------------+
% | Subdivision surfaces on generic Polyhedron.
% | 
% | 1.2.2005  Le-Jeng Andy Shiue
% |
\RCSdef{\subdivisionRev}{$Id$}
\RCSdefDate{\subdivisionDate}{$Date$}
% +------------------------------------------------------------------------+

\newcommand\DS{Doo-Sabin}

% ------------------------------------------------------------------------
\newcommand\FIGDIR{Subdivision_method_3/FIG}
\newcommand\IL{{\itshape left}}
\newcommand\IR{{\itshape right}}
\newcommand\IM{{\itshape middle}}
\newcommand\IT{{\itshape top}}
\newcommand\IB{{\itshape bottom}}
% ------------------------------------------------------------------------

\ccParDims

\chapter{Subdivision Methods}
\label{chapterSubdivision}
\ccChapterRelease{\subdivisionRev. \ \subdivisionDate}
\ccChapterAuthor{Le-Jeng Andy Shiue}
\hspace{.4cm}
\begin{ccTexOnly}
    \setlength{\unitlength}{1mm}
    \begin{picture}(0,0)(0.0,0.0)
      \put (78,25){% textwidth = 156mm
          \includegraphics[width=0.5\textwidth]{\FIGDIR/teaser}
      }
    \end{picture}\vspace{-4mm}% compensate for some vspace added by picture
\end{ccTexOnly}

\minitoc

% +------------------------------------------------------------------------+
\section{Introduction} \label{sectionSubIntro}
% +------------------------------------------------------------------------+
The subdivision method is a simple yet powerful way to 
generate smooth surfaces from arbitrary polyhedral meshes. 
Unlike spline-based surfaces (e.g NURBS) or other numeric-based 
modeling techniques, users of subdivision
surfaces do not need in-depth mathematics 
knowledge on subdivision methods. Users only need
natural geometric intuitions to control the subdivision 
surface; hence subdivision methods are popular choices for
character modeling in video games and character animations.

%Subdivision algorithms (see e.g.~\cite{cgal:ww-smgd-02})
%recursively refine coarse meshes and generate ever closer 
%approximations to a smooth surface.
%for character animation, surface modeling, or physics simulation.
%Setting aside the specific strategy of geometric averaging
%for the new points, subdivision algorithms can be classified 
%according to the topological refinement of the underlying mesh.
%\ccc{Subdivision_method_3}, working on the concept of the 
%\ccc{CGAL::Polyhedron_3} (see Chapter~\ref{chapterPolyhedron}),
%takes advantage of this separation of geometry and topology.
%Each subdivision algorithm is a refinement function parametrized
%by a set of rountines of geometric averageing.

\ccc{Subdivision_method_3} aims to be simple to use and extend.
It supports four most used subdivision methods, including Loop, 
Catmull-Clark, Doo-Sabin and $\sqrt{3}$ subdivisions. Variations 
of these methods can be easily implemented by plugging 
in the user-defined computation rules. \ccc{Subdivision_method_3}
is designed to work on \ccc{CGAL::Polyhedron_3} 
(see Chapter~\ref{chapterPolyhedron}), 


\begin{ccHtmlOnly}
     <CENTER>
         <img src="./FIG/teaser.jpg" alt="Catmul-Clark subdivision"><P>
     </CENTER>
\end{ccHtmlOnly}

% +------------------------------------------------------------------------+
\section{Subdivision Algorithms}
\label{secSubAlgo}
% +------------------------------------------------------------------------+
In this chapter, we explain some fundamentals of 
subdivision methods. We only focus on the topics helping you 
to understand the design of the package; interested readers can
still refer to \cite{cgal:ww-smgd-02} for an in-depth introduction.
Some terminologies introduced in this section will be used again
in later sections. If you are only interested in using a 
specific subdivision method, Section \ref{secFirstSub} 
gives a quick tutorial on Catmull-Clark subdivision.

A subdivision method recursively refines a coarse mesh and 
generates an ever closer approximation to a smooth surface.
The coarse mesh can have arbitrary shapes, but it has to 
be a 2-manifold. In a 2-manifold, every interior point has 
a neighborhood homomorphic to a 2D disk. Subdivision methods
on non-manifolds have be developed, but are not considered
in this work. 
%Subdivision algorithms (see e.g.~\cite{cgal:ww-smgd-02}) 
%define surfaces as the limit
%of recursive refinement of a polyhedral mesh, called
%\emph{control mesh}. 
%The refinements generate mesh points 
%to be smoothed to approximate the limit surface.   
The chapter teaser shows the process of Catlmull-Clark 
subdivision on a CAD model. The coarse mesh is repeatly refined 
by a quadrisection pattern, and new points are generated 
to approximate the smooth surface.

Many refinement patterns are used in practice. 
\ccc{Subdivision_method_3} supports the four most popular 
patterns, and each of them is used by 
Catmull-Clark\cite{cgal:cc-rgbss-78}, Loop, Doo-Sabin 
and $\sqrt{3}$ subdivision (left to right in the 
figure). Note we name these patterns by their topological
characteristics, not the associated subdivision methods. 
PQQ indicates the \emph{P}rimal \emph{Q}uadtrateral \emph{Q}uadrisection. 
PTQ indicates the \emph{P}rimal \emph{T}riangle \emph{Q}uadrisection. 
DQQ indicates the \emph{D}ual \emph{Q}uadtrateral \emph{Q}uadrisection.
$\sqrt{3}$ has a long story of its naming; simply put, it 
indicates the speed of the topological converging.

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.6\textwidth}{%
      \includegraphics[width=0.6\textwidth]{\FIGDIR/RefSchemes}%
    }\\ \vspace{0.5cm}
  \end{center}
\end{ccTexOnly}

\begin{ccHtmlOnly}
  <CENTER>
     <img src="./FIG/RefSchemes.gif" alt="Refinement Hosts"><P>
  </CENTER>
\end{ccHtmlOnly}

The figure demonstrates these four refinement patterns on 
the 1-disk of a valence-5 vertex/facet.
Refined meshes are shown below the source meshes. 
%We call a source mesh \emph{control mesh} if it is
%the origin of a squence of refinements.
Points on the refined mesh are generated by averaging
neighbor points on the source mesh. A graph, called \emph{stencil}, 
determines the source neighthood whose points contribute to the 
position of a refined point. A refinement pattern usually has 
several specific sets of stencils.
%Stencils are defined at the time the refinement pattern is chosen.  
%as illustrated in Figure \ref{fig:RefMap},
For example, the PQQ
%\emph{P}rimal \emph{Q}uadtrateral \emph{Q}uadrisection (PQQ) scheme 
refinement used by Catmull-Clark subdivision has a vertex-node stencil, 
which defines the 1-ring of an input vertex; an edge-node stencil, 
which defines the 1-ring of an input edge; and a facet-node stencil, 
which defines an input facet. The stecils of the PQQ refinement are
shown in the following figure. The blue neighborhoods in the 
top row indicate the corresponding stencils of the refined nodes 
in red. 

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.5\textwidth}{%
      \includegraphics[width=0.5\textwidth]{\FIGDIR/PQQStencil}%
    }\\ \vspace{0.5cm}
  \end{center}
\end{ccTexOnly}

\begin{ccHtmlOnly}
  <CENTER>
     <img src="./FIG/PQQStencil.gif" alt="Stencils of PQQ scheme "><P>
  </CENTER>
\end{ccHtmlOnly}


%while the DQQ scheme has only a corner-node stencil, which 
%relates the facet of a corner to a target node.
Stencils with weights are called \emph{geometry masks}.
%One practical set of geometry masks of the PQQ scheme is
A subdivision method defines the masks for the stencils, and 
generates new points by summarizing source points weighted by the mask. 
Geometry masks are usually carefully choosed to meet requirements of 
certain surface smoothness and shape quality.
The geometry masks of Catmull-Clark subdivision are shown
below (masks for extraordinary vertices are not shown).  

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.4\textwidth}{%
      \includegraphics[width=0.4\textwidth]{\FIGDIR/cc_mask}%
    } \\ \vspace{0.5cm}
  \end{center}
\end{ccTexOnly}

\begin{ccHtmlOnly}
  <CENTER>
     <img src="./FIG/cc_mask.gif" alt="Catmull-Clark geometry stencil"><P>
  </CENTER>
\end{ccHtmlOnly}

The weights shown here are unnormalized, and $n$ is the valence 
of the vertex. The generated point, in red, is computed by a summation
of the weighted points. For example, a Catmull-Clark facet-node is 
computed by the summation of $1/4$ of each points on its stencil.

A stencil may have several specific sets of geometry masks. In other 
words, a facet-node of Catmull-Clark refinement may be computed by 
the summation of $1/5$ of each stencil node instead of $1/4$. 
Although it is legal in \ccc{Subdivision_method_3} to have 
any kind of geometry mask, the result surfaces may be odd, 
not smooth, or not even exist. \cite{cgal:ww-smgd-02} explains the 
details on designing masks of quality subdivision surfaces.

%The averaging process can typically be factored into 
%simpler steps \cite{Oswald-2003-CSS}.
%and this has been implemented in the OpenMesh library \cite{Sovakar-2004-APISUB}.
%However, while stencil factoring simplifies the implementation,
%it is less efficient because it requires repeated visits 
%to all nodes.

%% Since only a fixed number of refinement patterns are 
%% practical but a wide variety of geometry masks can be developed,
%% \ccc{Subdivision_method_3} provides a set of refinement patterns 
%% (the \emph{refinement hosts})
%% and hands the definition of geometry masks
%% (the \emph{geometry policies}) to the library user.
%% A subdivision scheme is obtained by parameterizing the 
%% refinement host with geometry policies. 
%% For example, Catmull-Clark subdivision is constructed by 
%% parameterizing the PQQ refinement with the Catmull-Clark geometry 
%% policies.

%, which compute the smoothed points based on the
%Catmull-Clark geometry masks.

%A subdivision scheme of \ccc{CGAL::Subdivision_method_3} is a 
%refinement host parameterized with a geometry policy. 

%The refinement host realizes the topological refinement and 
%the stencils. The geometry policy consists a set of 
%averaging rules of the geometry stencils.

% +-------------------------------------------------------------+
\section{Create Your First Subdivision Surafce}
\label{secFirstSub}
Assuming your familiarity of \ccc{CGAL::Polyhedron_3},
you can intergrate \ccc{Subdivision_method_3} into your program 
without much effort.

\ccIncludeExampleCode{Subdivision_method_3/CatmullClark_subdivision.C}

This example demonstrates the use of Catmull-Clark subdivision
on a CGAL polyhedron. The polyhedron is restricted within the Cartesian
space, where most subdivision applications are designed to work.
There is only one line deserving a detailed explanation:
\begin{ccExampleCode}
Subdivision_method_3::CatmullClark_subdivision(P,d);
\end{ccExampleCode}
\ccc{Subdivision_method_3} specifies the namespace of our
subdivision functions. \ccc{CatmullClark_subdivision(P,d)} computes the 
Catmull-Clark subdivision surfaces of the polyhedron \ccc{P} after
\ccc{d} iterations of the refinements. The polyhedron \ccc{P} is 
passed by the reference and is modified (i.e.~subdivided) by the 
subdivision function.

Other subdivision methods (such as Doo-Sabin subdivision) can be
used with the same level of the ease.

This example shows how to subdivide a simple \ccc{CGAL::Polyhedron_3}
with \ccc{Subdivision_method_3}.
An application-defined polyhedron might use a specialized kernel and/or
a specialized internal container. There are two major restrictions on the 
your application-defined polyhedron to be able to work with 
\ccc{Subdivision_method_3}.
\begin{itemize}
\item
\ccc{Point_3} is type-defined within the kernel. Without \ccc{Point_3} 
and associated operations being defined, \ccc{Subdivision_method_3} 
can not know how to compute and where to store the new vertex points.
\item
The primitives (such as vertices, halfedges and facets) 
in the internal container are sequentially ordered. 
In other words, the iterators traverse the primitives in 
the order of their creation. Examples include \ccc{std::vector} and 
\ccc{std::list}.

\end{itemize}

Section~\ref{secRefHost} gives detailed explanations on these 
two restrictions.

% +-------------------------------------------------------------+
\section{Catmull-Clark Subdivision in Depth}
\label{secCC}
%Loop, Catmull-Clark, Doo-Sabin and $\sqrt{3}$ subdivision methods
%are popular in practice. Yet from time to time you may want to
%create your own method. You may be a graduate student believing 
%in a perfect subdivision scheme, or
%you just want a unique surface which looks simply bad. In either case,
%\ccc{Subdivision_method_3} allows you to try your beloved algorithms
%with a small amount of efforts. The best way to learn how to create
%a your-name subdivision is by digging into one of the four subdivisions
%\ccc{Subdivision_method_3} supported. 
%In this section, we will guide you through the implementation of 
%Catmull-Clark subdivision.
%This section explain how do we implement the
%Catmull-Clark subdivision based on the framework of 
%\ccc{Subdivision_method_3}.
\ccc{Subdivision_method_3} gives you easy-to-use functions on 
Catmull-Clark, Loop, Doo-Sabin and $\sqrt{3}$ subdivision methods.
But \ccc{Subdivision_method_3} is more like a framework that let 
you extend the methods with ease. This section explains the process
of \emph{implementing} the Catmull-Clark subdivision within
\ccc{Subdivision_method_3}. Following this procedure, you can 
easily implement a new subdivision method based on the refinement 
patterns in \ccc{Subdivision_method_3}

When a subdivision method is developed, a refinement pattern is 
chosen, and then a set of geometry masks are developed to 
\emph{position} the new points.
E. Catmull and J. Clark picked the \emph{P}rimal \emph{Q}uadtrateral 
\emph{Q}uadrisection (PQQ) to be the refinement pattern,
and developed a set of geometry masks to generate (or more precisely, 
to approximate) the B-spline surface from the control polyhedral 
mesh. 

There are three key components of implementing
Catmull-Clark subdivision: 
\begin{itemize}
\item
a mesh data structure that can represent arbitrary 2-manifolds, 
\item
a process that refines the mesh data structure, 
\item
and the geometry masks that compute and assign the new points.
\end{itemize}

%We have the mesh data structure in \ccc{CGAL::Polyhedron_3}, and 
%we have the PQQ refinement in \ccc{Subdivision_method_3} that 
%works on \ccc{CGAL::Polyhedron_3}. But we still need the 
%geometry masks to finish the job.
%\ccc{Subdivision_method_3} also supports three other refinements that 
%you can choose to use for your subdivision. These refinements are
%PT(riangle)Q for Loop subdivision, D(ual)QQ for Doo-Sabin subdivision, 
%and $\sqrt{3}$ triangulation for $\sqrt{3}$ 
%subdivision. Here is the function declaration of the PQQ refinement.
\ccc{Subdivision_method_3} defines a function that covers all 
three components for Catmull-Clark subdivision.

\begin{ccExampleCode}
template <class Polyhedron, template <typename> class Mask>
void PQQ(Polyhedron& p, Mask<Polyhedron> mask, int depth)
\end{ccExampleCode}

\ccc{Polyhedron} is a model of \ccc{CGAL::Polyhedron_3}, which
is a generic mesh data structure of arbitrary 
2-manifolds. \ccc{PQQ()} provides the process refining 
the control polyhedron \ccc{p}. During the refinement, 
\ccc{PQQ()}, the \emph{refinement host}, computes and assigns the 
new points by coorperating with the \ccc{mask}. 
To implement Catmull-Clark subdivision,
\ccc{Mask}, the \emph{geometry policy}, has to realize the geometry 
masks of Catmull-Clark subdivision. 
\ccc{depth} specifies how many steps of the refinement 
to be applied on the polyhedron. 
%To make the call to
%\ccc{PQQ} a Catmull-Clark subdivision, the only thing left is to
%implement a geometry policy realizing the Catmull-Clark geometry masks.

To implement the geometry masks, we need to know how  
a mask communicates with the refinement host. The PQQ refinement 
defines three stencils, and therefor three geometry masks
are required for Catmull-Clark subdivision.
The interfaces of the stencils are specified as
the policy class \ccc{PQQ_stencil_3}.

\begin{ccExampleCode}
template <class Polyhedron>
class PQQ_stencil_3 {
  void facet_node(Facet_handle facet, Point& pt);
  void edge_node(Halfedge_handle edge, Point& pt);
  void vertex_node(Vertex_handle vertex, Point& pt);
};
\end{ccExampleCode}

A mask computes the new point with the primitive handle
passed into the policy function, and assigns the new point to
\ccc{Point& pt}. Since our goal is to implement Catmull-Clark 
subdivision, we need to implement the policy functions realizing
its geometry masks. 
%For clarity, we rename the policy class 
%to indicate geometry masks are in place.

\begin{ccExampleCode}
template <class Polyhedron>
class CatmullClark_mask_3 {
  void facet_node(Facet_handle facet, Point& pt) {
    Halfedge_around_facet_circulator hcir = facet->facet_begin();
    int n = 0;
    FT p[] = {0,0,0};
    do {
      Point t = hcir->vertex()->point();
      p[0] += t[0], p[1] += t[1], p[2] += t[2]; 
      ++n;
    } while (++hcir != facet->facet_begin());
    pt = Point(p[0]/n, p[1]/n, p[2]/n);
  }
  void edge_node(Halfedge_handle edge, Point& pt) {
    Point p1 = edge->vertex()->point();
    Point p2 = edge->opposite()->vertex()->point();
    Point f1, f2;
    facet_node(edge->facet(), f1);
    facet_node(edge->opposite()->facet(), f2);
    pt = Point((p1[0]+p2[0]+f1[0]+f2[0])/4,
               (p1[1]+p2[1]+f1[1]+f2[1])/4,
               (p1[2]+p2[2]+f1[2]+f2[2])/4 );
  }
  void vertex_node(Vertex_handle vertex, Point& pt) {
    Halfedge_around_vertex_circulator vcir = vertex->vertex_begin();
    int n = circulator_size(vcir);    

    float Q[] = {0.0, 0.0, 0.0}, R[] = {0.0, 0.0, 0.0};
    Point& S = vertex->point();
    
    Point q;
    for (int i = 0; i < n; i++, ++vcir) {
      Point& p2 = vcir->opposite()->vertex()->point();
      R[0] += (S[0]+p2[0])/2;
      R[1] += (S[1]+p2[1])/2;
      R[2] += (S[2]+p2[2])/2;
      facet_node(vcir->facet(), q);
      Q[0] += q[0];      
      Q[1] += q[1];      
      Q[2] += q[2];
    }
    R[0] /= n;    R[1] /= n;    R[2] /= n;
    Q[0] /= n;    Q[1] /= n;    Q[2] /= n;
      
    pt = Point((Q[0] + 2*R[0] + S[0]*(n-3))/n,
               (Q[1] + 2*R[1] + S[1]*(n-3))/n,
               (Q[2] + 2*R[2] + S[2]*(n-3))/n );
  }
};
\end{ccExampleCode}

The listed codes show the default implementation of Catmull-Clark 
masks (and hence the Catmull-Clark subdivision function) 
in \ccc{Subdivision_method_3}.
This default implementation assumes the \emph{types} 
(such as \ccc{Point} and \ccc{Facet_handle}) are defined 
within the \ccc{Polyhedron}. It is designed
to work on a \ccc{CGAL::Polyhedron_3} with the default CGAL 
kernel geometry. You may need to rewrite the geometry computation
to match the kernel geometry of your application.

To invoke the subdivision method, you can 
simply call the \ccc{PQQ(...)} with the Catmull-Clark mask
we just defined.

\begin{ccExampleCode}
PQQ(p, CatmullClark_mask_3<Polyhedron>(), depth);
\end{ccExampleCode}

%\begin{ccExampleCode}
%template <class Polyhedron>
%void CatmullClark_subdivision(Polyhedron& p, int depth) {
%    PQQ(p, CatmullClark_mask_3<Polyhedron>(), depth);
%}
%\end{ccExampleCode}

Loop, Doo-Sabin and $\sqrt{3}$ subdivisions are implemented 
in a similar process: pick a refinement host and implement 
the geometry policy. The key of developing your own 
subdivision method is implementing the right combination of 
the refinement host and the geometry policy. It is 
explained in the next two sections.

% +-------------------------------------------------------------+
\section{Refinement Host}
\label{secRefHost}
A refinement host is a function with template parameters of 
a polyhedron class and a geometry mask class. It refines
the input polyhedron, and assigns new points by the geometry masks.
\ccc{Subdivision_method_3} supports four refinement hosts:
primal quadrilateral quadrisection (PQQ), 
primal triangle quadrisection (PTQ), dual quadrilateral 
quadrisection (DQQ) and $\sqrt{3}$ triangulation.
They are respectively used by Catmull-Clark, Loop, \DS\ and $\sqrt{3}$ 
subdivision. 

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.6\textwidth}{%
      \includegraphics[width=0.6\textwidth]{\FIGDIR/RefSchemes}%
    }\\ \vspace{0.5cm}
%    \ccc{Subdivision_method_3} supports hosts of these four refinement 
%    schemes that are demonstrated on a valence-n submesh.
%    The refined mesh is shown below the control mesh.
  \end{center}
\end{ccTexOnly}

\begin{ccHtmlOnly}
  <CENTER>
     <img src="./FIG/RefSchemes.gif" alt="Refinement Hosts"><P>
  </CENTER>
\end{ccHtmlOnly}


\begin{ccExampleCode}
namespace Subdivision_method_3 {
  template <class Polyhedron, template <typename> class Mask>
  void PQQ(Polyhedron& p, Mask<Polyhedron> mask, int step);

  template <class Polyhedron, template <typename> class Mask>
  void PTQ(Polyhedron& p, Mask<Polyhedron> mask, int step);

  template <class Polyhedron, template <typename> class Mask>
  void DQQ(Polyhedron& p, Mask<Polyhedron> mask, int step)

  template <class Polyhedron, template <typename> class Mask>
  void Sqrt3(Polyhedron& p, Mask<Polyhedron> mask, int step)
}
\end{ccExampleCode}

%% Stencils are maintained using the iteration concept
%% to avoid the need for vertex tags to distinguish
%% the stencil types.
%% For example, on a PQQ refined mesh, the vertex iterator 
%% visits the 
%% vertex-nodes, edge-nodes and then facet-nodes. The visit
%% order is implicitly used to determine the stencil of
%% the visited node.

The polyhedron class is a specialization of the 
\ccc{CGAL::Polyhedron_3}, and the mask is a policy 
class realizing the geometry masks of the subdivision 
method.

A refinement host refines the input polyhedron, maintains 
the stencils (i.e.~the mapping between the control mesh 
and the refined mesh), and calls the geometry mask 
to compute the new points. 
In \ccc{Subdivision_method_3}, refinements are implemented
as a sequence of connectivity operations (mostly Euler operations).
The order of the connectivity operations plays the key of the mapping 
of the stencils. By matching the order, no flag in the primitives 
is required to register the stencils, and it avoids the data 
dependency of the refinement host on the polyhedron class. 
To make the ordering trick work, the polyhedron class must 
have a sequential container, such as a vector or a linked-list, as
the internal storage. 
%The polyhedron class always inserts
%new primitives at the end, and 
A sequential container guarantees that the iterators of the 
polyhedron always traverse the primitives in the order of their 
insertions. Non-sequential structures such as 
tree or map do not provide the required ordering, and hence
can not be used with \ccc{Subdivision_method_3}.
 
Although \ccc{Subdivision_method_3} does not require flags
to support the refinements and the stencils, it
still needs to know how to compute and where to store the geometry
data (i.e.~the points). \ccc{Subdivision_method_3} 
expects that the typename \ccc{Point_3} is 
defined in the geometry kernel of the polyhedron
(i.e.~the \ccc{Polyhedron::Traits::Kernel}). 
A point of the type \ccc{Point_3} is returned by the geometry 
policy and is then assgined to the new vertex.  
The geometry policy is explained in next section. 

For details of the refinement implementation, 
interested users should refer to \cite{cgal:sp-mrbee-05}.

% +-------------------------------------------------------------+
\section{Geometry Policy}
A geometry policy defines a set of geometry masks. 
Each geometry mask is realized as a member function
computing the new point of the subdivision surface. 
%The policy interface is defined with the refinement host. 

Each geometry mask receives a primitive handle 
(e.g.~\ccc{Halfedge_handle}) of the control polyhedron, 
and returns a \ccc{Point_3} to the subdivided vertex. 
The function collects the neighbors of the primitive handle 
(i.e.~nodes on the stencil), and computes the new point 
based on the neighbors and the mask (i.e.~the stencil weights).

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.4\textwidth}{%
      \includegraphics[width=0.4\textwidth]{\FIGDIR/cc_mask}%
    } \\ \vspace{0.5cm}
  \end{center}
\end{ccTexOnly}
\begin{ccHtmlOnly}
  <CENTER>
     <img src="./FIG/cc_mask.gif" alt="Catmull-Clark geometry stencil"><P>
  </CENTER>
\end{ccHtmlOnly}

This figure shows the geometry masks for
Catmull-Clark subdivision. The weights shown here are unnormalized, 
and $n$ is the valence of the vertex. The new points are 
computed by the summation of the weighted points on their stencils.
Following codes show an implementation of the geometry mask of 
the facet-node. The complete listing
of the Catmull-Clark geometry policy is in the Section~\ref{secCC}.

\begin{ccExampleCode}
template <class Polyhedron>
class CatmullClark_mask_3 {
  void facet_node(Facet_handle facet, Point_3& pt) {
    Halfedge_around_facet_circulator hcir = facet->facet_begin();
    int n = 0;
    FT p[] = {0,0,0};
    do {
      Point t = hcir->vertex()->point();
      p[0] += t[0], p[1] += t[1], p[2] += t[2]; 
      ++n;
    } while (++hcir != facet->facet_begin());
    pt = Point(p[0]/n, p[1]/n, p[2]/n);
  }
}
\end{ccExampleCode}

In this example, the computation is based on the assumption that
the \ccc{Point_3} is the \ccc{CGAL::Point_3}. It is an assumption, 
but not a restriction.
You are allowed to use any point class as long as it is
defined as the \ccc{Point_3} in your polyhedron.
You may need to modify the geometry policy to support the computation
and assignment of the specialized point. This extension is not unusual 
in graphics applications. For example, you might want to subdivide the
texture coordinates when you subdivide the polyhedron. 
%The typename 
%\ccc{Point_3} is actually the attribute holder, including the 
%point of course, for the vertices.

The PQQ refinement host requires three geometry masks for 
polyhedrons without open boundaries: a vertex-node 
mask, an edge-node mask, and a facet-node mask. 
To support polyhedrons with boundaries, a border-node mask is 
also required. The border-node mask for Catmull-Clark subdivision
is listed below, where \ccc{ept} returns the new point splitting the
edge and \ccc{vpt} returns the new point on the vertex pointed by
the edge.  

%% \begin{ccTexOnly}
%%   \begin{center}
%%     \parbox{0.5\textwidth}{%
%%       \includegraphics[width=0.5\textwidth]{\FIGDIR/PQQStencil}%
%%     }
%%   \end{center}
%% \end{ccTexOnly}

\begin{ccExampleCode}
  void border_node(Halfedge_handle edge, Point_3& ept, Point_3& vpt) {
    Point_3& ep1 = edge->vertex()->point();
    Point_3& ep2 = edge->opposite()->vertex()->point();
    ept = Point_3((ep1[0]+ep2[0])/2, (ep1[1]+ep2[1])/2, (ep1[2]+ep2[2])/2);

    Halfedge_around_vertex_circulator vcir = edge->vertex_begin();
    Point_3& vp1  = vcir->opposite()->vertex()->point();
    Point_3& vp0  = vcir->vertex()->point();
    Point_3& vp_1 = (--vcir)->opposite()->vertex()->point();
    vpt = Point_3((vp_1[0] + 6*vp0[0] + vp1[0])/8,
                (vp_1[1] + 6*vp0[1] + vp1[1])/8,
                (vp_1[2] + 6*vp0[2] + vp1[2])/8 );
  }
\end{ccExampleCode}


The mask interfaces of all four refinement hosts are listed below.
Please note that \ccc{DQQ_stencil_3} and \ccc{Sqrt3_stencil_3} 
do not have the border-node stencil because the refinement hosts of
DQQ and $\sqrt{3}$ refinements do not support global boundaries in the 
current release of \ccc{Subdivision_method_3}. Though this might be 
changed in the future releases.

%The interface of a geometry policy need to match the stencils of 
%the refinement host. We have already seen the geometry masks for
%a PQQ-base subdivision, Catmull-Clark subdivision. 
%The mask interface the other three refinement hosts, PTQ, DQQ and 
%$\sqrt{3}$, are defined below 
%(PQQ as well).


\begin{ccExampleCode}
template <class Poly>
class PQQ_stencil_3 {
  void facet_node(Facet_handle, Point_3&);
  void edge_node(Halfedge_handle, Point_3&);
  void vertex_node(Vertex_handle, Point_3&);

  void border_node(Halfedge_handle, Point&, Point_3&);
};

template <class Poly>
class PTQ_stencil_3 {
  void edge_node(Halfedge_handle, Point_3&);
  void vertex_node(Vertex_handle, Point_3&);

  void border_node(Halfedge_handle, Point&, Point_&);
};

template <class Poly>
class DQQ_stencil_3 {
public:
  void corner_node(Halfedge_handle edge, Point_3& pt);
};

template <class Poly>
class Sqrt3_stencil_3 {
public:
  void vertex_node(Vertex_handle vertex, Point_3& pt);
};
\end{ccExampleCode}

The source codes of \ccc{CatmullClark_mask_3}, \ccc{Loop_mask_3},
\ccc{DooSabin_mask_3}, and \ccc{Sqrt3_mask_3} are
the best source of learning the these stencil 
interfaces. 


%Note, only the \ccc{PQQ_stencil_3} and the \ccc{DQQ_stencil_3}
%are provided in \ccc{Subdivision_method_3}.
%The \ccc{PTQ_stencil_3} and the \ccc{Sqrt3_stencil_3} are given
%here for reference only. Both stencils are a subset of the
%\ccc{PQQ_stencil_3}, and you can just use the 
%\ccc{PQQ_stencil_3} to develop masks for PTQ or $\sqrt{3}$ 
%schemes. 


%% \begin{ccExampleCode}
%% PQQ<_M,CCstencil>(Mesh,CCstencil<_M>())
%% \end{ccExampleCode}
%% (or, more simply \\
%% \begin{ccExampleCode}
%% PQQ(Mesh,CCstencil<_M>())}
%% \end{ccExampleCode}
%% since the compiler can derive the template
%% arguments from the function parameters),
%% instantiates Catmull-Clark subdivision.    
%% \ccc{_M}, the model of the mesh concept,
%% represents the mesh type (\ccc{Mesh}),
%% and \ccc{CCstencil} is a class template 
%% realizing geometry policies of Catmull-Clark subdivision.

%The geometry stencils of Catmull-Clark subdivision (border stencils are 
%not included) are shown below. 

%\begin{ccTexOnly}
%  \begin{center}
%    \parbox{0.4\textwidth}{%
%      \includegraphics[width=0.4\textwidth]{\FIGDIR/cc_mask}%
%    }
%  \end{center}
%\end{ccTexOnly}

%\begin{ccHtmlOnly}
%  <CENTER>
%  <A HREF="./FIG/cc_mask.gif">
%     <img src="./FIG/cc_mask.gif" alt="Catmull-Clark geometry stencil"></A><P>
%  </CENTER>
%\end{ccHtmlOnly}


% +------------------------------------------------------------------------+
\section{Subdivision methods}
% +------------------------------------------------------------------------+
\ccc{Subdivision_method_3} directly supports 
Catmull-Clark, Loop, \DS\ and $\sqrt{3}$ subdivisions by specializing
their respective refinemnt hosts.

\begin{ccExampleCode}
namespace Subdivision_method_3 {
  template <class Polyhedron>
  void CatmullClark_subdivision(Polyhedron& p, int step = 1) {
    PQQ(p, CatmullClark_mask_3<Polyhedron>(), step);
  }

  template <class Polyhedron>
  void Loop_subdivision(Polyhedron& p, int step = 1) {
    PTQ(p, Loop_mask_3<Polyhedron>() , step);
  }

  template <class Polyhedron>
  void DooSabin_subdivision(Polyhedron& p, int step = 1) {
    DQQ(p, DooSabin_mask_3<Polyhedron>(), step);
  }

  template <class Polyhedron>
  void Sqrt3_subdivision(Polyhedron& p, int step = 1) {
    Sqrt3(p, Sqrt3_mask_3<Polyhedron>(), step);
  }
}
\end{ccExampleCode}

The following example demonstrates the use of the \DS\ subdivision 
on a polyhedral mesh.
\ccIncludeExampleCode{Subdivision_method_3/DooSabin_subdivision.C}

% +------------------------------------------------------------------------+
\section{Subdivision customization}
% +------------------------------------------------------------------------+
One of the goals of \ccc{Subdivision_method_3} is 
to provide a flexible platform
to develop user-flavored subdivision schemes.
To construct a customized subdivision scheme, users can simply 
choose a refinement host with the intended topological pattern, 
and then realize the geometry policy accordingly. 
The following example develops a subdivision scheme
generating improved Loop subdivision surfaces. Loop subdivision is
based on PTQ refinement. The geometry policy is developed as a subclass 
of \ccc{PQQ_stencil_3}, which defines the superset of PTQ stencils.

\ccIncludeExampleCode{Subdivision_method_3/Customized_subdivision.C}

A policy function for subdivision surfaces assigns a point on 
the subdivided polyhedron. The points are semantically
required to converge to a smoothed surface of the control mesh.
This is the text-book requirement of a subdivision 
surface (it has to be smooth). Since this is the end of the
class, feel free to throw the text-book away and just try yours. 
Good luck though.

