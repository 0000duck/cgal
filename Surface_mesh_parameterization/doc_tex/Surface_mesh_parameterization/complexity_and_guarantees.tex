\section{Complexity and Guarantees}


\subsection{Parameterization Methods and Guarantees}

\begin{itemize}

\item Fixed boundaries

    \begin{itemize}

    \item One-to-one mapping

        Tutte's theorem guarantees a one-to-one mapping provided that the weights are positive
        and the border convex.
        It is the case for Tutte Barycentric Mapping and Floater Mean Value Coordinates.
        It is not always the case for Discrete Conformal Map (cotangents) and
        Discrete Authalic Parameterization.

    \item Non-singularity of the matrix

        Geshorgin's theorem guarantees the convergence of the solver if the matrix is diagonal dominant.
        This is the case with positive weights (Tutte Barycentric Mapping and Floater Mean Value
        Coordinates).

    \end{itemize}

\item Free boundaries

    \begin{itemize}

    \item One-to-one mapping

        No guarantee can be given for LSCM (both global overlaps and triangle flips can
        occur).

    \item Non-singularity of the matrix

        Proven for LSCM: the matrix of the system is the Gramm matrix of a matrix of maximal rank,
        and is therefore non-singular (Gramm theorem).

    \end{itemize}

\end{itemize}


\subsection{Precision}

Only a few algorithms of this package construct the sparse linear system(s)
using trigonometric functions, incompatible with an exact arithmetic:

\begin{itemize}

\item Floater Mean Value Coordinates

\item Circular border parameterization

\end{itemize}

On the other hand, linear solvers commonly use double precision floating point
numbers. \\
OpenNL's BICGSTAB solver (accessible though the
\ccc{OpenNL::DefaultLinearSolverTraits<COEFFTYPE, MATRIX, VECTOR, SOLVER>} interface)
is the only solver supported by this package that
computes exact results (when used with an exact arithmetic).

Therefore, this package is intended to be used with a \cgal\
cartesian kernel with doubles.


\subsubsection{OpenNL's BICGSTAB Solver with an Exact Arithmetic}

The BICGSTAB conjugate gradient is in fact a direct solver.
In a nutshell, it computes a vector basis
orthogonal with respect to the matrix, and the coordinates of the solution in this vector basis.
Each iteration computes one component of the basis and one coordinate, therefore the algorithm
converges to the solution in $n$ iterations, where $n$ is the dimension of the matrix.
In fact, it can be even less than $n$, it converges in $k$ iteration, where $k$ is the number
of distinct eigenvalues of the matrix. \\
\emph{Note:} for a perfectly conditioned matrix, it converges in one iteration!


\subsubsection{Solvers with a Floating Point Arithmetic}

\emph{OpenNL's BICGSTAB example:}

When inexact numerical types are used (e.g. doubles), accumulated errors slow down convergence
(in practice, it requires approximately $5k$ iterations to converge).
The required number of iterations depends on the eigenvalues of the matrix, and these eigenvalues depend
on the shape of the triangles. The optimum is when the triangles are equilateral (then the solver converges
in less than 10 iterations). The worst case is obtained when the mesh has a large number of skinny triangles (near-singular Jacobian matrix of the triangle). In this case, the spectrum of the matrix
is wide (many different eigenvalues), and the solver requires nearly $5n$ iterations to converge.


\subsection{Algorithmic Complexity}

In this package, we focus on piecewise linear mappings onto a planar
domain. All surface parameterization methods are based on solving one (or two)
sparse linear system(s).
The algorithmic complexity is dominated by the resolution of the sparse linear system(s).

\emph{OpenNL's BICGSTAB example:}

At each iteration, the operation of highest complexity is the sparse-matrix x vector product.
The sparse matrix has a fixed number of non-zero coefficients per row,
therefore the sparse-matrix x vector product has $O(n)$ complexity.
Since convergence is reached after $k$ iterations, the complexity is $O(k.n)$
(where $k$ is the number of distinct eigenvalues of the matrix).
Therefore, best case complexity is $O(n)$ (equilateral triangles),
and worst case complexity is $O(n^2)$ (skinny triangles).

