\section{Complexity and Guarantees}


\subsection{Parameterization Methods and Guarantees}

\begin{itemize}

\item Fixed boundaries

    \begin{itemize}

    \item One-to-one mapping

        Tutte's theorem guarantees a one-to-one mapping provided that the weights are all positive
        and the border convex.
        It is the case for Tutte barycentric mapping and Floater mean value coordinates.
        It is not always the case for discrete conformal map (cotangents) and
        discrete authalic parameterization.

    \item Non-singularity of the matrix

        Geshorgin's theorem guarantees the convergence of the solver if the matrix is diagonal dominant.
        This is the case with positive weights (Tutte barycentric mapping and Floater mean value coordinates).

    \end{itemize}

\item Free boundaries

    \begin{itemize}

    \item One-to-one mapping

        No guarantee is provided by LSCM (both global overlaps and triangle flips can
        occur).

    \item Non-singularity of the matrix

        For LSCM, the matrix of the system is the Gramm matrix of a matrix with maximal rank,
        and is therefore non-singular (Gramm theorem).

    \end{itemize}

\end{itemize}


\subsection{Precision}

Two algorithms of this package construct the sparse linear system(s)
using trigonometric functions, and are this incompatible with exact arithmetic:

\begin{itemize}

\item Floater mean value coordinates

\item Circular border parameterization

\end{itemize}

On the other hand, linear solvers commonly use double precision floating point
numbers. \\
OpenNL's BICGSTAB solver (accessible through the
\ccc{OpenNL::DefaultLinearSolverTraits<COEFFTYPE, MATRIX, VECTOR, SOLVER>} interface)
is the only solver supported by this package which 
computes exact results, when used with an exact arithmetic. This package is
intended to be used mainly with a \cgal\ Cartesian kernel with doubles.


\subsubsection{OpenNL's BICGSTAB Solver with an Exact Arithmetic}

The BICGSTAB conjugate gradient is in disguise a direct solver.
In a nutshell, it computes a vector basis
orthogonal with respect to the matrix, and the coordinates of the solution in this vector basis.
Each iteration computes one component of the basis and one coordinate, therefore the algorithm
converges to the solution in $n$ iterations, where $n$ is the dimension of the matrix. More precisely, it is shown to converge in $k$ iteration, where $k$ is the number of distinct eigenvalues of the matrix. 

% For a perfectly conditioned matrix, it converges in a single iteration.

\subsubsection{Solvers with a Floating Point Arithmetic}

\emph{OpenNL's BICGSTAB example:}

When inexact numerical types are used (e.g. doubles), accumulated errors slow down convergence
(in practice, it requires approximately $5k$ iterations to converge).
The required number of iterations depends on the eigenvalues of the matrix, and these eigenvalues depend
on the shape of the triangles. The optimum is when the triangles are equilateral (then the solver converges
in less than 10 iterations). The worst case is obtained when the mesh has a large number of skinny triangles (near-singular Jacobian matrix of the triangle). In this case, the spectrum of the matrix
is wide (many different eigenvalues), and the solver requires nearly $5n$ iterations to converge.


\subsection{Algorithmic Complexity}

In this package, we focus on piecewise linear mappings onto a planar
domain. All surface parameterization methods are based on solving one (or two)
sparse linear system(s).
The algorithmic complexity is dominated by the resolution of the sparse linear system(s).

\emph{OpenNL's BICGSTAB example:}

At each iteration, the operation of highest complexity is the product between the sparse-matrix and a vector.
The sparse matrix has a fixed number of non-zero coefficients per row,
therefore the matrix / vector product has $O(n)$ complexity.
Since convergence is reached after $k$ iterations, the complexity is $O(k.n)$
(where $k$ is the number of distinct eigenvalues of the matrix).
Therefore, best case complexity is $O(n)$ (equilateral triangles),
and worst case complexity is $O(n^2)$ (skinny triangles).

