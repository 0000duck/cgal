
\ccHtmlNoClassLinks
\begin{ccClassTemplate} {vector<T>}

\ccSection{vector}

\ccDefinition
An object of the class \ccClassName\ is a sequence that supports
random access iterators. In addition it supports (amortized)
constant time insert and erase operations at the end.  Insert and erase 
in the middle take linear time.

% prevent dead links to non-CGAL include files
\ccHtmlLinksOff
\ccInclude{vector}
\ccHtmlLinksOn

\ccTypes
\ccNestedType{iterator}{A mutable random access iterator.}
\ccNestedType{const_iterator}{A const random access iterator.}



\ccCreation
\ccCreationVariable{V}

\ccConstructor{vector();}
             {Introduces an empty vector.}

\ccConstructor{vector(const vector<T> &q);}
 	    {Copy constructor.}

\ccConstructor{vector(int n, const T& t = T() );}
            {Introduces a vector with $n$ items, all initialized to $t$.}


\ccOperations

\ccMethod{vector<T> & operator=(const vector<T> &V1);}
        {Assignment.}


\ccMethod{bool operator==(const vector<T> &V1) const;}
       {Test for equality: Two vectors are equal, iff they have the same size
        and if their corresponding elements are equal.}

\ccMethod{bool operator!=(const vector<T> &V1) const;}
       {Test for inequality.}

\ccMethod{bool operator<(const vector<T> &V1) const;}
       {Test for lexicographically smaller.}


\ccMethod{iterator begin();}
       {Returns a mutable iterator referring to the first element in
        vector~\ccVar.}

\renewcommand{\ccTagRmTrailingConst}{\ccFalse}
\ccMethod{const_iterator begin() const;}
       {Returns a constant iterator referring to the first element in
        vector~\ccVar.}
\renewcommand{\ccTagRmTrailingConst}{\ccTrue}

\ccMethod{iterator end();}
       {Returns a mutable iterator which is the past-end-value of
        vector~\ccVar.}

\renewcommand{\ccTagRmTrailingConst}{\ccFalse}
\ccMethod{const_iterator end() const;}
       {Returns a constant iterator which is the past-end-value of 
        vector~\ccVar.}
\renewcommand{\ccTagRmTrailingConst}{\ccTrue}

\ccMethod{bool empty() const;}
	{Returns \ccStyle{true} if \ccVar\ is empty.}

\ccMethod{int size() const;}
	{Returns the number of items in vector~\ccVar.}

\ccMethod{T& operator[](int pos);}
{Random access operator.}

\ccMethod{const T& operator[](int pos) const;}
{Random access operator.}

\ccMethod{T& front();}
       {Returns a reference to the first item in vector~\ccVar.}

\renewcommand{\ccTagRmTrailingConst}{\ccFalse}
\ccMethod{const T& front() const;}
       {Returns a const reference to the first item in vector~\ccVar.}
\renewcommand{\ccTagRmTrailingConst}{\ccTrue}


\ccMethod{T& back();}
       {Returns a reference to the last item in vector~\ccVar.}

\renewcommand{\ccTagRmTrailingConst}{\ccFalse}
\ccMethod{const T& back() const;}
       {Returns a const reference to the last item in vector~\ccVar.}
\renewcommand{\ccTagRmTrailingConst}{\ccTrue}

\subsubsection*{Insert and Erase}

\ccMethod{void push_back(const T&);}
       {Inserts an item at the back of vector~\ccVar.}

\ccMethod{iterator insert(iterator pos, 
	                             const T& t);}
 {Inserts a copy of \ccStyle{t} in front of iterator \ccStyle{pos}.
  The return value points to the inserted item.}


\ccMethod{void insert(iterator pos,
	                            int n,  const T& t = T());}
 {Inserts $n$ copy of \ccStyle{t} in front of iterator \ccStyle{pos}.}


\ccMethod{void insert(iterator pos,
	            const_iterator first,
	            const_iterator last);}
 {Inserts a copy of the range $\left[\right.$\ccStyle{first}, \ccStyle{last}$\left.\right)$
  in front of iterator \ccStyle{pos}.}

\ccMethod{void pop_back();}
 {Removes the last item from vector~\ccVar.}

\ccMethod{void erase(iterator pos);}
 {Removes the item from vector~\ccVar, where \ccStyle{pos} refers to.}

\ccMethod{void erase(iterator first,
	           iterator last);}
 {Removes the items in the range$\left[\right.$\ccStyle{first}, 
  \ccStyle{last}$\left.\right)$ from vector~\ccVar.}




\end{ccClassTemplate} 
