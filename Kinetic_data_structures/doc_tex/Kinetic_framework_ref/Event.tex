% +------------------------------------------------------------------------+
% | Reference manual page: Event.tex
% +------------------------------------------------------------------------+
% | 20.03.2005   Author
% | Package: Kinetic_data_structures
% | 
\RCSdef{\RCSEventRev}{$Id$}
\RCSdefDate{\RCSEventDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+

\ccDefGlobalScope{CGAL::}
\begin{ccRefConcept}[Kinetic::Simulator::]{Event}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
The concept \ccClassName\ represents a single event. Models of
\ccClassName\ should be passed to the \ccc{Kinetic::Simulator} when
scheduling events which will in turn pass them to the
\ccc{EventQueue}.

\ccCreationVariable{a}  %% choose variable name

\ccOperations

\ccMethod{void process();}{This method is called when the event
  occurs. This method will only be called once per time this event is
  scheduled and the event will be removed from the queue immediately
  afterwards.}

\ccMethod{void* kds();}{Return a \ccc{void *} which represents the KDS
  which this event belongs to. The pointer is used solely to tell if
  two events come from the same KDS for the purposes of handling
  degeneracy.}


\ccMethod{CGAL::Comparison_result perturb_concurrent(Key a, Key b) const;}{The two events \ccc{a} and \ccc{b} occur at the same time (\ccc{this} has key \ccc{a}). This method returns a \ccc{CGAL::Comparison_result} which is used to order the two equal events. If \ccc{CGAL::EQUAL} is returned then \ccc{merge} will be called.}

\ccMethod{bool merge_concurrent(Key a, Key b);}{ The two events \ccc{a} and \ccc{b} occur at the same time (\ccc{this} has key \ccc{a}) and cannot be perturbed to be unequal. This event  allows the KDS to merge event \ccc{b} with \ccc{a}. If it returns \ccc{true} then \ccc{b} is dropped from the event queue.}

%\ccMethod{void degenerate_events(Event_key this_event, Event_key other_event);}{This event and the event referenced by \ccc{k} belong to the same KDS and occur simultaneously. This function call gives the KDS a chance to handle } 

\ccGlobalFunction{std::ostream& operator<<(std::ostream&, Event);}{Write a text description of the event to a standard stream.}

\ccHasModels

All over the place. \ccc{Kinetic::Event_base}.

\ccSeeAlso

\ccc{Kinetic::EventQueue}

\ccExample

All of the kinetic data structures provided have models of
\ccRefName. Here is the code implementing a swap event from the
sorting kinetic data structure. Events occuring at equal times are
perturbed so that the one that occurs first in the list is processed
first (just to illustrate the idea).

\begin{ccExampleCode}
template <class Certificate, class Id, class Root_enumerator> 
class Swap_event {
  typedef Swap_event<class Certificate, class Id, class Root_enumerator> This;
public:
  Swap_event(Id o, Sort* sorter, 
	     const Certificate &s): left_object_(o), 
                                    sorter_(sorter), 
                                    s_(s){}
  void process(){
    sorter_->swap(left_object_, s_);
  }
  void *kds() const {return sorter_;}
  CGAL::Comparison_result perturb_comparison(typename Sort::Event_key a, typename Sort::Event_key b) const {
    return CGAL::compare(std::distance(sorter_->objects_begin(), left_object_),
                         std::distance(sorter_->objects_begin(),
			               sorter_->simulator_handle()->get_event<This>(b).left_object_));
  }
  bool merge(typename Sort::Event_key a, typename Sort::Event_key b) {
    return false;
  }
  Id left_object_; 
  Sort* sorter_; 
  Certificate s_;
};
\end{ccExampleCode}


\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

