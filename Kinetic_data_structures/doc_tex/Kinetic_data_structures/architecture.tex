
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Architecture}
\label{sec:architecture}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

As we have already mentioned, one of the major goals of our package is
to support the development of new kinetic data structures. Below we
discuss in detail each one of the first four major concepts which help
in implementing kinetic data structures: the \ccc{Kinetic::Simulator},
the Kinetic::Kernel, the \ccc{Kinetic::ActiveObjectsTable} and the
\ccc{Kinetic::InstantaneousKernel}.  The \ccc{Kinetic::FunctionKernel}
concept is discussed separately in Section \ref{algebraic_kernel}.

\subsection{The Kinetic::Simulator}
\label{simulator}

The \ccc{Kinetic::Simulator} is the central repository of all active events.
It maintains the event queue and can use its knowledge of the events
in the queue to find times for the kinetic data structures to easily
check their own correctness (this will be discussed in more detail
later in this section). Kinetic data structures call methods of the
Kinetic::Simulator to schedule new events, deschedule old ones and
access and change data contained in already scheduled events (the
operations on existing events are performed using a key which was
returned when the event was scheduled).  For controlling the
simulation, methods in the \ccc{Kinetic::Simulator} allow stepping through
events, advancing time and even running the simulation backwards (that
is we run the simulation with the time running in the opposite
direction).

The kinetic sorting example in Figure~\ref{sec:sort_example} shows the
basic usage of the \ccc{Kinetic::Simulator}. First, the \ccc{Simulator}
is created by the \ccc{Kinetic::SimulatorTraits}. The kinetic data structure
gets a handle to the simulator from the traits class and uses the
handle to add its events to the simulation. The \ccc{Kinetic::Simulator} is
then told to advance time up until the end of the simulation,
processing all events along the way.

Each event is represented by a \ccc{Kinetic::Time} and an instance of a
model of the \ccc{Kinetic::Event} concept.  Models of the \ccc{Kinetic::Event}
concept are responsible for taking the appropriate action in order to
handle the kinetic event they represent.  Specifically, the
Kinetic::Event concept specifies one method,
\ccc{Kinetic::Event::process()}, that is called when the event occurs.
The body of the \ccc{Kinetic::Event::process()} method typically
simply calls a method of the kinetic data structure that created the
event; for example in our kinetic sorting example, processing an event
means calling the \ccc{Kinetic::Sort<Traits, Visitor>::swap(Iterator)}
method of the kinetic sorting data structure.

In the model of the \ccc{Kinetic::Simulator} concept that we provide, any
model of the \ccc{Kinetic::Event} concept can be inserted as an event. This
ability implies that events can be mixed at run time, which is
essential when we want to support multiple kinetic data structures
operating on the same set of moving geometric primitives.

The \ccc{Kinetic::Time} concept is defined by the simulator, typically to be
some representation of a root of a polynomial, taken from the
\ccc{Kinetic::FunctionKernel} (details of the algebraic side of the package
will be discussed in Section~\ref{algebraic_kernel}). For most
kinetic data structures \ccc{Kinetic::Time} only needs to support
comparisons (we need to compare events, in order to process them in
the correct order) and a few other non-arithmetic operations.

When the failure times of certificates are sorted exactly (as opposed
to when we numerically approximate the roots of the certificate
polynomials) the correctness of kinetic data structures can be easily
verified.  Let $I$ be an open interval between the last event
processed and the next event to be processed.  As was mentioned in the
introduction kinetic data structures do not change combinatorially in
$I$. In addition, although the static data structures can be
degenerate at the roots defining the two ends of the interval, they
are not, in general, degenerate in the interior. An independent check
of the integrity of kinetic data structures can be provided by, for
example, using an \ccc{Kinetic::InstantaneousKernel} (cf. Subsection
\ref{instantaneous_kernel}) to rebuild the static version of the
structure from scratch at some time interior to $I$ and compare it to
the kinetic version. This auditing can typically catch algorithmic or
programming errors much closer to the time they arise in the
simulation than, for example, using visual inspection.  Such easy
auditing is one of the powerful advantages of having an exact
computational framework since, as with static data structures, when
using inexact computations differentiating between errors of
implementation and numeric errors is quite tricky.

Kinetic data structures receive alerts of appropriate times to audit
themselves using a notification framework. The same framework is also
used by the \ccc{Kinetic::ActiveObjectsTable} to alert kinetic data
structures when the set of primitives changes (see
Subsection~\ref{active_objects_table}). To use the notification
framework, the kinetic data structure creates a proxy object which
implements a standard Listener interface. It then registers
this proxy with the \ccc{Kinetic::Simulator}. When the \ccc{Kinetic::Simulator}
finds an appropriate time for the kinetic data structures to audit
themselves it calls the function
\ccc{Listener::new_notification(Type)} on each of the registered
proxy objects.  A helper for creating such proxy objects, called
\ccc{Kinetic::Simulator_kds_helper<Listener, KDS>}, is provided by the framework. It
translates the notification into a function call (\ccc{audit()}) on
the kinetic data structure.  Pointers in the notification framework
are reference counted appropriately to avoid issues caused by the
creation and destruction order of kinetic data structures and the
simulator.

Internally the \ccc{Kinetic::Simulator} maintains a priority queue
containing the scheduled events. The type of the priority queue is a
template argument to our \ccc{Kinetic::Simulator} model and, as such, it can
be replaced by the user.  In our package, we provide two different
types of priority queues, a heap and a two-list priority queue.  A
two-list queue is a queue in which there is a sorted front list,
containing all events before some time and an unsorted back list. The
queue tries to maintain a small number of elements in the front list,
leaving most of them in the unsorted main pool. The two-list queue,
although an unconventional choice, is our default queue when using
exact computation because it minimizes comparisons involving events
that are far in the future.  These events are likely to be deleted
before they are processed, so extra work done structuring them is
wasted.  Our experiments have shown that, for example, the two-list
queue causes a 20\% reduction in running time relative to a binary
heap for Delaunay triangulations with degree 3 polynomial motions and
20 points.



\subsection{The Kinetic::Kernel}

The \ccc{Kinetic::Kernel} is structured very much like static CGAL
kernels. It defines a number of primitives, which in the model
provided are \ccc{Kinetic::Kernel::Point_1},
\ccc{Kinetic::Kernel::Point_2}, \ccc{Kinetic::Kernel::Point_3} and
\ccc{Kinetic::Kernel::Weighted_point_3}. The primitives are defined by
a set of Cartesian coordinates each of which is a function of time, a
\ccc{Kernel::MotionFunction}. In addition it defines constructions
and certificate generators which act on the primitives.  The
certificate generators are the direct analog of the non-kinetic
predicates. Each certificate generator take a number of primitives as
arguments, but instead of producing an element from a discrete set
they produce a set of discrete failure times for the certificate.
These failure times are wrapped in a model of \ccc{Kinetic::Certificate}.

A \ccc{Kinetic::Certificate} is a simple object whose primary function is to
produce a \ccc{Kinetic::Time} object representing the failure time of the
certificate.  Since, the handling of most certificate failures
involves creating a new certificate whose certificate function is the
negation of the old certificate function, a \ccc{Kinetic::Certificate}
object caches any work that could be useful to isolate future roots of
the certificate function (such as the Sturm sequence of the
certificate function). To illustrate this further, if you have two
one-dimensional points with coordinate functions $p_0(t)$ and
$p_1(t)$, the certificate that the first moving point is after the
second corresponds to the inequality $p_0(t) - p_1(t) > 0$.  When the
certificate fails and the two points cross, the new certificate is
$p_1(t)- p_0(t) > 0$, which is the negated version of the certificate
just processed and which has the same roots.

The model of \ccc{Kinetic::Kernel} provided includes the certificate
generators necessary for Delaunay triangulations (in one, two and
three dimensions) and regular triangulations (in 3D).  New
certificates can be fairly easily added. An example is included in the
distributed code.



\subsection{The Kinetic::ActiveObjectsTable}
\label{active_objects_table}

The \ccc{Kinetic::ActiveObjectsTable} stores a set of kinetic primitives.
Its purpose is to notify kinetic data structures when new primitives
are added, when primitives are removed or when a trajectories change.
Each primitive is uniquely identified by a Key, assigned by
the table when the primitive is added, that can be used to change or
remove it.  We provide one model of the
Kinetic::ActiveObjectsTable concept, called
\ccc{Kinetic::Active_objects_vector<MovingObject>} which stores all the moving
primitives in an \ccc{std::vector<D>}.

Notifications of changes to the set of active objects are handled
using a setup similar to the \ccc{Kinetic::Simulator} audit time
notification. We provide a helper class,
\ccc{Kinetic::Active_objects_listener_helper<ActiveObjectsTable,
KDS>}, which translates the notifications into \ccc{insert(Key)},
\ccc{erase(Key)} or \ccc{set(Key)} function calls on the kinetic data
structure.



\subsection{The Kinetic::InstantaneousKernel}
\label{instantaneous_kernel}

The \ccc{Kinetic::InstantaneousKernel} allows existing CGAL data structures
to be used on moving data as it appears at some instant of time.
Models of this concept are, by definition, models of a CGAL
Kernel or a traits class, and, therefore, can then be used as
the traits class of CGAL's algorithms and data structures.

Consider for example the kinetic Delaunay data structure in either two
or three dimensions.  Internally, it uses a
\ccc{Delaunay_triangulation_2<Traits, Tds>} or
\ccc{Delaunay_triangulation_3<Traits, Tds>} to represent the
triangulation, instantiated with a model of the
Kinetic::InstantaneousKernel concept as its traits class.  At
initialization, as well as at times during the simulation when we want
to insert a point to the kinetic Delaunay triangulation, a static
version of the Delaunay triangulation is conceptually instantiated.
More precisely, the time for the copy of the model of the
Kinetic::InstantaneousKernel stored in the CGAL triangulation is set
to be the current time (or rather, as discussed in the introduction, a
more convenient time determined by the \ccc{Kinetic::Simulator}
combinatorially equivalent to the current time).  The kinetic data
structure then calls the
\ccc{Delaunay_triangulation_3<Traits, Tds>::insert(Point)} insert
method to insert the point.  The static insert method called uses
various predicate functors on the moving points which evaluate to the
values that the predicates have at that instant in time. Removal is
handled in an analogous manner. Auditing of the geometric structure is
easily handled in a similar manner (in the case of Delaunay
% MK:: is that a verify() method of the KDS or is it the is_valid()
% method of the static Delaunay triangulation?
triangulations by simply calling the \ccc{is_valid()} method after
setting the time).

Internally, in order to evaluate a static predicate, our model of the
Kinetic::InstantaneousKernel computes the current instantaneous
coordinates of the involved primitives and then passes them to a
static predicate. The static primitive coordinates are cached since
they are likely to be involved in other static predicates evaluated at
the same time.


Note that the time used in the \ccc{Kinetic::InstantaneousKernel} must be an
arithmetic type that fully supports ring and possibly field
operations.  These are much more stringent requirements than for
Kinetic::Time objects in the simulator, where we only require
comparisons. These requirements currently rule out our algebraic
kernels' \ccc{Root} objects (see Section \ref{algebraic_kernel}),
since they only support comparisons and some limited arithmetic
operations. In practice this is not a strong limitation since we can
almost always find a time that is representable by a rational number
type (such as \ccc{Gmpq}) which is close to the current time and such
that the combinatorial structure has not changed. Alternatively, if a
real number type such as \ccc{CORE::Expr} is used for time, then
computation can, of course, be performed at any time, although
computations will be significantly slower.
% MK:: I feel something is missing from the following sentence.
It is the job of the \ccc{Kinetic::Simulator} to determine an appropriate
time to perform operations.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Miscellaneous: notification and reference management.}
\label{sec:misc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We describe some coding conventions used, graphical display,
notification and reference management support in the framework in the
following sections.


\subsubsection{Reference management}

A number of objects need to maintain pointers to other independent
objects. For example, each kinetic data structure must have access to
the \ccc{Kinetic::Simulator} so that it can schedule and deschedule events. These
pointers are all reference counted in order to guarantee that they are
always valid. We provide a standard reference counting pointer and
object base to facilitate this, namely \ccc{Ref_counted<Object>}.

Each shared object in the framework defines a type \ccc{Handle} which is the
type for a reference counter pointer pointing to it. These should be
used for storing pointers to the objects in order to avoid dangling
pointers. In addition, many of the objects expect such pointers as
arguments.

\subsubsection{Runtime event passing}

Runtime events must be passed from \textit{notifiers}, namely the
Kinetic::ActiveObjectsTable and the \ccc{Kinetic::Simulator} to the kinetic data
structures to \textit{listeners}, such as a kinetic data structure
which needs to update itself when an event occurs These are passed
using a simple, standardized notification interface. To use
notifications, first defines a small proxy class which inherits from a
Listener base type provided by the notifier. The Listener
base class registers itself with the notifier on construction (and
unregisters itself on destruction).

When the some state of the notifier changes it, it calls the
\ccc{new_notification} method on the proxy object provided and passes
it a label corresponding to the name of the field that changed. The
proxy object can then call an appropriate method on the kinetic data
structure or other listening class.

In order to unregister on destruction, the Listener must store a
(reference counted) pointer to the object providing
notifications. This pointer can be accessed through the \ccc{notifier()}
field. The Listener object stores a reference counted pointer to
the notifying object, while the notifying object stores a plain
pointer to the Listener. It can do this since the Listener
is guaranteed to unregister itself when it is destroyed. This avoids
circular reference counted pointers.

\section{Algebraic Kernel}
\label{algebraic_kernel}

The interface between the algebraic kernel and the kinetic data
structures package was kept quite minimal in order to ease the
implementation of various underlying computation models. The interface
is detailed in the reference page (\ccc{Kinetic::FunctionKernel}).

We provide models of the algebraic kernel that handle polynomial
Kinetic::Function objects. The provided models perform
\begin{itemize}
\item exact computations using Sturm sequences to isolate roots
\item exact computations using Descartes rule of sign in order to
isolate roots (Sturm sequences are also used in order to properly
handle even multiplicity roots)
\item filtered exact computations using Descartes rule of sign
\item numeric (inexact) root approximations
\item numeric root approximations which take advantage of certain
assumptions that can be made about the types of polynomials solved in
the process of evaluating kinetic data structures
\item a wrapper for CORE::Expr which implements the required
  concepts.
\end{itemize}
The exact models, which we implement the numerics for, handle
non-square-free polynomials and polynomials with arbitrary field
number type coefficients and are quite robust.


\subsection{Kinetic::FunctionKernel customized for kinetic data structures}

There are several modifications we can make to the root isolation
algorithms to optimize them for the case of kinetic data structures.
The first question is how to handle degeneracies (certificate
functions which have roots at the same time).  Naively, there is no
way to differentiate between a certificate which fails immediately
when it is created and one whose function is momentarily 0, but will
be valid immediately in the future. In order to handle such
degeneracies we ensure that all the certificate function generators
produce certificate functions which are positive when the
corresponding certificates are valid.  Then, if we have a degeneracy
we can differentiate between a certificate which fails immediately and
one which is simply degenerate by looking at the sign of the
certificate function immediately following the root. In addition, this
allows us, under the assumption that computations are performed
exactly, to check that all certificates are valid upon creation.

This assumption is particular useful when using numeric solvers.
Without it there is no reliable way to tell whether a root near the
current time is the certificate having become valid just before the
current time, or failing shortly in the future. Testing the sign of
the function immediately after the root reliably disambiguates the two
cases.

In addition, we have to specially handle even roots of functions. For
the most part these can just be discarded as that is equivalent to
perturbing the simulation to remove the degeneracy. However, when we
are using the \ccc{Kinetic::Simulator} to audit the kinetic data structures,
they most be broken up in to two, equal, roots to avoid auditing at
the degeneracy.
