% +------------------------------------------------------------------------+
% | Reference manual page: Listener.tex
% +------------------------------------------------------------------------+
% | 21.03.2005   Author
% | Package: Support
% | 
\RCSdef{\RCSListenerRev}{$Id$}
\RCSdefDate{\RCSListenerDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Listener<Interface>}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition
 
The \ccRefName\ class provides the core of the run time notification
system used by the kinetic data structures package. In short,
notifications are handled through proxy objects called listeners. In
order to listen for notifications from an object, called the notifier,
you make define a small class called a listener proxy, which inherits
from the Listener interface defined by the notifier. When constructing
your listner poxy, you pass a reference counted pointer to the
notifier, which is used to register the proxy for notifications. When
a notification occurs, the notifier calls the \ccc{new_notification}
method on the proxy, passing the type of the notification. The proxy
stores a reference counted pointer to the notifier, ensuring that
there are never any dangling pointers in the system.

The class \ccRefName\ provides base class for listener proxy
objects. An notifier should provide class which uses this base. To use
this base class, implement a class, here called Interface, which
defines a type \ccc{Interface::Notification_type} and a type
\ccc{Interface::Notifier_handle}.

The \ccc{Notification_type} is generally an enum with one value for
each type of notification which can be used.

The \ccc{Notifier_handle} is the type of a (ref counted) pointer to
the object providing the notifications. The ref counter pointer must
provide a nested type \ccc{Pointer} which is the type of a raw
pointer.

The \ccRefName\ maintains a ref counted pointer to the object
performing notifications. It is registered for notifications on
construction and unregistered on destruction using the function
\ccc{set_listener} on the object providing the notifications. The use
of ref counted pointers means that as long as the notification object
exists, the object providing the notifications must exist, ensuring
that the object providing the notifications is not prematurely
destroyed.

These objects cannot be copied since the notifier only support one
listener.

Boost provides a similar functionality in the Boost.Signal
package. However, it is quite a bit more complex (and flexible). This
complexity add significantly to compile time and (although I did not
test this directly), I suspect it is much slower at runtime due to the
overhead of worrying about signal orders and not supporting single
signals. In addition, it does not get on well with Qt due to
collisions with the Qt moc keywords.

There is also the TinyTL library which implements signals. As of
writing it did not have any easy support for making sure all pointers
are valid, so it did not seem to offer significant code saving over
writing my own.

\ccInclude{CGAL/Kinetic/Listener.h}

\ccTypes

\ccNestedType{Notifier_handle}{This type is inherited from the \ccc{Interface} template argument. It is a reference counted pointer type for the object providing notifications.}

\ccNestedType{Notification_type}{The type (usually an enum) used to distinguish different types of notifications. This is inherited from the \ccc{Interface} template argument.}

\ccCreation
\ccCreationVariable{l}  %% choose variable name

\ccConstructor{Listener(Notifier_handle np);}{The \ccRefName\ subscribes to events coming from the notifier and stores a pointer to the notifier.}

\ccOperations

\ccMethod{Notifier_handle notifier();}{Return a pointer to the notifier.}

\ccMethod{virtual void new_notification(Notification_type);}{This method is pure virtual. A class which wishes to receive events must inherit from this class and implement this method. The method will then be called whenever there is a notification.}

\ccSeeAlso

\ccc{Multi_listener<Interface>}.

\ccExample

\ccIncludeExampleCode{Kinetic_data_structures/listener.C}


\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

