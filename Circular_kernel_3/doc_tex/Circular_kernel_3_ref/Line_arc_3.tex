\begin{ccRefClass}{Line_arc_3<SphericalKernel>}

\ccInclude{CGAL/Line_arc_3.h}

\ccIsModel

\ccc{SphericalKernel::LineArc_3}

\ccCreation
\ccCreationVariable{la}

\ccThree{Circular_arc_point_3}{ca.is_x_monotone()}{}
\ccThreeToTwo

\ccConstructor{Line_arc_3(const SphericalKernel::Line_3 &l,
		const SphericalKernel::Circular_arc_point_3 &p1,
		const SphericalKernel::Circular_arc_point_3 &p2)}
{Construct the line segment supported by \ccc{l}, whose source 
is \ccc{p1}, and whose target is \ccc{p2}.
\ccPrecond{\ccc{p1} and \ccc{p2} lie on \ccc{l}. 
\ccc{p1} and \ccc{p2} are different.}}

\ccConstructor{Line_arc_3(const SphericalKernel::Line_3 &l,
		const SphericalKernel::Point_3 &p1,
		const SphericalKernel::Point_3 &p2)}
{Same.}

\ccConstructor{Line_arc_3(const SphericalKernel::Segment_3 &s)}
{}

\ccAccessFunctions

\ccThree{SphericalKernel::Circular_arc_point_3}{ca.is_x_monotone()}{}
\ccThreeToTwo

\ccMethod{SphericalKernel::Line_3 supporting_line();}{}

\ccMethod{SphericalKernel::Circular_arc_point_3 source();}{}
\ccGlue
\ccMethod{SphericalKernel::Circular_arc_point_3 target();}{}

\ccMethod{SphericalKernel::Circular_arc_point_3 min();}
{Constructs the minimum vertex according to the lexicographic ordering 
of coordinates.} 
\ccGlue
\ccMethod{SphericalKernel::Circular_arc_point_3 max();}
{Same for the maximum vertex.}

\ccQueryFunctions

\ccMethod{bool is_vertical();}{Returns true \ccc{iff} the segment is vertical.}

\ccHeading{I/O}

\ccFunction{istream& operator>> (std::istream& is, Line_arc_3 & ca);}{}
\ccGlue
\ccFunction{ostream& operator<< (std::ostream& os, const Line_arc_3 & ca);}{}

The format for input/output is, for each line arc: a \ccc{Line_3} 
(the supporting line) and two \ccc{Circular_arc_point_3} (the two endpoints), 
under the condition that the endpoints are actually lying on the line.

\ccSeeAlso

\ccRefIdfierPage{CGAL::Circular_arc_point_3<SphericalKernel>}\\
\ccRefIdfierPage{CGAL::Circular_arc_3<SphericalKernel>}

\end{ccRefClass}

