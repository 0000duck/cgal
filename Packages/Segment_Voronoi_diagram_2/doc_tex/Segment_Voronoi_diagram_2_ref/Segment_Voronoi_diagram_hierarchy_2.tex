%% Copyright (c) 2003,2004  INRIA Sophia-Antipolis (France) and
%% Notre Dame University (U.S.A.).  All rights reserved.
%%
%% This file is part of CGAL (www.cgal.org); you may redistribute it under
%% the terms of the Q Public License version 1.0.
%% See the file LICENSE.QPL distributed with CGAL.
%%
%% Licensees holding a valid commercial license may use this file in
%% accordance with the commercial license agreement provided with the software.
%%
%% This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
%% WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
%%
%% $Source$
%% $Revision$ $Date$
%% $Name$
%%
%% Author(s)     : Menelaos Karavelas <mkaravel@cse.nd.edu>



\begin{ccRefClass}{Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>}
%% add template arg's if necessary

{\sc I have to modify this when I add the boolean about whether or not
  points are to be inserted in the upper levels of the hierarchy or
  not.}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries
\ccDefinition

We provide an alternative to the class
\ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} for the incremental
construction of the segment Voronoi diagram. The \ccRefName\ class
maintains a hierarchy of segment Voronoi diagram graphs. The
bottom-most level of the hierarchy contains the full segment Voronoi
diagram. A site that is in level $i$, is in level $i+1$ with
probability $1/\alpha$ where $\alpha > 1$ is some constant. The
difference between the \ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class
and the \ccRefName\ is on how the nearest neighbor location is
done. Given a point $p$ the location is done as follows: at the top
most level we find the nearest neighbor of $p$ as in the
\ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class. At every subsequent
level $i$ we use the nearest neighbor found at level $i+1$ to find the
nearest neighbor at level $i$. This is a variant of the corresponding
hierarchy for points found in \cite{d-iirdt-98}. The details are
described in \cite{k-peasv-04}.
%
The class has three template parameters which have essentially the same
meaning as in the \ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class. The
first template parameter must be a model of the
\ccc{SegmentVoronoiDiagramTraits_2} concept.
The second template parameter must be a model of the
\ccc{SimpleContainer} concept. The third template parameter must be a
model of the \ccc{SegmentVoronoiDiagramDataStructure_2}
concept. However, the vertex base class that is to be used in the
segment Voronoi diagram data structure must
be a model of the \ccc{SegmentVoronoiDiagramHierarchyVertexBase_2}
concept. The second template parameter defaults to
\ccc{CGAL::Simple_container<typename Gt::Point_2>}, whereas the third
template parameter defaults to
\ccc{Segment_Voronoi_diagram_data_structure_2<
Segment_Voronoi_diagram_hierarchy_vertex_base_2< 
Segment_Voronoi_diagram_vertex_base_2<Gt> >,
Segment_Voronoi_diagram_face_base_2<Gt> >}. 

The \ccRefName\ class derives publicly from the
\ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class. The interface is
the same with its base class. In the sequel only the methods
overridden are documented.


\ccInclude{CGAL/Segment_Voronoi_diagram_hierarchy_2.h}



\ccInheritsFrom
\ccc{CGAL::Segment_Voronoi_diagram_2<Gt,PC,DS>}


\ccTypes
\ccRefName\ introduces the following types in addition to those
introduced by its base class
\ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>}.

\ccThree{typedef CGAL::Segment_Voronoi_diagram_2<Gt,PC,DS>}{Base+}{}
\ccThreeToTwo
\ccTypedef{typedef STag Segments_in_hierarchy_tag;}{A type for the
  \ccc{STag} template parameter.}
\ccGlue
\ccTypedef{typedef CGAL::Segment_Voronoi_diagram_2<Gt,PC,DS> Base;}
	  {A type for the base class.}

\ccCreation
\ccCreationVariable{svdh}
%
\ccThree{Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>}
{svdh(Gt gt=Gt());}{}
\ccThreeToTwo
\ccTwo{Segment_Voronoi_diagram_hierarchy}{}
%
\ccConstructor{Segment_Voronoi_diagram_hierarchy_2(Gt
gt=Gt())}{Creates an hierarchy of segment Voronoi diagrams using
  \ccc{gt} as geometric traits.}
%
\ccGlue
\ccConstructor{template< class Input_iterator >
Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>(Input_iterator
first, Input_iterator beyond, Gt gt=Gt())}
{Creates a segment Voronoi diagram hierarchy using 
\ccc{gt} as geometric traits and inserts all sites in the
range [\ccc{first}, \ccc{beyond}).
\ccPrecond{\ccc{Input_iterator} must be a model of
  \ccc{InputIterator}. The value type of \ccc{Input_iterator} must be
    either \ccc{Point_2} or \ccc{Site_2}}.}
%
\ccGlue
\ccConstructor{Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>
(Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS> other)}
{Copy constructor. All faces, vertices and inter-level pointers
are duplicated. After the construction, \ccVar\ and \ccc{other} refer
to two different hierarchies: if \ccc{other} is modified, \ccVar\ is
not.}
%
\ccThree{Segment_Voronoi_diagram_hierarchy<Gt,STag,PC,DS>++}{svdh = other;}{}
\ccThreeToTwo
\ccGlue
\ccMethod{Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>
operator=(Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>
other);}{Assignment. All faces, vertices and inter-level pointers
are duplicated. After the construction, \ccVar\ and \ccc{other} refer
to two different hierarchies: if \ccc{other} is modified, \ccVar\ is
not.}



\ccHeading{Insertion}
\ccThree{Vertex_handle }{svdh.insert(Point_2 p)+}{}
%
{\sc In the following method I can insert the number of sites inserted
  in the diagram. Also I must add the possibility of shuffling.}
\ccMethod{template< class Input_iterator >
size_type insert(Input_iterator first, Input_iterator beyond);}
{Inserts the sites in the range
[\ccc{first},\ccc{beyond}). The number of sites in the range
  [\ccc{first}, \ccc{beyond}) is returned.
\ccPrecond{\ccc{Input_iterator} must be a model of \ccc{InputIterator}
  and its value type must be \ccc{Point_2} or \ccc{Site_2}.}}
%
\ccGlue
\ccMethod{Vertex_handle  insert(Point_2 p);}{Inserts the
point \ccc{p} in the segment Voronoi diagram hierarchy. If \ccc{p} has
already been inserted, then the vertex handle of its already inserted
copy is returned. If \ccc{p} has not been inserted yet, the vertex
handle of \ccc{p} is returned.}
%
\ccGlue
\ccMethod{Vertex_handle  insert(Point_2 p1, Point_2 p2);}{Inserts the
  closed segment with endpoints \ccc{p1} and \ccc{p2} in the segment
  Voronoi diagram hierarchy. If the segment has already been inserted
  in the diagram then the vertex handle of its already inserted copy
  is returned. If the segment does not intersect any segment in the
  existing diagram, the vertex handle corresponding to its
  corresponding open segment is returned. Finally, if the segment
  intersects other segments in the existing Voronoi diagram, the
  vertex handle to one of its open subsegments is returned.}
%
\ccGlue
\ccMethod{Vertex_handle insert(Point_2 p, Vertex_handle vnear);}
{A call to this method is equivalent to \ccc{svdh.insert(p);} and it
has been added for the sake of conformity with the interface of the
\ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class.}
%
\ccGlue
\ccMethod{Vertex_handle insert(Point_2 p1, Point_2 p2, Vertex_handle
  vnear);}{A call to this method is equivalent to
  \ccc{svdh.insert(p1, p2);} and it has been added for the sake of
  conformity with the interface of the
  \ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class.}
%\ccGlue
%\ccMethod{Vertex_handle insert(Site_2 s, Vertex_handle
%vnear);}{Inserts \ccc{s} in the Apollonius graph hierarchy using the
%site associated with \ccc{vnear} as
%an estimate for the nearest neighbor of the center of \ccc{s}.
%If \ccc{s} is visible then the vertex handle of \ccc{s} is
%returned, otherwise \ccc{Vertex_handle(NULL)} is returned.
%A call to this method is equivalent to \ccc{agh.insert(s);} and it has
%been added for the sake of conformity with the interface of the
%\ccc{Apollonius_graph_2<Gt,Agds>} class.}

%\ccHeading{Removal}
%\ccThree{void }{agh.remove(Vertex_handle v)+}{}
%%
%\ccMethod{void  remove(Vertex_handle v);}{Removes the site
%associated to the vertex handle \ccc{v} from the Apollonius
%graph hierarchy.
%\ccPrecond{\ccc{v} must correspond to a valid finite
%vertex of the Apollonius graph hierarchy.}}


\ccHeading{Nearest neighbor location}
\ccThree{Vertex_handle}{svdh.nearest_neighbor(Point_2 p)+}{}
%
\ccMethod{Vertex_handle  nearest_neighbor(Point_2 p);}
{Finds the nearest neighbor of the point \ccc{p}. In other words it
finds the site (point or open segment) whose Voronoi cell contains
\ccc{p}. Ties are broken arbitrarily and one of the nearest neighbors
of \ccc{p} is returned. If there are no sites in the
segment Voronoi diagram \ccc{Vertex_handle()} is returned.}
%
\ccGlue
\ccMethod{Vertex_handle  nearest_neighbor(Point_2 p,
Vertex_handle vnear);}{Finds the nearest neighbor of the point
\ccc{p}. If there are no visible sites in the segment Voronoi diagram
\ccc{Vertex_handle()} is returned.
A call to this method is equivalent to 
\ccc{svdh.nearest_neighbor(p);} and it has been added for the sake of
conformity with the interface of the
\ccc{Segment_Voronoi_diagram_2<Gt,PC,DS>} class.}



\ccHeading{Validity check}
\ccThree{bool}{svdh.is_valid;}{}
%
\ccMethod{bool is_valid(bool verbose = false, int level = 1) const;}
{Checks the validity of the segment Voronoi diagram hierarchy. If
\ccc{verbose} is \ccc{true} a short message is sent to
\ccc{std::cerr}. If \ccc{level} is 0, the data structure at all levels 
is validated, as well as the inter-level pointers. If \ccc{level} is
1, then the data structure at all levels is validated, the inter-level
pointers are validated and all levels of the segment Voronoi diagram
hierarchy are also validated. Negative values of \ccc{level} always
return \ccc{true}, and values greater then 1 are equivalent to
\ccc{level} being 1.}

\ccHeading{Miscellaneous}
\ccThree{void}{svdh.swap(other)+}{}
%
\ccMethod{void clear();}{Clears all contents of the segment Voronoi
  diagram hierarchy.}
\ccGlue
% MK:: add this method make copy(...) protected and see doc of TDS
\ccMethod{void swap(Segment_Voronoi_diagram_hierarchy_2<Gt,STag,PC,DS>
other);}
{The segment Voronoi diagram hierarchies \ccc{other} and \ccVar\ are
swapped. \ccVar.\ccc{swap(other)} should be preferred to \ccVar\ccc{ =
other} or to \ccVar\ccc{(other)} if \ccc{other} is deleted afterwards.}


\ccSeeAlso
\ccc{SegmentVoronoiDiagramDataStructure_2}\\
\ccc{SegmentVoronoiDiagramTraits_2}\\
\ccc{SegmentVoronoiDiagramHierarchyVertexBase_2}\\
\ccc{SimpleContainer}\\
\ccc{CGAL::Segment_Voronoi_diagram_2<Gt,PC,DS>}\\
\ccc{CGAL::Segment_Voronoi_diagram_data_structure_2<Vb,Fb>}\\
\ccc{CGAL::Segment_Voronoi_diagram_traits_2<ITag,K,MTag>}\\
\ccc{CGAL::Segment_Voronoi_diagram_filtered_traits_2<ITag,CK,CM,EK,EM,FK,FM>}\\
\ccc{CGAL::Segment_Voronoi_diagram_hierarchy_vertex_base_2<Vbb>}


\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+
