% +------------------------------------------------------------------------+
% | Reference manual page: Segment_Voronoi_diagram_2.tex
% +------------------------------------------------------------------------+
% | 12.04.2000   Author
% | Package: Package
% | 
%\RCSdef{\RCSRegulartriangulationtraitsRev}{$Revision$}
%\RCSdefDate{\RCSRegulartriangulationtraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Segment_Voronoi_diagram_2<Gt,SC,DS>}
%% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries
\ccCreationVariable{traits}
\ccDefinition

The class \ccRefName\ represents the dual of the segment Voronoi
diagram. Currently it supports only insertions of sites.
%and deletions of sites.
It is templated by three template arguments \ccc{Gt}, which
must be a model of \ccc{SegmentVoronoiDiagramTraits_2}, 
\ccc{SC} which must be a model of the concept \ccc{SimpleContainer},
and \ccc{DS},
which must be a model of \ccc{SegmentVoronoiDiagramDataStructure_2}.
The second template argument defaults to
\ccc{CGAL::Simple_container<typename Gt::Point_2>}, whereas
the third template argument defaults to
\ccc{CGAL::Segment_Voronoi_diagram_data_structure_2< 
CGAL::Segment_Voronoi_diagram_vertex_base_2<Gt>,
CGAL::Segment_Voronoi_diagram_face_base_2<Gt> >}.

\ccInclude{CGAL/Segment_Voronoi_diagram_2.h}

\ccTypes

\ccThree{typedef typename DS::size_type}{Point_container+}{}
%
\ccTypedef{typedef DS  Data_structure;}{A type for the underlying
data structure.}
\ccGlue
\ccTypedef{typedef typename DS::size_type size_type;}{Size type (an
  unsigned integral type)}
\ccGlue
\ccTypedef{typedef SC Point_container;}{A type for the container of points.}
\ccGlue
\ccTypedef{typedef Gt Geom_traits;}{A type for the geometric traits.}
\ccGlue
\ccTypedef{typedef Gt::Point_2 Point_2;}{A type for the
point defined in the geometric traits.}
\ccGlue
\ccTypedef{typedef Gt::Segment_2 Segment_2;}{A type for the
segment defined in the geometric traits.}
\ccGlue
\ccTypedef{typedef Gt::Site_2  Site_2;}
{A type for the segment Voronoi diagram site, defined in the geometric
  traits.}
\ccGlue
%

% MK:: in the following copy text from TDS

The vertices and faces of the dual of the segment Voronoi diagram are
accessed through \ccc{handles}, 
\ccc{iterators} and \ccc{circulators}. 
The iterators and circulators
are all bidirectional and non-mutable.
The circulators and iterators are assignable to the 
corresponding handle types, and they are also convertible to the
corresponding handles.
The edges of the dual of the segment Voronoi diagram can also be
visited through iterators and circulators,
the edge circulators and iterators
are also bidirectional and non-mutable.
In the following, we call {\it infinite} any face or edge 
incident  to the infinite vertex and the infinite vertex itself.
Any other feature (face, edge or vertex) of the dual of the segment
Voronoi diagram is said to be {\it finite}.
Some iterators (the \ccc{All} iterators ) allow to visit finite or 
infinite features while the others (the \ccc{Finite} iterators) visit only
finite features. Circulators visit both infinite and finite features.

\ccThree{typedef std::pair<Face_handle, int>}{}{the apollonius graph,
the apollonius graph, the graph}
%\ccThreeToTwo
%
% MK:: change the edge definition as follows?
\ccTypedef{typedef std::pair<Face_handle, int> Edge;} {the edge type.
The \ccc{Edge(f,i)} is the edge common to faces \ccc{f} and 
\ccc{f.neighbor(i)}. It is also the edge joining the vertices
\ccc{vertex(cw(i))} and \ccc{vertex(ccw(i))} of \ccc{f}.
\ccPrecond{\ccc{i} must be \ccc{0}, \ccc{1} or \ccc{2}.}
}
%
\ccTwo{Semgent_Voronoi_diagram_2<Gt,SC,DS>::Finite_vertices_iterator+}
{}
%
\ccGlue
\ccNestedType{Vertex_handle}{A type for a handle to a vertex.}
\ccGlue
\ccNestedType{Face_handle}{A type for a handle to a face.}
\ccGlue
\ccNestedType{Vertex_circulator}
{A type for a circulator over vertices incident to a given vertex.}
\ccGlue
\ccNestedType{Face_circulator}
{A type for a circulator over faces incident to a given vertex.}
\ccGlue
\ccNestedType{Edge_circulator}
{A type for a circulator over edges incident to a given vertex.}
\ccGlue
\ccNestedType{All_vertices_iterator}
{A type for an iterator over all vertices.}
\ccGlue
\ccNestedType{Finite_vertices_iterator}
{A type for an iterator over finite vertices.}
\ccGlue
\ccNestedType{All_faces_iterator}
{A type for an iterator over all faces.}
\ccGlue
\ccNestedType{Finite_faces_iterator}
{A type for an iterator over finite faces.}
\ccGlue
\ccNestedType{All_edges_iterator}
{A type for an iterator over all edges.}
\ccGlue
\ccNestedType{Finite_edges_iterator}
{A type for an iterator over finite edges.}


In addition to iterators and circulators for vertices and faces,
iterators for sites are provided. In particular there are iterators
for the entire set of sites, the hidden sites and the visible sites of
the Apollonius graph.


%\ccGlue
\ccNestedType{Sites_iterator}
{A type for an iterator over all sites.}
\ccGlue
\ccNestedType{Visible_sites_iterator}
{A type for an iterator over all visible sites.}
\ccGlue
\ccNestedType{Hidden_sites_iterator}
{A type for an iterator over all hidden sites.}

\ccCreationVariable{svd}

\ccCreation
\ccThree{Segment_Voronoi_diagram_2<Gt,SC,DS>}{svd = other other}{}
\ccThreeToTwo
%
\ccConstructor{Segment_Voronoi_diagram_2(Gt gt=Gt());}{Creates the
  dual of the segment Voronoi diagram using \ccc{gt} as geometric
  traits.}
%
\ccConstructor{template< class Input_iterator >
Segment_Voronoi_diagram_2(Input_iterator first, Input_iterator beyond,
Gt gt=Gt());}
{Creates the dual of the segment Voronoi diagram using \ccc{gt} as
geometric traits and inserts all sites in the range
[\ccc{first}, \ccc{beyond}).
\ccPrecond{\ccc{Input_iterator} must be a model of
\ccc{InputIterator}. The value type of
\ccc{Input_iterator} must be either \ccc{Point_2} or \ccc{Site_2}.}}
%
\ccConstructor{Segment_Voronoi_diagram_2(const
  Segment_Voronoi_diagram_2<Gt,SC,DS>& other)}
{Copy constructor. All faces and vertices are duplicated. After the
  construction, 
  \ccVar\ and \ccc{other} refer to two different segment Voronoi diagrams~: if
  \ccc{other} is modified, \ccVar\ is not.}
%
\ccMethod{Segment_Voronoi_diagram_2<Gt,SC,DS>
operator=(const Segment_Voronoi_diagram_2<Gt,SC,DS>& other);}
{Assignment. If \ccc{svd} and \ccc{other} are the same object
  nothing is done. Otherwise, all the vertices and faces are
  duplicated. After the assignment, \ccVar\ and \ccc{other} refer to
  different segment Voronoi diagrams~: if \ccc{other} is modified,
  \ccVar\ is not.}




\ccAccessFunctions
% MK:: in the following copy text from TDS
\ccThree{Point_container}{svd.number_of_vertices()+}{}
%
\ccMethod{Geom_traits geom_traits();}
{Returns a reference to the segment Voronoi diagram traits object.}
\ccGlue
\ccMethod{int dimension();}
{Returns the dimension of the segment Voronoi diagram.}
\ccGlue
\ccMethod{size_type number_of_vertices();}
{Returns the number of finite vertices of the dual of the segment
  Voronoi diagram.}
\ccGlue
\ccMethod{size_type number_of_faces();}
{Returns the number of faces (both finite and infinite) of the
  dual of the segment Voronoi diagram.}
\ccGlue
\ccMethod{Face_handle infinite_face();}
{Returns a face incident to the \ccc{infinite_vertex}.}
\ccGlue
\ccMethod{Vertex_handle
          infinite_vertex();}
{Returns the \ccc{infinite_vertex}.}
\ccGlue
\ccMethod{Vertex_handle finite_vertex();}
{Returns a vertex distinct from  the \ccc{infinite_vertex}.
\ccPrecond{The number of (visible) vertices in the Apollonius graph must
  be at least one.}}
\ccGlue
\ccMethod{Data_structure data_structure();}{Returns the data structure.}
\ccGlue
\ccMethod{Point_container point_container();}{Returns the point container.}


\ccHeading{Traversal of the dual of the segment Voronoi diagram}


An Apollonius graph can be seen as a container of faces and vertices.
Therefore the Apollonius graph provides several iterators and circulators
that allow to traverse it (completely or partially).



\ccHeading{Face, Edge and Vertex Iterators}

\ccThree{Finite_vertices_iterator}{svd.finite_vertices_begin()+}{}

The following iterators allow respectively to visit 
finite faces,  finite edges and  finite vertices of the dual of the
segment Voronoi diagram. These iterators are non-mutable,
bidirectional and their value types are respectively
\ccc{Face}, \ccc{Edge} and \ccc{Vertex}. 
They are all invalidated by any change in the segment Voronoi diagram.

\ccMethod{Finite_vertices_iterator finite_vertices_begin();}
{Starts at an arbitrary finite vertex.}
\ccGlue
\ccMethod{Finite_vertices_iterator finite_vertices_end();}
{Past-the-end iterator.}

\ccMethod{Finite_edges_iterator finite_edges_begin();}
{Starts at an arbitrary finite edge.}
\ccGlue
\ccMethod{Finite_edges_iterator finite_edges_end();}
{Past-the-end iterator.}

\ccMethod{Finite_faces_iterator finite_faces_begin();}
{Starts at an arbitrary finite face.}
\ccGlue
\ccMethod{Finite_faces_iterator finite_faces_end()
const;}{Past-the-end iterator.}

The following iterators allow respectively to visit all
(both finite and infinite) faces, edges and vertices
of the dual of the segment Voronoi diagram. These iterators are
non-mutable, bidirectional and their value types are respectively
\ccc{Face}, \ccc{Edge} and \ccc{Vertex}. 
They are all invalidated by any change in the segment Voronoi diagram.


\ccMethod{All_vertices_iterator all_vertices_begin();}
{Starts at an arbitrary  vertex.}
\ccGlue
\ccMethod{All_vertices_iterator all_vertices_end();}
{Past-the-end iterator.}

\ccMethod{All_edges_iterator all_edges_begin();}
{Starts at an arbitrary edge.}
\ccGlue
\ccMethod{All_edges_iterator all_edges_end();}
{Past-the-end iterator.}

\ccMethod{All_faces_iterator all_faces_begin();}
{Starts at an arbitrary face.}
\ccGlue
\ccMethod{All_faces_iterator all_faces_end();}
{Past-the-end iterator.}



\ccHeading{Site iterators}

The following iterators allow respectively to visit 
all sites. These iterators are non-mutable, bidirectional and their
value type is \ccc{Site_2}. They are all invalidated by any change in
the segment Voronoi diagram.


\ccMethod{Sites_iterator sites_begin();}
{Starts at an arbitrary site.}
\ccGlue
\ccMethod{Sites_iterator sites_end();}
{Past-the-end iterator.}


\ccThree{Vertex_circulator}{t.number_of_vertices()x}{}
\ccThreeToTwo



\ccHeading{Face, Edge and Vertex Circulators}

The \ccRefName\ class also provides
circulators that allow to visit
respectively all faces or edges incident to a given vertex
or all vertices adjacent to a given vertex.
These circulators are non-mutable and bidirectional.
The operator \ccc{operator++} moves the circulator
counterclockwise around the vertex while
the \ccc{operator--} moves clockwise.
A face circulator is invalidated by any modification of the face
pointed to.
An edge circulator is invalidated by any modification
in one of the two faces incident to the edge pointed to.
A vertex circulator is invalidated by any modification
in any of the faces adjacent to the vertex pointed to.

\ccMethod{Face_circulator incident_faces(Vertex_handle v);}
{Starts at an arbitrary face incident
to \ccc{v}.}
\ccGlue
\ccMethod{Face_circulator incident_faces(Vertex_handle v, Face_handle f);}
{Starts at face \ccc{f}.
\ccPrecond Face \ccc{f} is incident to vertex \ccc{v}.}
\ccGlue
\ccMethod{Edge_circulator incident_edges(Vertex_handle v);}
{Starts at an arbitrary edge incident
to \ccc{v}.}
\ccGlue
\ccMethod{Edge_circulator incident_edges(Vertex_handle v, Face_handle f);}
{Starts at the first edge of \ccc{f} incident to 
\ccc{v}, in counterclockwise order around \ccc{v}.
\ccPrecond Face \ccc{f} is incident to vertex \ccc{v}.}
\ccGlue
\ccMethod{Vertex_circulator incident_vertices(Vertex_handle v);}
{Starts at an arbitrary  vertex incident
to \ccc{v}.}
\ccGlue
\ccMethod{Vertex_circulator incident_vertices(Vertex_handle v, Face_handle f);}
{Starts at the first vertex of \ccc{f} adjacent  to \ccc{v}
in  counterclockwise order around \ccc{v}.
\ccPrecond Face \ccc{f} is incident to vertex \ccc{v}.}



\ccHeading{Traversal of the Convex Hull}

Applied on the \ccc{infinite_vertex}
the above  functions  allow to visit the vertices on the convex hull and
the infinite edges and faces. Note that a counterclockwise
traversal of the vertices adjacent to the \ccc{infinite_vertex} is
a clockwise traversal of the convex hull.

\ccMethod{Vertex_circulator incident_vertices(svd.infinite_vertex());}{}
\ccGlue
\ccMethod{Vertex_circulator incident_vertices(svd.infinite_vertex(),
  Face_handle f);}{}
\ccGlue
\ccMethod{Face_circulator incident_faces(svd.infinite_vertex());}{}
\ccGlue
\ccMethod{Face_circulator incident_faces(svd.infinite_vertex(),
  Face_handle f);}{}
\ccGlue
\ccMethod{Edge_circulator incident_edges(svd.infinite_vertex());}{}
\ccGlue
\ccMethod{Edge_circulator incident_edges(svd.infinite_vertex(),
  Face_handle f);}{}




\ccPredicates
The class \ccRefName\ provides methods to test
the finite or infinite character of any feature.
\ccThree{bool }{svd.is_infinite( Face_handle f, int i)x}{}

%
\ccMethod{bool
          is_infinite(Vertex_handle v) const;}
{\ccc{true}, iff \ccc{v} is the \ccc{infinite_vertex}.}
\ccGlue
\ccMethod{bool
          is_infinite(Face_handle f) const;}
{\ccc{true}, iff face \ccc{f} is infinite.}
\ccGlue
\ccMethod{bool is_infinite(Face_handle f, int i) const;}
{\ccc{true}, iff edge \ccc{(f,i)} is infinite.}
\ccGlue
\ccMethod{bool
          is_infinite(Edge e) const;}
{\ccc{true}, iff edge \ccc{e} is infinite.}
\ccGlue
\ccMethod{bool
          is_infinite(Edge_circulator ec) const;}
{\ccc{true}, iff edge \ccc{*ec} is infinite.}



\ccHeading{Insertion}
\ccThree{Vertex_handle }{svd.insert(Point_2 s)+}{}
%

\ccMethod{template< class Input_iterator >
size_type insert(Input_iterator first, Input_iterator beyond);}
{Inserts the sites in the range
[\ccc{first},\ccc{beyond}). The number of sites in the range
  [\ccc{first}, \ccc{beyond}) is returned.
% MK:: Implement this method with copying and sorting
\ccPrecond{\ccc{Input_iterator} must be a model of
  \ccc{InputIterator} and its value type must be
  either \ccc{Point_2} or \ccc{Site_2}.}}
%
\ccGlue
\ccMethod{Vertex_handle  insert(Point_2 p);}{Inserts the
point \ccc{p} in the segment Voronoi diagram. If \ccc{p} has already
been inserted, then the vertex handle of its already inserted copy is
returned. If \ccc{p} has not been inserted yet, the vertex handle of
\ccc{p} is returned.}
%
\ccGlue
\ccMethod{Vertex_handle  insert(Point_2 p1, Point_2 p2);}{Inserts the
  closed segment with endpoints \ccc{p1} and \ccc{p2} in the segment
  Voronoi diagram. If the segment has already been inserted in the
  diagram then the vertex handle of its already inserted copy is
  returned. If the segment does not intersect any segment in the
  existing diagram, the vertex handle corresponding to its
  corresponding open segment is returned. Finally, if the segment
  intersects other segments in the existing Voronoi diagram, the
  vertex handle to one of its open subsegments is returned.}
%
\ccGlue
\ccMethod{Vertex_handle insert(Point_2 p, Vertex_handle vnear);}
{Inserts \ccc{p} in the segment Voronoi diagram using the site
associated with \ccc{vnear} as an estimate for the nearest neighbor of
of \ccc{p}. The vertex handle returned has the same semantics with the
vertex handle returned by the method
\ccc{Vertex_handle insert(Point_2 p)}.}
%
\ccGlue
\ccMethod{Vertex_handle insert(Point_2 p1, Point_2 p2, Vertex_handle
vnear);}{Inserts the segment whose endpoints are \ccc{p1} and \ccc{p2}
  in the segment Voronoi diagram using the site
  associated with \ccc{vnear} as an estimate for the nearest neighbor of
  of \ccc{p1}. The vertex handle returned has the same semantics with the
  vertex handle returned by the method
  \ccc{Vertex_handle insert(Point_2 p1, Point_2 p2)}.}
%
%\ccGlue
%\ccMethod{Vertex_handle insert(Site_2 s, Vertex_handle
%vnear);}{Inserts \ccc{s} in the segment Voronoi diagram using the site
%associated with \ccc{vnear} as an estimate for the nearest neighbor of
%\ccc{s}, if \ccc{s} is a point, of the first endpoint of \ccc{s}, if
%\ccc{s} is a segment. The vertex handle returned has the same
%semantics with the vertex handle returned by the method
%\ccc{Vertex_handle insert(Site_2 s)}.}

%\ccHeading{Removal}
%\ccThree{void }{ag.remove(Vertex_handle v)+}{}
%
%\ccMethod{void  remove(Vertex_handle v);}{Removes the site
%associated to the vertex handle \ccc{v} from the Apollonius
%graph.
%\ccPrecond{\ccc{v} must correspond to a valid finite
%vertex of the Apollonius graph.}}


\ccHeading{Nearest neighbor location}
\ccThree{Vertex_handle }{svd.nearest_neighbor(Point_2 p)+}{}
%
\ccMethod{Vertex_handle  nearest_neighbor(Point_2 p);}
{Finds the nearest neighbor of the point \ccc{p}. In other words it
finds the site whose segment Voronoi diagram cell contains
\ccc{p}. Ties are broken arbitrarily and one of the nearest neighbors
of \ccc{p} is returned. If there are no sites in the
segment Voronoi diagram \ccc{Vertex_handle()} is returned.}
\ccGlue
\ccMethod{Vertex_handle  nearest_neighbor(Point_2 p,
Vertex_handle vnear);}{Finds the nearest neighbor of the point
\ccc{p} using the site associated with \ccc{vnear} as an
estimate for the nearest neighbor of \ccc{p}. Ties are broken
arbitrarily and one of the nearest neighbors of \ccc{p} is
returned. If there are no sites in the segment Voronoi diagram
\ccc{Vertex_handle()} is returned.}


%\ccHeading{Access to the dual}

%The \RefName\ class provides access to the duals of
%the faces of the segment Voronoi diagram.
%The dual of a face of the Apollonius graph is a site. 
%If the originating face is infinite, its dual is a point
%at infinity, which means that it can be represented geometrically as a line. 
%If the originating face is finite, its dual is a site with finite center and
%weight. 
%In the following three methods the returned object is
%assignable to either \ccc{Site_2} or \ccc{Gt::Line_2}, depending on
%whether the corresponding face of the Apollonius graph is finite or
%infinite, respectively.

%\ccThree{Gt::Object_2}{ag.dual(Finite_edges_iterator ei)+}{}
%
%\ccMethod{Gt::Object_2  dual(Face_handle f) const;}{Returns the
%dual corresponding to the face handle \ccc{f}. The returned object can
%be assignable to one of the following: \ccc{Site_2}, \ccc{Gt::Line_2}.}
%\ccGlue
%\ccMethod{Gt::Object_2  dual(All_faces_iterator it) const;}{Returns the
%dual of the face to which \ccc{it} points to. The returned object can
%be assignable to one of the following: \ccc{Site_2}, \ccc{Gt::Line_2}.}
%\ccGlue
%\ccMethod{Gt::Object_2  dual(Finite_faces_iterator it) const;}{Returns
%  the dual of the face to which \ccc{it} points to. The returned
%  object can be assignable to one of the following: \ccc{Site_2},
%  \ccc{Gt::Line_2}.}

\newpage

\ccHeading{I/O}
\ccThree{Stream& }{svd.draw_dual(Stream& str)+}{}
%
\ccMethod{template < class Stream > 
Stream& draw_dual(Stream& str);}{Draws the segment Voronoi
diagram to the stream \ccc{str}.
\ccPrecond{The following operators must be defined:\\
\ccc{Stream& operator<<(Stream&, Gt::Segment_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Ray_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Line_2)}.}
}
\ccGlue
\ccMethod{template< class Stream >
Stream& draw_dual_edge(Edge e, Stream& str);}{Draws an edge of the
  segment Voronoi diagram to the stream \ccc{str}.
\ccPrecond{The following operators must be defined:\\
\ccc{Stream& operator<<(Stream&, Gt::Segment_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Ray_2)},\\
\ccc{Stream& operator<<(Stream&, Gt::Line_2)}.}
}



\ccHeading{Validity check}
%\ccThree{bool}{svd.is_valid(bool verbose, int level)+}{}
%
% MK:: change the output stream in the code
\ccMethod{bool is_valid(bool verbose = false, int level = 1);}
{Checks the validity of the segment Voronoi diagram. If \ccc{verbose}
  is \ccc{true} a short message is sent to \ccc{std::cerr}. If
  \ccc{level} is 0, only the data structure is validated. If
  \ccc{level} is 1, then both the data structure and the Apollonius
  graph are validated. Negative values of \ccc{level} always return
  true, and values greater then 1 are equivalent to \ccc{level} being
  1.}

\ccHeading{Miscellaneous}
\ccThree{void}{svd.swap(& other)+}{}
%
\ccMethod{void clear();}{Clears all contents of the segment Voronoi
  diagram.}
\ccGlue
% MK:: add this method make copy(...) protected and see doc of TDS
\ccMethod{void swap(Segment_Voronoi_diagram_2<Gt,SC,DS>
other);}{The segment Voronoi diagrams
\ccc{other} and \ccVar\ are swapped. \ccVar.\ccc{swap(other)} should
be preferred to \ccVar\ccc{ = other} or to \ccVar\ccc{(other)} if
\ccc{other} is deleted afterwards.}




\ccSeeAlso
\ccc{SegmentVoronoiDiagramTraits_2}\\
\ccc{SegmentVoronoiDiagramDataStructure_2}\\
\ccc{SegmentVoronoiDiagramVertexBase_2}\\
\ccc{SegmentVoronoiDiagramFaceBase_2}\\
\ccc{SimpleContainer}\\
\ccc{CGAL::Segment_Voronoi_diagram_traits_2<K,Method_tag>}\\
\ccc{CGAL::Segment_Voronoi_diagram_filtered_traits_2<CK,CM,EK,EM,FK,FM>}\\
\ccc{CGAL::Segment_Voronoi_diagram_data_structure_2<Vb,Fb>}\\
\ccc{CGAL::Segment_Voronoi_diagram_vertex_base_2<Gt,StoreHidden>}\\
\ccc{CGAL::Segment_Voronoi_diagram_face_base_2<Gt>}\\
\ccc{CGAL::Simple_container<T>}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+
