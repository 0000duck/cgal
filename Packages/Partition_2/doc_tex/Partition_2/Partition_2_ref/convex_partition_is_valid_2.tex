\renewcommand\ccRefPageBegin{\ccParDims\cgalColumnLayout\begin{ccAdvanced}}
\renewcommand\ccRefPageEnd{\ccParDims\cgalColumnLayout\end{ccAdvanced}}
\begin{ccRefFunction}{convex_partition_is_valid_2}

\ccDefinition
Function that determines if a given set of polygons represents
a valid convex partitioning for a given sequence of points that represent a
simple, counterclockwise-oriented polygon.  
A convex partition is valid if the 
polygons do not overlap, the union of the polygons is the same as the original
polygon given by the sequence of points, and if each partition polygon is 
convex. 
\ccIndexSubsubitem{polygon partitioning}{convex}{valid}

\ccInclude{CGAL/partition_is_valid_2.h}

\ccFunction{
template<class InputIterator, class ForwardIterator, class Traits>
bool
convex_partition_is_valid_2 (InputIterator point_first, 
                             InputIterator point_last,
                             ForwardIterator poly_first, 
                             ForwardIterator poly_last,
                             const Traits& traits = Default_traits);
}
{
determines if the polygons in the range [\ccc{poly_first}, \ccc{poly_last})
define a valid convex partition of the polygon defined by the points in the 
range [\ccc{point_first}, \ccc{point_last}). 
The function returns \ccc{true} iff the partition is valid and otherwise
returns \ccc{false}.
}

\ccHeading{Preconditions}
\ccIndexSubitem[C]{convex_partition_is_valid_2}{preconditions}
\begin{enumerate}
    \item The points in the range [\ccc{point_first}, \ccc{point_last}) define
          a simple, counterclockwise-oriented polygon.
    \item \ccc{Traits} is a model of the concept
          ConvexPartitionIsValidTraits\_2%
          \ccIndexMainItem[c]{ConvexPartitionIsValidTraits_2}.
    \item \ccc{InputIterator::value_type} should be \ccc{Traits::Point_2},
          which should also be the type of the points stored in an object
          of type \ccc{Traits::Polygon_2}.
    \item \ccc{ForwardIterator::value_type} should be 
          \ccc{Traits::Polygon_2}.
\end{enumerate}

The default traits class \ccc{Default_traits} is \ccc{Partition_traits_2},%
\ccIndexTraitsClassDefault{convex_partition_is_valid_2} 
with the representation type determined by \ccc{InputIterator::value_type}.

\ccSeeAlso

\ccRefIdfierPage{CGAL::approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::greene_approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::optimal_convex_partition_2}\\
\ccRefIdfierPage{CGAL::partition_is_valid_2} \\
\ccc{CGAL::is_convex_2}

\ccExample

The following code fragment will compute an optimal
convex partitioning of the simple polygon \ccc{P} 
and store the partition polygons in the list \ccc{partition_polys}.
It then asserts that the partition produced is valid. 
(Note that this assertion is superfluous unless the postcondition checking
done in \ccc{optimal_convex_partition_2} has been turned off during
compilation.)

\begin{verbatim}
   #include <CGAL/basic.h>
   #include <CGAL/Cartesian.h>
   #include <CGAL/Partition_traits_2.h>
   #include <CGAL/partition_2.h>
   #include <list>

   typedef CGAL::Cartesian<double>                           R;
   typedef CGAL::Partition_traits_2<R>                       Traits;
   typedef Traits::Polygon_2                                 Polygon_2;
   typedef Polygon_2::Vertex_const_iterator                  Vertex_iterator;

   Polygon_2            P;
   std::list<Polygon_2> partition_polys;
   Traits               partition_traits;

   // ...
   // insert vertices into P to create a simple CCW-oriented polygon
   // ...
   CGAL::optimal_convex_partition_2(P.vertices_begin(),
                                   P.vertices_end(),
                                   std::back_inserter(partition_polys),
                                   partition_traits);
   assert(convex_partition_is_valid_2(P.vertices_begin(), P.vertices_end(),
                                      partition_polys.begin(), 
                                      partition_polys.end(),
                                      partition_traits));
\end{verbatim}

\end{ccRefFunction}
\renewcommand\ccRefPageBegin{\ccParDims\cgalColumnLayout}
\renewcommand\ccRefPageEnd{\ccParDims\cgalColumnLayout}
