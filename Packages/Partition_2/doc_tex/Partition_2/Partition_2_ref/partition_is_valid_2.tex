\renewcommand\ccRefPageBegin{\ccParDims\cgalColumnLayout\begin{ccAdvanced}}
\renewcommand\ccRefPageEnd{\ccParDims\cgalColumnLayout\end{ccAdvanced}}
\begin{ccRefFunction}{partition_is_valid_2}

\ccDefinition

Function that determines if a given set of polygons represents
a valid partition for a given sequence of points that 
define a simple, counterclockwise-oriented polygon.  A valid partition is one in
which the polygons are nonoverlapping and the union of the polygons is the 
same as the original polygon.
\ccIndexSubitem{polygon partitioning}{valid}
\ccIndexSubsubitem{polygon partitioning}{convex}{valid}
\ccIndexSubsubitem{polygon partitioning}{y-monotone}{valid}

\ccInclude{CGAL/partition_is_valid_2.h}

\ccFunction{
template<class InputIterator, class ForwardIterator, class Traits>
bool
partition_is_valid_2 (InputIterator point_first, InputIterator point_last,
                      ForwardIterator poly_first, ForwardIterator poly_last,
                      const Traits& traits = Default_traits);
}
{
returns \ccc{true} iff the polygons in the range [\ccc{poly_first}, 
\ccc{poly_last}) define a valid partition of the polygon defined by the 
points in the range [\ccc{point_first}, \ccc{point_last}) and 
\ccc{false} otherwise.  
Each polygon must also satisfy the property 
tested by \ccc{Traits::Is_valid()}. 
}

\ccHeading{Preconditions}
\ccIndexSubitem[C]{partition_is_valid_2}{preconditions}
\begin{enumerate}
    \item Points in the range [\ccc{point_first}, \ccc{point_last}) define
          a simple, counterclockwise-oriented polygon.
    \item \ccc{Traits} is a model of the concept 
          \ccc{PartitionIsValidTraits_2}%
          \ccIndexMainItem[c]{PartitionIsValidTraits_2} and the
          concept defining the requirements for the validity test 
          implemented by \ccc{Traits::Is_valid()}.
    \item \ccc{InputIterator::value_type} should be \ccc{Traits::Point_2},
          which should also be the type of the points stored in an object
          of type \ccc{Traits::Polygon_2}.
    \item \ccc{ForwardIterator::value_type} should be 
          \ccc{Traits::Polygon_2}.
\end{enumerate}

The default traits class \ccc{Default_traits} is \ccc{Partition_traits_2},%
\ccIndexTraitsClassDefault{partition_is_valid_2}
with the representation type determined by \ccc{InputIterator::value_type}.

\ccSeeAlso

\ccRefIdfierPage{CGAL::approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::greene_approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::is_y_monotone_2} \\
\ccRefIdfierPage{CGAL::optimal_convex_partition_2} \\
\ccRefIdfierPage{CGAL::Partition_is_valid_traits_2<Traits, PolygonIsValid>} \\
\ccRefIdfierPage{CGAL::y_monotone_partition_2} \\
\ccc{CGAL::is_convex_2} 

\ccExample

The following code fragment will compute an optimal
convex partitioning of the simple polygon \ccc{P} 
and store the partition polygons in the list \ccc{partition_polys}.
It then asserts that the partition produced is valid.  (Note that
this assertion is superfluous unless postcondition checking for 
\ccc{optimal_convex_partition_2} has been turned off during compilation.)

\begin{verbatim}
   #include <CGAL/basic.h>
   #include <CGAL/Cartesian.h>
   #include <CGAL/Partition_traits_2.h>
   #include <CGAL/Partition_is_valid_traits_2.h>
   #include <CGAL/polygon_function_objects.h>
   #include <CGAL/partition_2.h>
   #include <list>

   typedef CGAL::Cartesian<double>                           R;
   typedef CGAL::Partition_traits_2<R>                       Traits;
   typedef CGAL::Is_convex_2<Traits>                         Is_convex_2;
   typedef Traits::Polygon_2                                 Polygon_2;
   typedef Traits::Point_2                                   Point_2;
   typedef Polygon_2::Vertex_const_iterator                  Vertex_iterator;
   typedef std::list<Polygon_2>                              Polygon_list;
   typedef CGAL::Partition_is_valid_traits_2<Traits, Is_convex_2>
                                                             Validity_traits;
   Polygon_2             P;
   Polygon_list          partition_polys;
   Traits                partition_traits;
   Validity_traits       validity_traits;

   // ...
   // insert vertices into P to create a simple, CCW-oriented polygon
   // ...
   CGAL::optimal_convex_partition_2(P.vertices_begin(),
                                    P.vertices_end(),
                                    std::back_inserter(partition_polys),
                                    partition_traits);
   assert(partition_is_valid_2(P.vertices_begin(), P.vertices_end(),
                               partition_polys.begin(), partition_polys.end(),
                               validity_traits));
\end{verbatim}

\end{ccRefFunction}
\renewcommand\ccRefPageBegin{\ccParDims\cgalColumnLayout}
\renewcommand\ccRefPageEnd{\ccParDims\cgalColumnLayout}
