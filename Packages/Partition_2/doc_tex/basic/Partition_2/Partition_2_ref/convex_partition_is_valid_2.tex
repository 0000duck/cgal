\renewcommand\ccRefPageBegin{\ccParDims\cgalColumnLayout\begin{ccAdvanced}}
\renewcommand\ccRefPageEnd{\ccParDims\cgalColumnLayout\end{ccAdvanced}}
\begin{ccRefFunction}{convex_partition_is_valid_2}

\ccDefinition
Function that determines if a given set of polygons represents
a valid convex partitioning for a given sequence of points that represent a
simple, counterclockwise-oriented polygon.  
%A convex partition is valid if the 
%polygons do not overlap, the union of the polygons is the same as the original
%polygon given by the sequence of points, and if each partition polygon is 
%convex. 

\ccInclude{CGAL/partition_is_valid_2.h}

\ccFunction{
template<class InputIterator1, class InputIterator2, class Traits>
bool
convex_partition_is_valid_2 (InputIterator1 point_first, 
                             InputIterator1 point_last,
                             InputIterator2 poly_first, 
                             InputIterator2 poly_last,
                             const Traits& traits = Default_traits);
}
{
determines if the polygons in the range [\ccc{poly_first}, \ccc{poly_last})
define a valid convex partition of the polygon defined by the points in the 
range [\ccc{point_first}, \ccc{point_last}), where a valid convex partition 
is one in which the polygons are nonoverlapping and the union of the polygons 
is the same as the original polygon defined on [\ccc{point_first}, 
\ccc{point_last}) and each polygon is convex.
\ccIndexSubsubitem{polygon partitioning}{convex}{valid}
The function returns \ccc{true} iff the partition is valid and otherwise
returns \ccc{false}.
}

\ccHeading{Preconditions}
\ccIndexSubitem[C]{convex_partition_is_valid_2}{preconditions}
\begin{enumerate}
    \item The points in the range [\ccc{point_first}, \ccc{point_last}) define
          a simple, counterclockwise-oriented polygon.
    \item \ccc{Traits} is a model of the concept
          ConvexPartitionIsValidTraits\_2%
          \ccIndexMainItem[c]{ConvexPartitionIsValidTraits_2}.
    \item \ccc{InputIterator1::value_type} should be \ccc{Traits::Point_2},
          which should also be the type of the points stored in an object
          of type \ccc{InputIterator2::value_type}.
\end{enumerate}

The default traits class \ccc{Default_traits} is \ccc{Partition_traits_2}.%
\ccIndexTraitsClassDefault{convex_partition_is_valid_2}

\ccSeeAlso

\ccc{approx_convex_partition_2},
\ccc{greene_approx_convex_partition_2},
\ccc{is_convex_2},
\ccc{optimal_convex_partition_2},
\ccc{partition_is_valid_2}

\ccExample

The following code fragment will compute an optimal
convex partitioning of the simple polygon \ccc{P} 
and store the partition polygons in the list \ccc{partition_polys}.
It then asserts that the partition produced is valid. 
(Note that this assertion is superfluous unless the postcondition checking
done in \ccc{optimal_convex_partition_2} has been turned off during
compilation.)

\begin{verbatim}
   #include <CGAL/basic.h>
   #include <CGAL/Cartesian.h>
   #include <CGAL/Partition_traits_2.h>
   #include <CGAL/partition_2.h>
   #include <list>

   typedef CGAL::Cartesian<double>                           R;
   typedef CGAL::Partition_traits_2<R>                       Traits;
   typedef Traits::Polygon_2                                 Polygon_2;
   typedef Polygon_2::Vertex_const_iterator                  Vertex_iterator;

   Polygon_2            P;
   std::list<Polygon_2> partition_polys;
   Traits               partition_traits;

   // ...
   // insert vertices into P to create a simple CCW-oriented polygon
   // ...
   CGAL::optimal_convex_partition_2(P.vertices_begin(),
                                   P.vertices_end(),
                                   std::back_inserter(partition_polys),
                                   partition_traits);
   assert(convex_partition_is_valid_2(P.vertices_begin(), P.vertices_end(),
                                      partition_polys.begin(), 
                                      partition_polys.end(),
                                      partition_traits));
\end{verbatim}

\end{ccRefFunction}
\renewcommand\ccRefPageBegin{\ccParDims\cgalColumnLayout}
\renewcommand\ccRefPageEnd{\ccParDims\cgalColumnLayout}
