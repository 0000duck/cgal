\begin{ccRefFunction}{greene_approx_convex_partition_2}

\ccDefinition
Function that produces a set of 
convex polygons that represent a partitioning of a polygon defined
on a sequence of points.
The number of convex polygons produced is 
no more than four times the minimal number.%
\ccIndexSubsubitem{polygon partitioning}{convex}{approximately optimal}

\ccInclude{CGAL/partition_2.h}

\ccFunction{
template <class InputIterator, class OutputIterator, class Traits>
OutputIterator greene_approx_convex_partition_2(InputIterator first,
                                                InputIterator beyond,
                                                OutputIterator result,
                                                const Traits& traits = Default_traits);
}
{
computes a partition of the simple, counterclockwise-oriented polygon defined 
by the points in the range [\ccc{first}, \ccc{last}) into convex 
polygons. The counterclockwise-oriented partition polygons are written to
the sequence starting at position \ccc{result}.  The past-the-end iterator for 
the resulting sequence of polygons is returned.
}

\ccHeading{Requirements}
%\ccIndexSubitem[C]{greene_approx_convex_partition_2}{preconditions}
\begin{enumerate}
    \item \ccc{Traits} is a model of the concepts PartitionTraits\_2%
          \ccIndexMainItem[c]{PartitionTraits_2} and 
          YMonotonePartitionTraits\_2% 
          \ccIndexMainItem[c]{YMonotonePartitionTraits_2}. 
          For the purpose of 
          checking the validity of the $y$-monotone partition produced as
          a preprocessing step for the convex partitioning, it must also 
          be a model of YMonotonePartitionIsValidTraits\_2
          \ccIndexMainItem[c]{YMonotonePartitionIsValidTraits_2}. 
          For the purpose of checking
          the postcondition that the convex partition is valid, \ccc{Traits}
          must also be a model of ConvexPartitionIsValidTraits\_2%
          \ccIndexMainItem[c]{ConvexPartitionIsValidTraits_2}. 
    \item \ccc{OutputIterator::value_type} should be \ccc{Traits::Polygon_2}.
    \item \ccc{InputIterator::value_type} should be \ccc{Traits::Point_2},
          which should also be the type of the points stored in an object
          of type \ccc{Traits::Polygon_2}.
    \item Points in the range $[first, beyond)$ must define a simple polygon
          whose vertices are oriented counterclockwise.
\end{enumerate}

The default traits class \ccc{Default_traits} is \ccc{Partition_traits_2},
%\ccIndexTraitsClassDefault{greene_approx_convex_partition_2}
with the representation type determined by \ccc{InputIterator::value_type}.

\ccSeeAlso
\ccRefIdfierPage{CGAL::approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::convex_partition_is_valid_2} \\
\ccRefIdfierPage{CGAL::optimal_convex_partition_2} \\
\ccRefIdfierPage{CGAL::partition_is_valid_2} \\
\ccRefIdfierPage{CGAL::y_monotone_partition_2} 

\ccImplementation
This function implements the the approximation algorithm of 
Greene \cite{g-dpcp-83} and requires $O(n \log n)$ time and $O(n)$ space
to produce a convex partitioning given a $y$-monotone partitioning of a
polygon with $n$ vertices.  The function \ccc{y_monotone_partition_2} 
is used to produce the monotone partition.

\ccExample
The following code fragment will compute an approximately optimal
convex partitioning of the simple polygon \ccc{P} using the default
traits class and store the partition polygons in the list 
\ccc{partition_polys}.

\begin{verbatim}
   #include <CGAL/basic.h>
   #include <CGAL/Cartesian.h>
   #include <CGAL/Polygon_traits_2.h>
   #include <CGAL/partition_2.h>
   #include <list>

   typedef CGAL::Cartesian<double>                           R;
   typedef CGAL::Polygon_traits_2<R>                         Traits;
   typedef Traits::Point_2                                   Point_2;
   typedef std::list<Point_2>                                Container;
   typedef CGAL::Polygon_2<Traits, Container>                Polygon_2;

   Polygon_2            P;
   std::list<Polygon_2> partition_polys;

   // ...
   // insert vertices into P to create a simple CCW-oriented polygon
   // ...
   CGAL::greene_approx_convex_partition_2(P.vertices_begin(),
                                          P.vertices_end(),
                                          std::back_inserter(partition_polys));
\end{verbatim}


\end{ccRefFunction}
