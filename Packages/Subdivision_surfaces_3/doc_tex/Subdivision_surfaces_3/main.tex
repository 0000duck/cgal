% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  Subdivision_surfaces_3
% +------------------------------------------------------------------------+
% | Subdivision surfaces on generic Polyhedron.
% | 
% | 1.2.2005  Le-Jeng Andy Shiue
% |
\RCSdef{\subdivisionRev}{$Revision$}
\RCSdefDate{\subdivisionDate}{$Date$}
% +------------------------------------------------------------------------+

\newcommand\DS{Doo-Sabin}

% ------------------------------------------------------------------------
\newcommand\FIGDIR{Subdivision_surfaces_3/FIG}
\newcommand\IL{{\itshape left}}
\newcommand\IR{{\itshape right}}
\newcommand\IM{{\itshape middle}}
\newcommand\IT{{\itshape top}}
\newcommand\IB{{\itshape bottom}}
% ------------------------------------------------------------------------

\ccParDims

\chapter{Subdivision Surfaces}
\label{chapterSubdivision}
\ccChapterRelease{\subdivisionRev. \ \subdivisionDate}
\ccChapterAuthor{Le-Jeng Andy Shiue}
\hspace{.4cm}
\begin{ccTexOnly}
    \setlength{\unitlength}{1mm}
    \begin{picture}(0,0)(0.0,0.0)
      \put (78,25){% textwidth = 156mm
          \includegraphics[width=0.095\textwidth]{\FIGDIR/rook_mesh}
          \includegraphics[width=0.095\textwidth]{\FIGDIR/rook_qt1}
          \includegraphics[width=0.095\textwidth]{\FIGDIR/rook_qt2}
          \includegraphics[width=0.095\textwidth]{\FIGDIR/rook_surf1}
          \includegraphics[width=0.095\textwidth]{\FIGDIR/rook_surf2}
      }
    \end{picture}\vspace{-4mm}% compensate for some vspace added by picture
\end{ccTexOnly}

\minitoc

% +------------------------------------------------------------------------+
\section{Introduction} \label{sectionSubIntro}
% +------------------------------------------------------------------------+
Subdivision algorithms (see e.g.~\cite{cgal:ww-smgd-02})
recursively refine coarse meshes and generate ever closer 
approximations to a smooth surface.
%for character animation, surface modeling, or physics simulation. 
Setting aside the specific strategy of geometric averaging
for the new points, subdivision algorithms can be classified 
according to the topological refinement of the underlying mesh.
\ccc{Subdivision_surfaces_3}, working on the concept of the 
\ccc{CGAL::Polyhedron_3} (see Chapter~\ref{chapterPolyhedron}),
takes advantage of this separation of topology and geometry, 
and takes a cue from the policy-based design \cite{cgal:sp-mrlbg-05}.

 
%% \begin{ccHtmlOnly}
%%     <CENTER>
%%         <img src="./fig/shark.gif" alt="Hammerhead"><P>
%%     </CENTER>
%% \end{ccHtmlOnly}

%% the combinatorial integrity of them. It is based on the highly
%% flexible design of the halfedge data structure, see the introduction
%% in Chapter~\ref{chapterHalfedgeDS} and~\cite{k-ugpdd-99}. However, the
%% polyhedral surface can be used and understood with


% +------------------------------------------------------------------------+
\section{Subdivision Algorithms}
% +------------------------------------------------------------------------+
Subdivision algorithms define surfaces as the limit
of recursive refinement of a polyhedral mesh. The chapter teaser
shows a sequence of a subdivision on the rook mesh.
%Figure \ref{fig:RefSchemes} shows the four major refinement 
%patterns used in practice.
%% A mesh is a special graph whose
%% primitives (i.e.~vertices, edges and facets)
%% carry attribute information such as vertex 
%% positions or facet colors. 

Points on the refined mesh are smoothed by averaging
neighbor points on the input mesh. A graph, called \emph{stencil}, 
determines the input submesh whose points contribute to the 
position of a smoothed point. Stencils are defined at the time 
the refinement pattern is chosen. For example, 
%as illustrated in Figure \ref{fig:RefMap},
the PQQ scheme has a vertex-node stencil, which defines 
the 1-ring of an input vertex; an edge-node stencil, which 
defines the 1-ring of a input edge; and a facet-node stencil,
which defines an input facet.

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.5\textwidth}{%
      \includegraphics[width=0.5\textwidth]{\FIGDIR/PQQStencil}%
    }
  \end{center}
\end{ccTexOnly}

%while the DQQ scheme has only a corner-node stencil, which 
%relates the facet of a corner to a target node.
Stencils with weights are called \emph{geometry masks}.
Geometry masks of Catmull-Clark subdivision are shown below,

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.4\textwidth}{%
      \includegraphics[width=0.4\textwidth]{\FIGDIR/cc_mask}%
    }
  \end{center}
\end{ccTexOnly}

%\begin{ccHtmlOnly}
%  <CENTER>
%  <A HREF="./FIG/cc_mask.gif">
%     <img src="./FIG/cc_mask.gif" alt="Catmull-Clark geometry stencil"></A><P>
%  </CENTER>
%\end{ccHtmlOnly}

The weights shown here are unnormalized, and $n$ is the valence 
of the vertex. 
Points on the subdivided mesh are computed by a linear combination
of the points on the source submesh (i.e.~the stencil) and the mask.
%The averaging process can typically be factored into 
%simpler steps \cite{Oswald-2003-CSS}.
%and this has
%been implemented in the OpenMesh library \cite{Sovakar-2004-APISUB}.
%However, while stencil factoring simplifies the implementation,
%it is less efficient because it requires repeated visits 
%to all nodes.

Since only a fixed number of refinement patterns are 
practical but a wide variety of geometry masks can be developed,
\ccc{Subdivision_surfaces_3} provides a set of refinement patterns 
(the \emph{refinement hosts})
and hands the definition of geometry masks
(the \emph{geometry policies}) to the library user.
A subdivision scheme is obtained by parameterizing the 
refinement host with geometry policies. 
For example, Catmull-Clark subdivision is constructed by 
parameterizing the PQQ refinement with the Catmull-Clark geometry 
policies.
%, which compute the smoothed points based on the
%Catmull-Clark geometry masks.

%\ccc{Subdivision_surfaces_3} supports 1-ring mesh refinement based on 
%half-edge data structures.
%A subdivision scheme of \ccc{CGAL::Subdivision_surfaces_3} is a 
%refinement host parameterized with a geometry policy. 

%The refinement host realizes the topological refinement and 
%the stencils. The geometry policy consists a set of 
%averaging rules of the geometry stencils.

% +-------------------------------------------------------------+
\subsection{Example: Catmull-Clark Subdivision}
\ccc{CGAL::Subdivision_surfaces_3::PQQ}, the refinement 
host for the PQQ refinement, realizes the topological 
refinement, maintains three stencils of the 
PQQ scheme, and calls policies to smooth the refined points.

\begin{ccExampleCode}
  // S is the geometry policy realizing the geometry masks
  template <template <typename> class S>
  static void PQQ(Polyhedron& p, S<Polyhedron> rule, int step)
\end{ccExampleCode}

\ccc{Subdivision_surfaces_3} provides \ccc{CGAL::CatmullClark_stencil} 
realizing the geometry masks of Catmull-Clark subdivision 
\cite{cgal:cc-rgbss-78}. 
The Catmull-Clark subdivision is then constructed by parameterizing 
\ccc{CGAL::Subdivision_surfaces_3::PQQ} with 
\ccc{CGAL::CatmullClark_stencil}.

\begin{ccExampleCode}
  void CatmullClark_subdivision(Polyhedron& p, int step) {
    PQQ(p, CatmullClark_stencil<Polyhedron>(), step);
  }
\end{ccExampleCode}

\ccc{Polyhedron} is a model of the \ccc{CGAL::Polyhedron_3}
concept, and \ccc{step} specifies the subdivision depth.

%Catmull-Clark, Loop, Doo-Sabin and $\sqrt{3}$ subdivisions are supported
%in \ccc{CGAL::Subdivision_surfaces_3} as convenient functions.

% +-------------------------------------------------------------+
\section{Refinement Host}
\ccc{Subdivision_surfaces_3} provides four refinement hosts of primal 
quadrilateral quadrisection (PQQ), primal triangle 
quadrisection (PTQ), dual quadrilateral 
quadrisection (DQQ) and $\sqrt{3}$ triangulation, which 
are used by Catmull-Clark, Loop, \DS\ and $\sqrt{3}$ subdivision, 
respectively. 

The refined mesh is shown below the input mesh.
\begin{ccTexOnly}
  \begin{center}
    \parbox{0.6\textwidth}{%
      \includegraphics[width=0.6\textwidth]{\FIGDIR/RefSchemes}%
    }
  \end{center}
\end{ccTexOnly}

%\begin{ccHtmlOnly}
%  <CENTER>
%  <A HREF="./FIG/RefSchemes.gif">
%     <img src="./FIG/RefSchemes.gif" alt="Refinement Hosts"></A><P>
%  </CENTER>
%\end{ccHtmlOnly}


\begin{ccExampleCode}
template <class Polyhedron>
class Subdivision_surfaces_3 {
  // S is the geometry policy realizing the geometry masks
  template <template <typename> class S>
  static void PQQ(Polyhedron& p, S<Polyhedron> rule, int step);

  template <template <typename> class S>
  static void PTQ(Polyhedron& p, S<Polyhedron> rule, int step);

  template <template <typename> class S>
  static void DQQ(Polyhedron& p, S<Polyhedron> rule, int step);

  template <template <typename> class S>
  static void Sqrt3(Polyhedron& p, S<Polyhedron> rule, int step);
}
\end{ccExampleCode}

%% Stencils are maintained using the iteration concept
%% to avoid the need for vertex tags to distinguish
%% the stencil types.
%% For example, on a PQQ refined mesh, the vertex iterator 
%% visits the 
%% vertex-nodes, edge-nodes and then facet-nodes. The visit
%% order is implicitly used to determine the stencil of
%% the visited node.

Each refinement host is a template function of
a mesh type and a policy type. The mesh type is
a model of the \ccc{CGAL::Polyhedron_3} concept, and the
policy type is a class with functions realizing the 
geometry masks of the subdivision scheme.
Refinement hosts refine the mesh, maintain the stencils 
(i.e.~the mapping between the source and the refined mesh), 
and call policy functions
to assign the smoothed points. \ccc{Point_3} type is required
to be defined in the mesh type, but no flag of the mesh 
is required to maintain the stencils. The stencils are maintained
by ordering new vertices to match the sequence of connectivity 
operations of the refinement. Interested users should 
refer to \cite{cgal:sp-mrbee-05} for details of the 
ordering algorithm.

% +-------------------------------------------------------------+
\section{Geometry Policy}
A geometry policy is a class that defines a set of geometry masks. 
Each geometry mask is realized as a member function (i.e.~the policy) 
assigning new points according to the stencil weights.
%The policy interface is defined with the refinement host. 
Each policy receives a primitive handle 
(e.g.~\ccc{Halfedge_handle}) of the input mesh, and the reference of 
the \ccc{Point} to the refined vertex. The realization of the policy
collects the neighbors of the primitive handle (i.e.~the stencil),
and computes the new point by a linear combination of the stencil 
points and the mask (i.e.~the stencil weights).

The interfaces of a geometry policy need to match the stencils of 
the refinement host. For example, a PQQ host requires three 
policy functions for meshes without open boundaries: a vertex-node 
stencil, an edge-node stencil, and a facet-node stencil. 
%To support meshes with boundaries, a policy function
%for border vertices is also required.

\begin{ccTexOnly}
  \begin{center}
    \parbox{0.5\textwidth}{%
      \includegraphics[width=0.5\textwidth]{\FIGDIR/PQQStencil}%
    }
  \end{center}
\end{ccTexOnly}

%\begin{ccHtmlOnly}
%  <CENTER>
%  <A HREF="./FIG/PQQStencil.gif">
%     <img src="./FIG/PQQStencil.gif" alt="Stencils of PQQ scheme "></A><P>
%  </CENTER>
%\end{ccHtmlOnly}

Following example shows an implementation of geometry masks 
of Catmull-Clark subdivision. \ccc{Point} is an alias to \ccc{Point_3}
in \ccc{Poly}.

\begin{ccExampleCode}
template <class P>
class CatmullClark_stencil {
  //
  void facet_node(Facet_handle facet, Point& pt) {
    Halfedge_around_facet_circulator hcir = facet->facet_begin();
    int n = 0;
    FT p[] = {0,0,0};
    do {
      Point t = hcir->vertex()->point();
      p[0] += t[0], p[1] += t[1], p[2] += t[2]; 
      ++n;
    } while (++hcir != facet->facet_begin());
    pt = Point(p[0]/n, p[1]/n, p[2]/n);
  }
  //
  void edge_node(Halfedge_handle edge, Point& pt) {
    Point p1 = edge->vertex()->point();
    Point p2 = edge->opposite()->vertex()->point();
    Point f1, f2;
    facet_node(edge->facet(), f1);
    facet_node(edge->opposite()->facet(), f2);
    pt = Point((p1[0]+p2[0]+f1[0]+f2[0])/4,
               (p1[1]+p2[1]+f1[1]+f2[1])/4,
               (p1[2]+p2[2]+f1[2]+f2[2])/4 );
  }
  //
  void vertex_node(Vertex_handle vertex, Point& pt) {
    Halfedge_around_vertex_circulator vcir = vertex->vertex_begin();
    int n = circulator_size(vcir);    

    float Q[] = {0.0, 0.0, 0.0}, R[] = {0.0, 0.0, 0.0};
    Point& S = vertex->point();
    
    Point q;
    for (int i = 0; i < n; i++, ++vcir) {
      Point& p2 = vcir->opposite()->vertex()->point();
      R[0] += (S[0]+p2[0])/2;
      R[1] += (S[1]+p2[1])/2;
      R[2] += (S[2]+p2[2])/2;
      facet_node(vcir->facet(), q);
      Q[0] += q[0];      
      Q[1] += q[1];      
      Q[2] += q[2];
    }
    R[0] /= n;    R[1] /= n;    R[2] /= n;
    Q[0] /= n;    Q[1] /= n;    Q[2] /= n;
      
    pt = Point((Q[0] + 2*R[0] + S[0]*(n-3))/n,
               (Q[1] + 2*R[1] + S[1]*(n-3))/n,
               (Q[2] + 2*R[2] + S[2]*(n-3))/n );
  }
}
\end{ccExampleCode}
%% Move these back when add the border support
%%   void border_node(Halfedge_handle edge, Point& ept, Point& vpt) {
%%     Point& ep1 = edge->vertex()->point();
%%     Point& ep2 = edge->opposite()->vertex()->point();
%%     ept = Point((ep1[0]+ep2[0])/2, (ep1[1]+ep2[1])/2, (ep1[2]+ep2[2])/2);

%%     Halfedge_around_vertex_circulator vcir = edge->vertex_begin();
%%     Point& vp1  = vcir->opposite()->vertex()->point();
%%     Point& vp0  = vcir->vertex()->point();
%%     Point& vp_1 = (--vcir)->opposite()->vertex()->point();
%%     vpt = Point((vp_1[0] + 6*vp0[0] + vp1[0])/8,
%%                 (vp_1[1] + 6*vp0[1] + vp1[1])/8,
%%                 (vp_1[2] + 6*vp0[2] + vp1[2])/8 );
%%   }

%% \begin{ccExampleCode}
%% PQQ<_M,CCstencil>(Mesh,CCstencil<_M>())
%% \end{ccExampleCode}
%% (or, more simply \\
%% \begin{ccExampleCode}
%% PQQ(Mesh,CCstencil<_M>())}
%% \end{ccExampleCode}
%% since the compiler can derive the template
%% arguments from the function parameters),
%% instantiates Catmull-Clark subdivision.    
%% \ccc{_M}, the model of the mesh concept,
%% represents the mesh type (\ccc{Mesh}),
%% and \ccc{CCstencil} is a class template 
%% realizing geometry policies of Catmull-Clark subdivision.

%The geometry stencils of Catmull-Clark subdivision (border stencils are 
%not included) are shown below. 

%\begin{ccTexOnly}
%  \begin{center}
%    \parbox{0.4\textwidth}{%
%      \includegraphics[width=0.4\textwidth]{\FIGDIR/cc_mask}%
%    }
%  \end{center}
%\end{ccTexOnly}

%\begin{ccHtmlOnly}
%  <CENTER>
%  <A HREF="./FIG/cc_mask.gif">
%     <img src="./FIG/cc_mask.gif" alt="Catmull-Clark geometry stencil"></A><P>
%  </CENTER>
%\end{ccHtmlOnly}


% +------------------------------------------------------------------------+
\section{Built-in subdivision schemes}
% +------------------------------------------------------------------------+
Catmull-Clark , Loop, \DS\ and $\sqrt{3}$ subdivisions are directly supported 
by \ccc{Subdivision_surfaces_3}. 
%Each of these subdivision schemes is realized by parameterizing 
%the corresponding geometry policy to the .

\begin{ccExampleCode}
  static void CatmullClark_subdivision(Polyhedron& p, int step) {
    PQQ(p, CatmullClark_stencil<Polyhedron>(), step);
  }
  static void Loop_subdivision(Polyhedron& p, int step) {
    PTQ(p, Loop_stencil<Polyhedron>() , step);
  }
  static void DooSabin_subdivision(Polyhedron& p, int step) {
    DQQ(p, DooSabin_stencil<Polyhedron>(), step);
  }
  static void Sqrt3_subdivision(Polyhedron& p, int step) {
    Sqrt3(p, Sqrt3_stencil<Polyhedron>(), step);
  }
\end{ccExampleCode}

Following shows an example of \DS\ subdivision on a polyhedral mesh.
\ccIncludeExampleCode{Subdivision_surfaces_3/DooSabin_subdivision.C}

% +------------------------------------------------------------------------+
\section{Customize subdivision schemes}
% +------------------------------------------------------------------------+
To construct a customized subdivision scheme, users first choose a 
refinement host with the intended topological pattern, and then 
implement the geometry policy accordingly. 
Following example develops a subdivision scheme
generating improved Loop subdivision surfaces based on the PTQ 
refinement (i.e~\ccc{Subdivision_surfaces_3<Polyhedron>::PTQ}). 
The geometry policy is developed as a subclass 
of \ccc{PQQ_stencil}), which defines the superset of PTQ stencils.

A policy function for subdivision surfaces is semantically
required to assigned the smoothed point based on the source mesh.

\ccIncludeExampleCode{Subdivision_surfaces_3/Customized_subdivision.C}
