#!/usr/local/bin/perl -w
#
# version: 3.0
# author:  Geert-Jan Giezeman
#
# This script creates a WWW page with a table of test suite results.
#
# Usage:
#   create_testpage [-p previous-release] <directory>

use Cwd;
use strict;
use vars qw($opt_p);
use Getopt::Std;

my ($PLATFORMS_BESIDE_RESULTS, $PLATFORMS_REF_BETWEEN_RESULTS)=(1,1);

my $SCRIPTDIR = './';

my $TEMPPAGE="tmp$$.html";
my $TEMPPAGE2="tmp2$$.html";
my $WWWPAGE;
my $VERSIONS_WEBPAGE;
my $release_name;
my @platforms_to_do;
my @known_platforms;
my %platform_short_names;
my @available_platforms;
my @test_directories;
my @testresults;
my $currentdir;
my $testresult_dir;

$currentdir=cwd();
$testresult_dir="$currentdir/TESTRESULTS";


sub write_select()
{
  my($filename, @result);
  print OUTPUTV << "EOF";
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>CGAL Versions</title>
  </head>
  <LINK REL=stylesheet HREF="testresult.sty">
  <body>
EOF
  print OUTPUTV '<form><table><tr><td><h2>Test-suite results for CGAL version</h2></td><td><select name="sel" onchange="top.results.location.href=this.form.sel.options[this.form.sel.selectedIndex].value">';

  my (@version_nr_vector, @version_name_vector);
  my ($i, $j);
  my $temp;
  $i = 0;
  $j = 0;
  foreach $_ (glob("results-*.*-I-*\.html")) {
    $temp = $_;
    $temp =~ /results-(.)\.(.)-I-(.+)\.html/;
    $version_nr_vector[$i] = ${3};
    $version_name_vector[$i] = $temp;
    $i++;
  }

  #@sorted = sort {$a <= $b} (@version_nr_vector);
  #here we sort the array version_nr_vector, making the 
  #corresponding array version_name_vector look the same

  my $l_index;
  $l_index = $#version_nr_vector; 
  for ( my $i = 0; $i<($l_index + 1); $i++){
    for ( my $j = 0; $j<$l_index; $j++){
	if ( $version_nr_vector[$j] <= $version_nr_vector[$j+1]){
	    $temp = $version_nr_vector[$j+1];
	    $version_nr_vector[$j+1] = $version_nr_vector[$j];
	    $version_nr_vector[$j] = $temp;
	    $temp = $version_name_vector[$j+1];
	    $version_name_vector[$j+1] = $version_name_vector[$j];
	    $version_name_vector[$j] = $temp;
	}
    }
  }

  for ($i = 0; $i<($#version_nr_vector + 1); $i++){
    print OUTPUTV '<option value="', $version_name_vector[$i], '">';
    $temp = $version_name_vector[$i];
    $temp =~ /results-(.*?)\.html\s*/;
    print OUTPUTV ${1}, "</option>";
  }
  print OUTPUTV "</select></td></tr></table></form>";
  print OUTPUTV "</body></html>";
}

sub list_platforms()
{
    my ($filename, @result);
    foreach $_ (glob("results_*.txt")) {
	($filename) =  m/results_(.*?)\.txt\s*/;
	push(@result, $filename) if $filename;
    }
    return @result;
}

sub list_packages($)
#
# Fill @test_directories with the packages found in the argument platform.
# Return false if that platform does not have a list of packages.
{
    my ($platform) = @_;
    @test_directories = ();
    my $test_result="results_${platform}.txt";
    open(TESTRESULT, $test_result) or return 0;
    while (<TESTRESULT>) {
	if (/^\s*(.*?)\s+(\w)\s*$/) {
	    push (@test_directories, $1);
	}
    }
    close TESTRESULT or return 0;
    return 1;
}

sub collect_results_of_platform($)
{
    my ($platform) = @_;
# Create an anonymous hash that hashes packages to their result.
    my $platform_results = {};
    my $test_result="results_${platform}.txt";
    my ($yeahs, $nays, $warnings) = (0,0,0);
    my $resulttext;
    open(TESTRESULT, $test_result) or return $platform_results;
    while (<TESTRESULT>) {
	if (/^\s*(.*?)\s+(\w)\s*$/) {
	    #($package,$succes) = ($1,$2);
	    if ($2 eq 'y' or $2 eq 'Y') {
		$resulttext = 'y';
		++$yeahs;
	    } elsif ($2 eq 'w' or $2 eq 'W') {
		$resulttext = 'w';
		++$warnings;
	    } elsif ($2 eq 'n' or $2 eq 'N') {
		$resulttext = 'n';
		++$nays;
	    } else {
		$resulttext = ' ';
	    }
	    $platform_results->{$1} = $resulttext;
	}
    }
    close TESTRESULT;
    $platform_results->{"y"} = $yeahs;
    $platform_results->{"n"} = $nays;
    $platform_results->{"w"} = $warnings;
    return $platform_results;
}

sub collect_results()
{
    my $platform;
    foreach $platform (@platforms_to_do) {
	last if list_packages($platform);
    }
    foreach $platform (@platforms_to_do) {
	push(@testresults, collect_results_of_platform($platform));
    }
}

sub print_result_table()
{
    my $platform_count = scalar(@platforms_to_do);
    my $pc_plus_2 = $platform_count + 2;

    print OUTPUT <<"EOF";
<TABLE CLASS="result" BORDER=1 CELLSPACING=2 CELLPADDING=5>
<TR ALIGN=CENTER>
<TH ROWSPAN=2>Package</TH>
<!-- <TH ROWSPAN=2>Version</TH> -->
<TH COLSPAN=$platform_count>Test Platform</TH>
</TR>
<TR ALIGN=CENTER>
EOF

#<TR>
#<TD ALIGN=CENTER COLSPAN=$pc_plus_2>
#<FONT SIZE="+2">Test Suite Results $release_name</FONT></TD>
#</TR>

    my ($platform_num,$platform)=(0,"");
    foreach $platform (@platforms_to_do) {
	++$platform_num;
	print OUTPUT "<TD><B>$platform_num</B></TD>\n";
    }

    print OUTPUT "</TR>\n";
    my $test_directory;
    my $test_num = 0;
    foreach $test_directory (@test_directories) {
    	if ($PLATFORMS_REF_BETWEEN_RESULTS) {
	    $test_num++;
	    if ($test_num == 15) {
	    	$test_num = 0;
	    	#print OUTPUT "\n<TR>  <TD ALIGN=center COLSPAN=2 >\n";
	    	print OUTPUT "\n<TR>  <TD ALIGN=center>\n";
	    	print OUTPUT
		    '<A HREF="#platforms">Platform Description</A>';
	    	print OUTPUT "\n</TD>\n";
    	    	$platform_num=0;
	    	while ($platform_num < $platform_count) {
		    ++$platform_num;
		    print OUTPUT "<TD ALIGN=center> <B> $platform_num</B></TD>\n";
	    	}
	    	print OUTPUT "\n</TR>\n";
	    }
	}
	# my $version;
	# if ( -r "$test_directory/version" ) {
	#     open(VERSION, "$test_directory/version");
	#     while(<VERSION>) {
	# 	($version) = /^\s*([^\s]*)\s/;
	# 	last if $version;
	#     }
	#     close VERSION;
	# }
	print OUTPUT "\n<TR>\n";
	print OUTPUT "<TD>$test_directory</TD>\n";
	# if ( $version ) {
	#     print OUTPUT "<TD ALIGN=CENTER>$version</TD>\n";
	# } else {
	#     print OUTPUT "<TD ALIGN=CENTER>?.?</TD>\n";
	# }
	$platform_num=0;
	foreach $platform (@platforms_to_do) {
	    my ($result,$resulttext);
	    $resulttext = $testresults[$platform_num]->{$test_directory};
	    if (! defined($resulttext)) {
		$resulttext = ' ';
	    }
	    print OUTPUT '<TD ALIGN=CENTER';
	    if ($resulttext eq 'y') {
		print OUTPUT ' class=ok';
	    } elsif ($resulttext eq 'w') {
		print OUTPUT ' class=warning';
	    } elsif ($resulttext eq 'n') {
		print OUTPUT ' class=error';
	    } 
	    print OUTPUT '> <A HREF="',
	    "$release_name/$test_directory/TestReport_$platform.gz\"";
	    print OUTPUT '>', "$resulttext</A></TD>\n";
	    ++$platform_num;

	}
	print OUTPUT "</TR>\n";
    }
    print OUTPUT "</TABLE>\n";
}

sub print_resultpage()
{
    my $platform_count = scalar(@platforms_to_do);
    my $pc_plus_2 = $platform_count + 2;

    print OUTPUT << "EOF";
<H2><A NAME="testresults">Test Results for $release_name</A></H2>

EOF
    if ($PLATFORMS_BESIDE_RESULTS) {
    	print OUTPUT <<"EOF";
<TABLE BORDER=0 CELLSPACING=5 CELLPADDING=0>
<TR ALIGN=CENTER>
<TD>
EOF
    }

    print_result_table();


    if ($PLATFORMS_BESIDE_RESULTS) {
    	print OUTPUT <<"EOF";
</TD>
<TD>
<TABLE BORDER=0 CELLSPACING=2 CELLPADDING=0>
EOF
    	if ($platform_count > 0) {
    	    my $repeat_count = (1 + 1.1/16.5)*scalar(@test_directories)/($platform_count+0.25);
	    while ($repeat_count >= 1) {
	    	$repeat_count--;
	    	print OUTPUT <<"EOF";
<TR>
<TD>
EOF
                print_platforms();
                print OUTPUT <<"EOF";
</TD>
</TR>
EOF
	    }
	}

	print OUTPUT <<"EOF";
</TABLE>
</TD>
</TR>
</TABLE>
EOF
    }
}

sub parse_platform($)
{
    my ($pf) = @_;
    $pf =~ s/_LEDA$//;
    my @list = split /_/, $pf;
    return @list;
}

sub parse_platform_2($)
{
    my ($pf) = @_;
    my @list = parse_platform($pf);
    if (@list > 3) {
        splice(@list,0,@list-3);
    }
    while (@list < 3) {
    	push(@list,'?');
    }
    return @list;
}

sub short_pfname($)
{
    my @pflist = parse_platform_2($_[0]);
    my $shortpf = join('_', $pflist[2], $pflist[1]);
    return $shortpf;
}

sub choose_platforms()
{
    my (%platform_index, $pf);
# List all platforms for which there are results
    @available_platforms = list_platforms();
    my $index = 0;
# Put all known platforms in a hash table.
    for ($index=0; $index < @known_platforms; $index += 1) {
	$pf = $known_platforms[$index];
	$platform_index{$pf} = 1;
    }
# Check if there are platforms listed that are not known. Warn about this
# and add those platforms at the end of the list of known platforms.
    foreach (@available_platforms) {
	$pf = $_;
	my @pflist = parse_platform_2($pf);
	my $shortpf = join('_', $pflist[2], $pflist[1]);
	$pf =~ s/^[^_]*_//;
	$pf =~ s/_LEDA$//;
	if (!exists $platform_index{$shortpf}) {
	    # print STDERR "Warning: Platform $_ is unknown!\n";
	    $platform_index{$shortpf} = 1;
	    push(@known_platforms,$shortpf); # ???
    	    $platform_short_names{$shortpf} = $shortpf;
	}
    }

# Make a list of all the platforms that are to be treated, in the order they
# appear in the list of known_platforms.
    @platforms_to_do = ();
    @known_platforms = sort(@known_platforms);
    for ($index=0; $index < @known_platforms; $index += 1) {
	$pf = $known_platforms[$index];
	my $ind2 = 0;
	foreach (@available_platforms) {
	    my $apf = short_pfname($_);
	    if ($apf eq $pf) {
	    	push(@platforms_to_do, $_);
	    }
	}
    }
}

sub print_platform_descriptions()
{
    my ($i,$pf_no,$pf) = (0,1);
    print OUTPUT <<'EOF';
<TABLE BORDER=1 CELLSPACING=2 CELLPADDING=5 >
<TR ALIGN=CENTER>
<TH COLSPAN=2>OS and compiler</TH>
<TH>Tester</TH>
<TH>LEDA</TH>
<TH>GMP</TH>
<TH>CLN</TH>
<TH>QT</TH>
<TH class=ok>y</TH>
<TH class=warning>w</TH>
<TH class=error>n</TH>
</TR>
EOF
    my ($platform_num)=(0);
    foreach $pf (@platforms_to_do) {
	print OUTPUT "<TR>\n<TD>$pf_no</TD>\n";
	$pf_no++;
	my $pf_short = join('_',parse_platform_2($pf));
	print OUTPUT "<TD NOWRAP>$pf_short</TD>\n";
        if (open (PLATFORM_INFO, "results_${pf}.info")) {
	    $_ = <PLATFORM_INFO>;
	    $_ = <PLATFORM_INFO>;
	    chomp;
	    my $tester_name = <PLATFORM_INFO>;
	    my $tester_address = <PLATFORM_INFO>;
	    print OUTPUT "<TD NOWRAP><A HREF=\"mailto:$tester_address\">$tester_name</A></TD>\n";
	    my $index = 4;
	    while ($index) {
	        $index--;
		$_ = <PLATFORM_INFO>;
		chomp;
		print OUTPUT "<TD ALIGN=CENTER NOWRAP>$_</TD>\n";
	    }
	} else {
	    print OUTPUT "<TD NOWRAP>?</TD>\n";
	    print OUTPUT "<TD NOWRAP>?</TD>\n";
	    print OUTPUT "<TD NOWRAP>?</TD>\n";
	    print OUTPUT "<TD NOWRAP>?</TD>\n";
	}
	my $count;
	$count = $testresults[$platform_num]->{"y"};
	print OUTPUT "<TD>$count</TD>\n"; 
	$count = $testresults[$platform_num]->{"w"};
	print OUTPUT "<TD>$count</TD>\n"; 
	$count = $testresults[$platform_num]->{"n"};
	print OUTPUT "<TD>$count</TD>\n"; 
	++$platform_num;
    }
    print OUTPUT "</TABLE>\n";
}

sub print_platforms()
{
    my ($pf_no,$pf) = (1,"");
    print OUTPUT <<'EOF';
<TABLE BORDER=1 CELLSPACING=2 CELLPADDING=5 >
EOF
    foreach $pf (@platforms_to_do) {
	print OUTPUT "<TR>\n<TD>$pf_no</TD>\n";
	$pf_no++;
	my $pf_short = short_pfname($pf);
	print OUTPUT "<TD NOWRAP>$platform_short_names{$pf_short}</TD>\n";
	print OUTPUT "</TR>\n";
    }
    print OUTPUT "</TABLE>\n";
}

sub search_previous_release()
{
    if (! -r $WWWPAGE) {
	print STDERR "Warning: no previous release known.\n";
	print STDERR "Did you forget the -p option?.\n";
	return;
    }
    open INPUT, $WWWPAGE or die;
    while (<INPUT>) {
	if (m/<!-- previous version: (.*) -->/) {
	    $opt_p = $1;
	    last;
	}
    }
    close INPUT;
}

sub result_filename($)
{
    return "results".substr($_[0],4).".html";
#	$name =~ s/-I-/-/;
}


sub print_little_header(){
    print OUTPUT<<"EOF";
<HTML>
<HEAD><TITLE>CGAL Test Result Page</TITLE>
<LINK REL=stylesheet HREF="testresult.sty">
<!-- This file is generated by a program. Don't edit manually!! -->
</HEAD>
<BODY>
The results of the tests are presented in a table
('y' = success, 'w' = warning, 'n' = failure),
and the error + compiler output from each test can be retrieved by clicking
on it.
<B>N.B. The detection of warnings is not exact.
Look at the output to be sure!</B>
<OL>
<LI><A HREF="https://www-sop.inria.fr/geometrica/CGAL/Members/Releases/">
Downloading internal releases</A></LI>
<LI><A HREF="http://www.cgal.org/Members/Manual_test/${release_name}/" style="color: red">
The documentation of this release</A></LI>
EOF
    if (defined($opt_p)) {
	my $prev_page = result_filename($opt_p);
	print OUTPUT<<"EOF";
<LI><A HREF="$prev_page" TARGET="results">Test Results $opt_p</A></LI>
EOF

    }
    if ( -r "announce.html" ) {
	print OUTPUT<<"EOF";
<LI><A HREF="$release_name/announce.html">Announcement of this release</A></LI>
EOF
    }

    print OUTPUT<<'EOF';
</OL>

EOF


}


sub main()
{
    getopts('p:');
    
    if (scalar(@ARGV)  != 1 ) {
	print STDERR "usage: $0 [-p previous-release-directory] directory\n";
	exit 1;
    }

    $release_name =shift(@ARGV);

    $release_name =~ s<(\s+)$><>;
    $release_name =~ s<(/)$><>;
    chdir $testresult_dir or die;
    if ( ! -d $release_name ) {
	print STDERR "$release_name is not a valid directory\n";
	exit 1;
    }
    $WWWPAGE = result_filename($release_name);


    if (defined($opt_p)) {
	$opt_p =~ s</?\s*$><>;
    } else {
	search_previous_release();
    }
    undef($opt_p) if (defined ($opt_p) and $opt_p =~ /^\s*$/);

#    init_known_platforms();
    chdir $testresult_dir or die;
    chdir $release_name or die;
    choose_platforms();
    chdir "..";

    umask 0022;
    unlink $TEMPPAGE;
    unlink $TEMPPAGE2;
    open(OUTPUT,">$TEMPPAGE") or die;
    open(OUTPUTV,">$TEMPPAGE2") or die;
    chdir $testresult_dir or die;
    chdir $release_name or die;
    collect_results();
    print_little_header();
    chdir $testresult_dir or die;
    write_select();
    chdir $release_name or die;    
    print OUTPUT
     '<H2><A NAME="platforms">Platform Description and Summary</A></H2>',"\n";
    print_platform_descriptions();
    print OUTPUT "<P>\n";
    print_resultpage();
    print OUTPUT "<P>\n";
    close OUTPUT;
    chdir "..";
    $VERSIONS_WEBPAGE="versions.html";
    rename $TEMPPAGE, $WWWPAGE;
    rename $TEMPPAGE2, $VERSIONS_WEBPAGE;
    chmod 0664, $VERSIONS_WEBPAGE;
    chmod 0664, $WWWPAGE;
#    system("chgrp cgal $WWWPAGE");
    system("cp $WWWPAGE results.html");
}

sub init_known_platforms()
{
    my ($short_name, $full_name);
    open(PLATFORMS,'known_platforms') or die;
    @known_platforms = ();
    while(<PLATFORMS>) {
        ($short_name, $full_name) =split;
	$full_name = short_pfname($full_name);
	push(@known_platforms,$full_name);
    	$platform_short_names{$full_name} = $full_name;
    }
    close(PLATFORMS);
}

main();
