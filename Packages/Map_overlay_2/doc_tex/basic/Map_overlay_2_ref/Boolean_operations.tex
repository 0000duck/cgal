% +------------------------------------------------------------------------+
% | Reference manual page: Map_overlay.tex (Map_overlay)
% +------------------------------------------------------------------------+
% | 
% | Package: ovl (Map_overlay_2)
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


% +========================================================================+
%   Map Overlay
% +========================================================================+
\begin{ccRefClass}{Boolean_operations_2<Map_overlay>}
\label{OVL_sec:bops}
    
\ccDefinition
The class \ccClassTemplateName\ provides boolean operations 
on two given subdivisions. 
An object $bops$ of the class \ccClassTemplateName\ is constructed by two input subdivisions. 
Their overlay is constructed by the creation of $bops$, in order to make all boolean 
operations, on the two input subdivisions, available for users.
\ccc{Self} is an abbreviation of the \ccRefName\ type hereafter.

\ccInclude{CGAL/Boolean_operations_2.h}

\ccTypes

  \ccNestedType{Map_overlay}{map overlay class.}
  \ccGlue
  \ccNestedType{Vertex_container}
  {a container of all vertices corresponing to the boolean operation performed on the two input subdivisions.}
  \ccGlue
  \ccNestedType{Halfedges_container}
  {a container of all halfedges corresponing to the boolean operation performed on the two input subdivisions.}
  \ccGlue
  \ccNestedType{Faces_container}
  {a container of all faces corresponing to the boolean operation performed on the two input subdivisions.}

  \ccTypedef{typedef typename Map_overlay::Subdivision  Subdivision;}
  {the subdivision presenting the overlay and the two input subdivisions.}
  %\ccGlue
  %\ccTypedef{typedef typename Map_overlay::Change_notification  Change_notification;}
  %{the notifier class of the overlay induced by the two input subdivisions.}
  %\ccGlue
  %\ccTypedef{typedef typename Map_overlay::Map_overlay_algorithm  Map_overlay_algorithm;}
  %{the algorithm for constructing the overlay induced by the two input subdivisions.}
  
\ccCreation
  \ccCreationVariable{bops}
    
  \ccConstructor{Boolean_operations<Map_overlay>();} {constructs an
     ``empty boolean operations'' object of two ``empty input subdivisions'', 
     each of which contains one unbounded face, which corresponds to the entire plane.}
  
  \ccConstructor{Boolean_operations(<Map_overlay>(const Subdivision & s1,const Subdivision & s2);}
  {constructs a boolean operations object out of two planar subdivisions;}
  
  \ccConstructor{Boolean_operations(<Map_overlay>(const Self & bops);}{copy constructor;}

\begin{ccAdvanced}

\ccHeading{Empolying Map-Overlay}

A Boolean Operation object can be constructed out of a Map Overlay object.
In this case, users may construct a Map Overlay object out of two input subdivision, 
where the a choice of the notifier class, the overlay construction algorithm, or the point location strategy 
can be taken, as described in \ccRefPage{CGAL::MapOverlay<Subdivision,Notifier>}. 
When constructing a Boolean Operation object out of two input subdivision, as described above,
the Map Overlay object maintained in the \ccClassTemplateName\ class,
is contructed, when taking the default notifier class, overlay construction algorithm and point location.
As described in~\ref{Ovl_Ref_intro}, the default choices are not always 
the most efficient. Hence, users may provide their own Map Overlay object, defined under the optimal choices, 
and then, they may construct the Boolean Operations object defined over their Map Overlay object. 

\ccConstructor{Boolean_operations(<Map_overlay>(const Map_overlay& ovl>);}
{constructs a boolean operations object from $ovl$;}

\end{ccAdvanced}
%\ccThree{Halfedge_handle}{}{\hspace*{11cm}}

The boolean operations class defines an assignment operator:

\ccMethod{const Self& operator=(const Self& bops);}{}

The \ccClassTemplateName\ class contains methods performing 
boolean operations of the input subdivisions.
In each such method, we return, as output, all vertices, halfedge, and faces 
contained in the subdivision, insuced by the boolean operation performed 
on the two input subdivisions. All these three output paramerters are optional 
in our methods.

\ccMethod{void intersection (Faces_container& list_of_faces,
   Halfedges_container& list_of_halfedges, 
   Vertices_container& list_of_vertices) const;}
{returns all vertices, halfedges and faces in the intersection of the two input subdivisions.}

\ccMethod{void Union (Faces_container& list_of_faces,
   Halfedges_container& list_of_halfedges, 
   Vertices_container& list_of_vertices) const;}
{returns all vertices, halfedges and faces in the union of the two input subdivisions.}

\ccMethod{void  symmetric_difference (Faces_container& list_of_faces,
   Halfedges_container& list_of_halfedges, 
   Vertices_container& list_of_vertices) const;}
{returns all vertices, halfedges and faces in the symmetric difference of the two input subdivisions.}

\ccMethod{void  difference (Faces_container& list_of_faces,
   Halfedges_container& list_of_halfedges, 
   Vertices_container& list_of_vertices,
   bool first = true) const;}
{returns all vertices, halfedges and faces in the difference of the two input subdivisions.
   if $first$ is set to $true$, then the difference is computed as the first input subdivision 
   minus the second one. Otherwise, the difference is computed vise versa}

\ccSeeAlso
\ccc{MapOverlay<Subdivision>}\lcTex{ 
   (\ccRefPage{CGAL::MapOverlay<Subdivision,Notifier>})}

\end{ccRefClass}

% FILL IN THE REST OF THE FILES
% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+






