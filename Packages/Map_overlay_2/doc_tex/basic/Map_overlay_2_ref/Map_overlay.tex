% +------------------------------------------------------------------------+
% | Reference manual page: Map_overlay.tex (Map_overlay)
% +------------------------------------------------------------------------+
% | 
% | Package: ovl (Map_overlay_2)
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


% +========================================================================+
%   Map Overlay
% +========================================================================+
\begin{ccRefClass}{Map_overlay_2<Subdivision,Notifier>}
\label{OVL_sec:ovl}
    
\ccDefinition
An object $ovl$ of the class \ccClassTemplateName\ is the 
overlay of two given creators.
The \ccc{Notifier} type is \ccc{Map_overlay_default_notifier<Subdivision>} by default.
The available subdivisions and notifier classes are described bellow. 
\ccc{Self} is an abbreviation of the \ccRefName\ type hereafter.

\ccInclude{CGAL/Map_overlay_2.h}

%\ccThree{Planar_map_2<Dcel,Traits> :: Traits}{}{\hspace*{6cm}}
%\ccThreeToTwo

\ccTypes

%  \ccTypedef{typedef Planar_map_2<Dcel,Traits> Self;}{planar map class}

  \ccNestedType{Subdivision}{subdivision type.}
  \ccGlue
  \ccNestedType{Change_notification}{notifier type.}

  \ccHtmlNoLinksFrom{
  The \ccStyle{Map Overlay} \ccc{Vertex}, \ccc{Halfedge} and \ccc{Face}
  types of are defined as part of the overlay DCEL, 
  and are built on top of the planar map vertex, halfedge and face 
  correspondingly. 
  The \ccStyle{Map Overlay} Vertex, Halfedge and Face have additional 
  attributes and functionality, 
  each of which updating or returning the corresponding pointers 
  to the creator components.} % ccHtmlNoLinksFrom
  See concepts \ccc{MapOverlayDcel_2}\lcTex{ (\ccRefPage{MapOverlayDcel_2})},
  \ccc{MapOverlayDcelVertex_2} \lcTex{(\ccRefPage{MapOverlayDcelVertex_2})},
  \ccc{MapOverlayDcelHalfedge_2} \lcTex{(\ccRefPage{MapOverlayDcelHalfedge_2})} 
  and \ccc{MapOverlayDcelFace_2} 
  \lcTex{(\ccRefPage{MapOverlayDcelFace_2})}. 

  \ccHtmlNoLinksFrom{
  \ccNestedType{Vertex}{overlay vertex type.}}
  \ccGlue
  \ccHtmlNoLinksFrom{
  \ccNestedType{Halfedge}{overlay halfedge type.}}
  \ccGlue
  \ccHtmlNoLinksFrom{
  \ccNestedType{Face}{overlay face type.}}


  \ccTypedef{typedef typename Subdivision::Traits::X_curve_2 X_curve_2;}
  {overlay curve type.}
  \ccGlue
  \ccTypedef{typedef typename Subdivision::Traits::Point_2 Point_2;}
  {overlay point type.}


%    \ccNestedType{Vertex}{Represents a vertex of the planar-map.}
%    \ccNestedType{Halfedge}{Represents an half-edge of the planar-map.}
%    \ccNestedType{Face}{Represents a face of the planar-map.}
    
%    \ccNestedType{Vertex_iterator}{A bidirectional iterator over the
%       vertices of the planar-map. Its value-type is
%       \ccStyle{Vertex}.}
%     
%    \ccNestedType{Halfedge_iterator}{A bidirectional iterator over the
%       halfedges of the planar-map.  Its value-type is \ccStyle{Halfedge}.}
%    
%    \ccNestedType{Face_iterator}{A bidirectional iterator over the
%       faces of the planar-map.  Its value-type is \ccStyle{Face}.}
%    
%    \ccNestedType{Ccb_halfedge_circulator}{A forward circulator over the
%       edges of a CCB (connected components of the boundary).  Its
%       value-type is \ccStyle{Halfedge}.}
%    
%    \ccNestedType{Halfedge_around_vertex_circulator}{A forward circulator over
%       the half-edges which have  the vertex as their source .  
%       The half-edges are traversed in
%       their clockwise order around the vertex. Its value-type is
%       \ccStyle{Halfedge}.}
%    
%    \ccNestedType{Holes_iterator}{A bidirectional iterator to
%       traverse all the holes ( i.e., inner CCBs ) of a face 
%       (\ccStyle{Holes_iterator++}{} is the next hole in the face).
%       Its value type is
%       \ccStyle{Ccb_halfedge_circulator}.}
    
%\def\ccLongParamLayout{\ccTrue}

\ccCreation
  \ccCreationVariable{ovl}
    
  \ccConstructor{Map_overlay_2<Subdivision,Notifier>();} {constructs an
     ``empty map-overlay object'' of two ``empty creators'', each of which 
     contains one unbounded face, which corresponds to the whole plane.}
  
  \ccConstructor{Map_overlay_2<Subdivision,Notifier>(const Subdivision & s);}
  {a converter between a subdivision and overlay;}
  
  \ccConstructor{Map_overlay_2<Subdivision,Notifier>(const Self & ovl1,const Self& ovl2);}
  {constructs an overlay out of the two creators given in \ccStyle{ovl1} and \ccStyle{ovl2};}
  
  \ccConstructor{Map_overlay_2<Subdivision,Notifier>(const Self & ovl);}{copy constructor;}

The \ccClassTemplateName\ class defines an assignment operator.

%\ccMethod{const Self& operator=(const Self& ovl);}{}
%\ccThree{Halfedge_handle}{}{\hspace*{11cm}}


The map-overlay user may need to access the subdivision induced by the 
overlay. 
For example, users may want to traverse the overlay components, 
and check which of the creators components are laying above each 
such component.
%When performing boolean operations in this package,
%we make such traversals in order to decide whether a component 
%is reported.
%The function returning the subdivision is given below, 
%note that the returned pointers are \ccc{const} so
%the users cannot change the internal state.

\ccMethod{const Subdivision&  subdivision ();}
{returns a const pointer to the subdivision induced by the overlay.}

                                %For some applications the users may want to have direct access to
                                %the creators and the notifier. For this, we have implemented the 
                                %following functions, note that the returned pointers are \ccc{const} so the users cannot change the internal state.

\ccMethod{const Self&  first_creator ();}
{returns a const reference to the first creator of the overlay.}

\ccMethod{const Self&  second_creator ();}
{returns a const reference to the second creator of the overlay.}

\ccMethod{const Change_notification*  change_notification();}
{returns a const pointer to the notifier of the overlay.}

\begin{ccAdvanced}

\ccHeading{Employing Point-Location, Construction-Algorithm and Notifier}

As described in the introduction, in the construction of 
a \ccStyle{Map_Overlay_2} object, users can define 
the following:
(i) The algorithm which constructs of the overlay, 
(ii) the notifier used for updating the overlay and 
(iii) the point location strategy to be used in the subdivision. 
This is done by passing parameters of some overlay-algorithm object, 
a notifier object and some point-location object. 
The algorithm class should be a model of the 
\ccc{MapOverlayAlgorithm_2} concept, the notifier class has be a model 
of the \ccc{MapOverlayNotifier_2} concept, and finally the 
point-location class should be a model of the
\ccc{PlanarMapPointLocation_2} concept. 

The sweep-line algorithm is the default overlay-construction algorithm,
and the \ccc{Map_overlay_default_notifier<Subdivision>} class is the default notifier.
The default point-location strategy is determined according the 
subdivision instance: If the subdivision is a \ccStyle{Planar_map_2}, 
then the default point-location strategy is the randomized trapezoidal 
decomposition strategy, otherwise,
if the chosen subdivision is a \ccStyle{Planar_map_with_intersections_2}, 
then the default point-location strategy is the ``walk along a line'' 
strategy. 
However, users can choose the incremental algorithm as their 
overlay-algorithm, or use the naive point-location 
(trading time for memory efficiency) as their point-location strategy.
In addition, users can implement their own overlay-construction 
algorithm, overlay notifier or point-location algorithm. 
Implementing a new algorithm can be achieved with a class derived 
from the \ccc{Map_overlay_base<Subdivision,Notifier>}. 
In the same manner, defining a new notifier is done by deriving a 
class from the \ccStyle{Subdivision::Change_notification}, which is the 
notifier class defined in the subdivision class.
Finally, implementing a user point-location algorithm is performed by a 
class derived from the \ccc{Point_location_base<Planar_map>}.
The concepts \ccc{MapOverlayAlgorithm_2} 
(\ccRefPage{MapOverlayAlgorithm_2}), 
\ccc{MapOverlayNotifier} (\ccRefPage{MapOverlayNotifier_2}) and 
\ccc{PlanarMapPointLocation_2} (\ccRefPage{PlanarMapPointLocation_2}) 
list the set of requirements of each class.

The following is the list of all constructors of the \ccClassTemplateName
defined by the user parameters, as described above.
  
\ccConstructor{Map_overlay_2 (const Subdivision &arr, 
   Notifier* notifier);}{}
  
\ccConstructor{Map_overlay_2 (const Subdivision &arr, 
   Map_overlay_base<Subdivision,Notifier> *algo);}{}

\ccConstructor{Map_overlay_2 (const Subdivision &arr, 
   Notifier* notifier 
   Map_overlay_base<Subdivision,Notifier> *algo);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Point_location_base<Subdivision> *pl);}{}
  
\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Notifier* notifier);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Notifier* notifier);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Point_location_base<Subdivision>* pl,
   Notifier* notifier);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Map_overlay_base<Subdivision,Notifier> *algo);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Point_location_base<Subdivision>* pl,
   Map_overlay_base<Subdivision,Notifier> *algo);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Notifier* notifier,
   Map_overlay_base<Subdivision,Notifier> *algo);}{}

\ccConstructor{Map_overlay_2 (const Self &ovl1, const Self &ovl2, 
   Point_location_base<Subdivision>* pl,
   Notifier* notifier,
   Map_overlay_base<Subdivision,Notifier> *algo);}{}

\end{ccAdvanced}

\ccSeeAlso
\ccc{Map_overlay_default_notifier<Subdivision>}\lcTex{ 
   (\ccRefPage{CGAL::Map_overlay_default_notifier<Subdivision>})}\\
\ccc{Map_overlay_default_dcel<Traits,Vertex_base,Halfedge_base,Face_base>}\lcTex{ 
   (\ccRefPage{CGAL::Map_overlay_default_dcel<Traits,V,H,F>})}
\ccc{Map_overlay_incremental<Subdivision,Notifier>}\lcTex{ 
   (\ccRefPage{CGAL::Map_overlay_incremental<Subdivision,Notifier>})}
\ccc{Map_overlay_sweep<Subdivision,Notifier>}\lcTex{ 
   (\ccRefPage{CGAL::Map_overlay_sweep<Subdivision,Notifier>})}

\end{ccRefClass}

% FILL IN THE REST OF THE FILES
% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+




