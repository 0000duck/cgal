%% Copyright (c) 2005  Foundation for Research and Technology-Hellas (Greece).
%% All rights reserved.
%%
%% This file is part of CGAL (www.cgal.org); you may redistribute it under
%% the terms of the Q Public License version 1.0.
%% See the file LICENSE.QPL distributed with CGAL.
%%
%% Licensees holding a valid commercial license may use this file in
%% accordance with the commercial license agreement provided with the software.
%%
%% This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
%% WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
%%
%% $Source$
%% $Revision$ $Date$
%% $Name$
%%
%% Author(s)     : Menelaos Karavelas <mkaravel@tem.uoc.gr>

\begin{ccRefFunctionObjectConcept}{EdgeDegeneracyTester}

\ccRefines
\ccc{DefaultConstructible}, \ccc{CopyConstructible}, \ccc{Assignable},
\ccc{AdaptableFunctor} (with two arguments)

\ccTypes

In addition to the types required by the \ccc{AdaptableFunctor}
concept, a model of this concept must provide the following types:


\ccThree{typedef Delaunay_graph::Finite_edges_iterator}
{Finite_edges_iterator}{}
\ccThreeToTwo
\ccNestedType{Delaunay_graph}{A type for the Delaunay graph. It must be
  model of the \ccc{DelaunayGraph_2} concept.}
\ccGlue
\ccTypedef{typedef Delaunay_graph::Edge Edge;}{}
\ccGlue
\ccTypedef{typedef Delaunay_graph::Face_handle Face_handle;}{}
\ccGlue
\ccTypedef{typedef Delaunay_graph::Edge_circulator
  Edge_circulator;}{}
\ccGlue
\ccTypedef{typedef Delaunay_graph::All_edges_iterator
  All_edges_iterator;}{}
\ccGlue
\ccTypedef{typedef Delaunay_graph::Finite_edges_iterator
  Finite_edges_iterator;}{}

\ccCreationVariable{edt}

\ccOperations
%It must also provide the following operations:

\ccThree{bool}{edt(Delaunay_graph dg, Finite_edges_iterator feit)+}{}
\ccThreeToTwo
\ccMemberFunction{bool operator()(Delaunay_graph dg, Edge e);}
{Returns \ccStyle{true}, if the dual edge of \ccc{e} (that
  belongs to the Delaunay graph \ccc{dg}) is
  degenerate, i.e., it has zero length.}
%
\ccMemberFunction{bool operator()(Delaunay_graph dg, Face_hanfle f, int i);}
{Returns \ccStyle{true}, if the dual edge of the edge
  \ccc{(f,i)} (that belongs to the Delaunay graph \ccc{dg}) is
  degenerate, i.e., it has zero length.}
%
\ccGlue
\ccMemberFunction{bool operator()(Delaunay_graph dg, Edge_circulator ec);}
{Returns \ccStyle{true}, if the dual edge of \ccc{*ec} (that
  belongs to the Delaunay graph \ccc{dg}) is
  degenerate, i.e., it has zero length.}
%
\ccGlue
\ccMemberFunction{bool operator()(Delaunay_graph dg, All_edges_iterator aeit);}
{Returns \ccStyle{true}, if the dual edge of \ccc{*aeit} (that
  belongs to the Delaunay graph \ccc{dg}) is
  degenerate, i.e., it has zero length.}
%
\ccGlue
\ccMemberFunction{bool operator()(Delaunay_graph dg,
  Finite_edges_iterator feit);}
{Returns \ccStyle{true}, if the dual edge of \ccc{*feit}  (that
  belongs to the Delaunay graph \ccc{dg}) is
  degenerate, i.e., it has zero length.}



\ccHeading{Miscellaneous}
The following methods are important when the edge degeneracy tester
maintains a state. This can happen if the edge degeneracy tester
caches its results.

\ccThree{bool}{edt.swap(other)++}{}
%
\ccMethod{void clear();}{Clears the state of the tester.}
\ccGlue
\ccMethod{void swap(EdgeDegeneracyTester other);}{The tester
  \ccc{edt} and \ccc{other} are swapped. This method should be
  preferred to \ccStyle{edt=other} or \ccStyle{edt(other)} if
  \ccc{other} is deleted afterwards.}
\ccGlue
\ccMethod{bool is_valid();}{Tests the validity of the tester.}


\ccHasModels
\ccc{CGAL::Apollonius_graph_Voronoi_traits_2<AG2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Apollonius_graph_caching_Voronoi_traits_2<AG2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Apollonius_graph_identity_Voronoi_traits_2<AG2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Delaunay_triangulation_Voronoi_traits_2<DT2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Delaunay_triangulation_caching_Voronoi_traits_2<DT2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Delaunay_triangulation_identity_Voronoi_traits_2<DT2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Regular_triangulation_Voronoi_traits_2<RT2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Regular_triangulation_caching_Voronoi_traits_2<RT2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Regular_triangulation_identity_Voronoi_traits_2<RT2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Segment_Voronoi_diagram_Voronoi_traits_2<SVD2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Segment_Voronoi_diagram_caching_Voronoi_traits_2<SVD2>::Edge_degeneracy_tester}\\
\ccc{CGAL::Segment_Voronoi_diagram_identity_Voronoi_traits_2<SVD2>::Edge_degeneracy_tester}


\ccSeeAlso
\ccc{VoronoiTraits_2}\\
\ccc{FaceDegeneracyTester}\\
\ccc{CGAL::Apollonius_graph_Voronoi_traits_2<AG2>}\\
\ccc{CGAL::Apollonius_graph_caching_Voronoi_traits_2<AG2>}\\
\ccc{CGAL::Apollonius_graph_identity_Voronoi_traits_2<AG2>}\\
\ccc{CGAL::Delaunay_triangulation_Voronoi_traits_2<DT2>}\\
\ccc{CGAL::Delaunay_triangulation_caching_Voronoi_traits_2<DT2>}\\
\ccc{CGAL::Delaunay_triangulation_identity_Voronoi_traits_2<DT2>}\\
\ccc{CGAL::Regular_triangulation_Voronoi_traits_2<RT2>}\\
\ccc{CGAL::Regular_triangulation_caching_Voronoi_traits_2<RT2>}\\
\ccc{CGAL::Regular_triangulation_identity_Voronoi_traits_2<RT2>}\\
\ccc{CGAL::Segment_Voronoi_diagram_Voronoi_traits_2<SVD2>}\\
\ccc{CGAL::Segment_Voronoi_diagram_caching_Voronoi_traits_2<SVD2>}\\
\ccc{CGAL::Segment_Voronoi_diagram_identity_Voronoi_traits_2<SVD2>}

\end{ccRefFunctionObjectConcept}
