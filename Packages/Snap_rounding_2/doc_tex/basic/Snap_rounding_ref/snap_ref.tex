% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  main.tex
% +------------------------------------------------------------------------+
% | snap rounding of line segments
% |
% | 9.4.00   Eli Packer
% | 
\RCSdef{\snapRoundingRev}{$Revision$}
\RCSdefDate{\snapRoundingDate}{$Date$}
% +------------------------------------------------------------------------+

\ccRefPageBegin

%\chapter{Snap Rounding - Reference Manual}
%\label{chapterSnapRoundibgRef}
%\ccChapterRelease\snapRoundingRev. \ \snapRoundingDate\\
%\ccChapterAuthor{Eli Packer}

\begin{ccRefFunction}{snap_rounding_2}

\ccDefinition

Snap rounding is a well known method for converting
arbitrary-precision arrangements of segments into a fixed-precision
representation. It is classified as a finite precision approximation 
technique. Iterated Snap Rounding is a modification of Snap Rounding in
which each vertex is at leat half-the-width-of-a-pixel away from any
non-incident edge.
This package provides supports both methods.

Given a finite collection $\S$ of segments in the plane, the
arrangement of $\S$ denoted $\A(\S)$ is the subdivision of the plane
into vertices, edges, and faces induced by $\S$. %\cite{arrg-surveys}.
A {\it vertex\/} of the arrangement is either a segment endpoint or
the intersection of two segments. Given an arrangement of segments
whose vertices are represented with arbitrary-precision coordinates,
snap rounding (SR, for short) proceeds as follows.  We tile the plane
with a grid of unit squares, {\it pixels}, each centered at a point
with integer coordinates. A pixel is {\it hot\/} if it contains a
vertex of the arrangement. Each vertex of the arrangement is replaced
by the center of the hot pixel containing it and each edge $e$ is
replaced by the polygonal chain through the centers of the hot pixels
met by $e$, in the same order as they are met by $e$.

In a snap-rounded arrangement, the distance between a vertex and
a non-incident edge can be extremely small compared with the width of a
pixel in the grid used for rounding. Iterated Snap Rounding is a modification
of Snap Rounding which makes the a vertex and a non-incident edge well separated
(the distance between each is at least half-the-width-of-a-pixel).
However, the guaranteed quality of the approximation in Iterated Snap Rounding
degrades.

The traits used here must support arbitrary-precision number type as this is a
basic requirement of Snap Rounding.

\ccInclude{CGAL/Snap_rounding_2.h}

\ccGlobalFunction{
  template < class Traits, class InputIterator, class OutputContainer >
  void
  snap_rounding_2(
  InputIterator begin,
  InputIterator end,
  OutputContainer& output_container,
  typename Traits::FT pixel_size,
  bool do_isr = true,
  bool int_output = true,
  unsigned int number_of_kd_trees = 1);}

The first two parameters denote the first and after-the-last iterators of the input segments.
The third parameter is a referrence to a container of the output polylines. Since a polyline
is composed of a sequence of points, a polyline is a container itself.
The forth parameter denotes the pixel size. The fifth parameter determines whether to apply Iterated Snap Rounding
or Snap Rounding. The sixth parameter determines the output representation. If the
parameter value is {\ccc true}, then the output is represented in an integer
grid just as defined by the Snap Rounding algorithm. Note that the number type of
the representation remains {\ccc Traits::FT}. Otherwise, the plane is tiled
with unit pixels with size {\ccc pixel\_size} and each vertice of the output is
represented by the coordinates of the cenetr of the hot pixel that contains it.
The seventh parameter is desribed below.


\ccPrecond{\ccc{pixel_size} must have a positive value.}
\ccPrecond{\ccc{number_of_kd_trees} must be a positive integer.}

\begin{ccAdvanced}

 A basic query used in the algorithm is to report the hot pixels of
 size $w$ that a certain segment $s$ intersects.  An alternative way to
 do the same is to query the hot pixels' centers contained in a
 Minkowski sum of $s$ with a pixel of width $w$ centered at the origin;
 we denote this Minkowski sum by $M(s)$. Since efficiently implementing
 this kind of query is difficult, we use an orthogonal range-search
 structure instead. We query with the bounding box $B(M(s))$ of $M(s)$
 in a two-dimensional kd-tree which stores the centers of hot
 pixels. Since $B(M(s))$ in general is larger than $M(s)$, we still
 need to filter out the hot pixels which do not intersect $s$.

 While this approach is easy to implement with CGAL, it may incur
 considerable overhead since the area of $B(M(s))$ may be much larger
 than $M(s)$, possibly resulting in many redundant hot pixels to filter
 out. Our heuristic solution, which we describe next, is to use a
 cluster of kd-trees rather than just one.  The cluster includes
 several kd-trees, each has the plane, and hence the centers of hot
 pixels, rotated by a different angle in the first quarter of the
 plane; for our purpose, rotation by other angles are symmetric to a
 rotation by an angle in the first quarter.

 Given a parameter $c$, the angles of rotation are $(i - 1)
 \frac{\pi}{2c}, i=1,\ldots,c$, and we construct a kd-tree
 corresponding to each of these angles. Then for a query segment $s$,
 we choose the kd-tree for which the area of $B(M(s))$ is the smallest,
 in order to (potentially) get less hot pixels to filter out.  Since
 constructing many kd-trees may be costly, our algorithm avoids
 building a kd-tree which it expects to be queried a relatively small
 number of times (we estimate this number in advance).  How many
 kd-trees should be used?  It is difficult to provide a simple
 answer for that.  There are inputs for which the time to build more
 than one kd-tree is far greater than the time saved by having to
 filter out less hot pixels (sparse arrangements demonstrate this
 behavior), and there are inputs which benefit from using several
 kd-trees. Thus, the user can control the number of kd-trees
 with the parameter \ccc{number_of_kd_trees}. Typically, but not
 always, one kd-tree (the default) is sufficient.

\end{ccAdvanced}

\end{ccRefFunction}
%\end{ccRefClass}

% +--------------------------------------------------------+

% EOF
