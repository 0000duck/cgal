% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  main.tex
% +------------------------------------------------------------------------+
% | snap rounding of line segments
% |
% | 9.4.00   Eli Packer
% | 
\RCSdef{\snapRoundingRev}{$Revision$}
\RCSdefDate{\snapRoundingDate}{$Date$}
% +------------------------------------------------------------------------+

\chapter{Snap Rounding - Reference Manual}
\label{chapterSnapRoundibgRef}
\ccChapterRelease\snapRoundingRev. \ \snapRoundingDate\\
\ccChapterAuthor{Eli Packer}


\section*{Summary}

Snap rounding is a well known method for converting
arbitrary-precision arrangements of segments into a fixed-precision
representation. It is classified as a finite precision approximation 
technique. Iterated Snap Rounding is a modification of Snap Rounding in
which each vertex is at leat half-the-width-of-a-pixel away from any
non-incident edge.
This package provides supports both methods.

Given a finite collection $\S$ of segments in the plane, the
arrangement of $\S$ denoted $\A(\S)$ is the subdivision of the plane
into vertices, edges, and faces induced by $\S$. %\cite{arrg-surveys}.
A {\it vertex\/} of the arrangement is either a segment endpoint or
the intersection of two segments. Given an arrangement of segments
whose vertices are represented with arbitrary-precision coordinates,
snap rounding (SR, for short) proceeds as follows.  We tile the plane
with a grid of unit squares, {\it pixels}, each centered at a point
with integer coordinates. A pixel is {\it hot\/} if it contains a
vertex of the arrangement. Each vertex of the arrangement is replaced
by the center of the hot pixel containing it and each edge $e$ is
replaced by the polygonal chain through the centers of the hot pixels
met by $e$, in the same order as they are met by $e$.

In a snap-rounded arrangement, the distance between a vertex and
a non-incident edge can be extremely small compared with the width of a
pixel in the grid used for rounding. Iterated Snap Rounding is a modification
of Snap Rounding which makes the a vertex and a non-incident edge well separated
(the distance between each is at least half-the-width-of-a-pixel).
However, the guaranteed quality of the approximation in Iterated Snap Rounding
degrades.

%\begin{ccRefClass}{Isr<NT>}

\subsection*{Definition}
\ccInclude{CGAL/Snap_rounding_2.h}

\ccTypedef{typedef typename std::list<Segment_2> Segments_container;}{The segments container.}
\ccTypedef{typedef typename std::list<std::list<CGAL::Point_2<Rep> > > Polylines_container;}{The polylines output container}
\ccTypedef{typedef typename std::list<CGAL::Point_2<Rep> > Points_container;}{The polyline points container.}
\ccTypedef{typedef Segments_container::const_iterator Segment_const_iterator;}{A constant iterator of segments.}
\ccTypedef{typedef Segments_container::const_iterator Segment_iterator;}{An iterator of segments.}
\ccTypedef{typedef Polylines_container::const_iterator Polyline_const_iterator;}{A constant iterator of polylines output.}
\ccTypedef{typedef Segments_container::const_iterator Segment_iterator;}{An iterator of segments.}

\ccParameters
The template declaration of the \ccc{Snap_rounding_2} function has one parameter:

\ccCreation
    \ccCreationVariable{Snap_rounding_2}

\ccConstructor{snap_rounding(typename std::list<Segment_2>::const_iterator first,typename std::list<Segment_2>::const_iterator beyond,NT pixel_size,bool do_isr = true,bool use_integer_mode = true, int number_of_kd_trees = 1);}{
The first two parameters denote the first and after-the-last iterators of a list of Segment\_2 which are the input of Snap Rounding.
The third parameter denotes the pixel size. The forth parameter determines whether to apply Iterated Snap Rounding
or Snap Rounding. The fifth parameter determines the output representation. If the
parameter value is {\ccc true}, then the output is represented in an integer
grid just as defined by the Snap Rounding algorithm. Note that the number type of
the representation remains {\ccc NT}. Otherwise, the plane is tiled
with unit pixels with size {\ccc pixel\_size} and each vertice of the output is
represented by the coordinates of the cenetr of the hot pixel that contains it.
The sixth parameter denotes the number of KD trees to use (see \cite{isr-2002} for details).
The default, $1$, is ussually the best one to use.
}

\ccAccessFunctions

\ccMethod{Snap_rounding_2<Rep>::Segment_const_iterator segments_begin() const;}{
Returns a constant iterator to the first input segment.
}

\ccMethod{Snap_rounding_2<Rep>::Segment_const_iterator segments_end() const;}{
Returns a constant iterator to the after-the-last of the input segments.
}

\ccMethod{Snap_rounding_2<Rep>::Segment_iterator segments_begin(); }{
Returns an iterator to the first input segment.
}

\ccMethod{Snap_rounding_2<Rep>::Segment_iterator segments_end(); }{
Returns an iterator to the after-the-last of the input segments.
}

\ccMethod{Snap_rounding_2<Rep>::Polyline_const_iterator polylines_begin(); }{
Returns a constant iterator to the output of the first input segment.
}

\ccMethod{Snap_rounding_2<Rep>::Polyline_const_iterator polylines_end(); }{
Returns a constant iterator to the after-the-last of the output of the input segments.
}

\ccHeading{Insertion}

\ccMethod{void 
  insert(const Segment_2& s);}
{Inserts segment \ccc{s} in the segment set.}

\ccMethod{void 
  push_back(const Segment_2& s);}
{The STL standard member function for insertion.}

\ccMethod{template < class InputIterator >
          int
          insert(InputIterator first, InputIterator last);}
{Inserts the segments in the range $\left[\right.$\ccc{first},
\ccc{last}$\left.\right)$.  Returns the number of inserted segments. \\ \\
\ccRequirements The \ccc{value_type} of \ccc{first} and \ccc{last} is \ccc{Segment}.}

\ccHeading{Removal}

\ccMethod{bool remove(const Segment_2& p);}{Removes segment \ccc{s}.
Returns false iff \ccc{s} is not in the segment set. }

\ccMethod{void clear();}
{Removes all segments.}

\ccHeading{Parameter Updates}

\ccMethod{void do_isr(bool b);}
{Determine whether to apply Iterated Snap Rounding (when \ccc{b} is true),
or Snap Rounding (when \ccc{b} is false).}

\ccMethod{bool set_pixel_size(NT pixel_size);}
{set the pixel size.
Return false if the size is not valid (e.g. negative). }

\ccMethod{bool use_integer_mode(bool b);}
{Determine which mode of output representation to use (see the explanation of
the first constructor for details).}

\ccMethod{bool set_number_of_kd_trees(unsigned int number_of_kd_trees);}
{Set the number of kd-trees used for segment-hot pixel queries.
Return false if the number is not valid (e.g. negative). }

%\end{ccRefClass}

% +--------------------------------------------------------+

% EOF
