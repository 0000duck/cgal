% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  main.tex
% +------------------------------------------------------------------------+
% | snap rounding of line segments
% |
% | 9.4.00   Eli Packer
% | 
\RCSdef{\snapRoundingRev}{$Revision$}
\RCSdefDate{\snapRoundingDate}{$Date$}
% +------------------------------------------------------------------------+

\chapter{Snap Rounding - Reference Manual}
\label{chapterSnapRoundibgRef}
\ccChapterRelease\snapRoundingRev. \ \snapRoundingDate\\
\ccChapterAuthor{Eli Packer}


\section*{Summary}

Snap rounding is a well known method for converting
arbitrary-precision arrangements of segments into a fixed-precision
representation. It is classified as a finite precision approximation 
technique. This package makes Snap Rounding of line segments in $\reals_2$.
It is based on the paper 'Snap Rounding Revisited' which provides a modification
to Snap Rounding named Iterated Snap Rounding. This package provides both
Iterated Snap Rounding and the usual Snap Rounding which is a private case.
For details we refer you to the article.\\ \\

Given a finite collection $\S$ of segments in the plane, the
arrangement of $\S$ denoted $\A(\S)$ is the subdivision of the plane
into vertices, edges, and faces induced by $\S$. %\cite{arrg-surveys}.
A {\it vertex\/} of the arrangement is either a segment endpoint or
the intersection of two segments. Given an arrangement of segments
whose vertices are represented with arbitrary-precision coordinates,
snap rounding (SR, for short) proceeds as follows.  We tile the plane
with a grid of unit squares, {\it pixels}, each centered at a point
with integer coordinates. A pixel is {\it hot\/} if it contains a
vertex of the arrangement. Each vertex of the arrangement is replaced
by the center of the hot pixel containing it and each edge $e$ is
replaced by the polygonal chain through the centers of the hot pixels
met by $e$, in the same order as they are met by $e$.

Since in a snap-rounded arrangement, the distance between a vertex and
a non-incident edge can be extremely small compared with the width of a
pixel in the grid used for rounding, this package provides, beside the
usual Snap Rounding, a modification of it, named Iterated Snap Rounding,
which makes the a vertex and a non-incident edge well separated.

%\begin{ccRefClass}{Isr<NT>}

\subsection*{Definition}
\ccInclude{CGAL/Snap_rounding_2.h}

\ccTypedef{typedef typename std::list<Segment_2> Segments_container;}{The segments container.}
\ccTypedef{typedef typename std::list<std::list<CGAL::Point_2<Rep> > > Polylines_container;}{The polylines output container}
\ccTypedef{typedef Segments_container::const_iterator Segment_const_iterator;}{a constant iterator of segments.}
\ccTypedef{typedef Segments_container::const_iterator Segment_iterator;}{an iterator of segments.}
\ccTypedef{typedef Polylines_container::const_iterator Polyline_const_iterator;}{a constant iterator of polylines output.}
\ccTypedef{typedef Segments_container::const_iterator Segment_iterator;}{an iterator of segments.}
\ccTypedef{typedef typename std::list<CGAL::Point_2<Rep> > Points_container;}{A polyline points container.}

\ccParameters
The template declaration of the \ccc{Snap_rounding_2} function has one parameter:

\ccCreation
    \ccCreationVariable{Snap_rounding_2}

\ccConstructor{snap_rounding(typename std::list<Segment_2>::const_iterator first,typename std::list<Segment_2>::const_iterator beyond,NT precision,bool inp_do_isr = true,int 
inp_number_of_kd_trees = 5);}{
The first two parameters denote the first and after-the-last iterators of a list of Segment\_2 which are the input of {\em Isr}.
The third parameter denotes the precision of the Isr. The forth parameter determines whether to do an Iterated Snap Rounding
or a Snap Rounding. The forth parameter denotes the number of KD trees to use (see [Snap Rounding Revisited] for more details on
this issue).
}

\ccConstructor{snap_rounding(NT precision,bool inp_do_isr = true,int 
inp_number_of_kd_trees = 5);}{
The same as the constructor above but here the instance is initialized with no segments.
}

\ccConstructor{snap_rounding(const snap_rounding &other);}{
Copy constructor
}

\ccOperations
\ccHeading{Assignment}

\ccMethod{snap_rounding
	operator=(const snap_rounding & s);}
{}

\ccAccessFunctions

\ccMethod{Snap_rounding_2<Rep>::Segment_const_iterator segments_begin() const;}{
Returns a constant iterator to the first input segment.
}

\ccMethod{Snap_rounding_2<Rep>::Segment_const_iterator segments_end() const;}{
Returns a constant iterator to the after-the-last of the input segments.
}

\ccMethod{Snap_rounding_2<Rep>::Segment_iterator segments_begin(); }{
Returns an iterator to the first input segment.
}

\ccMethod{Snap_rounding_2<Rep>::Segment_iterator segments_end(); }{
Returns an iterator to the after-the-last of the input segments.
}

\ccMethod{Snap_rounding_2<Rep>::Polyline_const_iterator polylines_begin(); }{
Returns a constant iterator to the output of the first input segment.
}

\ccMethod{Snap_rounding_2<Rep>::Polyline_const_iterator polylines_end(); }{
Returns a constant iterator to the after-the-last of the output of the input segments.
}

\ccHeading{Insertion}

\ccMethod{void 
  insert(const Segment_2& s);}
{Inserts segment \ccc{s} in the segment set.}

\ccMethod{void 
  push_back(const Segment_2& s);}
{The STL standard member function for insertion.}

\ccMethod{template < class InputIterator >
          int
          insert(InputIterator first, InputIterator last);}
{Inserts the segments in the range $\left[\right.$\ccc{first},
\ccc{last}$\left.\right)$.  Returns the number of inserted segments. \\ \\
\ccRequirements The \ccc{value_type} of \ccc{first} and \ccc{last} is \ccc{Segment}.}

\ccHeading{Removal}

\ccMethod{bool remove(const Segment_2& p);}{Removes segment \ccc{s}.
Returns false iff \ccc{s} is not in the segment set. }

\ccMethod{void clear();}
{Removes all segments of \ccVar.}

\ccHeading{Parameter Updates}

\ccMethod{bool change_number_of_kd_trees(int number_of_kd_trees);}
{Change the number of kd-trees used for segment-hot pixel queries.
Return false if the number is not valid (e.g. negative). }

\ccMethod{bool change_pixel_size(NT pixel_size);}
{Change the pixel size of the tiling.
Return false if the size is not valid (e.g. negative). }

\ccMethod{void do_isr(bool b);}
{Determine whether to apply Iterated Snap Rounding (when \ccc{b} is true),
or Snap Rounding (when \ccc{b} is false).}


%\end{ccRefClass}

% +--------------------------------------------------------+

% EOF
