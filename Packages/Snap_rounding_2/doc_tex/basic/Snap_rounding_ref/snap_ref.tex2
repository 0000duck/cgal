% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  main.tex
% +------------------------------------------------------------------------+
% | snap rounding of line segments
% |
% | 9.4.00   Eli Packer
% | 
\RCSdef{\snapRoundingRev}{$Revision$}
\RCSdefDate{\snapRoundingDate}{$Date$}
% +------------------------------------------------------------------------+

\chapter{Line Segments Snap Rounding - Reference Manual}
\label{chapterSnapRoundibgRef}
\ccChapterRelease\snapRoundingRev. \ \snapRoundingDate\\
\ccChapterAuthor{Eli Packer}


\section*{Summary}

Snap rounding is a well known method for converting
arbitrary-precision arrangements of segments into a fixed-precision
representation. It is classified as a finite precision approximation 
technique. This package makes Snap Rounding of line segments in $\reals_2$.
It is based on the paper 'Snap Rounding Revisited' which provides a modification
to Snap Rounding named Iterated Snap Rounding. This package provides both
Iterated Snap Rounding and the usual Snap Rounding which is a private case.
For details we refer you to the article.\\ \\

Given a finite collection $\S$ of segments in the plane, the
arrangement of $\S$ denoted $\A(\S)$ is the subdivision of the plane
into vertices, edges, and faces induced by $\S$. %\cite{arrg-surveys}.
A {\it vertex\/} of the arrangement is either a segment endpoint or
the intersection of two segments. Given an arrangement of segments
whose vertices are represented with arbitrary-precision coordinates,
snap rounding (SR, for short) proceeds as follows.  We tile the plane
with a grid of unit squares, {\it pixels}, each centered at a point
with integer coordinates. A pixel is {\it hot\/} if it contains a
vertex of the arrangement. Each vertex of the arrangement is replaced
by the center of the hot pixel containing it and each edge $e$ is
replaced by the polygonal chain through the centers of the hot pixels
met by $e$, in the same order as they are met by $e$.

Since in a snap-rounded arrangement, the distance between a vertex and
a non-incident edge can be extremely small compared with the width of a
pixel in the grid used for rounding, this package provides, beside the
usual Snap Rounding, a modification of it, named Iterated Snap Rounding,
which makes the a vertex and a non-incident edge well seperated.

\begin{ccRefClass}{Isr<NT>}

\subsection*{Definition}
\ccInclude{CGAL/Isr_2.h}

\ccParameters
The template declaration of the \ccc{Isr} function has one parameter:

\ccCreation
    \ccCreationVariable{sr}


\ccConstructor{Arrangement_2<Dcel,Traits,Base_node>();}{create an empty arrangement with the default point location strategy.}

\ccConstructor{Arrangement_2<Dcel,Traits,Base_node>();}{create an empty arrangement with the default point location strategy.}

\ccConstructor{Arrangement_2<Dcel,Traits,Base_node>();}{
The first two parameters denote the first and after-the-last iterators of a list of Segment_2 which are the input of.
}

\ccConstructor{snap_rounding(typename std::list<Segment_2>::const_iterator first, \
               typename std::list<Segment_2>::const_iterator beyond,NT precision, \
               bool inp_do_isr = true,int inp_number_of_kd_trees = 5);}{
The first two parameters denote the first and after-the-last iterators of a list of Segment_2 which are the input of {\em Isr}.
The third parameter denotes the precision of the Isr. The forth parameter determines whether to do an Iterated Snap Rounding
or A Snap Rounding.The forth parameter denotes the number of KD trees to use (see [Snap Rounding Revisited] for more details on
this issue).
}

%\ccConstructor{ typename std::list<list<Point_2> >::const_iterator begin() }{
%
%Returns an iterator to the output of the first input segment.
%}
% 
%\ccConstructor{ typename std::list<list<Point_2> >::const_iterator end() }{
%
%Returns an iterator to the after-the-last of the output of the input segments.
%}

\end{ccRefClass}

% +--------------------------------------------------------+

% EOF
