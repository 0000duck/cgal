#include <iostream>

#ifndef CGAL_USE_LEDA
int main()
{

  std::cout << "Sorry, this demo needs LEDA for visualisation.";
  std::cout << std::endl;

  return 0;
}

#else

#include <fstream>
#include <CGAL/Cartesian.h>
#include <CGAL/Segment_2.h>
#include <CGAL/Iso_rectangle_2.h>
#include <CGAL/squared_distance_2.h>
#include <CGAL/Polygon_2.h>
#include <CGAL/IO/Window_stream.h>
//#include <CGAL/IO/cgal_window_redefine.h>
#include "../../include/CGAL/Snap_rounding_2_traits.h"
#include "../../include/CGAL/Snap_rounding_2_mine.h"

typedef leda_rational                                  Number_Type;
typedef CGAL::Cartesian<Number_Type>                   Rep;
typedef Rep::Point_2                                   Local_point_2;
typedef Rep::Segment_2                                 Local_segment_2;
typedef CGAL::Snap_rounding_traits<Rep>                Sr_traits;
typedef CGAL::Snap_rounding_2<Sr_traits>               Snap_rounding_2;
typedef Snap_rounding_2::Segment_2                     Segment_2;
typedef Snap_rounding_2::Point_2                       Point_2;
typedef Snap_rounding_2::Segment_iterator              Segment_iterator;
typedef Snap_rounding_2::Polyline_const_iterator       Polyline_const_iterator;
typedef Snap_rounding_2::Point_const_iterator          Point_const_iterator;
typedef CGAL::Iso_rectangle_2<Rep>                     Iso_rectangle_2;
typedef CGAL::Window_stream                            Window_stream;

#define MIN_X 0
#define MIN_Y 0
#define MAX_X 50
#define MAX_Y 50
#define PRECISION 0.5
#define DEF_DELTA 1

Number_Type min(const Number_Type &p,const Number_Type &q,Number_Type &r)
{
  return(p > q ? min(q,r) : min(p,r));
}

Number_Type max(const Number_Type &p,const Number_Type &q,const Number_Type &r)
{
  return(p > q ? max(p,r) : max(q,r));
}

void get_extreme_points(std::list<Segment_2> &seg_list,
                        Number_Type &min_x,
                        Number_Type &min_y,
                        Number_Type &max_x,
                        Number_Type &max_y)
{
  std::list<Segment_2>::iterator iter = seg_list.begin();

  min_x = min(iter->source().x(),iter->target().x());
  max_x = max(iter->source().x(),iter->target().x());
  min_y = min(iter->source().y(),iter->target().y());
  max_y = max(iter->source().y(),iter->target().y());
   
  for(++iter;iter != seg_list.end();++iter) {
    min_x = min(iter->source().x(),iter->target().x(),min_x);
    max_x = max(iter->source().x(),iter->target().x(),max_x);
    min_y = min(iter->source().y(),iter->target().y(),min_y);
    max_y = max(iter->source().y(),iter->target().y(),max_y);
  }
}

void show_results(Snap_rounding_2 &s,
                 Number_Type prec,
                 CGAL::Window_stream &w,
                 bool show_hp,
                 bool show_output)
{
  // draw isr polylines
  for(Polyline_const_iterator i = s.polylines_begin();
      i != s.polylines_end();
      ++i) {
    Point_const_iterator prev = i->begin();
    Point_const_iterator i2 = prev;
    bool seg_painted = false;

    if(show_hp)
      w << CGAL::GREEN << Iso_rectangle_2(Point_2(i2->x() - prec / 2.0,
					          i2->y() - prec / 2.0),
                                          Point_2(i2->x() + prec / 2.0,
					          i2->y() + prec / 2.0));
    for(++i2;
        i2 != i->end();
        ++i2) {
      seg_painted = true;
      if(show_output)
        w << CGAL::RED << Segment_2(*prev,*i2);
      if(show_hp)
        w << CGAL::GREEN << Iso_rectangle_2(Point_2(i2->x() - prec / 2.0,
					            i2->y() - prec / 2.0),
                                            Point_2(i2->x() + prec / 2.0,
					            i2->y() + prec / 2.0));
      prev = i2;
    }

    if(!seg_painted && show_output) // segment entirely inside hot pixel
      w << CGAL::RED << *(i->begin());
  }
}

void display_bounding_box(CGAL::Window_stream &W,
                          const Iso_rectangle_2 &b,
                          bool display_bbox)
{
  //  if(display_bbox)
    W << CGAL::BLACK << b;
}

void window_output(Snap_rounding_2 &s,Window_stream &w,
                   Number_Type prec,
                   bool wait_for_click)
{
  w << CGAL::BLACK;

  // draw original segments
  for(Segment_iterator i1 = s.segments_begin();
      i1 != s.segments_end();
      ++i1)
    w << *i1;

  // draw isr polylines
  double x,y;
  for(Polyline_const_iterator i = s.polylines_begin();
      i != s.polylines_end();
      ++i) {
    if(wait_for_click)
      w.read_mouse(x,y);
    Point_const_iterator prev = i->begin();
    Point_const_iterator i2 = prev;
    bool seg_painted = false;
    w << CGAL::GREEN << Iso_rectangle_2(Point_2(i2->x() - prec / 2.0,
					        i2->y() - prec / 2.0),
                                        Point_2(i2->x() + prec / 2.0,
					        i2->y() + prec / 2.0));
    for(++i2;
        i2 != i->end();
        ++i2) {
      seg_painted = true;
      w << CGAL::RED << Segment_2(*prev,*i2);
      w << CGAL::GREEN << Iso_rectangle_2(Point_2(i2->x() - prec / 2.0,
					          i2->y() - prec / 2.0),
                                          Point_2(i2->x() + prec / 2.0,
					          i2->y() + prec / 2.0));
      prev = i2;
    }
    if(!seg_painted) // segment entirely inside hot pixel
      w << *(i->begin());
  }

  int mouse_input;
  while(true) {
    mouse_input = w.read_mouse(x,y);
    if(mouse_input == 1)
      return;
  }
}

void read_data(int argc,
               char *argv[],
               Number_Type &prec,
               std::list<Segment_2> &seg_list,
               // @@@@
               Number_Type& delta)
{
  int number_of_segments,i;
  CGAL::Segment_data<Rep> seg;
  Number_Type x1,y1,x2,y2;

  std::ifstream is(argv[1]);

  if(is.bad()) {
    std::cerr << "Bad input file : " << argv[1] << std::endl;
    exit(1);
  }

  is >> number_of_segments;

  is >> prec;

  if(number_of_segments < 1) {
    std::cerr << "Bad input file(number of segments)" << argv[2] << std::endl;
    exit(1);
  }

  for(i = 0;i < number_of_segments;++i) {
      is >> x1;
      is >> y1;
      is >> x2;
      is >> y2;
      seg_list.push_back(Segment_2(Point_2(x1,y1),
                                   Point_2(x2,y2)));
  }

  // @@@@
  delta = Number_Type(argv[2]);
}

void clear(Snap_rounding_2 &s,
           CGAL::Window_stream &W,
           const Iso_rectangle_2 &b,
           bool display_bbox)
{
  s.clear();

  W.clear();

  //  display_bounding_box(W,b,display_bbox);
}

void redraw(Snap_rounding_2 &s,
            CGAL::Window_stream &W,
            const Iso_rectangle_2 &b,
            bool show_input,
            bool display_bbox)
{
  W.clear();

  //  display_bounding_box(W,b,display_bbox);

  if(show_input) {
    W << CGAL::BLACK;
    for(Segment_iterator i1 = s.segments_begin();
        i1 != s.segments_end();
        ++i1)
      W << *i1;
  }
}

int main(int argc,char *argv[])
{
  CGAL::Window_stream W(600, 600);
  std::ifstream *is_ptr;
  bool automatic_show = false;
  Number_Type prec;
  // @@@@ next
  Number_Type delta;
  std::list<Segment_2> seg_list;
  bool sr_shown;
  bool remove_segments = false;
  bool do_isr = true;
  bool show_hp = true;
  bool show_input = true;
  bool show_output = true;

  if(argc == 1 || argc == 3) {
    // initialize window
    W.init(MIN_X - 3,MAX_X + 3,MIN_Y - 2);
    W.set_mode(leda_src_mode);
    W.set_node_width(3);
    W.buttons_per_line(4);
    W.button("Show results",1);
    W.button("Clear",2);
    W.button("Automatic",3);
    W.button("Manual",4);
    W.button("Add Segments",5);
    W.button("Remove Segments",6);
    W.button("Isr",7);
    W.button("Sr",8);
    W.button("Isrs",9);
    W.button("Show hot pixels",10);
    W.button("Hide hot pixels",11);
    W.button("Show input",12);
    W.button("Hide input",13);
    W.button("Show output",14);
    W.button("Hide output",15);
    W.button("Enlarge Pixel",16);
    W.button("Shrink Pixel",17);
    W.button("Reset Pixel",18);
    W.button("Exit",19);
    W.display();
    W.disable_button(4);
    W.disable_button(5);
    W.disable_button(9);
    W.disable_button(12);
    W.disable_button(14);
  } else {
    std::cerr << "Syntax : demo [input file name,delta]\n";
    return(1);
  }

  if(argc == 3) {
    // initialize input file
    is_ptr = new std::ifstream(argv[1]);
    if(is_ptr->bad()) {
      std::cerr << "Bad input file : " << argv[1] << std::endl;
      return(1);
    }
  }

  // determine bounding box
  Number_Type x1,y1,x2,y2;
  if(argc == 1) {
    x1 = MIN_X;
    y1 = MIN_Y;
    x2 = MAX_X;
    y2 = MAX_Y;
    prec = PRECISION;
    // @@@@ next
    delta = DEF_DELTA;
  } else {
    // @@@@ next (delta)
    read_data(argc,argv,prec,seg_list,delta);
    get_extreme_points(seg_list,x1,y1,x2,y2);
    /*    W.init((x1 - 3 - prec * 3).to_double(),x2 - x1 > y2 - y1 ? 
           (x2 + 3 + prec * 3).to_double() : 
           (y2 - y1 + x1 + 3 + prec * 3).to_double(),
           (y1 - 3 - prec * 3).to_double());*/
    W.set_mode(leda_src_mode);
    W.set_node_width(3);
  }

  CGAL::cgalize(W);

  // @@@@ next (delta)
  Snap_rounding_2 s(prec,true,false,5,delta);

  Iso_rectangle_2 b(Point_2(x1, y1), Point_2(x2, y2));

  //  display_bounding_box(W,b,argc == 1);
  
  double x3,y3,x4,y4;
  int mouse_input;

  if(argc == 3) {
    s.insert(seg_list.begin(),seg_list.end());
    show_results(s,prec,W,show_hp,show_output);
    sr_shown = true;
  } else
    sr_shown = false;

  // main loop over input points
  for (;;) {
    mouse_input = W.read_mouse(x3,y3);
    if(mouse_input == -1 && 
       x3 >= x1 && x3 <= x2 &&
       y3 >= y1 && y3 <= y2) {
      if(remove_segments) {
	Number_Type min_dist = -1,dist;
        Segment_iterator closest_iter =
                s.segments_end();
        for(Segment_iterator i1 = s.segments_begin();
            i1 != s.segments_end();
            ++i1) {
          Local_segment_2 l_s(Local_point_2(i1->source().x(),i1->source().y()),
              Local_point_2(i1->target().x(),i1->target().y()));
          dist = CGAL::squared_distance(Local_point_2(x3,y3),l_s);

          if(min_dist == -1 || dist < min_dist) {
            min_dist = dist;
            closest_iter = i1;
	  }
	}
        
        if(closest_iter != s.segments_end())
          s.remove(*closest_iter);

	redraw(s,W,b,show_input,argc == 1);
      } else {
        // add a segment
        mouse_input = W.read_mouse_seg(x3,y3,x4,y4);
        if(x4 >= x1 && x4 <= x2 &&
           y4 >= y1 && y4 <= y2) {
          if(sr_shown) {
            sr_shown = false;
            redraw(s,W,b,show_input,argc == 1);
          }
          W << CGAL::BLACK;
          Segment_2 tmp1(Point_2(x3,y3),Point_2(x4,y4));
          s.insert(tmp1);
          W << tmp1;
        }
      }

      if(automatic_show) {
        // automatic display of biggest rectangle
        show_results(s,prec,W,show_hp,show_output);
        sr_shown = true;
      }
    } else if(mouse_input == 1) {
      // show biggest rectangle
      show_results(s,prec,W,show_hp,show_output);
      sr_shown = true;
    } else if(mouse_input == 2) {
      clear(s,W,b,argc == 1);
      sr_shown = false;
    } else if(mouse_input == 3) {
      // change to automatic mode
      automatic_show = true;
      show_results(s,prec,W,show_hp,show_output);
      W.enable_button(4);
      W.disable_button(3);
      W.disable_button(1);
      sr_shown = true;
      redraw(s,W,b,show_input,argc == 1);
      show_results(s,prec,W,show_hp,show_output);
      sr_shown = true;
    } else if(mouse_input == 4) {
      // change to manual mode
      automatic_show = false;
      W.enable_button(1);
      W.enable_button(3);
      W.disable_button(4);
      sr_shown = false;
      redraw(s,W,b,show_input,argc == 1);
    } else if(mouse_input == 5) {
      W.enable_button(6);
      W.disable_button(5);
      remove_segments = false;
    } else if(mouse_input == 6) {
      W.enable_button(5);
      W.disable_button(6);
      remove_segments = true;
    } else if(mouse_input == 7) {
      W.enable_button(8);
      W.enable_button(9);
      W.disable_button(7);
      s.do_isrs(false);
      s.do_isr(true);
      do_isr = true;
    } else if(mouse_input == 8) {
      W.enable_button(7);
      W.enable_button(9);
      W.disable_button(8);
      s.do_isrs(false);
      s.do_isr(false);
      do_isr = false;
    } else if(mouse_input == 9) {
      W.enable_button(7);
      W.enable_button(8);
      W.disable_button(9);
      s.do_isrs(true);
    } else if(mouse_input == 10) {
      W.enable_button(11);
      W.disable_button(10);
      show_hp = true;
    } else if(mouse_input == 11) {
      W.enable_button(10);
      W.disable_button(11);
      show_hp = false;
    } else if(mouse_input == 12) {
      W.enable_button(13);
      W.disable_button(12);
      show_input = true;
    } else if(mouse_input == 13) {
      W.enable_button(12);
      W.disable_button(13);
      show_input = false;
    } else if(mouse_input == 14) {
      W.enable_button(15);
      W.disable_button(14);
      show_output = true;
    } else if(mouse_input == 15) {
      W.enable_button(14);
      W.disable_button(15);
      show_output = false;
    } else if(mouse_input == 16) {
      prec = prec * 2;
      s.change_pixel_size(prec);
      delta = delta * 2;
      s.change_delta(delta);
      if(prec == 2)
        W.disable_button(16);
      W.enable_button(17);
    } else if(mouse_input == 17) {
      prec = prec / 2;
      s.change_pixel_size(prec);
      delta = delta / 2;
      s.change_delta(delta);
      if(prec < 1.0 / 5)
        W.disable_button(17);
      W.enable_button(16);
    } else if(mouse_input == 18) {
      prec = PRECISION;
      delta = DEF_DELTA;
      s.change_pixel_size(prec);
      W.enable_button(16);
      W.enable_button(17);
    } else if(mouse_input == 19) {
      // finish
      break;
    }

    if(mouse_input > 4 && mouse_input < 18) {
      redraw(s,W,b,show_input,argc == 1);
      if(automatic_show)
        show_results(s,prec,W,show_hp,show_output);
    }
  }

  if(argc == 3)
    delete(is_ptr);

  return(0);
}

#endif
