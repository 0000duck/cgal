// ============================================================================
//
// Copyright (c) 1997-2000 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------------
//
// release       : $CGAL_Revision$
// release_date  : $CGAL_Date$
//
// file          : include/CGAL/Linear_algebra.h
// package       : Kernel_d
// chapter       : Kernel
//
// source        : ddgeo/Linear_algebra.lw
// revision      : $Revision$
// revision_date : $Date$
//
// author(s)     : Michael Seel <seel@mpi-sb.mpg.de>
// maintainer    : Michael Seel <seel@mpi-sb.mpg.de>
// coordinator   : Susan Hert <hert@mpi-sb.mpg.de>
//
// implementation: Higher dimensional geometry
// ============================================================================
//---------------------------------------------------------------------
// file generated by notangle from Linear_algebra.lw
// please debug or modify noweb file
// based on LEDA architecture by S. Naeher, C. Uhrig
// coding: K. Mehlhorn, M. Seel
// debugging and templatization: M. Seel
//---------------------------------------------------------------------


#ifndef LINEAR_ALGEBRA_H
#define LINEAR_ALGEBRA_H

#include <CGAL/Kernel_d/Ivector.h>
#include <CGAL/Kernel_d/Imatrix.h>

// #define LA_SELFTEST
LA_BEGIN_NAMESPACE

/*{\Moptions 
outfile=Linear_algebra.man
}*/
/*{\Manpage {Linear_algebra} {RT} {Linear Algebra on RT} {LA}}*/

template <class _RT, class _ALLOC = CGAL_ALLOCATOR(_RT) >
class Linear_algebra
{ 
/*{\Mdefinition
The data type |\Mname| encapsulates two classes |Imatrix|, |Ivector| and many
functions of basic linear algebra. It is parametrized by a number type |RT|. An
instance of data type |Imatrix| is a matrix of variables of type |RT|, the so
called ring type. Accordingly |Ivector| implements vectors of variables of type
|RT|. The arithmetic type |RT| is required to behave like integers in the
mathematical sense.

All functions compute the exact result, i.e., there is no rounding error.  Most
functions of linear algebra are \emph{checkable}, i.e., the programs can be
asked for a proof that their output is correct. For example, if the linear
system solver declares a linear system $A x = b$ unsolvable it also returns a
vector $c$ such that $c^T A = 0$ and $c^T b \neq 0$.  All internal correctness
checks can be switched on by the flag [[LA_SELFTEST]].}*/
public:

/*{\Mtypes 5.5}*/

typedef _RT RT;
/*{\Mtypemember the ring type of the components.}*/ 

typedef Ivector<_RT,_ALLOC> Vector;
/*{\Mtypemember the vector type.}*/ 

typedef Imatrix<_RT,_ALLOC> Matrix;
/*{\Mtypemember the matrix type.}*/ 

typedef _ALLOC allocator_type;
/*{\Mtypemember the allocator used for memory management. |\Mname| is
an appreviation of |Linear_algebra<RT, ALLOC = allocator<RT,LA> >|. Thus  
|allocator_type| defaults to the standard allocator offered by the STL.}*/ 


/*{\Moperations 2 1}*/

static Matrix  transpose(const Matrix& M); 
/*{\Mstatic  returns  $M^T$ ($m\times n$ - matrix). }*/

static bool inverse(const Matrix& M, Matrix& I, RT& D, Vector& c); 
/*{\Mstatic determines whether |M| has an inverse. It also computes 
            either the inverse as $(1/D) \cdot |I|$ or a vector $c$ 
            such that $c^T \cdot M = 0 $.  }*/

static Matrix  inverse(const Matrix& M, RT& D)
/*{\Mstatic returns the inverse matrix of |M|. More precisely, $1/D$ 
            times the matrix returned is the inverse of |M|.\\
            \precond  |determinant(M) != 0|. }*/
{ 
  Matrix result; 
  Vector c;
  if (!inverse(M,result,D,c)) 
    ERROR_HANDLER(1,"Imatrix<RT,A>::inverse: matrix is singular."); 
  return result;
}

static RT  determinant (const Matrix& M, Matrix& L, Matrix& U, 
                        std::vector<int>& q, Vector& c);
/*{\Mstatic returns the determinant $D$ of |M| and sufficient information 
            to verify that the value of the determinant is correct. If 
            the determinant is zero then $c$ is a vector such that 
            $c^T \cdot M = 0$. If the determinant is non-zero then $L$ 
            and $U$ are lower and upper diagonal matrices respectively 
            and $q$ encodes a permutation matrix $Q$ with $Q(i,j) = 1$ 
            iff $i = q(j)$ such that $L \cdot M \cdot Q = U$, 
            $L(0,0) = 1$, $L(i,i) = U(i - 1,i - 1)$ for all $i$, 
            $1 \le i < n$, and $D = s \cdot U(n - 1,n - 1)$ where $s$ is 
            the determinant of $Q$. \precond  |M| is quadratic. }*/

static bool verify_determinant (const Matrix& M, RT D, Matrix& L, Matrix& U, 
                                const std::vector<int>& q, Vector& c);
/*{\Mstatic verifies the conditions stated above. }*/

static RT determinant (const Matrix& M); 
/*{\Mstatic  returns the determinant of |M|.
         \precond  |M| is quadratic. }*/

static int sign_of_determinant (const Matrix& M); 
/*{\Mstatic returns the sign of the determinant of |M|.
        \precond  |M| is quadratic. }*/

static bool linear_solver(const Matrix& M, const Vector& b,
                   Vector& x, RT& D, 
                   Matrix& spanning_vectors, 
                   Vector& c);
/*{\Mstatic determines the complete solution space of the linear system 
            $M\cdot x = b$. If the system is unsolvable then 
            $c^T \cdot M = 0$ and $c^T \cdot b \not= 0$. 
            If the system is solvable then $(1/D) x$ is a solution, and 
            the columns of |spanning_vectors| are a maximal set of linearly 
            independent solutions to the corresponding homogeneous system.
            \precond |M.row_dimension() = b.dimension()|. }*/

static bool linear_solver(const Matrix& M, const Vector& b, 
                   Vector& x, RT& D, 
                   Vector& c) 
/*{\Mstatic determines whether the linear system $M\cdot x = b$ is 
           solvable. If yes, then $(1/D) x$ is a solution, if not then 
           $c^T \cdot M = 0$ and $c^T \cdot b \not= 0$.
           \precond |M.row_dimension() = b.dimension()|. }*/
{ 
  Matrix spanning_vectors; 
  return linear_solver(M,b,x,D,spanning_vectors,c); 
}

static bool linear_solver(const Matrix& M, const Vector& b,
                   Vector& x, RT& D) 
/*{\Mstatic as above, but without the witness $c$ 
           \precond |M.row_dimension() = b.dimension()|. }*/
{ 
  Matrix spanning_vectors; Vector c; 
  return linear_solver(M,b,x,D,spanning_vectors,c); 
}

static bool is_solvable(const Matrix& M, const Vector& b) 
/*{\Mstatic determines whether the system $M \cdot x = b$ is solvable \\
        \precond |M.row_dimension() = b.dimension()|. }*/
{ 
  Vector x; RT D; Matrix spanning_vectors; Vector c; 
  return linear_solver(M,b,x,D,spanning_vectors,c); 
}

static bool homogeneous_linear_solver (const Matrix& M, Vector& x); 
/*{\Mstatic determines whether the homogeneous linear system 
        $M\cdot x = 0$ has a non - trivial solution. If
        yes, then $x$ is such a solution. }*/

static int homogeneous_linear_solver (const Matrix& M, Matrix& spanning_vecs); 
/*{\Mstatic determines the solution space of the homogeneous linear system 
$M\cdot x = 0$. It returns the dimension of the solution space.
Moreover the columns of |spanning_vecs| span the solution space. }*/

static void independent_columns (const Matrix& M, std::vector<int>& columns); 
/*{\Mstatic returns the indices of a maximal subset of independent 
columns of |M|.}*/

static int rank (const Matrix & M); 
/*{\Mstatic returns the rank of matrix |M| }*/

/*{\Mimplementation The datatype |\Mname| is a wrapper class for the
linear algebra functionality on matrices and vectors.  Operations
|determinant|, |inverse|, |linear_solver|, and |rank| take time
$O(n^3)$, and all other operations take time $O(nm)$. These time
bounds ignore the cost for multiprecision arithmetic operations.

All functions on integer matrices compute the exact result, i.e.,
there is no rounding error. The implemenation follows a proposal of
J. Edmonds (J. Edmonds, Systems of distinct representatives and linear
algebra, Journal of Research of the Bureau of National Standards, (B),
71, 241 - 245). Most functions of linear algebra are { \em checkable
}, i.e., the programs can be asked for a proof that their output is
correct. For example, if the linear system solver declares a linear
system $A x = b$ unsolvable it also returns a vector $c$ such that
$c^T A = 0$ and $c^T b \not= 0$.}*/

};


template <class _RT, class _ALLOC>
bool Linear_algebra<_RT,_ALLOC>::
linear_solver(const Imatrix<_RT,_ALLOC>& A, const Vector& b, 
             Vector& x, RT& D, 
             Imatrix<_RT,_ALLOC>& spanning_vectors, Vector& c)
{ 
  bool solvable = true; 
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }


    for(i =rank ; i <rows && C(i,cols) == 0; i++); // no body
    if (i < rows) { 
      solvable = false; 
      c = Vector(rows); 
      for (j = 0; j <rows; j++) 
        c[j] = L(i,j); 
    }

  if (solvable) 
  { 
      x = Vector(cols); 
      D = denom; 
      for(i=rank - 1 ; i>= 0; i--) { 
        _RT h =C(i,cols) * D; 
        for (j = i + 1; j<rank; j++) { 
          h -= C(i,j)*x[var[j]]; 
        }
        x[var[i]]= h / C(i,i); 
      }

    #ifdef LA_SELFTEST
      /* we check whether |x| is a solution */
      { 
        for (i = 0; i < rows; i++) { 
          RT sum = 0; 
          for (j =0; j < cols; j++) 
            sum += A(i,j)*x[j]; 
          if (sum != D * b[i])
            ERROR_HANDLER(1,"linear_solver: base is not a solution"); 
        }
      }
    #endif

      int dimension = cols - rank; //dimension of solution
      spanning_vectors = Matrix(cols,dimension); 
     
      if (dimension > 0) { 
     
      /* In the $l$ - th spanning vector, $0 \le l < |dimension|$ we set
         variable |var[rank + l]| to $1 = |denom|/|denom|$ and then the
         dependent variables as dictated by the $|rank| + l$ - th column of
         |C|.*/

        for(int l=0; l < dimension; l++) { 
          spanning_vectors(var[rank + l],l)=D; 
          for(i = rank - 1; i >= 0 ; i--) { 
            _RT h = - C(i,rank + l)* D; 
            for ( j= i + 1; j<rank; j++)  
              h -= C(i,j)*spanning_vectors(var[j],l); 
            spanning_vectors(var[i],l)= h / C(i,i); 
          }

    #ifdef LA_SELFTEST
          /* we check whether the $l$ - th spanning vector is a solution 
             of the homogeneous system */
          { 
            Vector zero(rows); 
            if (A *spanning_vectors.col(l) != zero)
              ERROR_HANDLER(1,"linear_solver: spanning_vector is not a solution."); 
          }
    #endif
        }
      }

  }
  return solvable; 
}


template <class _RT, class _ALLOC>
_RT Linear_algebra<_RT,_ALLOC>::
determinant(const Imatrix<_RT,_ALLOC>& A)
{ 
  if (A.row_dimension() != A.column_dimension())
    ERROR_HANDLER(1,"determinant: only square matrices are legal inputs."); 
  Vector b(A.row_dimension()); // zero - vector
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }



  if (rank < rows) 
    return 0; 
  else
    return RT(sign) * denom; 
}


template <class _RT, class _ALLOC>
_RT Linear_algebra<_RT,_ALLOC>::
determinant(const Imatrix<_RT,_ALLOC>& A, 
            Imatrix<_RT,_ALLOC>& Ld, Imatrix<_RT,_ALLOC>& Ud, 
            std::vector<int>& q, Ivector<_RT,_ALLOC>& c) 
{ 
  if (A.row_dimension() != A.column_dimension())
    ERROR_HANDLER(1,"determinant: only square matrices are legal inputs."); 
  Vector b(A.row_dimension()); // zero - vector
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }



  if (rank < rows) { 
    c = L.row(rows - 1); 
    return 0; 
  } else { 
    Ld = L; 
    Ud = Matrix(rows); // quadratic
    for (i = 0; i < rows; i++) 
      for(j = 0; j <rows; j++) 
        Ud(i,j) = C(i,j); 
    q = var; 
    return RT(sign) * denom; 
  }
}

template <class _RT, class _ALLOC>  
int  Linear_algebra<_RT,_ALLOC>:: 
sign_of_determinant(const Imatrix<_RT,_ALLOC>& M)
{ return CGAL_NTS sign(determinant(M)); }

template <class _RT, class _ALLOC>  
bool Linear_algebra<_RT,_ALLOC>:: 
verify_determinant(const Imatrix<_RT,_ALLOC>& A, _RT D, 
                   Imatrix<_RT,_ALLOC>& L, Imatrix<_RT,_ALLOC>& U, 
                   const std::vector<int>& q, Ivector<_RT,_ALLOC>& c) 
{ 
  if ((int)q.size() != A.column_dimension())
    ERROR_HANDLER(1,"verify_determinant: \
    q should be a permutation array \
    with index range [0,A.column_dimension() - 1]."); 
  int n = A.row_dimension(); 
  int i,j; 
  if (D == 0) { /* we have $c^T \cdot A = 0$  */
    Ivector<_RT,_ALLOC> zero(n); 
    return  (transpose(A) * c == zero); 
  } else { 
    /* we check the conditions on |L| and |U| */
    if (L(0,0) != 1) return false; 
    for (i = 0; i<n; i++) { 
      for (j = 0; j < i; j++) 
        if (U(i,j) != 0) 
          return false; 

      if (i > 0 && L(i,i) != U(i - 1,i - 1)) 
        return false; 

      for (j = i + 1; j < n; j++) 
        if (L(i,j) != 0) 
          return false; 
    }

    /* check whether $L \cdot A \cdot Q = U$ */
   Imatrix<_RT,_ALLOC> LA = L * A; 
   for (j = 0; j < n; j++)
     if (LA.column(q[j]) != U.column(j)) 
       return false; 

    /* compute sign |s| of |Q| */
    int sign = 1; 

    /* we chase the cycles of |q|. An even length cycle contributes - 1
       and vice versa */

    std::vector<bool> already_considered(n); 

    for (i = 0; i < n; i++)  
      already_considered[i] = false; 

    for (i = 0; i < n; i++)  
      already_considered[q[i]] = true; 

    for (i = 0; i < n; i++) 
      if (! already_considered[i])
        ERROR_HANDLER(1,"verify_determinant:q is not a permutation."); 
      else 
        already_considered[i] = false; 

    for (i = 0; i < n; i++) { 
      if (already_considered[i]) continue; 

      /* we have found a new cycle with minimal element $i$. */
      int k = q[i]; 
      already_considered[i] =true; 

      while (k != i) { 
        sign = - sign; 
        already_considered[k]= true; 
        k = q[k]; 
      }
    }
    return (D == RT(sign) * U(n - 1,n - 1)); 
  }
}

template <class _RT, class _ALLOC> 
void Linear_algebra<_RT,_ALLOC>:: 
independent_columns(const Imatrix<_RT,_ALLOC>& A, 
                    std::vector<int>& columns) 
{ 
  Ivector<_RT,_ALLOC> b(A.row_dimension()); // zero - vector
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }


  /* at this point we have:
     |C| has an $rank \times rank$ upper triangular matrix 
     in its left upper corner; 
     |var| tells us the columns of |A| corresponding to the
     dependent variables; */
     
  columns = std::vector<int>(rank); 
  for(i = 0; i < rank; i++) 
    columns[i] = var[i]; 
}


template <class _RT, class _ALLOC>  
int  Linear_algebra<_RT,_ALLOC>::
rank(const Imatrix<_RT,_ALLOC>& A)
{ 
  Ivector<_RT,_ALLOC> b(A.row_dimension()); // zero - vector
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }


  return rank; 
}

template <class _RT, class _ALLOC>  
bool  Linear_algebra<_RT,_ALLOC>::
inverse(const Imatrix<_RT,_ALLOC>& A, Imatrix<_RT,_ALLOC>& inverse, 
        _RT& D, Ivector<_RT,_ALLOC>& c)
{ 
  if (A.row_dimension() != A.column_dimension())
    ERROR_HANDLER(1,"inverse: only square matrices are legal inputs."); 
  Ivector<_RT,_ALLOC> b(A.row_dimension()); // zero - vector
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }


  
  if (rank < rows)
  { 
    /* matrix is singular; 
       we return a vector $c$ with $c^T \cdot A = 0$.*/

    c = Vector(rows); 
    for (j = 0; j <rows; j++) 
      c[j] = L(rows - 1,j); 

    return false; 
  }
  
    D = denom; 
    inverse = Imatrix<_RT,_ALLOC>(rows); //quadratic
    _RT h; 
    for(i = 0; i <rows; i++) 
    {  // $i$-th column of inverse
      for (j = rows - 1; j >= 0; j--) 
      { 
        h = L (j,i) * D; 
        for (int l = j + 1; l<rows; l++)  
          h -= C(j,l)*inverse(var[l],i); 
        inverse(var[j],i) = h / C(j,j); 
      }
    }  

  #ifdef LA_SELFTEST
    if (A*inverse != Matrix(rows,Matrix::RT_val(1))*D)
      ERROR_HANDLER(1,"inverse: matrix inverse computed incorrectly."); 
  #endif      

  return true; 
}



template <class _RT, class _ALLOC>  
int  Linear_algebra<_RT,_ALLOC>::
homogeneous_linear_solver(const Imatrix<_RT,_ALLOC> &A, 
                          Imatrix<_RT,_ALLOC>& spanning_vectors)
/* returns the dimension of the solution space of the homogeneous system 
   $Ax = 0$. The columns of spanning\_vectors span the solution space. */
{ 
  Ivector<_RT,_ALLOC> b(A.row_dimension()); // zero - vector
  _RT D; 
  
    int i,j,k; // indices to step through the matrix
    int rows = A.row_dimension(); 
    int cols = A.column_dimension(); 

    /* at this point one might want to check whether the computation can
       be carried out with doubles, see section \ref{ optimization }.
    */

    if (b.dimension() != rows) 
      ERROR_HANDLER(1,"linear_solver: b has wrong dimension"); 

    Imatrix<_RT,_ALLOC> C(rows,cols + 1); 
    // the matrix in which we will calculate ($C = (A \vert b)$)
    
    /* copy |A| and |b| into |C| and L becomes the identity matrix */
    Imatrix<_RT,_ALLOC> L(rows); // zero initialized
    for(i=0; i<rows; i++) { 
      for(j=0; j<cols; j++) 
        C(i,j)=A(i,j); 
      C(i,cols)=b[i]; 
      L(i,i) = 1; // diagonal elements are 1
    }


    std::vector<int> var(cols); 
    // column $j$ of |C| represents the |var[j]| - th variable
    // the array is indexed between |0| and |cols - 1|

    for(j=0; j<cols; j++)
      var[j]= j; // at the beginning, variable $x_j$ stands in column $j$

    _RT denom = 1; // the determinant of an empty matrix is 1
    int sign = 1; // no interchanges yet
    int rank = 0; // we have not seen any non-zero row yet

    /* here comes the main loop */
    for(k=0; k<rows; k++) {   
         bool non_zero_found = false; 
         for(i = k; i < rows; i++) { // step through rows $k$ to |rows - 1|
           for (j = k ; j < cols && C(i,j) == 0; j++) ; 
           // step through columns |k| to |cols - 1|
           if (j < cols) {  
             non_zero_found = true; 
             break; 
           }
         }


      if (non_zero_found) { 
        rank++; //increase the rank
          if (i != k) { 
            sign = -sign; 
            /* we interchange rows |k| and |i| of |L| and |C| */
            std::swap(L[i],L[k]); 
            std::swap(C[i],C[k]); 
          }

          if (j != k)
          { 
            sign = - sign; 
            /* We interchange columns |k| and |j| */
            for(int ih = 0; ih < rows; ih++) 
              std::swap(C(ih,k),C(ih,j)); 

            /* We store the exchange of variables in |var| */
            std::swap(var[k],var[j]); 
          }
         
          for(i = k + 1; i < rows; i++)  
            for (j = 0; j <  rows; j++)  //and all columns of |L|
              L(i,j) = (L(i,j)*C(k,k) - C(i,k)*L(k,j))/denom; 

          for(i = k + 1; i < rows; i++) 
          {      
            /* the following iteration uses and changes |C(i,k)| */
            _RT temp = C(i,k); 
            for (j = k; j <= cols; j++)
              C(i,j) = (C(i,j)*C(k,k) - temp*C(k,j))/denom; 
          }
          denom = C(k,k); 
          #ifdef LA_SELFTEST
            for(i = 0; i < rows; i++) { 
              for (j = 0; j < cols; j++) { 
                RT Sum = 0; 
                for (int l = 0; l < rows; l++) 
                  Sum += L(i,l)*A(l, var[j]); 
                if (Sum  != C(i,j)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 
              }
              RT Sum = 0; 
              for (int l = 0; l < rows; l++) 
                Sum += L(i,l)*b[l];
                if (Sum  != C(i,cols)) 
                  ERROR_HANDLER(1,"linear_solver: L*A*P different from C"); 

            }
          #endif


      }
      else 
        break; 
    }


  Ivector<_RT,_ALLOC> x; 
    x = Vector(cols); 
    D = denom; 
    for(i=rank - 1 ; i>= 0; i--) { 
      _RT h =C(i,cols) * D; 
      for (j = i + 1; j<rank; j++) { 
        h -= C(i,j)*x[var[j]]; 
      }
      x[var[i]]= h / C(i,i); 
    }

  #ifdef LA_SELFTEST
    /* we check whether |x| is a solution */
    { 
      for (i = 0; i < rows; i++) { 
        RT sum = 0; 
        for (j =0; j < cols; j++) 
          sum += A(i,j)*x[j]; 
        if (sum != D * b[i])
          ERROR_HANDLER(1,"linear_solver: base is not a solution"); 
      }
    }
  #endif

    int dimension = cols - rank; //dimension of solution
    spanning_vectors = Matrix(cols,dimension); 
   
    if (dimension > 0) { 
   
    /* In the $l$ - th spanning vector, $0 \le l < |dimension|$ we set
       variable |var[rank + l]| to $1 = |denom|/|denom|$ and then the
       dependent variables as dictated by the $|rank| + l$ - th column of
       |C|.*/

      for(int l=0; l < dimension; l++) { 
        spanning_vectors(var[rank + l],l)=D; 
        for(i = rank - 1; i >= 0 ; i--) { 
          _RT h = - C(i,rank + l)* D; 
          for ( j= i + 1; j<rank; j++)  
            h -= C(i,j)*spanning_vectors(var[j],l); 
          spanning_vectors(var[i],l)= h / C(i,i); 
        }

  #ifdef LA_SELFTEST
        /* we check whether the $l$ - th spanning vector is a solution 
           of the homogeneous system */
        { 
          Vector zero(rows); 
          if (A *spanning_vectors.col(l) != zero)
            ERROR_HANDLER(1,"linear_solver: spanning_vector is not a solution."); 
        }
  #endif
      }
    }
; 
  return dimension; 
}

template <class _RT, class _ALLOC>  
bool  Linear_algebra<_RT,_ALLOC>::
homogeneous_linear_solver(const Imatrix<_RT,_ALLOC>& A, Ivector<_RT,_ALLOC>& x)
/* returns true if the homogeneous system $Ax = 0$ has a non - trivial
   solution and false otherwise. */
{  
  Imatrix<_RT,_ALLOC> spanning_vectors; 
  int dimension = homogeneous_linear_solver(A,spanning_vectors); 

  if (dimension == 0) 
    return false; 

  /* return first column of |spanning_vectors| */
  for (int i = 0; i < spanning_vectors.row_dimension() ; i++)  
    x[i] = spanning_vectors(i,0); 
  return true; 
}



template <class _RT, class _ALLOC>  
Imatrix<_RT,_ALLOC>  Linear_algebra<_RT,_ALLOC>::
transpose(const Imatrix<_RT,_ALLOC>& M)
{ 
  int d1 = M.row_dimension(); 
  int d2 = M.column_dimension(); 
  Imatrix<_RT,_ALLOC> result(d2,d1); 
  for(int i = 0; i < d2; i++)
    for(int j = 0; j < d1; j++)
      result(i,j) = M(j,i); 
  return result; 
}


LA_END_NAMESPACE
#endif // LINALG_ALGEBRA_H

