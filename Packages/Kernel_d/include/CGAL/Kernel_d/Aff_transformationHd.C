//---------------------------------------------------------------------
// file generated by notangle from noweb/Aff_transformationHd.lw
// please debug or modify noweb file
// coding: K. Mehlhorn, M. Seel
//---------------------------------------------------------------------

#ifndef CGAL_AFF_TRANSFORMATIONHD_C
#define CGAL_AFF_TRANSFORMATIONHD_C
CGAL_BEGIN_NAMESPACE

template <class RT, class LA>
Aff_transformationHd<RT,LA>::
Aff_transformationHd(int d, Rotation,  
  const RT& sin_num, const RT& cos_num, const RT& den, 
  int e1, int e2) : Base( Rep(d) )
{
  CGAL_assertion_msg((sin_num*sin_num + cos_num*cos_num == den*den),
    "planar_rotation: rotation parameters disobey precondition.");
  CGAL_assertion_msg((0<=e1 && e1<=e2 && e2<d), 
    "planar_rotation: base vector indices wrong.");
  Matrix& M = ptr->M_;
  for (int i=0; i<d; i++) M(i,i) = 1;
  M(e1,e1) = cos_num; M(e1,e2) = -sin_num;
  M(e2,e1) = sin_num; M(e2,e2) = cos_num;
  M(d,d) = den;
}

template <class RT, class LA>
Aff_transformationHd<RT,LA>::
Aff_transformationHd(int d, Rotation, const DirectionHd<RT,LA>& dir, 
   const RT& num, const RT& den, int e1, int e2) : Base( Rep(d) )
{
  CGAL_assertion_msg((dir.dimension() == 2),
    "planar_rotation: dir has to be 2 dimensional.");
  CGAL_assertion_msg((RT(0)<=num && num < den),
    "planar_rotation: num and den have to be positive.");
  CGAL_assertion_msg((0<=e1 && e1<=e2 && e2<d), 
    "planar_rotation: base vector indices wrong.");

  // now |num/den| is a rational greater zero

  RT sin;
  RT cos;
  RT denom;
  RT dx = CGAL_NTS abs(dir.dx());
  RT dy = CGAL_NTS abs(dir.dy());
  RT sq_hypotenuse = dx*dx + dy*dy;
  RT common_part;
  RT diff_part;
  RT rhs;
  bool lower_ok;
  bool upper_ok;

  if (dy > dx) {
    RT tmp = dx;
    dx = dy;
    dy = tmp;
  }
  /* approximate |sin = dy / sqrt(sq_hypotenuse)| \\
     |if ( dy / sqrt(sq_hypotenuse) < num/den )| */
  if (dy * dy * den * den < sq_hypotenuse * num * num) {
     cos = denom = 1;
     sin = 0;
  } else {
    RT p,q,p0,q0,p1,q1;
    p0 = 0;
    q0 = p1 = q1 = 1;

    for(;;) {
      p = p0 + p1;
      q = q0 + q1;
      sin = RT(2)*p*q;
      denom = CGAL_NTS square(p) + CGAL_NTS square(q);

      // sanity check for approximation
      // |       sin/denom < dy/sqrt(hypotenuse) + num/den|
      // |   &&  sin/denom > dy/sqrt(hypotenuse) - num/den|
      // | ==    sin/denom - num/den  <   dy/sqrt(sq_hypotenuse)|
      // |   &&  sin/denom + num/den  >   dy/sqrt(sq_hypotenuse)|
      // | ==    (sqr(sin) sqr(den) + sqr(num) sqr(denom)) sq_hypotenuse - 2..|
      // |       < sqr(dy) sqr(den) sqr(denom)|
      // |   &&  (sqr(sin) sqr(den) + sqr(num) sqr(denom))sq_hypotenuse + 2..|
      // |       > sqr(dy) sqr(den) sqr(denom)|

      common_part = (CGAL_NTS square(sin)*CGAL_NTS square(den) + 
                     CGAL_NTS square(num)*CGAL_NTS square(denom))*
                     sq_hypotenuse;
      diff_part   = RT(2)*num*sin*den*denom*sq_hypotenuse;
      rhs         = CGAL_NTS square(dy)*CGAL_NTS square(den)*
                    CGAL_NTS square(denom);

      upper_ok    = (common_part - diff_part < rhs);
      lower_ok    = (common_part + diff_part > rhs);

      if ( lower_ok && upper_ok ) {
         if ( CGAL_NTS square(p)%RT(2) + CGAL_NTS square(q)%RT(2) > 1) {
             sin = p*q;
             cos = (CGAL_NTS square(q) - CGAL_NTS square(p))/RT(2);     
             // exact division
             denom = (CGAL_NTS square(p) + CGAL_NTS square(q))/RT(2);   
             // exact division
         } else {
             cos = CGAL_NTS square(q) - CGAL_NTS square(p);
         }

         break;
      } else {
          /* |if ( dy/sqrt(sq_hypotenuse) < sin/denom )| */
          if ( CGAL_NTS square(dy)*CGAL_NTS square(denom) < 
               CGAL_NTS square(sin)*sq_hypotenuse )
          { p1 = p; q1 = q; }
          else
          { p0 = p; q0 = q; }
      }
    } // for(;;)
  }

  dx = dir.dx();
  dy = dir.dy();
  if (dy > dx) {
    RT tmp = dx;
    dx = dy;
    dy = tmp;
  }
  if (dx < 0) sin = - sin;
  if (dy < 0) cos = - cos;
  Matrix& M = ptr->M_;
  for (int i=0; i<d; i++) M(i,i) = 1;
  M(e1,e1) = cos; M(e1,e2) = -sin;
  M(e2,e1) = sin; M(e2,e2) = cos;
  M(d,d) = denom;
}


CGAL_END_NAMESPACE
#endif // CGAL_AFF_TRANSFORMATIONHD_C

