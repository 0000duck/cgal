//---------------------------------------------------------------------
// file generated by notangle from VectorHd.lw
// please debug or modify noweb web file
// based on LEDA architecture by S. Naeher, C. Uhrig
// coding: K. Mehlhorn, M. Seel
// debugging and templatization: M. Seel
//---------------------------------------------------------------------

#ifndef CGAL_VECTORHD_H
#define CGAL_VECTORHD_H 

#ifndef NOCGALINCL
#include <CGAL/basic.h>
#include <CGAL/Quotient.h>
#endif
#include <CGAL/Kernel_d/Tuple_d.h> 
#include <CGAL/Kernel_d/PointHd.h>
#include <CGAL/Kernel_d/Aff_transformationHd.h>

CGAL_BEGIN_NAMESPACE

template <class RT, class LA> class VectorHd;
template <class RT, class LA>
std::istream& operator>>(std::istream&, VectorHd<RT,LA>&);
template <class RT, class LA>
std::ostream& operator<<(std::ostream&, const VectorHd<RT,LA>&);

/*{\Manpage {Vector_d}{R}{Vectors in d-space}{v}}*/
/*{\Msubst 
Hd<RT,LA>#_d<R>
VectorHd#Vector_d
PointHd#Point_d
Quotient<RT>#FT
}*/

template <class _RT, class _LA>
class VectorHd : public Handle_for< Tuple_d<_RT,_LA> > { 
  typedef Tuple_d<_RT,_LA>  Tuple;
  typedef Handle_for<Tuple> Base;
  typedef VectorHd<_RT,_LA> Self;

/*{\Mdefinition
An instance of data type |\Mname| is a vector of Euclidean space in
dimension $d$. A vector $r = (r_0,\ldots,r_{ d - 1})$ can be represented
in homogeneous coordinates $(h_0,\ldots,h_d)$ of number type |RT|,
such that $r_i = h_i/h_d$ which is of type |FT|. We call the
$r_i$'s the cartesian coordinates of the vector. The homogenizing
coordinate $h_d$ is positive.

This data type is meant for use in computational geometry. It realizes
free vectors as opposed to position vectors (type |PointHd|). The
main difference between position vectors and free vectors is their
behavior under affine transformations, e.g., free vectors are
invariant under translations.}*/

const typename _LA::Vector& vector_rep() const { return ptr->v; }
_RT& entry(int i) { return ptr->v[i]; }
const _RT& entry(int i) const { return ptr->v[i]; }
void invert_rep() { ptr->invert(); }
VectorHd(const Base& b) : Base(b) {}

public: 
/*{\Mtypes 4}*/

typedef _RT RT;
/*{\Mtypemember the ring type.}*/
typedef Quotient<_RT> FT;
/*{\Mtypemember the field type.}*/
typedef _LA LA;
/*{\Mtypemember the linear algebra layer.}*/
typedef typename Tuple::Cartesian_iterator Cartesian_iterator;
/*{\Mtypemember a read-only iterator for the cartesian coordinates.}*/
typedef typename Tuple::Homogeneous_iterator Homogeneous_iterator;
/*{\Mtypemember a read-only iterator for the homogeneous coordinates.}*/

class Base_vector {};
/*{\Mtypemember construction tag.}*/

friend class PointHd<RT,LA>; 
friend class DirectionHd<RT,LA>; 
friend class HyperplaneHd<RT,LA>; 

/*{\Mcreation 4}*/

VectorHd(int d = 0) : Base( Tuple(d+1) )  
/*{\Mcreate introduces a variable |\Mvar| of type |\Mname| in 
$d$-dimensional space.}*/
{ if ( d > 0 ) entry(d) = 1; }

VectorHd(int d, Null_vector NULL_VECTOR) : Base( Tuple(d+1) )  
/*{\Mcreate introduces the zero vector |\Mvar| of type |\Mname| in 
$d$-dimensional space.}*/
{ if ( d > 0 ) entry(d) = 1; }

template <class InputIterator>
VectorHd(int d, InputIterator first, InputIterator last) :
  Base( Tuple(d+1,first,last) )
/*{\Mcreate introduces a variable |\Mvar| of type |\Mname| in dimension |d|.
If |size [first,last) == d| this creates a vector with Cartesian coordinates 
|set [first,last)|. If |size [first,last) == p+1| the range specifies the
homogeneous coordinates $|H = set [first,last)| = (\pm h_0, \pm h_1, \ldots,
\pm h_d)$ where the sign chosen is the sign of $h_d$.
\precond |d| is nonnegative, |[first,last)| has |d| or |d+1| elements where the
last has to be non-zero, and the value type of |InputIterator| is |RT|.}*/
{ RT D = entry(d);
  CGAL_assertion_msg(D!=0, "VectorHd::constructor: denom must be nonzero.");
  if (D < 0) invert_rep();
}

template <class InputIterator>
VectorHd(int d, InputIterator first, InputIterator last, 
         const RT& D) : Base( Tuple(d+1,first,last,D) )
/*{\Mcreate introduces a variable |\Mvar| of type |\Mname|
in dimension |d| initialized to the vector with homogeneous 
coordinates as defined by |H = set [first,last)| and |D|:
$(\pm |H[0]|, \pm|H[1]|, \ldots, \pm|H[d-1]|, \pm|D|)$. The sign chosen 
is the sign of $D$. \precond |D| is non-zero, the iterator range defines 
a $d$-tuple of |RT|, and the value type of |InputIterator| is |RT|. }*/
{ CGAL_assertion_msg(D!=0, "VectorHd::constructor: D must be nonzero.");
  if (D < 0) invert_rep();
}

VectorHd(Base_vector, int d, int i) : Base( Tuple(d+1) )
/*{\Mcreate returns a variable |\Mvar| of type |\Mname| initialized  
to the $i$-th base vector of dimension $d$. }*/
{ entry(d) = 1;
  if ( d == 0 ) return;
  CGAL_assertion_msg((0<=i&&i<d),"VectorHd::base: index out of range.");
  entry(i) = 1;
}

VectorHd(const RT& a, const RT& b, const RT& c = 1) : Base( Tuple(a,b,c) ) 
/*{\Mcreate introduces a variable |\Mvar| of type |\Mname| in 
$2$-dimensional space. }*/
{ CGAL_assertion_msg((c != 0), "VectorHd::construction: c == 0.");
  if (c < 0) invert_rep();
}

VectorHd(int a, int b, int c = 1) : 
  Base( Tuple((RT)a,(RT)b,(RT)c) ) 
{ CGAL_assertion_msg((c != 0), "VectorHd::construction: c == 0.");
  if (c < 0) invert_rep();
}

VectorHd(const RT& a, const RT& b, const RT& c, const RT& d) :
  Base( Tuple((RT)a,(RT)b,(RT)c,(RT)d) )
/*{\Mcreate introduces a variable |\Mvar| of type |\Mname| in 
            $3$-dimensional space. }*/
{ CGAL_assertion_msg((d!=0), "VectorHd::construction: d == 0.");
  if (d < 0) invert_rep();
}

VectorHd(int a, int b, int c, int d) :
  Base( Tuple((RT)a,(RT)b,(RT)c,(RT)d) )
{ CGAL_assertion_msg((d!=0), "VectorHd::construction: d == 0.");
  if (d < 0) invert_rep();
}

VectorHd(const VectorHd<RT,LA>& p) : Base(p)  {}
~VectorHd() {}     

/*{\Moperations 5 3 }*/

int dimension() const { return ptr->size()-1; } 
/*{\Mop returns the dimension of |\Mvar|. }*/ 

Quotient<RT> cartesian(int i) const 
/*{\Mop     returns the $i$-th cartesian coordinate of |\Mvar|. }*/
{ CGAL_assertion_msg((0<=i && i<(dimension())), "VectorHd::cartesian():\
  index out of range.");
  return Quotient<RT>(entry(i), entry(dimension())); 
}

Quotient<RT> operator[](int i) const { return cartesian(i); }
/*{\Marrop  returns the $i$-th cartesian coordinate of |\Mvar|.}*/

RT homogeneous(int i) const 
/*{\Mop returns the $i$-th hcoord coordinate of |\Mvar|. }*/
{ CGAL_assertion_msg((0<=i && i<=(dimension())), "VectorHd::homogeneous():\
  index out of range.");
  return entry(i);
}

Quotient<RT> squared_length() const
/*{\Mop returns the square of the length of |\Mvar|. }*/
{ RT nom = 0; 
  for (int i = 0; i < dimension(); i++) 
    nom += sqr(homogeneous(i));
  RT denom = sqr(homogeneous(dimension()));
  return Quotient<RT>(nom,denom); 
}

Cartesian_iterator cartesian_begin() const 
/*{\Mop returns an iterator pointing to the zeroth cartesian coordinate 
of |\Mvar|. }*/
{ return Cartesian_iterator(ptr->begin(),ptr->last()); }

Cartesian_iterator cartesian_end() const 
/*{\Mop returns an iterator pointing beyond the last cartesian coordinate 
of |\Mvar|. }*/
{ return Cartesian_iterator(ptr->last(),ptr->last()); }

Homogeneous_iterator homogeneous_begin() const 
/*{\Mop returns an iterator pointing to the zeroth homogeneous coordinate 
of |\Mvar|. }*/
{ return ptr->begin(); }

Homogeneous_iterator homogeneous_end() const 
/*{\Mop returns an iterator pointing beyond the last homogeneous
coordinate of |\Mvar|. }*/ 
{ return ptr->end(); }

inline PointHd<RT,LA> to_point() const;

inline DirectionHd<RT,LA> direction() const; 
/*{\Mop converts to a direction. }*/

VectorHd<RT,LA> transform(const Aff_transformationHd<RT,LA>& t) const; 
/*{\Mop returns $t(v)$. }*/
/*{\Mtext \headerline{Arithmetic Operators, Tests and IO}}*/

VectorHd<RT,LA> scale(const RT& m, const RT& n) const; 
void            self_scale(const RT& m, const RT& n); 

VectorHd<RT,LA>& operator*=(const RT& n) 
{ self_scale(n,1); return *this; }
/*{\Mbinop  multiplies all cartesian coordinates by |n|.}*/

VectorHd<RT,LA>& operator*=(int n) 
{ self_scale(n,1); return *this; }

VectorHd<RT,LA>& operator*=(const Quotient<RT>& r) 
{ self_scale(r.numerator(),r.denominator()); return *this; }
/*{\Mbinop  multiplies all cartesian coordinates by |r|.}*/

VectorHd<RT,LA> operator/(int n) const
{ return scale(1,n); }

VectorHd<RT,LA> operator/(const RT& n) const
/*{\Mbinop returns the vector with cartesian coordinates 
$v_i/n, 0 \leq i < d$.}*/
{ return scale(1,n); }

VectorHd<RT,LA> operator/(const Quotient<RT>& r) const
/*{\Mbinop returns the vector with cartesian coordinates 
$v_i/r, 0 \leq i < d$.}*/
{ return scale(r.denominator(),r.numerator()); }

VectorHd<RT,LA>& operator/=(const RT& n) 
{ self_scale(1,n); return *this; }
/*{\Mbinop divides all cartesian coordinates by |n|.}*/

VectorHd<RT,LA>& operator/=(int n) 
{ self_scale(1,n); return *this; }

VectorHd<RT,LA>& operator/=(const Quotient<RT>& r) 
{ self_scale(r.denominator(),r.numerator()); return *this; }
/*{\Mbinop     divides all cartesian coordinates by |r|.}*/

Quotient<RT> 
operator* (const VectorHd<RT,LA>& w) const
/*{\Mbinopfunc inner product, i.e., $\sum_{ 0 \le i < d } v_i w_i$, 
where $v_i$ and $w_i$ are the cartesian coordinates of $v$ and $w$ 
respectively. }*/
{ int d = dimension(); 
  CGAL_assertion_msg((d==w.dimension()),
    "inner product: dimensions disagree."); 
  RT nom = 0; 
  for (int i = 0; i < d; i++) 
    nom += homogeneous(i) * w.homogeneous(i); 
  RT denom = homogeneous(d) * w.homogeneous(d); 
  return Quotient<RT>(nom,denom); 
}

VectorHd<RT,LA> operator+(const VectorHd<RT,LA>& w) const 
/*{\Mbinop returns the vector with cartesian coordinates 
$v_i+w_i, 0 \leq i < d$.}*/
{ VectorHd<RT,LA> res(dimension()); 
  res.ptr->homogeneous_add(ptr, w.ptr); 
  return res; 
}

VectorHd<RT,LA>& operator+=(const VectorHd<RT,LA>& w) 
/*{\Mbinop addition plus assignment.}*/
{ int d = dimension(); 
  VectorHd<RT,LA> old(*this); 
  *this = VectorHd<RT,LA>(d); 
  ptr->homogeneous_add(old.ptr, w.ptr); 
  return *this; 
}

VectorHd<RT,LA> operator-(const VectorHd<RT,LA>& w) const 
/*{\Mbinop returns the vector with cartesian coordinates 
$v_i-w_i, 0 \leq i < d$.}*/
{ VectorHd<RT,LA> res(dimension()); 
  res.ptr->homogeneous_sub(ptr, w.ptr); 
  return res; 
}

VectorHd<RT,LA>& operator-=(const VectorHd<RT,LA>& w) 
/*{\Mbinop subtraction plus assignment.}*/
{ int d = dimension(); 
  VectorHd<RT,LA> old(*this); 
  *this = VectorHd<RT,LA>(d); 
  ptr->homogeneous_sub(old.ptr, w.ptr); 
  return *this; 
}

VectorHd<RT,LA> operator-() const 
/*{\Munop returns -|\Mvar|.}*/
{ VectorHd<RT,LA> result(*this); 
  result.copy_on_write(); // creates a copied object!
  result.ptr->invert(dimension()); 
  return result; 
}

static Comparison_result cmp(
  const VectorHd<RT,LA>& x, const VectorHd<RT,LA>& y) 
{ Compare_homogeneously<RT,LA> cmpobj;
  return cmpobj(x.vector_rep(),y.vector_rep());
}

bool operator==(const VectorHd<RT,LA>& w) const
{ if ( identical(w) ) return true;
  if ( dimension() != w.dimension() ) return false;
  return cmp(*this,w) == EQUAL; 
}

bool operator!=(const VectorHd<RT,LA>& w) const
{ return !operator==(w); }

bool  is_zero() const
/*{\Mop returns true if |\Mvar| is the zero vector. }*/
{ for (int i = 0; i < dimension(); i++)
    if  ( homogeneous(i) != RT(0) ) return false;
  return true;
}

/*{\Mtext \headerline{Downward compatibility}
We provide all operations of the lower dimensional interface |x()|, |y()|,
|z()|, |hx()|, |hy()|, |hz()|, |hw()|.}*/
RT hx() const { return homogeneous(0); }
RT hy() const { return homogeneous(1); }
RT hz() const { return homogeneous(2); }
RT hw() const { return homogeneous(dimension()); }
Quotient<RT> x()  const { return Quotient<RT>(hx(),hw());}
Quotient<RT> y()  const { return Quotient<RT>(hy(),hw());}
Quotient<RT> z()  const { return Quotient<RT>(hz(),hw());}

friend std::istream& operator>> <> 
  (std::istream& I, VectorHd<RT,LA>& v);
friend std::ostream& operator<< <> 
  (std::ostream& O, const VectorHd<RT,LA>& v);

}; // end of class VectorHd

/*{\Mimplementation 
Vectors are implemented by arrays of variables of type |RT| as an item
type.  All operations like creation, initialization, tests, vector
arithmetic, input and output on an vector $v$ take time
$O(|v.dimension()|)$. |dimension()|, coordinate access and conversions take
constant time.  The space requirement of a vector is $O(|v.dimension()|)$.
The operations for linear hull, rank and independence have the cubic
costs of the used matrix operations.  }*/

//----------------------- end of file ----------------------------------



CGAL_END_NAMESPACE
#endif // CGAL_VECTORHD_H 

