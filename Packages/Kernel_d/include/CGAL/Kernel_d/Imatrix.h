// ============================================================================
//
// Copyright (c) 1997-2000 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------------
//
// release       : $CGAL_Revision$
// release_date  : $CGAL_Date$
//
// file          : include/CGAL/Imatrix.h
// package       : Kernel_d
// chapter       : Kernel
//
// source        : ddgeo/Linear_algebra.lw
// revision      : $Revision$
// revision_date : $Date$
//
// author(s)     : Michael Seel <seel@mpi-sb.mpg.de>
// maintainer    : Michael Seel <seel@mpi-sb.mpg.de>
// coordinator   : Susan Hert <hert@mpi-sb.mpg.de>
//
// implementation: Higher dimensional geometry
// ============================================================================
//---------------------------------------------------------------------
// file generated by notangle from Linear_algebra.lw
// please debug or modify noweb file
// based on LEDA architecture by S. Naeher, C. Uhrig
// coding: K. Mehlhorn, M. Seel
// debugging and templatization: M. Seel
//---------------------------------------------------------------------

#ifndef LINALG_IMATRIX_H
#define LINALG_IMATRIX_H

#include <math.h>
#include <CGAL/Kernel_d/Ivector.h>

/*{\Msubst
<>#
<_RT,_ALLOC>#<RT,LA>
}*/

LA_BEGIN_NAMESPACE

/*{\Moptions 
outfile=Imatrix.man
}*/
/*{\Manpage {Imatrix} {RT} {Matrices with RT Entries} {M}}*/

template <class _RT, class _ALLOC>
class Imatrix 
{ 
/*{\Mdefinition
An instance of data type |Imatrix| is a matrix of variables of type |RT|, the
so called ring type. The arithmetic type |RT| is required to behave like
integers in the mathematical sense.

The types |Imatrix| and |Ivector| together realize many functions of basic
linear algebra.  All functions on integer matrices compute the exact result,
i.e., there is no rounding error. |\Mname| offers all simple matrix
operations. The more sophisticated ones are provided by the class
|Linear_algebra|.  Preconditions are checked by default and can be switched off
by the compile flag [[LA_PRECOND_OFF]].}*/
public:

/*{\Mtypes 5.5}*/

typedef Ivector<_RT,_ALLOC>* vector_pointer;
typedef const Ivector<_RT,_ALLOC>* const_vector_pointer;

typedef _RT    RT;
/*{\Mtypemember the ring type of the components.}*/ 

typedef Ivector<_RT,_ALLOC> Vector;
/*{\Mtypemember the vector type used.}*/ 

typedef vector_pointer iterator;
/*{\Mtypemember the iterator type for accessing rows.}*/ 

typedef const_vector_pointer const_iterator;
/*{\Mtypemember the const iterator type for accessing rows.}*/ 

class Identity {};
/*{\Mtypemember a tag class for identity initialization}*/

class Initialize {};
/*{\Mtypemember a tag class for homogeneous initialization}*/

protected:
  vector_pointer* v; 
  int  d1; 
  int  d2; 

  RT&  elem(int i, int j) const { return v[i]->v[j]; }
  #ifndef _MSC_VER
  typedef typename _ALLOC::template rebind<vector_pointer>::other 
          allocator_type;
  static allocator_type MM;
  #endif

  #ifndef _MSC_VER
  inline void allocate_mat_space(vector_pointer*& vi, int d)
  {
  /* We use this procedure to allocate memory. We use our allocator
     memory allocation scheme. There we first get an appropriate piece
     of memory and then initialize each cell by an inplace new. */

    vi = MM.allocate(d); 
    vector_pointer* p = vi + d - 1; 
    while (p >= vi) { 
      new (p,0) vector_pointer*; p--; 
    }
  }

  inline void deallocate_mat_space(vector_pointer*& vi, int d)
  {
  /* deallocate memory via our _ALLOC object. */

    MM.deallocate(vi,d);
    vi = (vector_pointer*)0;
  }
  #else

  inline void allocate_mat_space(vector_pointer*& vi, int d)
  { vi = new vector_pointer[d]; }

  inline void deallocate_mat_space(vector_pointer*& vi, int d)
  { delete[] vi;
    vi = (vector_pointer*)0; }

  #endif

  inline void check_dimensions(const Imatrix<_RT,_ALLOC>& mat) const
  { 
    LA_PRECOND((d1 == mat.d1 && d2 == mat.d2), 
      "Imatrix::check_dimensions: incompatible matrix dimensions.") 
  }



public:

/*{\Mcreation 4}*/

Imatrix() : d1(0),d2(0) { v = (Vector**)0; }

Imatrix(int n); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of
dimension $n \times n$ initialized to the zero matrix.}*/
Imatrix(int n, int m); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of 
dimension $n \times m$ initialized to the zero matrix.}*/
Imatrix(int n , const Identity&, const RT& x = RT(1) ); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of
dimension $n \times n$ initialized to the identity matrix
(times |x|).}*/
Imatrix(int n, int m, const Initialize&, const RT& x); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of 
dimension $n \times m$ initialized to the matrix with |x|
entries.}*/
template <class RAIterator>
void range_initialize(RAIterator first, RAIterator last,  
                      std::random_access_iterator_tag) 
{ typedef typename std::iterator_traits<RAIterator>::value_type value_type;
  typedef typename value_type::const_iterator const_iterator;
  d2 = last-first;
  if (d2 == 0) { d1=0; v=0; return; }
  d1 = first->dimension(); 
  if (d1 > 0) { 
    int i,j;
    allocate_mat_space(v,d1);
    for (i=0; i<d1; i++) {
      v[i] = new Vector(d2);
      // for (int j = 0; j < d2; j++) elem(i,j) = (*(first+j))[i];
    }
    const_iterator it;
    for (j=0; first != last; ++j, ++first) // column wise
      for (i=0, it=first->begin(); it != first->end(); ++i, ++it) // row wise
        elem(i,j) = *it;
  } else 
    v = (Vector**)0; 
}

template <class InputIterator>
void range_initialize(InputIterator first, InputIterator last, 
                 std::forward_iterator_tag) 
{ typedef typename std::iterator_traits<InputIterator>::value_type value_type;
  std::vector<value_type> V(first,last);
  range_initialize(V.begin(),V.end(),std::random_access_iterator_tag());
}

template <class Forward_iterator>
Imatrix(Forward_iterator first, Forward_iterator last)
/*{\Mcreate creates an instance |\Mvar| of type |\Mname|. Let $S$ be the
ordered set of $m$ column-vectors of common dimension $n$ as given by the
iterator range |[first,last)|.  |\Mvar| is initialized to an $n \times m$
matrix with the columns as specified by $S$.  \precond |Forward_iterator| has a
value type |V| from which we require to provide a iterator type
|V::const_iterator|, to have value type |V::value_type == RT| and to provide a
random access iterator range via |[ V::begin(), V::end() )|.\\ Note that
|Vector| or |std::vector<RT,LA>| fulfill these requirements.}*/
{ range_initialize(first,last,
  std::iterator_traits<Forward_iterator>::iterator_category()); }

Imatrix(const std::vector< Vector >& A) 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname|. Let $A$
            be an array of $m$ column - vectors of common dimension $n$. 
            |\Mvar| is initialized to an $n \times m$ matrix with the 
            columns as specified by $A$. }*/
{ range_initialize(A.begin(),A.end(),std::random_access_iterator_tag()); }

Imatrix(const Imatrix<_RT,_ALLOC>&); 

Imatrix(const Ivector<_RT,_ALLOC>&); 
/* creates a $d \times 1$ matrix */
Imatrix(int, int, RT**); 
Imatrix<_RT,_ALLOC>& operator=(const Imatrix<_RT,_ALLOC>&); 
~Imatrix(); 

/*{\Moperations 1.7 3.5}*/

int row_dimension()  const {  return d1; }
/*{\Mop  returns $n$, the number of rows of |\Mvar|. }*/

int column_dimension()  const { return d2; }
/*{\Mop  returns $m$, the number of columns of |\Mvar|. }*/

Vector& row(int i) const
/*{\Mop  returns the $i$-th row of |\Mvar| (an $m$ - vector).\\
         \precond  $0 \le i \le n - 1$. }*/
{ 
  LA_PRECOND((0<=i && i<d1), "Imatrix::row: index out of range.")
  return *v[i]; 
}

Vector  column(int i) const; 
/*{\Mop  returns the $i$-th column of |\Mvar| (an $n$ - vector).\\
         \precond  $0 \le i \le m - 1$. }*/
Ivector<_RT,_ALLOC> to_vector() const 
{ 
  LA_PRECOND((d2==1), 
    "Imatrix::to_vector: cannot make vector from matrix.") 
  return column(0); 
}

friend Ivector<_RT,_ALLOC>  to_vector(const Imatrix<RT,_ALLOC>& M)
{ return M.to_vector(); }

Ivector<_RT,_ALLOC>& operator[](int i) const  
{ 
  LA_PRECOND((0<=i && i<d1), 
    "Imatrix::operator[]: index out of range.")
  return row(i); 
}

RT& operator()(int i, int j)
/*{\Mfunop returns $M_{ i,j }$. \\
   \precond $0\le i\le n - 1$ and $0\le j\le m - 1$. }*/
{ 
  LA_PRECOND((0<=i && i<d1), 
    "Imatrix::operator(): row index out of range.")
  LA_PRECOND((0<=j && j<d2), 
    "Imatrix::operator(): column index out of range.") 
  return elem(i,j); 
}

RT  operator()(int i, int j) const
{ 
  LA_PRECOND((0<=i && i<d1), 
    "Imatrix::operator(): row index out of range.")
  LA_PRECOND((0<=j && j<d2), 
    "Imatrix::operator(): column index out of range.")
  return elem(i,j); 
}

bool  operator==(const Imatrix<_RT,_ALLOC>& M1)  const; 
/*{\Mbinop Test for equality. }*/

bool  operator!=(const Imatrix<_RT,_ALLOC>& M1)  const 
/*{\Mbinop Test for inequality. }*/
{ return !(*this == M1); }

/*{\Mtext \headerline{Arithmetic Operators}}*/
/*{\Mtext
\settowidth{\typewidth}{|Imatrix<RT,LA>m|}
\addtolength{\typewidth}{\colsep}
\callwidth2cm
\computewidths
\newcommand{\dimeq}[2]{ 
\\|M.row_dimension() == M1.row_dimension()| and
\\|M.column_dimension() == M1.column_dimension()|
}
}*/

Imatrix<_RT,_ALLOC> operator+ (const Imatrix<_RT,_ALLOC>& M1); 
/*{\Mbinop Addition. \precond \dimeq.}*/

Imatrix<_RT,_ALLOC> operator- (const Imatrix<_RT,_ALLOC>& M1); 
/*{\Mbinop Subtraction. \precond \dimeq.}*/

Imatrix<_RT,_ALLOC> operator-(); // unary
/*{\Munop Negation.}*/

Imatrix<_RT,_ALLOC>& operator-=(const Imatrix<_RT,_ALLOC>&); 

Imatrix<_RT,_ALLOC>& operator+=(const Imatrix<_RT,_ALLOC>&); 

Imatrix<_RT,_ALLOC> 
operator*(const Imatrix<_RT,_ALLOC>& M1) const; 
/*{\Mbinop Multiplication. \precond \\ 
           |\Mvar.column_dimension() = M1.row_dimension()|. }*/

Ivector<_RT,_ALLOC> 
operator*(const Ivector<_RT,_ALLOC>& vec) const
{  return ((*this) * Imatrix<_RT,_ALLOC>(vec)).to_vector(); }
/*{\Mbinop  Multiplication with vector. \precond \\
            |\Mvar.column_dimension() = vec.dimension()|.}*/

Imatrix<_RT,_ALLOC> compmul(const RT& x) const; 

static int compare(const Imatrix<_RT,_ALLOC>& M1, 
                   const Imatrix<_RT,_ALLOC>& M2);

}; // end of class

/*{\Xtext \headerline{Input and Output}}*/

template <class RT, class A> 
std::ostream&  operator<<(std::ostream& os, const Imatrix<RT,A>& M);
/*{\Xbinopfunc writes matrix |\Mvar| row by row to the output stream |os|.}*/

template <class RT, class A> 
std::istream&  operator>>(std::istream& is, Imatrix<RT,A>& M);
/*{\Xbinopfunc reads matrix |\Mvar| row by row from the input stream |is|.}*/


/*{\Mimplementation 
The datatype |\Mname| is implemented by two-dimensional arrays of variables
of type |RT|. The memory layout is row oriented. Operation |column| takes time
$O(n)$, |row|, |dim1|, |dim2| take constant time, and all other operations take
time $O(nm)$.  The space requirement is $O(nm)$.}*/

template <class RT, class A>
Imatrix<RT,A>::
Imatrix(int dim) : d1(dim),d2(dim)
{ 
  LA_PRECOND((dim >= 0), "Imatrix::constructor: negative dimension.") 
  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
  } else 
    v = (Vector**)0; 
}

template <class RT, class A>
Imatrix<RT,A>::
Imatrix(int dim1, int dim2) : d1(dim1),d2(dim2)
{ 
  LA_PRECOND((dim1>=0 && dim2>=0), 
    "Imatrix::constructor: negative dimension.") 

  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
  } else 
    v = (Vector**)0; 
}

template <class RT, class A>
Imatrix<RT,A>::
Imatrix(int dim, const Identity&, const RT& x) : d1(dim),d2(dim)
{ 
  LA_PRECOND((dim >= 0), "Imatrix::constructor: negative dimension.") 
  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
    if (x!=RT(0)) for (int i=0; i<d1; i++) elem(i,i)=x;
  } else 
    v = (Vector**)0; 
}

template <class RT, class A>
Imatrix<RT,A>::
Imatrix(int dim1, int dim2, const Initialize&, const RT& x) : 
  d1(dim1),d2(dim2)
{ 
  LA_PRECOND((dim1>=0 && dim2>=0), 
    "Imatrix::constructor: negative dimension.") 

  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2, Vector::Initialize(), x); 
  } else 
    v = (Vector**)0; 
}


template <class RT, class A>
Imatrix<RT,A>::
Imatrix(const Imatrix<RT,A>& p) : d1(p.d1),d2(p.d2)
{ 
  if (d1 > 0) {  
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(*p.v[i]); 
  }
  else 
    v = (Ivector<RT,A>**)0; 
}

template <class RT, class A>
Imatrix<RT,A>::
Imatrix(const Ivector<RT,A>& vec) : d1(vec.dim),d2(1)
{   
  if (d1>0)
    allocate_mat_space(v,d1);
  else
    v = (Ivector<RT,A>**)0; 
  for(int i = 0; i < d1; i++) { 
    v[i] = new Vector(1); 
    elem(i,0) = vec[i]; 
  }
}

template <class RT, class A>
Imatrix<RT,A>::
Imatrix(int dim1, int dim2, RT** p) : d1(dim1),d2(dim2)
{ 
  LA_PRECOND((dim1 >= 0 && dim2 >= 0), 
    "Imatrix::constructor: negative dimension.")
  if (d1 > 0) {
    allocate_mat_space(v,d1);
    for(int i=0; i<d1; i++) { 
      v[i] = new Ivector<RT,A>(d2); 
      for(int j=0; j<d2; j++) 
        elem(i,j) = p[i][j]; 
    }
  } else 
    v = (Ivector<RT,A>**)0; 
}

template <class RT, class A>
Imatrix<RT,A>& Imatrix<RT,A>::
operator=(const Imatrix<RT,A>& mat)
{ 
  register int i,j; 
  if (d1 != mat.d1 || d2 != mat.d2) { 
    for(i=0; i<d1; i++) delete v[i]; 
    if (v) deallocate_mat_space(v,d1);

    d1 = mat.d1; d2 = mat.d2; 
    if (d1>0)
      allocate_mat_space(v,d1);
    for(i = 0; i < d1; i++) 
      v[i] = new Vector(d2); 
  }

  for(i = 0; i < d1; i++)
    for(j = 0; j < d2; j++) 
      elem(i,j) = mat.elem(i,j); 
  return *this; 
}


template <class RT, class A>
Imatrix<RT,A>::
~Imatrix()  
{ 
  if (v) {
    for (int i=0; i<d1; i++) 
      delete v[i];  
    deallocate_mat_space(v,d1);
  }
}



template <class RT, class A>
Ivector<RT,A> Imatrix<RT,A>::
column(int i)  const
{ 
  LA_PRECOND((i>=0 && i<d2), 
    "Imatrix::column: index out of range.") 

  Vector result(d1); 
  int j = d1; 
  while (j--) result.v[j] = elem(j,i); 
  return result; 
}

template <class RT, class A>
bool Imatrix<RT,A>::
operator==(const Imatrix<RT,A>& x) const
{ 
  register int i,j; 
  if (d1 != x.d1 || d2 != x.d2) 
    return false; 

  for(i = 0; i < d1; i++)
    for(j = 0; j < d2; j++)
      if (elem(i,j) != x.elem(i,j)) 
        return false; 
  return true; 
}

template <class RT, class A>
Imatrix<RT,A> Imatrix<RT,A>::
operator+ (const Imatrix<RT,A>& mat)
{ 
  register int i,j; 
  check_dimensions(mat); 
  Imatrix<RT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = elem(i,j) + mat.elem(i,j); 
  return result; 
}

template <class RT, class A>
Imatrix<RT,A> Imatrix<RT,A>::
operator- (const Imatrix<RT,A>& mat)
{ 
  register int i,j; 
  check_dimensions(mat); 
  Imatrix<RT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = elem(i,j) - mat.elem(i,j); 
  return result; 
}

template <class RT, class A>
Imatrix<RT,A> Imatrix<RT,A>::
operator- ()  // unary
{ 
  register int i,j; 
  Imatrix<RT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = -elem(i,j); 
  return result; 
}

template <class RT, class A>
Imatrix<RT,A>& Imatrix<RT,A>::
operator-= (const Imatrix<RT,A>& mat) 
{ 
  register int i,j; 
  check_dimensions(mat); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      elem(i,j) -= mat.elem(i,j); 
  return *this; 
}

template <class RT, class A>
Imatrix<RT,A>& Imatrix<RT,A>::
operator+= (const Imatrix<RT,A>& mat) 
{ 
  register int i,j; 
  check_dimensions(mat); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      elem(i,j) += mat.elem(i,j); 
  return *this; 
}

template <class RT, class A>
Imatrix<RT,A> Imatrix<RT,A>::
operator*(const Imatrix<RT,A>& mat) const
{ 
  LA_PRECOND((d2==mat.d1), 
    "Imatrix::operator*: incompatible matrix types.") 
  
  Imatrix<RT,A> result(d1, mat.d2); 
  register int i,j; 

  for (i=0; i<mat.d2; i++)
  for (j=0; j<d1; j++) 
    result.elem(j,i) = *v[j] * mat.column(i); 
  return result; 
}

template <class RT, class A>
Imatrix<RT,A> Imatrix<RT,A>::
compmul(const RT& f) const
{ 
  register int i,j; 
  Imatrix<RT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = elem(i,j) *f; 
  return result; 
}


template <class RT, class A>
Imatrix<RT,A>  operator*(const Imatrix<RT,A>& M, const RT& x)
{ return M.compmul(x); }
/*{\Mbinopfunc Multiplication of every entry with |x|. }*/

template <class RT, class A>
Imatrix<RT,A>  operator*(const Imatrix<RT,A>& M, int x)
{ return M.compmul(x); }

template <class RT, class A>
Imatrix<RT,A>  operator*(const RT& x, const Imatrix<RT,A>& M)
{ return M.compmul(x); }
/*{\Mbinopfunc Multiplication of every entry with |x|. }*/

template <class RT, class A>
Imatrix<RT,A>  operator*(int x, const Imatrix<RT,A>& M)
{ return M.compmul(x); }


template <class RT, class A> 
int Imatrix<RT,A>::
compare(const Imatrix<RT,A>& M1, const Imatrix<RT,A>& M2) 
{ 
  register int i;
  int res;
  M1.check_dimensions(M2);
  for(i=0; i < M1.row_dimension() && 
      (res = compare(M1.row(i),M2.row(i))) != 0; i++);
  return res;
}


template <class RT, class A> 
std::ostream&  operator<<(std::ostream& O, const Imatrix<RT,A>& M)
{ 
  /* syntax: d1 d2 
             x_0,0  ... x_0,d1-1
                  d2-times
             x_d2,0 ... x_d2,d1-1 */
  O << M.row_dimension() << ' ' << M.column_dimension() << std::endl;
  for (register int i=0; i < M.row_dimension(); i++) {
    for (register int j=0; j < M.column_dimension(); j++) 
      O << M(i,j) << " ";
    O << std::endl;
  }
  return O; 
}

template <class RT, class A> 
std::istream&  operator>>(std::istream& in, Imatrix<RT,A>& M) 
{ 
  /* syntax: d1 d2 
             x_0,0  ... x_0,d1-1
                  d2-times
             x_d2,0 ... x_d2,d1-1 */

  int dim1 = 0, dim2 = 0;
  if (!(in >> dim1 >> dim2)) 
    return in;
  if (M.row_dimension() != dim1 || M.column_dimension() != dim2)
    M = Imatrix<RT,A>(dim1,dim2);

  for (register int i=0; i<dim1; i++)
    for (register int j=0; j<dim2; j++) 
      if (!(in >> M(i,j)))
        return in;
  return in; 
}

#ifndef _MSC_VER
template <class RT, class A>
Imatrix<RT,A>::allocator_type Imatrix<RT,A>::MM;
#endif


LA_END_NAMESPACE
#endif // LINALG_IMATRIX_H

