// ============================================================================
//
// Copyright (c) 1997-2000 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------------
//
// release       : $CGAL_Revision$
// release_date  : $CGAL_Date$
//
// file          : include/CGAL/Imatrix.h
// package       : Kernel_d
// chapter       : Kernel
//
// source        : ddgeo/Linear_algebra.lw
// revision      : $Revision$
// revision_date : $Date$
//
// author(s)     : Michael Seel <seel@mpi-sb.mpg.de>
// maintainer    : Michael Seel <seel@mpi-sb.mpg.de>
// coordinator   : Susan Hert <hert@mpi-sb.mpg.de>
//
// implementation: Higher dimensional geometry
// ============================================================================
//---------------------------------------------------------------------
// file generated by notangle from Linear_algebra.lw
// please debug or modify noweb file
// based on LEDA architecture by S. Naeher, C. Uhrig
// coding: K. Mehlhorn, M. Seel
// debugging and templatization: M. Seel
//---------------------------------------------------------------------

#ifndef CGAL_IMATRIX_H
#define CGAL_IMATRIX_H

#include <math.h>
#include <CGAL/Kernel_d/Ivector.h>
#include <new>

CGAL_BEGIN_NAMESPACE

/*{\Msubst
<_NT,_ALLOC>#<NT>
Ivector#Vector
Imatrix#Matrix
}*/
/*{\Moptions print_title=yes}*/
/*{\Moptions outfile=Imatrix.man}*/
/*{\Manpage {Matrix}{NT}{Matrices with NT Entries}{M}}*/

template <class _NT, class _ALLOC>
class Imatrix 
{ 
/*{\Mdefinition An instance of data type |\Mname| is a matrix of
variables of number type |NT|. The types |\Mname| and |Ivector|
together realize many functions of basic linear algebra.  All
functions on integer matrices compute the exact result, i.e., there is
no rounding error. |\Mname| offers all simple matrix operations. The
more sophisticated ones are provided by the class |Linear_algebra|.
Preconditions are checked by default and can be switched off by the
compile flag [[CGAL_LA_PRECOND_OFF]].}*/

public:

/*{\Mtypes 5.5}*/

typedef Ivector<_NT,_ALLOC>* vector_pointer;
typedef const Ivector<_NT,_ALLOC>* const_vector_pointer;

typedef _NT NT;
/*{\Mtypemember the ring type of the components.}*/ 

typedef Ivector<_NT,_ALLOC> Vector;
/*{\Mtypemember the vector type used.}*/ 

typedef vector_pointer iterator;
/*{\Mtypemember the iterator type for accessing rows.}*/ 

typedef const_vector_pointer const_iterator;
/*{\Mtypemember the const iterator type for accessing rows.}*/ 

typedef NT* Row_iterator;
/*{\Xtypemember accessing row entries.}*/ 
typedef const NT& Row_const_iterator;

class Identity {};
/*{\Mtypemember a tag class for identity initialization}*/

class Initialize {};
/*{\Mtypemember a tag class for homogeneous initialization}*/

protected:
  vector_pointer* v; 
  int  d1; 
  int  d2; 

  NT&  elem(int i, int j) const { return v[i]->v[j]; }
  #ifndef _MSC_VER
  typedef typename _ALLOC::template rebind<vector_pointer>::other 
          allocator_type;
  static allocator_type MM;
  #endif

  #ifndef _MSC_VER
  inline void allocate_mat_space(vector_pointer*& vi, int d)
  {
  /* We use this procedure to allocate memory. We use our allocator
     memory allocation scheme. There we first get an appropriate piece
     of memory and then initialize each cell by an inplace new. */

    vi = MM.allocate(d); 
    vector_pointer* p = vi + d - 1; 
    while (p >= vi) { 
      new (p) vector_pointer*(0); p--;
    }
  }

  inline void deallocate_mat_space(vector_pointer*& vi, int d)
  {
  /* deallocate memory via our _ALLOC object. */

    MM.deallocate(vi,d);
    vi = (vector_pointer*)0;
  }
  #else

  inline void allocate_mat_space(vector_pointer*& vi, int d)
  { vi = new vector_pointer[d]; }

  inline void deallocate_mat_space(vector_pointer*& vi, int d)
  { delete[] vi;
    vi = (vector_pointer*)0; }

  #endif

  inline void check_dimensions(const Imatrix<_NT,_ALLOC>& mat) const
  { 
    CGAL_LA_PRECOND((d1 == mat.d1 && d2 == mat.d2), 
      "Imatrix::check_dimensions: incompatible matrix dimensions.") 
  }



public:

/*{\Mcreation 4}*/

Imatrix() : d1(0),d2(0) { v = (Vector**)0; }

Imatrix(int n); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of
dimension $n \times n$ initialized to the zero matrix.}*/
Imatrix(int n, int m); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of 
dimension $n \times m$ initialized to the zero matrix.}*/
Imatrix(std::pair<int,int> p); 
Imatrix(int n , const Identity&, const NT& x = NT(1) ); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of
dimension $n \times n$ initialized to the identity matrix
(times |x|).}*/
Imatrix(int n, int m, const Initialize&, const NT& x); 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname| of 
dimension $n \times m$ initialized to the matrix with |x|
entries.}*/
template <class RAIterator>
void range_initialize(RAIterator first, RAIterator last,  
                      std::random_access_iterator_tag) 
{ typedef typename std::iterator_traits<RAIterator>::value_type value_type;
  typedef typename value_type::const_iterator const_iterator;
  d2 = last-first;
  if (d2 == 0) { d1=0; v=0; return; }
  d1 = first->dimension(); 
  if (d1 > 0) { 
    int i,j;
    allocate_mat_space(v,d1);
    for (i=0; i<d1; i++) {
      v[i] = new Vector(d2);
      // for (int j = 0; j < d2; j++) elem(i,j) = (*(first+j))[i];
    }
    const_iterator it;
    for (j=0; first != last; ++j, ++first) // column wise
      for (i=0, it=first->begin(); it != first->end(); ++i, ++it) // row wise
        elem(i,j) = *it;
  } else 
    v = (Vector**)0; 
}

template <class InputIterator>
void range_initialize(InputIterator first, InputIterator last, 
                 std::forward_iterator_tag) 
{ typedef typename std::iterator_traits<InputIterator>::value_type 
    value_type;
  std::vector<value_type> V(first,last);
  range_initialize(V.begin(),V.end(),std::random_access_iterator_tag());
}

template <class Forward_iterator>
Imatrix(Forward_iterator first, Forward_iterator last)
/*{\Mcreate creates an instance |\Mvar| of type |\Mname|. Let $S$ be
the ordered set of $m$ column-vectors of common dimension $n$ as given
by the iterator range |[first,last)|.  |\Mvar| is initialized to an $n
\times m$ matrix with the columns as specified by $S$.  \precond
|Forward_iterator| has a value type |V| from which we require to
provide a iterator type |V::const_iterator|, to have |V::value_type ==
NT|.\\ Note that |Ivector| or |std::vector<NT,LA>| fulfill these
requirements.}*/
{ range_initialize(first,last,
  std::iterator_traits<Forward_iterator>::iterator_category()); }

Imatrix(const std::vector< Vector >& A) 
/*{\Mcreate creates an instance |\Mvar| of type |\Mname|. Let $A$
            be an array of $m$ column-vectors of common dimension $n$. 
            |\Mvar| is initialized to an $n \times m$ matrix with the 
            columns as specified by $A$. }*/
{ range_initialize(A.begin(),A.end(),
    std::random_access_iterator_tag()); }

Imatrix(const Imatrix<_NT,_ALLOC>&); 

Imatrix(const Vector&); 
/* creates a $d \times 1$ matrix */

Imatrix(int, int, NT**); 

Imatrix<_NT,_ALLOC>& operator=(const Imatrix<_NT,_ALLOC>&); 

~Imatrix(); 

/*{\Moperations 1.7 3.5}*/

int row_dimension()  const {  return d1; }
/*{\Mop returns $n$, the number of rows of |\Mvar|.}*/

int column_dimension()  const { return d2; }
/*{\Mop returns $m$, the number of columns of |\Mvar|.}*/

std::pair<int,int> dimension() const 
/*{\Mop returns $(m,n)$, the dimension pair of |\Mvar|.}*/
{ return std::pair<int,int>(d1,d2); }

Vector& row(int i) const
/*{\Mop  returns the $i$-th row of |\Mvar| (an $m$ - vector).\\
         \precond  $0 \le i \le n - 1$. }*/
{ 
  CGAL_LA_PRECOND((0<=i && i<d1), "Imatrix::row: index out of range.")
  return *v[i]; 
}

inline Vector column(int i) const; 
/*{\Mop  returns the $i$-th column of |\Mvar| (an $n$ - vector).\\
         \precond  $0 \le i \le m - 1$. }*/

Vector to_vector() const 
{ 
  CGAL_LA_PRECOND((d2==1), 
    "Imatrix::to_vector: cannot make vector from matrix.") 
  return column(0); 
}

friend Ivector<_NT,_ALLOC> to_vector(const Imatrix<NT,_ALLOC>& M)
{ return M.to_vector(); }

Ivector<_NT,_ALLOC>& operator[](int i) const  
{ 
  CGAL_LA_PRECOND((0<=i && i<d1), 
    "Imatrix::operator[]: index out of range.")
  return row(i); 
}

NT& operator()(int i, int j)
/*{\Mfunop returns $M_{ i,j }$. \\
\precond $0\le i\le n - 1$ and $0\le j\le m - 1$. }*/
{ 
  CGAL_LA_PRECOND((0<=i && i<d1), 
    "Imatrix::operator(): row index out of range.")
  CGAL_LA_PRECOND((0<=j && j<d2), 
    "Imatrix::operator(): column index out of range.") 
  return elem(i,j); 
}

NT  operator()(int i, int j) const
{ 
  CGAL_LA_PRECOND((0<=i && i<d1), 
    "Imatrix::operator(): row index out of range.")
  CGAL_LA_PRECOND((0<=j && j<d2), 
    "Imatrix::operator(): column index out of range.")
  return elem(i,j); 
}

void swap_columns(int i, int j) 
/*{\Mop swaps columns $i$ and $j$.}*/
{ CGAL_assertion(0<=i && i<d2 && 0<=j && j<d2);
  for(int l = 0; l < d1; l++) std::swap(elem(l,i),elem(l,j)); 
}

void swap_rows(int i, int j)
/*{\Mop swaps rows $i$ and $j$.}*/
{ CGAL_assertion(0<=i && i<d1 && 0<=j && j<d1);
  std::swap(v[i],v[j]); 
}

Row_iterator row_begin(int i) { return v[i]->begin(); }
Row_iterator row_end(int i)   { return v[i]->end(); }

Row_const_iterator row_begin(int i) const { return v[i]->begin(); }
Row_const_iterator row_end(int i)   const { return v[i]->end(); }


bool  operator==(const Imatrix<_NT,_ALLOC>& M1)  const; 
/*{\Mbinop Test for equality. }*/

bool  operator!=(const Imatrix<_NT,_ALLOC>& M1)  const 
/*{\Mbinop Test for inequality. }*/
{ return !(*this == M1); }

/*{\Mtext \headerline{Arithmetic Operators}}*/
/*{\Mtext
\settowidth{\typewidth}{|Imatrix<NT,LA>m|}
\addtolength{\typewidth}{\colsep}
\callwidth2cm
\computewidths
\newcommand{\dimeq}[2]{ 
\\|M.row_dimension() == M1.row_dimension()| and
\\|M.column_dimension() == M1.column_dimension()|
}
}*/

Imatrix<_NT,_ALLOC> operator+ (const Imatrix<_NT,_ALLOC>& M1); 
/*{\Mbinop Addition. \precond \dimeq.}*/

Imatrix<_NT,_ALLOC> operator- (const Imatrix<_NT,_ALLOC>& M1); 
/*{\Mbinop Subtraction. \precond \dimeq.}*/

Imatrix<_NT,_ALLOC> operator-(); // unary
/*{\Munop Negation.}*/

Imatrix<_NT,_ALLOC>& operator-=(const Imatrix<_NT,_ALLOC>&); 

Imatrix<_NT,_ALLOC>& operator+=(const Imatrix<_NT,_ALLOC>&); 

Imatrix<_NT,_ALLOC> 
operator*(const Imatrix<_NT,_ALLOC>& M1) const; 
/*{\Mbinop Multiplication. \precond \\ 
           |\Mvar.column_dimension() = M1.row_dimension()|. }*/

Ivector<_NT,_ALLOC> 
operator*(const Ivector<_NT,_ALLOC>& vec) const
{  return ((*this) * Imatrix<_NT,_ALLOC>(vec)).to_vector(); }
/*{\Mbinop  Multiplication with vector. \precond \\
|\Mvar.column_dimension() = vec.dimension()|.}*/

Imatrix<_NT,_ALLOC> compmul(const NT& x) const; 

static int compare(const Imatrix<_NT,_ALLOC>& M1, 
                   const Imatrix<_NT,_ALLOC>& M2);

}; // end of class

/*{\Xtext \headerline{Input and Output}}*/

template <class NT, class A> 
std::ostream&  operator<<(std::ostream& os, const Imatrix<NT,A>& M);
/*{\Xbinopfunc writes matrix |\Mvar| row by row to the output stream |os|.}*/

template <class NT, class A> 
std::istream&  operator>>(std::istream& is, Imatrix<NT,A>& M);
/*{\Xbinopfunc reads matrix |\Mvar| row by row from the input stream |is|.}*/


/*{\Mimplementation 
The data type |\Mname| is implemented by two-dimensional arrays of
variables of type |NT|. The memory layout is row oriented. Operation
|column| takes time $O(n)$, |row|, |dim1|, |dim2| take constant time,
and all other operations take time $O(nm)$.  The space requirement is
$O(nm)$.}*/

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(int dim) : d1(dim),d2(dim)
{ 
  CGAL_LA_PRECOND((dim >= 0), "Imatrix::constructor: negative dimension.") 
  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
  } else 
    v = (Vector**)0; 
}

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(int dim1, int dim2) : d1(dim1),d2(dim2)
{ 
  CGAL_LA_PRECOND((dim1>=0 && dim2>=0), 
    "Imatrix::constructor: negative dimension.") 

  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
  } else 
    v = (Vector**)0; 
}

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(std::pair<int,int> p) : d1(p.first),d2(p.second)
{ 
  CGAL_LA_PRECOND((d1>=0 && d2>=0), 
    "Imatrix::constructor: negative dimension.") 
  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
  } else 
    v = (Vector**)0; 
}

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(int dim, const Identity&, const NT& x) : d1(dim),d2(dim)
{ 
  CGAL_LA_PRECOND((dim >= 0),
    "matrix::constructor: negative dimension.") 
  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2); 
    if (x!=NT(0)) for (int i=0; i<d1; i++) elem(i,i)=x;
  } else 
    v = (Vector**)0; 
}

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(int dim1, int dim2, const Initialize&, const NT& x) : 
  d1(dim1),d2(dim2)
{ 
  CGAL_LA_PRECOND((dim1>=0 && dim2>=0), 
    "Imatrix::constructor: negative dimension.") 

  if (d1 > 0) { 
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(d2, Vector::Initialize(), x); 
  } else 
    v = (Vector**)0; 
}

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(const Imatrix<NT,A>& p) : d1(p.d1),d2(p.d2)
{ 
  if (d1 > 0) {  
    allocate_mat_space(v,d1);
    for (int i=0; i<d1; i++) 
      v[i] = new Vector(*p.v[i]); 
  }
  else 
    v = (Ivector<NT,A>**)0; 
}

template <class NT, class A>
Imatrix<NT,A>::
Imatrix(const Vector& vec) : d1(vec.dim),d2(1)
{   
  if (d1>0)
    allocate_mat_space(v,d1);
  else
    v = (Ivector<NT,A>**)0; 
  for(int i = 0; i < d1; i++) { 
    v[i] = new Vector(1); 
    elem(i,0) = vec[i]; 
  }
}


template <class NT, class A>
Imatrix<NT,A>::
Imatrix(int dim1, int dim2, NT** p) : d1(dim1),d2(dim2)
{ 
  CGAL_LA_PRECOND((dim1 >= 0 && dim2 >= 0), 
    "Imatrix::constructor: negative dimension.")
  if (d1 > 0) {
    allocate_mat_space(v,d1);
    for(int i=0; i<d1; i++) { 
      v[i] = new Ivector<NT,A>(d2); 
      for(int j=0; j<d2; j++) 
        elem(i,j) = p[i][j]; 
    }
  } else 
    v = (Ivector<NT,A>**)0; 
}


template <class NT, class A>
Imatrix<NT,A>& Imatrix<NT,A>::
operator=(const Imatrix<NT,A>& mat)
{ 
  register int i,j; 
  if (d1 != mat.d1 || d2 != mat.d2) { 
    for(i=0; i<d1; i++) delete v[i]; 
    if (v) deallocate_mat_space(v,d1);

    d1 = mat.d1; d2 = mat.d2; 
    if (d1>0)
      allocate_mat_space(v,d1);
    for(i = 0; i < d1; i++) 
      v[i] = new Vector(d2); 
  }

  for(i = 0; i < d1; i++)
    for(j = 0; j < d2; j++) 
      elem(i,j) = mat.elem(i,j); 
  return *this; 
}


template <class NT, class A>
Imatrix<NT,A>::
~Imatrix()  
{ 
  if (v) {
    for (int i=0; i<d1; i++) 
      delete v[i];  
    deallocate_mat_space(v,d1);
  }
}

template <class NT, class A>
Ivector<NT,A> Imatrix<NT,A>::
column(int i)  const
{ 
  CGAL_LA_PRECOND((i>=0 && i<d2), 
    "Imatrix::column: index out of range.") 

  Vector result(d1); 
  int j = d1; 
  while (j--) result.v[j] = elem(j,i); 
  return result; 
}

template <class NT, class A>
bool Imatrix<NT,A>::
operator==(const Imatrix<NT,A>& x) const
{ 
  register int i,j; 
  if (d1 != x.d1 || d2 != x.d2) 
    return false; 

  for(i = 0; i < d1; i++)
    for(j = 0; j < d2; j++)
      if (elem(i,j) != x.elem(i,j)) 
        return false; 
  return true; 
}

template <class NT, class A>
Imatrix<NT,A> Imatrix<NT,A>::
operator+ (const Imatrix<NT,A>& mat)
{ 
  register int i,j; 
  check_dimensions(mat); 
  Imatrix<NT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = elem(i,j) + mat.elem(i,j); 
  return result; 
}

template <class NT, class A>
Imatrix<NT,A> Imatrix<NT,A>::
operator- (const Imatrix<NT,A>& mat)
{ 
  register int i,j; 
  check_dimensions(mat); 
  Imatrix<NT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = elem(i,j) - mat.elem(i,j); 
  return result; 
}

template <class NT, class A>
Imatrix<NT,A> Imatrix<NT,A>::
operator- ()  // unary
{ 
  register int i,j; 
  Imatrix<NT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = -elem(i,j); 
  return result; 
}

template <class NT, class A>
Imatrix<NT,A>& Imatrix<NT,A>::
operator-= (const Imatrix<NT,A>& mat) 
{ 
  register int i,j; 
  check_dimensions(mat); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      elem(i,j) -= mat.elem(i,j); 
  return *this; 
}

template <class NT, class A>
Imatrix<NT,A>& Imatrix<NT,A>::
operator+= (const Imatrix<NT,A>& mat) 
{ 
  register int i,j; 
  check_dimensions(mat); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      elem(i,j) += mat.elem(i,j); 
  return *this; 
}

template <class NT, class A>
Imatrix<NT,A> Imatrix<NT,A>::
operator*(const Imatrix<NT,A>& mat) const
{ 
  CGAL_LA_PRECOND((d2==mat.d1), 
    "Imatrix::operator*: incompatible matrix types.") 
  
  Imatrix<NT,A> result(d1, mat.d2); 
  register int i,j; 

  for (i=0; i<mat.d2; i++)
  for (j=0; j<d1; j++) 
    result.elem(j,i) = *v[j] * mat.column(i); 
  return result; 
}

template <class NT, class A>
Imatrix<NT,A> Imatrix<NT,A>::
compmul(const NT& f) const
{ 
  register int i,j; 
  Imatrix<NT,A> result(d1,d2); 
  for(i=0; i<d1; i++)
    for(j=0; j<d2; j++)
      result.elem(i,j) = elem(i,j) *f; 
  return result; 
}


template <class NT, class A>
Imatrix<NT,A>  operator*(const Imatrix<NT,A>& M, const NT& x)
{ return M.compmul(x); }
/*{\Mbinopfunc Multiplication of every entry with |x|. }*/

template <class NT, class A>
Imatrix<NT,A>  operator*(const Imatrix<NT,A>& M, int x)
{ return M.compmul(x); }

template <class NT, class A>
Imatrix<NT,A>  operator*(const NT& x, const Imatrix<NT,A>& M)
{ return M.compmul(x); }
/*{\Mbinopfunc Multiplication of every entry with |x|. }*/

template <class NT, class A>
Imatrix<NT,A>  operator*(int x, const Imatrix<NT,A>& M)
{ return M.compmul(x); }


template <class NT, class A> 
int Imatrix<NT,A>::
compare(const Imatrix<NT,A>& M1, const Imatrix<NT,A>& M2) 
{ 
  register int i;
  int res;
  M1.check_dimensions(M2);
  for(i=0; i < M1.row_dimension() && 
      (res = compare(M1.row(i),M2.row(i))) != 0; i++);
  return res;
}


template <class NT, class A> 
std::ostream&  operator<<(std::ostream& os, const Imatrix<NT,A>& M)
{ 
  /* syntax: d1 d2 
             x_0,0  ... x_0,d1-1
                  d2-times
             x_d2,0 ... x_d2,d1-1 */

  CGAL::print_d<NT> prt(&os);
  if (os.iword(IO::mode)==IO::PRETTY) os << "LA::Matrix(";
  prt(M.row_dimension());
  prt(M.column_dimension());
  if (os.iword(IO::mode)==IO::PRETTY) { os << " [\n"; prt.reset(); }
  for (register int i=0; i<M.row_dimension(); i++) {
    std::for_each(M.row(i).begin(),M.row(i).end(),prt);
    if (i != M.row_dimension() && os.iword(IO::mode)==IO::PRETTY) 
    { prt.reset(); os << ",\n";}
  }
  if (os.iword(IO::mode)==IO::PRETTY) os << "])";
  return os;
}

template <class NT, class A> 
std::istream&  operator>>(std::istream& is, Imatrix<NT,A>& M) 
{ 
  /* syntax: d1 d2 
             x_0,0  ... x_0,d1-1
                  d2-times
             x_d2,0 ... x_d2,d1-1 */

  int cdim, rdim;
  switch(is.iword(IO::mode)) {
    case IO::BINARY : 
      CGAL::read(is,rdim);
      CGAL::read(is,cdim);
      for (register int i=0; i<rdim*cdim; ++i)
        CGAL::read(is,M(i/rdim,i%cdim));
      break;
    case IO::ASCII :
      is >> rdim >> cdim;
      M = Imatrix<NT,A>(rdim,cdim);
      for (register int i=0; i<rdim*cdim; ++i)
        is >> M(i/rdim,i%cdim);
      break; 
    default:
      std::cerr<<"\nStream must be in ascii or binary mode"<<std::endl;
      break;
  }
  return is;
}

#ifndef _MSC_VER
template <class NT, class A>
Imatrix<NT,A>::allocator_type Imatrix<NT,A>::MM;
#endif


CGAL_END_NAMESPACE
#endif // CGAL_IMATRIX_H

