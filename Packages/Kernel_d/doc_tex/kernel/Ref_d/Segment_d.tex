% begin cgal manual page

\begin{ccRefClass}{Segment_d<R>}\ccCreationVariable{s}

\ccDefinition


An instance $s$ of the data type \ccc{Segment_d} is a directed straight
line segment in $d$-dimensional Euclidian space connecting two points
$p$ and $q$. $p$ is called the source point and $q$ is called
the target point of $s$, both points are called endpoints of $s$. A
segment whose endpoints are equal is called \emph{degenerate}. 



\ccSetOneOfTwoColumns{5cm}

\ccTypes

\ccNestedType{R}{the representation type. 
}

\ccNestedType{RT}{the ring type. 
}

\ccNestedType{FT}{the field type. 
}

\ccNestedType{LA}{the linear algebra layer. 
}

\ccSetOneOfTwoColumns{3cm}

\ccCreation

\ccConstructor{Segment_d<R>(int d = 0)}{introduces a variable \ccc{s} of type \ccc{Segment_d<R>} and
initializes it to some segment in $d$ - dimensional space. 
}

\ccConstructor{Segment_d<R>(Point_d<R> p, Point_d<R> q)}{introduces a variable \ccc{s} of type \ccc{Segment_d<R>} which
is initialized to the segment $(p,q)$.  
}

\ccConstructor{Segment_d<R>(Point_d<R> p, Vector_d<R> v)}{introduces a variable \ccc{s} of type \ccc{Segment_d<R>} which 
is initialized to the segment \ccc{(p,p+v)}.  
}

\ccSetTwoOfThreeColumns{3cm}{3cm}

\ccOperations

\ccMethod{int dimension() ;}{returns the dimension of the underlying space.  
}

\ccMethod{Point_d<R>  source() ;}{returns the source point of segment \ccc{s}.  
}

\ccMethod{Point_d<R>  target() ;}{returns the target point of segment \ccc{s}.  
}

\ccMethod{Point_d<R>  vertex(int i) ;}{returns source or target of \ccc{s}: \ccc{vertex(0)} returns the
source, \ccc{vertex(1)} returns the target. The parameter $i$ is taken
modulo $2$, which gives easy access to the other vertex.
\ccPrecond $i \geq 0$. 
}

\ccMethod{Point_d<R>  point(int i) ;}{returns \ccc{vertex(i)}. 
}

\ccMethod{Point_d<R>  operator[](int i) ;}{returns \ccc{vertex(i)}. 
}

\ccMethod{Point_d<R> min() ;}{returns the lexicographically smaller vertex. 
}

\ccMethod{Point_d<R> max() ;}{returns the lexicographically larger vertex. 
}

\ccMethod{Segment_d<R> opposite() ;}{returns the segment \ccc{(target(),source())}. 
}

\ccMethod{Direction_d<R> direction() ;}{returns the direction from source to target.\\
\ccPrecond \ccc{s} is non-degenerate.  
}

\ccMethod{Vector_d<R> vector() ;}{returns the vector from source to target.\\
\ccPrecond \ccc{s} is non-degenerate.  
}

\ccMethod{FT squared_length() ;}{returns the square of the length of \ccc{s}. 
}

\ccMethod{bool has_on(const Point_d<R>& p) ;}{returns true if $p$ lies on \ccc{s} and false otherwise.  
}

\ccMethod{ Line_d<R> supporting_line() ;}{returns the supporting line of \ccc{s}.
\ccPrecond \ccc{s} is non-degenerate.  
}

\ccMethod{Segment_d<R>    transform(const Aff_transformation_d<R>& t) ;}{returns $t(s)$. 
}

\ccMethod{Segment_d<R> operator+(const Vector_d<R>& v) ;}{returns $s+v$, i.e., \ccc{s} translated by vector $v$. 
}

\ccMethod{bool is_degenerate() ;}{returns true if \ccc{s} is degenerate i.e. 
\ccc{s.source()=s.target()}.  
}

\ccHeading{Non-Member Functions}  



\ccFunction{template <class R>
template <class R> bool weak_equality(const Segment_d<R>& s, const Segment_d<R>& t) ;}{Test for equality as unoriented segments. 
}

\ccFunction{template <class R>
template <class R> bool parallel(const Segment_d<R>& s1, const Segment_d<R>& s2) ;}{return true if one of the segments is trivial or
if the unoriented supporting lines are parallel.  
}

\ccFunction{template <class R>
template <class R> bool common_endpoint(const Segment_d<R>& s1, const Segment_d<R>& s2,   Point_d<R>& common)  ;}{if \ccc{s1} and \ccc{s2} touch in a common end point, this point
is assigned to \ccc{common} and the result is \ccc{true}, otherwise the 
result is \ccc{false}.  
}

\ccImplementation


Segments are implemented by a pair of points as an item type.  All
operations like creation, initialization, tests, the calculation of
the direction and source - target vector, input and output on a
segment $s$ take time $O(\ccc{s.dimension()})$. \ccc{dimension()}, coordinate
and end point access, and identity test take constant time.  The
operations for intersection calculation also take time
$O(\ccc{s.dimension()})$. The space requirement is $O(\ccc{s.dimension()})$.
 



\end{ccRefClass}


