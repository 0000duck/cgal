% begin cgal manual page

\begin{ccRefClass}{Line_d<RT>}\ccCreationVariable{l}

\ccDefinition


An instance of data type \ccc{Line_d} is an oriented line in
$d$-dimensional Euclidian space. 



\ccSetOneOfTwoColumns{5cm}

\ccTypes

\ccNestedType{R}{the representation type. 
}

\ccNestedType{RT}{the ring type. 
}

\ccNestedType{FT}{the field type. 
}

\ccNestedType{LA}{the linear algebra layer. 
}

\ccSetOneOfTwoColumns{3cm}

\ccCreation

\ccConstructor{Line_d<RT>(int d = 0)}{introduces a variable \ccc{l} of type \ccc{Line_d<RT>} and 
initializes it to some line in $d$ - dimensional space  
}

\ccConstructor{Line_d<RT>(Point_d<R> p, Point_d<R> q)}{introduces a line through \ccc{p} and \ccc{q} and oriented
from \ccc{p} to \ccc{q}. \ccPrecond $p$ and $q$ are distinct and have the same 
dimension. 
}

\ccConstructor{Line_d<RT>(Point_d<R> p, Direction_d<R> dir)}{introduces a line through \ccc{p} with direction \ccc{dir}.
\ccPrecond \ccc{p} and \ccc{dir} have the same dimension, \ccc{dir} is not trivial.  
}

\ccConstructor{Line_d<RT>(Segment_d<R> s)}{introduces a variable \ccc{l} of type \ccc{Line_d<RT>} and 
initializes it to the line through \ccc{s.source()} and \ccc{s.target()}
with direction from \ccc{s.source()} to \ccc{s.target()}.
\ccPrecond $s$ is not degenerate.  
}

\ccConstructor{Line_d<RT>(Ray_d<R> r)}{introduces a variable \ccc{l} of type \ccc{Line_d<RT>} and 
initializes it to the line through \ccc{r.point(1)} and \ccc{r.point(2)}.  
}

\ccSetTwoOfThreeColumns{3cm}{3cm}

\ccOperations

\ccMethod{int dimension() ;}{returns the dimension of the underlying space. 
}

\ccMethod{Point_d<R> point(int i) ;}{returns an arbitrary point on \ccc{l}.  It holds that \ccc{point(i) == 
point(j)}, iff \ccc{i==j}. Furthermore, \ccc{l} is directed from \ccc{point(i)} to
\ccc{point(j)}, for all \ccc{i < j}. 
}

\ccMethod{Line_d<R> opposite() ;}{returns the line \ccc{(point(2),point(1))}.  
}

\ccMethod{Direction_d<R> direction() ;}{returns the direction of \ccc{l}.  
}

\ccMethod{Line_d<R> transform(const Aff_transformation_d<R> & t) ;}{returns $t(l)$.  
}

\ccMethod{Line_d<R> operator+(const Vector_d<R>& v) ;}{returns \ccc{l+v}, i.e., \ccc{l} translated by vector $v$. 
}

\ccMethod{Point_d<R> projection(const Point_d<R>& p) ;}{returns the point of intersection of \ccc{l} with the hyperplane 
that is orthogonal to \ccc{l} through \ccc{p}.  
}

\ccMethod{bool has_on(const Point_d<R>& p) ;}{returns true if $p$ lies on \ccc{l} and false otherwise.  
}

\ccHeading{Non-Member Functions}  



\ccFunction{template <class R>
template <class R> bool weak_equality(const Line_d<R>& l1, const Line_d<R>& l2) ;}{Test for equality as unoriented lines. 
}

\ccFunction{template <class R>
template <class R> bool parallel(const Line_d<R>& l1, const Line_d<R>& l2) ;}{returns true if \ccc{l1} and \ccc{l2} are parallel as unoriented lines
and false otherwise.  
}

\ccImplementation


Lines are implemented by a pair of points as an item type.  All
operations like creation, initialization, tests, direction
calculation, input and output on a line $l$ take time
$O(\ccc{l.dimension()})$. \ccc{dimension()}, coordinate and point access, and
identity test take constant time.  The operations for intersection
calculation also take time $O(\ccc{l.dimension()})$. The space requirement
is $O(\ccc{l.dimension()})$. 



\end{ccRefClass}


