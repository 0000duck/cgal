% begin cgal manual page

\begin{ccRefClass}{Convex_hull_d<R>}\ccCreationVariable{C}

\ccDefinition

An instance \ccc{C} of type \ccc{Convex_hull_d<R>} is the convex
hull of a multi-set \ccc{S} of points in $d$-dimensional space. We call
\ccc{S} the underlying point set and $d$ or \ccc{dim} the dimension of the
underlying space. We use \ccc{dcur} to denote the affine dimension of \ccc{S}.
The data type supports incremental construction of hulls.

The closure of the hull is maintained as a simplicial complex, i.e.,
as a collection of simplices. The intersection of any two is a face of
both\footnote{The empty set if a facet of every simplex.}. In the
sequel we reserve the word simplex for the simplices of dimension
\ccc{dcur}. For each simplex there is a handle of type \ccc{Simplex_handlex}
and for each vertex there is a handle of type \ccc{Vertex_handle}.  Each
simplex has $1 + \ccc{dcur}$ vertices indexed from $0$ to \ccc{dcur}; for a
simplex $s$ and an index $i$, \ccc{C.vertex(s,i)} returns the $i$-th
vertex of $s$. For any simplex $s$ and any index $i$ of $s$ there may
or may not be a simplex $t$ opposite to the $i$-th vertex of $s$.  The
function \ccc{C.opposite_simplex(s,i)} returns $t$ if it exists and
returns \ccc{Simplex_handle()} (the undefined handle) otherwise. If $t$
exists then $s$ and $t$ share \ccc{dcur} vertices, namely all but the
vertex with index $i$ of $s$ and the vertex with index
\ccc{C.index_of_vertex_in_opposite_simplex(s,i)} of $t$. Assume that $t$
exists and let \ccc{j = C.index_of_vertex_in_opposite_simplex(s,i)}.  Then
$s =$ \ccc{C.opposite_simplex(t,j)} and $i =$
\ccc{C.index_of_vertex_in_opposite_simplex(t,j)}.

The boundary of the hull is also a simplicial complex. All simplices
in this complex have dimension $\ccc{dcur} - 1$.  For each boundary simplex
there is a handle of type \ccc{Facet_handle}.  Each facet has \ccc{dcur} vertices
indexed from $0$ to $\ccc{dcur} - 1$. If \ccc{dcur > 1} then for each facet $f$
and each index $i$, $0 \le i < \ccc{dcur}$, there is a facet $g$ opposite
to the $i$-th vertex of $f$.  The function \ccc{C.opposite_facet(f,i)}
returns $g$.  Two neighboring facets $f$ and $g$ share \ccc{dcur - 1}
vertices, namely all but the vertex with index $i$ of $f$ and the
vertex with index \ccc{C.index_of_vertex_in_opposite_facet(f,i)} of $g$.
Let \ccc{j = C.index_of_vertex_in_opposite_facet(f,i)}. Then 
\ccc{f = C.opposite_facet(g,j)} and 
\ccc{i = C.index_of_vertex_in_opposite_facet(g,j)}. 



\ccSetOneOfTwoColumns{6.5cm}

\ccTypes

\ccNestedType{R}{the representation class. 
}

\ccNestedType{Point_d}{the point type. 
}

\ccNestedType{Hyperplane_d}{the hyperplane type. 
}

\ccNestedType{Simplex_handle}{handle for simplices. 
}

\ccNestedType{Facet_handle}{handle for facets. 
}

\ccNestedType{Vertex_handle}{handle for vertices. 
}

\ccNestedType{Simplex_iterator}{iterator for simplices. 
}

\ccNestedType{Vertex_iterator}{iterator for vertices. 
}

\ccNestedType{Point_const_iterator}{const iterator for points. 
}

\ccSetOneOfTwoColumns{3cm}

\ccCreation

\ccConstructor{Convex_hull_d<R>(int d, R Kernel = R())}{creates an instance \ccc{C} of type \ccc{Convex_hull_d}. The
dimension of the underlying space is $d$ and \ccc{S} is initialized to the
empty point set. The traits class \ccc{R} specifies the models of
all types and the implementations of all geometric primitives used by
the convex hull class. The default model is one of the $d$-dimensional
representation classes (e.g., \ccc{Homogeneous_d}). 
}

The data type \ccc{Convex_hull_d} offers neither copy constructor nor
assignment operator. 



\ccSetOneOfTwoColumns{3cm}

\ccOperations

All operations below that take a point \ccc{x} as argument have
the common precondition that \ccc{x} is a point of ambient space. 



\ccMethod{int dimension() ;}{returns the dimension of ambient space 
}

\ccMethod{int current_dimension() ;}{returns the affine dimension \ccc{dcur} of $S$. 
}

\ccMethod{Point_d  associated_point(Vertex_handle v) ;}{returns the point associated with vertex $v$. 
}

\ccMethod{Vertex_handle  vertex_of_simplex(Simplex_handle s, int i) ;}{returns the vertex corresponding to the $i$-th vertex of $s$.\\
\ccPrecond $0 \leq i \leq \ccc{dcur}$.  
}

\ccMethod{Point_d  point_of_simplex(Simplex_handle s,int i) ;}{same as \ccc{C.associated_point(C.vertex_of_simplex(s,i))}.  
}

\ccMethod{Simplex_handle opposite_simplex(Simplex_handle s,int i) ;}{returns the simplex opposite to the $i$-th vertex of $s$
(\ccc{Simplex_handle()} if there is no such simplex). 
\ccPrecond $0 \leq i \leq \ccc{dcur}$.  
}

\ccMethod{int  index_of_vertex_in_opposite_simplex(Simplex_handle s,int i) ;}{returns the index of the vertex opposite to the $i$-th vertex
of $s$. \ccPrecond $0 \leq i \leq \ccc{dcur}$ and there is a
simplex opposite to the $i$-th vertex of $s$.  
}

\ccMethod{Simplex_handle  simplex(Vertex_handle v) ;}{returns a simplex of which $v$ is a node. Note that this
simplex is not unique.  
}

\ccMethod{int index(Vertex_handle v) ;}{returns the index of $v$ in \ccc{simplex(v)}. 
}

\ccMethod{Vertex_handle  vertex_of_facet(Facet_handle f, int i) ;}{returns the vertex corresponding to the $i$-th vertex of $f$.
\ccPrecond $0 \leq i < \ccc{dcur}$.  
}

\ccMethod{Point_d point_of_facet(Facet_handle f, int i) ;}{same as \ccc{C.associated_point(C.vertex_of_facet(f,i))}. 
}

\ccMethod{Facet_handle opposite_facet(Facet_handle f, int i) ;}{returns the facet opposite to the $i$-th vertex of $f$
(\ccc{Facet_handle()} if there is no such facet). \ccPrecond $0 \leq i <
\ccc{dcur}$ and \ccc{dcur > 1}.  
}

\ccMethod{int index_of_vertex_in_opposite_facet(Facet_handle f, int i) ;}{returns the index of the vertex opposite to the $i$-th vertex of 
$f$. \ccPrecond $0 \leq i < \ccc{dcur}$ and \ccc{dcur > 1}. 
}

\ccMethod{Hyperplane_d hyperplane_supporting(Facet_handle f) ;}{returns a hyperplane supporting facet \ccc{f}. The hyperplane is
oriented such that the interior of \ccc{C} is on the negative
side of it. \ccPrecond \ccc{f} is a facet of \ccc{C} and \ccc{dcur > 1}. 
}

\ccMethod{Vertex_handle insert(const Point_d& x);}{adds point \ccc{x} to the underlying set of points.  If $x$ is
equal to (the point associated with) a vertex of the current hull this
vertex is returned and its associated point is changed to $x$. If $x$
lies outside the current hull, a new vertex \ccc{v} with associated point
$x$ is added to the hull and returned. In all other cases, i.e., if
$x$ lies in the interior of the hull or on the boundary but not on a
vertex, the current hull is not changed and \ccc{Vertex_handle()} is 
returned. If \ccc{CGAL_CHECK_EXPENSIVE} is defined then the validity
check \ccc{is_valid(true)} is executed as a post condition. 
}

\ccMethod{template <typename Forward_iterator>
void insert(Forward_iterator first, Forward_iterator last) ;}{adds \ccc{S = set [first,last)} to the underlying set of
points. If any point \ccc{S[i]} is equal to (the point associated with) a
vertex of the current hull its associated point is changed to \ccc{S[i]}. 
}

\ccMethod{bool is_dimension_jump(const Point_d& x) ;}{returns true if $x$ is not contained in the affine hull of \ccc{S}. 
}

\ccMethod{std::list<Facet_handle>  facets_visible_from(const Point_d& x);}{returns the list of all facets that are visible from \ccc{x}.\\
\ccPrecond \ccc{x} is contained in the affine hull of \ccc{S}. 
}

\ccMethod{Bounded_side bounded_side(const Point_d& x);}{returns \ccc{ON_BOUNDED_SIDE} (\ccc{ON_BOUNDARY},\ccc{ON_UNBOUNDED_SIDE}) 
if \ccc{x} is contained in the interior (lies on the boundary, is contained 
in the exterior) of \ccc{C}. \ccPrecond \ccc{x} is contained in the affine 
hull of \ccc{S}. 
}

\ccMethod{void clear(int d) ;}{reinitializes \ccc{C} to an empty hull in $d$-dimensional space. 
}

\ccMethod{int number_of_vertices() ;}{returns the number of vertices of \ccc{C}. 
}

\ccMethod{int number_of_facets() ;}{returns the number of facets of \ccc{C}. 
}

\ccMethod{int number_of_simplices() ;}{returns the number of bounded simplices of \ccc{C}. 
}

\ccMethod{void print_statistics() ;}{gives information about the size of the current hull and the
number of visibility tests performed. 
}

\ccMethod{bool is_valid(bool throw_exceptions = false) ;}{checks the validity of the data structure.
If \ccc{throw_exceptions == thrue} then the program throws
the following exceptions to inform about the problem.\\
\ccc{chull_has_center_on_wrong_side_of_hull_facet} the hyperplane
supporting a facet has the wrong orientation.\\
\ccc{chull_has_local_non_convexity} a ridge is locally non convex.\\
\ccc{chull_has_double_coverage} the hull has a winding number larger
than 1.
}

\ccHeading{Lists and Iterators}

\ccMethod{Point_const_iterator points_begin() ;}{returns the start iterator for points in \ccc{C}. 
}

\ccMethod{Point_const_iterator points_end() ;}{returns the past the end iterator for points in \ccc{C}. 
}

\ccMethod{Vertex_iterator vertices_begin() ;}{the first vertex of \ccc{C}. 
}

\ccMethod{Vertex_iterator vertices_end()   ;}{the past the end iterator for vertices. 
}

\ccMethod{Simplex_iterator simplices_begin() ;}{the first simplex of \ccc{C}. 
}

\ccMethod{Simplex_iterator simplices_end()   ;}{the past the end iterator for simplices. 
}


\ccMethod{template <typename Visitor>
void visit_all_facets(const Visitor& V) ;}{each facet of \ccc{C} is visited by the visitor object \ccc{V}.
\ccc{V} has to have a function call operator:\\
\ccc{void operator()(Facet_handle) const} 
}

\ccMethod{const std::list<Point_d>& all_points() ;}{returns a list of all points in \ccc{C}. 
}

\ccMethod{std::list<Vertex_handle> all_vertices() ;}{returns a list of all vertices of \ccc{C}
(also interior ones). 
}

\ccMethod{std::list<Simplex_handle> all_simplices() ;}{returns a list of all simplices in \ccc{C}. 
}

\ccMethod{std::list<Facet_handle>  all_facets()  ;}{returns a list of all facets of \ccc{C}. 
}


\ccHeading{Iteration Statements}

{\bf forall\_ch\_simplices}($s,C$)       
$\{$ ``the simplices of $C$ are successively assigned to $s$'' $\}$

{\bf forall\_ch\_vertices}($v,C$)       
$\{$ ``the vertices of $C$ are successively assigned to $v$'' $\}$

 



\ccImplementation

The implementation of type \ccc{Convex_hull_d} is based on
\cite{cms:fourresults-93} and \cite{BMS:degeneracy-94}.  The details
of the implementation can be found in the implementation document
available at the download site of this package.

The time and space requirements are input dependent.  Let $C_1$, $C_2$,
$C_3$, \ldots be the sequence of hulls constructed and for a point $x$
let $k_i$ be the number of facets of $C_i$ that are visible from $x$
and that are not already facets of $C_{i-1}$. Then the time for
inserting $x$ is $O(\ccc{dim} \sum_i k_i)$ and the number of new simplices
constructed during the insertion of $x$ is the number of facets of the
hull which were not already facets of the hull before the insertion.

The data type \ccc{Convex_hull_d} is derived from
\ccc{Regular_complex_d}. The space requirement of regular complexes is
essentially $12(\ccc{dim} +2)$ bytes times the number of simplices
plus the space for the points. \ccc{Convex_hull_d} needs an additional
$8 + (4 + x)\ccc{dim}$ bytes per simplex where $x$ is the space
requirement of the underlying number type and an additional $12$ bytes
per point. The total is therefore $(16 + x)\ccc{dim} + 32$ bytes times
the number of simplices plus $28 + x \cdot \ccc{dim}$ bytes times the
number of points.

\ccHeading{Low Dimensional Conversion Routine}
include \ccc{<CGAL/Convex_hull_d_to_polyhedron_3.h>}

\ccFunction{template <class R, class T, class HDS>
void convex_hull_d_to_polyhedron_3(   const Convex_hull_d<R>& C, Polyhedron_3<T,HDS>& P) ;}{converts the convex hull \ccc{C} to polyedral surface stored in 
   \ccc{P}.\\ \ccPrecond \ccc{dim == 3} and \ccc{dcur == 3}.  
}

\ccHeading{Low Dimensional Output Routines}
include \ccc{<CGAL/IO/Convex_hull_d_window_stream.h>}

\ccFunction{template <class R>
void d2_show(const Convex_hull_d<R>& C, CGAL::Window_stream& W);}{draws the convex hull \ccc{C} in window \ccc{W}.\\
\ccPrecond \ccc{dim == 2}.  
}

\ccFunction{template <class R>
void d3_surface_map(const Convex_hull_d<R>& C, GRAPH< typename Convex_hull_d<R>::Point_d ,int>& G);}{constructs the representation of the surface of \ccc{C} as a 
bidirected LEDA graph \ccc{G}.\\ \ccPrecond \ccc{dim == 3}. 
}

\end{ccRefClass}


