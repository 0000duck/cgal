@! $RCSfile$
@! $Revision$
@! $Date$

@! Author: Geert-Jan Giezeman

@i cgal_util.fwi

@A@<Three dimensional squared distances@>

The distance between zero and one dimensional objects (points, segments, rays
and lines) in three dimensions is much the same as the computation in two
dimensions.

If one of the objects is a point, this is not surprising. Then there is a plane
that contains both the point and the other object.

If both objects are one dimensional, we can use the following trick.
There is a normal vector perpendicular to the direction vectors of both objects.
We can project the two objects on a plane perpendicular to this normal and
compute the distance of the projected objects (now a two dimensional problem).

This projection doesn't actually take place in the code. Instead, the one
dimensional object is extended to a two dimensional object in the direction of
the normal. If the one dimensional object is a segment, the result is a strip
formed by the points  @{p+s*normal@}, where @{p@} is an arbitrary point on the
segment and @{s@} is an arbitrary real value (positive, negative or zero).  In
the same way a plane can be formed by extending a line in the direction of the
normal. If we extend a ray, we also speak of the resulting strip.

In the sequel, when we talk about the extension strip of a segment or ray, or
the extension plane of a line, we mean the strip or plane as defined above.
The extension vector will not be mentioned explicitly, but is always understood
to be the normal vector. The phrase 'extension plane of a segment (or ray)'
will be used as an abbreviation for the 'extension plane of the supporting line
of a segment (or ray)'.


@B@<Utility routines@>

While computing square distances we need a number of routines that are not
supplied as basic facilities in CGAL, but that are pretty basic and not tied
to distance computations. Perhaps they should be added to more basic
components.

@C@<Low level routines that avoid divisions@>

In order to avoid division (which is important for homogeneous types), we
sometimes need to compute with different routines than the natural ones.
We prefix the natural name of such a routine with a @{w@} to indicate this.

For example, the dot product of two vectors @{u@} and @{v@} is computed as
@{dot(u,v) == (ux*vx + uy*vy)/(uw*vw)@}.
The routine @{wdot@} is computed as follows: @{wdot(u,v) == ux*vx + uy*vy@}.
We use a short notation here where @{ux@} stands for @{u.hx()@}, @{uw@} stands
for @{u.hw()@} and so on.

Often we only need the sign of a routine. Then multiplication by homogeneous
factors has no influence, as they are positive by definition.
Also, when we need to compare the dot product of two different vectors, we can
use multiplications instead of divisions. Instead of comparing @{dot(p,q)@}
with @{dot(u,v)@}, we can compare @{uw*vw*wdot(p,q)@} with
@{pw*qw*wdot(u,v)@}. The homogenising factors are brought to the other side of
the comparison operator which can be done, again, because they are positive.

The homogeneous factors that are multiplied differ from case to case. This
makes those routines pretty low level and care should be taken when they are
used.

In the case of cartesian coordinates, we know that the homogenising factors
are 1 by definition. This leads to ample possibilities for optimisation.
Therefore, most routines have a specialisation for the cartesian case that is
more efficient.


@D@<Testing for null vector@>

A routine to test whether a vector is a null vector.
This code does not belong in this chapter. It should be moved to the vector
class.
@$@<3D squared distance general utilities@>+=@{

template <class R>
bool is_null(const Vector_3<R> &v)
{
    typedef typename R::RT RT;
    return v.hx()==RT(0) && v.hy()==RT(0) && v.hz()==RT(0);
}
@}

@D@<The dot product@>

The dot product is useful for projecting a point on a line, and for deciding
whether an angle is acute, straight or obtuse.
Apart from the @{wdot@} routine there are also routines that use @{wdot@} to
decide on the acuteness of an angle.

Of all the routines there are different flavours, taking points or
vectors as arguments.
The homogenising factors that are used for multiplication are different.
For vectors @{u@} and @{v@} we have @{wdot(u,v) == wu*wv*dot(u,v)@}
For points @{p,q@} and @{r@} we have @{wdot(p,q,r) == wp*wq*wq*wr*dot(p-q,r-q)@}
Note the double occurrence of the factor @{wq@} in the latter definition.


@$@<3D squared distance general utilities@>+=@{

template <class R>
typename R::RT
wdot(const Vector_3<R> &u,
    const Vector_3<R> &v)
{
    return  (u.hx()*v.hx() + u.hy()*v.hy() + u.hz()*v.hz());
}


template <class R>
typename R::RT
wdot(const Point_3<R> &p,
     const Point_3<R> &q,
     const Point_3<R> &r)
{
    R* pR = 0;
    return  (wmult(pR, p.hx(),q.hw()) - wmult(pR, q.hx(),p.hw()))
          * (wmult(pR, r.hx(),q.hw()) - wmult(pR, q.hx(),r.hw()))
        +   (wmult(pR, p.hy(),q.hw()) - wmult(pR, q.hy(),p.hw()))
          * (wmult(pR, r.hy(),q.hw()) - wmult(pR, q.hy(),r.hw()))
        +   (wmult(pR, p.hz(),q.hw()) - wmult(pR, q.hz(),p.hw()))
          * (wmult(pR, r.hz(),q.hw()) - wmult(pR, q.hz(),r.hw()));
}

@}

@D@<The cross product@>

The cross product of two vectors is a vector perpendicular to both.
The absolute value gives the area of the parallelogram spanned by the two
vectors.

Like with the dot product, we have versions for two vectors and for three
points.

We define @{wcross(u,v) == wu*wv*cross(u,v)@} and
@{wcross(p,q,r) == @}@{wp*wq*wr*cross(q-p,r-q)@}.
Different from the dot case, the factor @{wq@} occurs only once in the
definition of the wcross product for points.


@$@<3D squared distance general utilities@>+=@{


template <class R>
Vector_3<R> wcross(const Vector_3<R> &u,
    const Vector_3<R> &v)
{
    return Vector_3<R>(
        u.hy()*v.hz() - u.hz()*v.hy(),
        u.hz()*v.hx() - u.hx()*v.hz(),
        u.hx()*v.hy() - u.hy()*v.hx());
}

#if defined CGAL_HOMOGENEOUS_H
template <class RT>
Vector_3< Homogeneous<RT> >
wcross(const Point_3< Homogeneous<RT> > &p,
    const Point_3< Homogeneous<RT> > &q,
    const Point_3< Homogeneous<RT> > &r)
{
    RT x,y,z;
    x =  p.hy() * (q.hz()*r.hw() - q.hw()*r.hz() )
       + p.hz() * (q.hw()*r.hy() - q.hy()*r.hw() )
       + p.hw() * (q.hy()*r.hz() - q.hz()*r.hy() );
    y =  p.hz() * (q.hx()*r.hw() - q.hw()*r.hx() )
       + p.hx() * (q.hw()*r.hz() - q.hz()*r.hw() )
       + p.hw() * (q.hz()*r.hx() - q.hx()*r.hz() );
    z =  p.hx() * (q.hy()*r.hw() - q.hw()*r.hy() )
       + p.hy() * (q.hw()*r.hx() - q.hx()*r.hw() )
       + p.hw() * (q.hx()*r.hy() - q.hy()*r.hx() );
    return Vector_3< Homogeneous<RT> >(x, y, z);
}
#endif // CGAL_HOMOGENEOUS_H

#if defined CGAL_SIMPLE_HOMOGENEOUS_H
template <class RT>
Vector_3< Simple_homogeneous<RT> >
wcross(const Point_3< Simple_homogeneous<RT> > &p,
    const Point_3< Simple_homogeneous<RT> > &q,
    const Point_3< Simple_homogeneous<RT> > &r)
{
    RT x,y,z;
    x =  p.hy() * (q.hz()*r.hw() - q.hw()*r.hz() )
       + p.hz() * (q.hw()*r.hy() - q.hy()*r.hw() )
       + p.hw() * (q.hy()*r.hz() - q.hz()*r.hy() );
    y =  p.hz() * (q.hx()*r.hw() - q.hw()*r.hx() )
       + p.hx() * (q.hw()*r.hz() - q.hz()*r.hw() )
       + p.hw() * (q.hz()*r.hx() - q.hx()*r.hz() );
    z =  p.hx() * (q.hy()*r.hw() - q.hw()*r.hy() )
       + p.hy() * (q.hw()*r.hx() - q.hx()*r.hw() )
       + p.hw() * (q.hx()*r.hy() - q.hy()*r.hx() );
    return Vector_3< Simple_homogeneous<RT> >(x, y, z);
}
#endif // CGAL_SIMPLE_HOMOGENEOUS_H

#if defined CGAL_CARTESIAN_H
template <class FT>
Vector_3< Cartesian<FT> >
wcross(const Point_3< Cartesian<FT> > &p,
    const Point_3< Cartesian<FT> > &q,
    const Point_3< Cartesian<FT> > &r)
{
    FT x,y,z;
    x = (q.y()-p.y())*(r.z()-q.z()) - (q.z()-p.z())*(r.y()-q.y());
    y = (q.z()-p.z())*(r.x()-q.x()) - (q.x()-p.x())*(r.z()-q.z());
    z = (q.x()-p.x())*(r.y()-q.y()) - (q.y()-p.y())*(r.x()-q.x());
    return Vector_3< Cartesian<FT> >(x, y, z);
}
#endif // CGAL_CARTESIAN_H

#if defined CGAL_SIMPLE_CARTESIAN_H
template <class FT>
Vector_3< Simple_cartesian<FT> >
wcross(const Point_3< Simple_cartesian<FT> > &p,
    const Point_3< Simple_cartesian<FT> > &q,
    const Point_3< Simple_cartesian<FT> > &r)
{
    FT x,y,z;
    x = (q.y()-p.y())*(r.z()-q.z()) - (q.z()-p.z())*(r.y()-q.y());
    y = (q.z()-p.z())*(r.x()-q.x()) - (q.x()-p.x())*(r.z()-q.z());
    z = (q.x()-p.x())*(r.y()-q.y()) - (q.y()-p.y())*(r.x()-q.x());
    return Vector_3< Simple_cartesian<FT> >(x, y, z);
}
#endif // CGAL_SIMPLE_CARTESIAN_H

@}

@C@<Routines that characterise angles@>

Often one needs to know whether an angle is sharp or obtuse or whether it is a
left turn or a right turn. An angle can be characterised by three points
@{p,q@} and @{r@} (the angle formed at @{q@} when going from @{p@} to @{r@}
via @{q@}), or by two vectors @{u@} and @{v@} (the angle formed when their
tails are placed in the origin).
Then we can use the routines @{wdot@} and @{wcross@} for this purpose.

@D@<Sharp or obtuse@>

Here are routines to decide whether an angle is sharp, straight or obtuse.
There should also be an enum with three values (@{ACUTE@},
@{STRAIGHT@},@{OBTUSE@}) and a routine that returns such a value.

@$@<3D squared distance general utilities@>+=@{

template <class R>
inline bool is_acute_angle(const Vector_3<R> &u,
    const Vector_3<R> &v)
{
    typedef typename R::RT RT;
    return RT(wdot(u, v)) > RT(0) ;
}

template <class R>
inline bool is_straight_angle(const Vector_3<R> &u,
    const Vector_3<R> &v)
{
    typedef typename R::RT RT;
    return RT(wdot(u, v)) == RT(0) ;
}

template <class R>
inline bool is_obtuse_angle(const Vector_3<R> &u,
    const Vector_3<R> &v)
{
    typedef typename R::RT RT;
    return RT(wdot(u, v)) < RT(0) ;
}

template <class R>
inline bool is_acute_angle(const Point_3<R> &p,
    const Point_3<R> &q, const Point_3<R> &r)
{
    typedef typename R::RT RT;
    return RT(wdot(p, q, r)) > RT(0) ;
}

template <class R>
inline bool is_straight_angle(const Point_3<R> &p,
    const Point_3<R> &q, const Point_3<R> &r)
{
    typedef typename R::RT RT;
    return RT(wdot(p, q, r)) == RT(0) ;
}

template <class R>
inline bool is_obtuse_angle(const Point_3<R> &p,
    const Point_3<R> &q, const Point_3<R> &r)
{
    typedef typename R::RT RT;
    return RT(wdot(p, q, r)) < RT(0) ;
}
@}

@B@<Point Point distance@>

The squared distance between two points is computed by taking the dot product
of the difference vector.

@$@<3D squared distance 0 header declarations@>+=@{@-

template <class R>
inline typename R::FT
squared_distance(
    const Point_3<R> & pt1,
    const Point_3<R> & pt2)
{
    Vector_3<R> vec(pt1-pt2);
    return vec*vec;
}

@}

@B@<Point Plane distance@>

@C@<Declarations@>

The regular squared distance routines for the point plane case are given
further on. They are defined in another header file.

Here we define a specialised routine that computes this squared distance with
the following parameters: the normal vector to the plane and the difference
vector between the point and an arbitrary point on the plane.
This specialised routine is used extensively in other routines.

@$@<3D squared distance 0 header declarations@>+=@{@-
@<Point Plane distance implementation 1@>
@}

@C@<Implementation@>

@$@<Point Plane distance implementation 1@>==@{@-

template <class R>
typename R::FT
squared_distance_to_plane(
    const Vector_3<R> & normal,
    const Vector_3<R> & diff)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    RT dot, squared_length;
    dot = wdot(normal, diff);
    squared_length = wdot(normal, normal);
    return FT(dot*dot) /
        FT(wmult((R*)0, squared_length, diff.hw(), diff.hw()));
//    return R::make_FT((dot*dot),
//        wmult((R*)0, squared_length, diff.hw(), diff.hw()));
}
@}

@B@<Point Line distance@>

@C@<Declarations@>

The third function is meant for internal use. It computes the squared
distance from a point to a line, given a direction vector (not necessarily
normalised) of the line and the vector between the point and an arbitrary
point on the line.

@$@<3D squared distance header declarations@>+=@{@-
@<Point Line distance implementation 2@>

template <class R>
inline typename R::FT
squared_distance(
    const Line_3<R> & line,
    const Point_3<R> & pt)
{
    return squared_distance(pt, line);
}
@}

@$@<3D squared distance 0 header declarations@>+=@{@-
@<Point Line distance implementation 1@>
@}

@C@<Implementation@>

The cross product of two vectors is a vector whose length is equal to the area
of the parallellogram spanned by the two vectors. This area is length of base
times height.

We can use this to compute the distance from a point to a line. As base vector
we take the direction vector of the line. The other vector is the vector
connecting a point on the line to the point. Now, the length of the cross
product vector divided by the length of the base vector is the distance from
the point to the line. Squaring everything, we get the square distance.

@$@<Point Line distance implementation 1@>==@{@-

template <class R>
typename R::FT
squared_distance_to_line(
    const Vector_3<R> & dir,
    const Vector_3<R> & diff)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    Vector_3<R> wcr = wcross(dir, diff);
    return FT(wcr*wcr)/FT(wmult(
        (R*)0, RT(wdot(dir, dir)), diff.hw(), diff.hw()));
//    return R::make_FT((wcr*wcr),
//        wmult((R*)0, RT(wdot(dir, dir)), diff.hw(), diff.hw()));
}
@}

@$@<Point Line distance implementation 2@>==@{

template <class R>
typename R::FT
squared_distance(
    const Point_3<R> &pt,
    const Line_3<R> &line)
{
    Vector_3<R> dir(line.direction().vector());
    Vector_3<R> diff = pt - line.point();
    return squared_distance_to_line(dir, diff);
}
@}

@B@<Point Ray distance@>

@C@<Declarations@>

@$@<3D squared distance header declarations@>+=@{@-
@<Point Ray distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Ray_3<R> & ray,
    const Point_3<R> & pt)
{
    return squared_distance(pt, ray);
}
@}

@C@<Implementation@>

We test the angle between the direction vector of the ray and the  vector from
the start point of the ray to the point @{pt@}. If this angle is acute,
the distance from the point to the ray is the same as the distance from the
point to the supporting line of the ray. Otherwise we compute the squared
distance from @{pt@} to the start point of the ray, as this is the closest
point.

@$@<Point Ray distance implementation@>==@{

template <class R>
extern typename R::FT
squared_distance(
    const Point_3<R> &pt,
    const Ray_3<R> &ray)
{
    Vector_3<R> diff = pt-ray.start();
    const Vector_3<R> &dir = ray.direction().vector();
    if (!is_acute_angle(dir,diff) )
        return (typename R::FT)(diff*diff);
    return squared_distance_to_line(dir, diff);
}
@}

@B@<Point Segment distance@>

@$@<3D squared distance header declarations@>+=@{@-
@<Point Segment distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Segment_3<R> & seg,
    const Point_3<R> & pt)
{
    return squared_distance(pt, seg);
}

@}

@C@<Implementation@>

To compute the distance of a point to a segment, first we divide the space in
three parts. We draw two planes perpendicular to the segment, one through the
start point, the other through the end point of the segment. If the query
point lies between those two planes, we need to compute the distance of the
query point to the supporting line of the segment. Otherwise we need to
compute the distance from the point to either the endpoint or the startpoint.

To decide which case applies, we compute the dot poduct of the vector from
segment start to segment end and the vector from segment start to the point.
If this product is negative, the distance from the point to the start of the
segment is taken.

@$@<Point Segment distance implementation@>==@{

template <class R>
typename R::FT
squared_distance(
    const Point_3<R> &pt,
    const Segment_3<R> &seg)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    // assert that the segment is valid (non zero length).
    Vector_3<R> diff = pt-seg.start();
    Vector_3<R> segvec = seg.end()-seg.start();
    RT d = wdot(diff,segvec);
    if (d <= (RT)0)
        return (FT(diff*diff));
    RT e = wdot(segvec,segvec);
    if (wmult((R*)0 ,d, segvec.hw()) > wmult((R*)0, e, diff.hw()))
        return squared_distance(pt, seg.end());
    return squared_distance_to_line(segvec, diff);
}
@}

@B@<Segment Segment distance@>

@C@<Declarations@>

@$@<3D squared distance header declarations@>+=@{@-
@<Segment Segment distance implementation@>

@}

@C@<Implementation@>

The computation of the distance between two segments in 3D goes along the same
lines as the computation in 2D. An important role is played by the @{normal@}
vector, which is a vector perpendicular to both segments.


@D@<Distance computation@>

To compute the squared distance of two segments, the following steps are
taken.


@$@<3D seg seg squared distance main routine start@>==@{@-
template <class R>
typename R::FT
squared_distance(
    const Segment_3<R> &seg1,
    const Segment_3<R> &seg2)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    const Point_3<R> &start1 = seg1.start();
    const Point_3<R> &start2 = seg2.start();
    const Point_3<R> &end1 = seg1.end();
    const Point_3<R> &end2 = seg2.end();
@}

First we check if one of the segments is degenerate (coinciding start and
end point). If so, we solve the problem for a point and a segment.

Then we compute a vector that is normal to the direction vectors of both
segments. This is done by taking the cross product of the two vectors.
If the normal is the null vector, the segments must be parallel to each other.
This is dealt with as a special case.

@$@<3D seg seg squared distance main routine degeneracy checking@>==@{@-
if (start1 == end1)
    return squared_distance(start1, seg2);
if (start2 == end2)
    return squared_distance(start2, seg1);

Vector_3<R> dir1, dir2, normal;
dir1 = seg1.direction().vector();
dir2 = seg2.direction().vector();
normal = wcross(dir1, dir2);
if (is_null(normal))
    return squared_distance_parallel(seg1, seg2);
@}

We decide if the segments intersects the extension plane of the other segment.
See the top of this chapter on three dimensional squared distances for the
definition of the extension plane of a segment.  The boolean @{crossing1@}
tells whether @{seg1@} intersects the extension plane of @{seg2@}, and vice
versa for @{crossing2@}.  If an endpoint lies in the plane, we consider this as
an intersection.

To decide whether a segment and a plane intersect, we compute the signed
distance of the endpoints of the segment to the plane. We first compute the
vectors perpendicular to the planes (@{perpend1@} and @{perpend2@}). The signed
distance is then computed by taking the dot product between this vector and the
vectors connecting endpoints of the segment to a point in the plane.

As the @{perpend@} vectors are not normalised to length 1,  this is not the
exact distance. What we compute is a measure related to the signed distance.
For the moment we are only interested in the sign of the distances (positive
means on one side of the plane, negative on the other side and 0 means in the
plane), and this is retained in this measure.

We store the signed distance measures in variables which we will need later
on.  The names are a bit cryptic: @{sdm_s1to2@} stands for the signed distance
measure from the start point of @{seg1@} to the extension plane of @{seg2@}.

@$@<3D seg seg squared distance main routine crossing computation@>==@{@-
bool crossing1, crossing2;
RT sdm_s1to2, sdm_e1to2, sdm_s2to1, sdm_e2to1;
Vector_3<R> perpend1, perpend2, s2mins1, e2mins1, e1mins2;
perpend1 = wcross(dir1, normal);
perpend2 = wcross(dir2, normal);
s2mins1 = start2-start1;
e2mins1 = end2-start1;
e1mins2 = end1-start2;
sdm_s1to2 = -RT(wdot(perpend2, s2mins1));
sdm_e1to2 = wdot(perpend2, e1mins2);
sdm_s2to1 = wdot(perpend1, s2mins1);
sdm_e2to1 = wdot(perpend1, e2mins1);

if (sdm_s1to2 < RT(0)) {
    crossing1 = (sdm_e1to2 >= RT(0));
} else {
    if (sdm_e1to2 <= RT(0)) {
        crossing1 = true;
    } else {
        crossing1 = (sdm_s1to2 == RT(0));
    }
}
if (sdm_s2to1 < RT(0)) {
    crossing2 = (sdm_e2to1 >= RT(0));
} else {
    if (sdm_e2to1 <= RT(0)) {
        crossing2 = true;
    } else {
        crossing2 = (sdm_s2to1 == RT(0));
    }
}
@}

Depending on the values of the crossing variables we now proceed.  If both
segments intersect the extension plane of the other segment, the extension
strips of the segments themselves must cross. In this case we compute the
distance from an arbitrary point of segment 1 to the plane perpendicular to
@{normal@} that goes through segment 2.

We use the special routine that computes this squared distance from a point to
a plane, given the normal to the plane and the vector from the point to an
arbitrary point in the plane.



@$@<3D seg seg squared distance main routine two crossings case@>==@{@-
if (crossing1) {
    if (crossing2) {
        return squared_distance_to_plane(normal, s2mins1);
    }
@}

If exactly one of the segments does not intersect, the distance is the
distance of one of the endpoints of this (non intersecting) segment to the
other (intersecting) segment. Which endpoint? The one that is closest to
the extension plane of the other segment. This latter property can easily
be computed with the value of the signed distance measure that was
computed earlier. The function @{_distance_measure_sub@} makes this
comparison (it subtracts the two absolute values of the signed distance
measure, first corrected by homogenising factors).

@$@<3D seg seg squared distance main routine one crossing case@>==@{@-
    RT dm;
    dm = _distance_measure_sub(
              sdm_s2to1, sdm_e2to1, s2mins1, e2mins1);
    if (dm < RT(0)) {
        return squared_distance(start2, seg1);
    } else {
        if (dm > RT(0)) {
            return squared_distance(end2, seg1);
        } else {
            // should not happen with exact arithmetic.
            return squared_distance_parallel(seg1, seg2);
        }
    }
} else {
    if (crossing2) {
        RT dm;
        dm =_distance_measure_sub(
             sdm_s1to2, sdm_e1to2, s2mins1, e1mins2);
        if (dm < RT(0)) {
            return squared_distance(start1, seg2);
        } else {
            if (dm > RT(0)) {
                return squared_distance(end1, seg2);
            } else {
                // should not happen with exact arithmetic.
                return squared_distance_parallel(seg1, seg2);
            }
        }
    } else {
@}

Finally, neither of the segments may cross. This is the case when the two
segments are parallel, which we deal with as a separate case. This case should
have been detected before, when the normal was checked for being null, but we
check anyway to cope with approximation errors due to possible inexact
arithmetic.

Otherwise we have to compare the squared distance of two endpoints to the
other segment and take the minimum.

@$@<3D seg seg squared distance main routine no crossing case@>==@{@-
        FT min1, min2;
        RT dm;
        dm = _distance_measure_sub(
                 sdm_s1to2, sdm_e1to2, s2mins1, e1mins2);
        if (dm == RT(0)) // should not happen with exact arithmetic.
           return squared_distance_parallel(seg1, seg2);
        min1 = (dm < RT(0)) ?
            squared_distance(seg1.start(), seg2):
            squared_distance(end1, seg2);
        dm = _distance_measure_sub(
                 sdm_s2to1, sdm_e2to1, s2mins1, e2mins1);
        if (dm == RT(0)) // should not happen with exact arithmetic.
            return squared_distance_parallel(seg1, seg2);
        min2 = (dm < RT(0)) ?
            squared_distance(start2, seg1):
            squared_distance(end2, seg1);
        return (min1 < min2) ? min1 : min2;
    }
}
@}

We need a small helper function to compare the distance from a point to the
the extension planes of the two segments. With the help
of the signed distance measure (that is known), this can be computed cheaply.

The previously computed signed distance measure differ from the actual signed
distance by several factors. First, they they are computed by taking the dot
product with a vector that was not normalised to 1. This is not important,
because this multiplies both signed distance measures by the same factor.
The other thing is that we took the wdot product.
For this we have to compensate, which accounts for the last two parameters.

@$@<3D segment segment squared distance helper routine@>==@{

template <class RT, class R>
RT _distance_measure_sub(RT startwdist, RT endwdist,
const Vector_3<R> &start, const Vector_3<R> &end
)
{
    return  CGAL_NTS abs(wmult((R*)0, startwdist, end.hw())) -
            CGAL_NTS abs(wmult((R*)0, endwdist, start.hw()));
}
@}

We still need to deal with the case where both segments are parallel. The
segments may not be degenerate (this was tested before), but they may have
opposite directions. This is checked and stored in the boolean variable
@{same_direction@}.

The distance between two parallel segments is either the
distance between two endpoints or the distance between an arbitrary point on
one segment to the supporting line of the other segment. In order to decide
which case applies, we can project the second segment perpendicularly on the
supporting line of the first segment. If the resulting segments overlap, the
second case apllies, otherwise the first case. The projections are just a way
of explaining, they are not actually done. The acuteness of angles is used
to make the necessary decisions.

@$@<3D segment segment squared distance parallel case@>+=@{

template <class R>
typename R::FT
squared_distance_parallel(
    const Segment_3<R> &seg1,
    const Segment_3<R> &seg2)
{
    bool same_direction;
    const Vector_3<R> &dir1 = seg1.direction().vector();
    const Vector_3<R> &dir2 = seg2.direction().vector();
    if (CGAL_NTS abs(dir1.hx()) > CGAL_NTS abs(dir1.hy())) {
        if (CGAL_NTS abs(dir1.hx()) > CGAL_NTS abs(dir1.hz())) {
            same_direction =
                (CGAL_NTS sign(dir1.hx()) == CGAL_NTS sign(dir2.hx()));
        } else {
            same_direction =
                (CGAL_NTS sign(dir1.hz()) == CGAL_NTS sign(dir2.hz()));
        }
    } else {
        if (CGAL_NTS abs(dir1.hy()) > CGAL_NTS abs(dir1.hz())) {
            same_direction =
                (CGAL_NTS sign(dir1.hy()) == CGAL_NTS sign(dir2.hy()));
        } else {
            same_direction =
                (CGAL_NTS sign(dir1.hz()) == CGAL_NTS sign(dir2.hz()));
        }
    }
    if (same_direction) {
        if (!is_acute_angle(seg1.start(), seg1.end(), seg2.start()))
            return squared_distance(seg1.end(), seg2.start());
        if (!is_acute_angle(seg1.end(), seg1.start(), seg2.end()))
            return squared_distance(seg1.start(), seg2.end());
    } else {
        if (!is_acute_angle(seg1.start(), seg1.end(), seg2.end()))
            return squared_distance(seg1.end(), seg2.end());
        if (!is_acute_angle(seg1.end(), seg1.start(), seg2.start()))
            return squared_distance(seg1.start(), seg2.start());
    }
    return squared_distance(seg2.start(), seg1.supporting_line());
}
@}

@$@<3D segment segment squared distance main routine@>==@{@-

@<3D seg seg squared distance main routine start@>
    @<3D seg seg squared distance main routine degeneracy checking@>
    @<3D seg seg squared distance main routine crossing computation@>
    @<3D seg seg squared distance main routine two crossings case@>
    @<3D seg seg squared distance main routine one crossing case@>
    @<3D seg seg squared distance main routine no crossing case@>
}
@}

@$@<Segment Segment distance implementation@>==@{
@<3D segment segment squared distance parallel case@>
@<3D segment segment squared distance helper routine@>
@<3D segment segment squared distance main routine@>
@}

@B@<Segment Ray distance@>

@C@<Declarations@>

@$@<3D squared distance header declarations@>+=@{@-
@<Ray Segment distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Ray_3<R> & ray,
    const Segment_3<R> & seg)
{
    return squared_distance(seg, ray);
}

@}

@C@<Implementation@>

The computation of the squared distance between a segment and a ray goes along
the same lines as the computation of the square distance of two segments.
We give only short comments here.

First we check if the segment is degenerate (coinciding start and
end point). If so, we solve the problem for a point and a ray.

Then we compute a vector that is normal to the direction vectors of both the
segment and the ray. This is done by taking the cross product of the two
vectors.  If the normal is the null vector, the objects must be parallel to
each other.  This is dealt with as a special case.

@$@<3D ray segment squared distance computation@>+=@{
template <class R>
typename R::FT
squared_distance(
    const Segment_3<R> &seg,
    const Ray_3<R> &ray)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    const Point_3<R> & ss = seg.start();
    const Point_3<R> & se = seg.end();
    if (ss == se)
        return squared_distance(ss, ray);
    Vector_3<R> raydir, segdir, normal;
    raydir = ray.direction().vector();
    segdir = seg.direction().vector();
    normal = wcross(segdir, raydir);
    if (is_null(normal))
        return squared_distance_parallel(seg, ray);
@}

We decide if the objects intersect the extension plane of the other object.
The boolean @{crossing1@} tells whether @{seg@} intersects the extension plane
of @{ray@}, and vice versa for @{crossing2@}.  If an endpoint lies in the
plane, we consider this as an intersection.

This intersection computation goes in the same way as the two segments case.
The only difference is that the ray only has a start point, not an end point,
so we can not compute the signed distance measure of the end point to the
extension plane of the segment. Instead, we can take the signed distance
measure of a point that is computed by adding the direction vector of the ray
to an arbitrary point of the extension plane of the segment.

As for naming: @{ss_min_rs@} stands for the segment start point minus the ray
start point. @{sdm_se2r@} stands for the signed distance measure(@{sdm@}) from
the segment end point(@{se@}) to the extension plane of the ray(@{r@}).

@$@<3D ray segment squared distance computation@>+=@{
    bool crossing1, crossing2;
    RT sdm_ss2r, sdm_se2r, sdm_rs2s, sdm_re2s;
    Vector_3<R> perpend2seg, perpend2ray, ss_min_rs, se_min_rs;
    perpend2seg = wcross(segdir, normal);
    perpend2ray = wcross(raydir, normal);
    ss_min_rs = ss-ray.start();
    se_min_rs = se-ray.start();
    sdm_ss2r = wdot(perpend2ray, ss_min_rs);
    sdm_se2r = wdot(perpend2ray, se_min_rs);
    if (sdm_ss2r < RT(0)) {
        crossing1 = (sdm_se2r >= RT(0));
    } else {
        if (sdm_se2r <= RT(0)) {
            crossing1 = true;
        } else {
            crossing1 = (sdm_ss2r == RT(0));
        }
    }

    sdm_rs2s = -RT(wdot(perpend2seg, ss_min_rs));
    sdm_re2s = wdot(perpend2seg, raydir);
    if (sdm_rs2s < RT(0)) {
        crossing2 = (sdm_re2s >= RT(0));
    } else {
        if (sdm_re2s <= RT(0)) {
            crossing2 = true;
        } else {
            crossing2 = (sdm_rs2s == RT(0));
        }
    }
@}

Depending on the values of the crossing variables we now proceed. If both
the segment and the ray intersect the extension plane of the other object,
the extension strips of the objects intersect.
In this case we compute the
distance from an arbitrary point of the segment to the plane perpendicular to
@{normal@} that goes through the ray.

Also the other cases go very similar to the segment segment case, so we omit
further commentary.

@$@<3D ray segment squared distance computation@>+=@{
    if (crossing1) {
        if (crossing2) {
            return squared_distance_to_plane(normal, ss_min_rs);
        }
        return squared_distance(ray.start(), seg);
    } else {
        if (crossing2) {
            RT dm;
            dm = _distance_measure_sub(
                    sdm_ss2r, sdm_se2r, ss_min_rs, se_min_rs);
            if (dm < RT(0)) {
                return squared_distance(ss, ray);
            } else {
                if (dm > RT(0)) {
                    return squared_distance(se, ray);
                } else {
                    // parallel, should not happen (no crossing)
                    return squared_distance_parallel(seg, ray);
                }
            }
        } else {
            FT min1, min2;
            RT dm;
            dm = _distance_measure_sub(
                    sdm_ss2r, sdm_se2r, ss_min_rs, se_min_rs);
            if (dm == RT(0))
                return squared_distance_parallel(seg, ray);
            min1 = (dm < RT(0))
                 ? squared_distance(ss, ray)
                 : squared_distance(se, ray);
            min2 = squared_distance(ray.start(), seg);
            return (min1 < min2) ? min1 : min2;
        }
    }
}
@}

@$@<3D ray segment squared distance parallel case@>==@{
template <class R>
typename R::FT
squared_distance_parallel(
    const Segment_3<R> &seg,
    const Ray_3<R> &ray)
{
    bool same_direction;
    const Vector_3<R> &dir1 = seg.direction().vector();
    const Vector_3<R> &dir2 = ray.direction().vector();
    if (CGAL_NTS abs(dir1.hx()) > CGAL_NTS abs(dir1.hy())) {
        same_direction = (CGAL_NTS sign(dir1.hx()) == CGAL_NTS sign(dir2.hx()));
    } else {
        same_direction = (CGAL_NTS sign(dir1.hy()) == CGAL_NTS sign(dir2.hy()));
    }
    if (same_direction) {
        if (!is_acute_angle(seg.start(), seg.end(), ray.start()))
            return squared_distance(seg.end(), ray.start());
    } else {
        if (!is_acute_angle(seg.end(), seg.start(), ray.start()))
            return squared_distance(seg.start(), ray.start());
    }
    return squared_distance(ray.start(), seg.supporting_line());
}
@}


@$@<Ray Segment distance implementation@>==@{

@! @<3D ray segment squared distance helper routine@>
@<3D ray segment squared distance parallel case@>
@<3D ray segment squared distance computation@>
@}

@B@<Segment Line distance@>

@C@<Declarations@>

@$@<3D squared distance header declarations@>+=@{@-
@<3D line segment squared distance computation@>

template <class R>
inline typename R::FT
squared_distance(
    const Line_3<R> & line,
    const Segment_3<R> & seg)
{
    return squared_distance(seg, line);
}

@}

@C@<Implementation@>

The computation of the squared distance between a segment and a line goes along
the same lines as the computation of the squared distance of two segments.
We do not repeat the comments of the code that is the same.

@$@<3D line segment squared distance computation@>+=@{
template <class R>
typename R::FT
squared_distance(
    const Segment_3<R> &seg,
    const Line_3<R> &line)
{
    typedef typename R::RT RT;
    const Point_3<R> &linepoint = line.point();
    const Point_3<R> &start = seg.start();
    const Point_3<R> &end = seg.end();
@}

We start with checking for degenerate cases.

@$@<3D line segment squared distance computation@>+=@{
    if (start == end)
        return squared_distance(start, line);
    Vector_3<R> linedir = line.direction().vector();
    Vector_3<R> segdir = seg.direction().vector();
    Vector_3<R> normal = wcross(segdir, linedir);
    if (is_null(normal))
        return squared_distance_to_line(linedir, start-linepoint);
@}

Then we test for intersection with the extension planes.  Things are a bit
easier in this case. We do not have to check if the line intersects the
extension plane of the segment. It always does, unless the segment and the line
are parallel to each other. This is the reason why there is only one
@{crossing@} variable.

@$@<3D line segment squared distance computation@>+=@{
    bool crossing;
    RT sdm_ss2l, sdm_se2l;
    Vector_3<R> perpend2line, start_min_lp, end_min_lp;
    perpend2line = wcross(linedir, normal);
    start_min_lp = start-linepoint;
    end_min_lp = end-linepoint;
    sdm_ss2l = wdot(perpend2line, start_min_lp);
    sdm_se2l = wdot(perpend2line, end_min_lp);
    if (sdm_ss2l < RT(0)) {
        crossing = (sdm_se2l >= RT(0));
    } else {
        if (sdm_se2l <= RT(0)) {
            crossing = true;
        } else {
            crossing = (sdm_ss2l == RT(0));
        }
    }
@}

Finally, we compute the squared distance, depending on which case applies.

@$@<3D line segment squared distance computation@>+=@{
    if (crossing) {
        return squared_distance_to_plane(normal, start_min_lp);
    } else {
        RT dm;
        dm = _distance_measure_sub(
                sdm_ss2l, sdm_se2l, start_min_lp, end_min_lp);
        if (dm <= RT(0)) {
            return squared_distance_to_line(linedir, start_min_lp);
        } else {
            return squared_distance_to_line(linedir, end_min_lp);
        }
    }
}
@}




@B@<Ray Ray distance@>

@C@<Declarations@>
@$@<3D squared distance header declarations@>+=@{@-
@<Ray Ray distance implementation@>

@}

@C@<Implementation@>



The computation of the squared distance two rays goes along the same lines as
the computation of the square distance between a segment and a ray.

Look at that routine for comments.

@$@<3D ray ray squared distance computation@>+=@{
template <class R>
typename R::FT
squared_distance(
    const Ray_3<R> &ray1,
    const Ray_3<R> &ray2)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    const Point_3<R> & s1 = ray1.start();
    const Point_3<R> & s2 = ray2.start();
    Vector_3<R> dir1, dir2, normal;
    dir1 = ray1.direction().vector();
    dir2 = ray2.direction().vector();
    normal = wcross(dir1, dir2);
    Vector_3<R> s1_min_s2 = s1-s2;
    if (is_null(normal))
        return ray_ray_squared_distance_parallel(dir1, dir2, s1_min_s2);

    bool crossing1, crossing2;
    RT sdm_s1_2, sdm_s2_1;
    Vector_3<R> perpend1, perpend2;
    perpend1 = wcross(dir1, normal);
    perpend2 = wcross(dir2, normal);

    sdm_s1_2 = wdot(perpend2, s1_min_s2);
    if (sdm_s1_2 < RT(0)) {
        crossing1 = (RT(wdot(perpend2, dir1)) >= RT(0));
    } else {
        if (RT(wdot(perpend2, dir1)) <= RT(0)) {
            crossing1 = true;
        } else {
            crossing1 = (sdm_s1_2 == RT(0));
        }
    }
    sdm_s2_1 = -RT(wdot(perpend1, s1_min_s2));
    if (sdm_s2_1 < RT(0)) {
        crossing2 = (RT(wdot(perpend1, dir2)) >= RT(0));
    } else {
        if (RT(wdot(perpend1, dir2)) <= RT(0)) {
            crossing2 = true;
        } else {
            crossing2 = (sdm_s2_1 == RT(0));
        }
    }
    if (crossing1) {
        if (crossing2)
            return squared_distance_to_plane(normal, s1_min_s2);
        return squared_distance(ray2.start(), ray1);
    } else {
        if (crossing2) {
            return squared_distance(ray1.start(), ray2);
        } else {
          FT min1, min2;
            min1 = squared_distance(ray1.start(), ray2);
            min2 = squared_distance(ray2.start(), ray1);
            return (min1 < min2) ? min1 : min2;
        }
    }
}
@}

The following routine computes the squared distance between two rays if they
are parallel. The parameters are the two directions of the rays and the vector
from the start point of the first ray to the start point of the second.

The distance is the distance between the two start points if there is no
line perpendicular to the rays that passes through both rays. Otherwise we can
take the distance between the starting point of the one ray to the supporting
line of the other.


@$@<3D ray ray squared distance parallel case@>==@{
template <class R>
typename R::FT
ray_ray_squared_distance_parallel(
    const Vector_3<R> &ray1dir,
    const Vector_3<R> &ray2dir,
    const Vector_3<R> &s1_min_s2)
{
    if (!is_acute_angle(ray2dir, s1_min_s2)) {
        bool same_direction;
        if (CGAL_NTS abs(ray1dir.hx()) > CGAL_NTS abs(ray1dir.hy())) {
            if (CGAL_NTS abs(ray1dir.hx()) > CGAL_NTS abs(ray1dir.hz()))
                same_direction =
                   (CGAL_NTS sign(ray1dir.hx()) == CGAL_NTS sign(ray2dir.hx()));
            else
                same_direction =
                   (CGAL_NTS sign(ray1dir.hz()) == CGAL_NTS sign(ray2dir.hz()));
        } else {
            if (CGAL_NTS abs(ray1dir.hy()) > CGAL_NTS abs(ray1dir.hz()))
                same_direction =
                   (CGAL_NTS sign(ray1dir.hy()) == CGAL_NTS sign(ray2dir.hy()));
            else
                same_direction =
                   (CGAL_NTS sign(ray1dir.hz()) == CGAL_NTS sign(ray2dir.hz()));
        }
        if (!same_direction)
            return (typename R::FT)(s1_min_s2*s1_min_s2);
    }
    return squared_distance_to_line(ray1dir, s1_min_s2);
}
@}

@$@<Ray Ray distance implementation@>==@{

@<3D ray ray squared distance parallel case@>
@<3D ray ray squared distance computation@>
@}

@B@<Line Ray distance@>

@C@<Declarations@>
@$@<3D squared distance header declarations@>+=@{@-
@<Line Ray distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Ray_3<R> & ray,
    const Line_3<R> & line)
{
    return squared_distance(line, ray);
}

@}

@C@<Implementation@>

The computation of the squared distance a line and a ray goes along the same
lines as the computation of the square distance between two segments. With
fewer endpoints, things get ever simpler to compute.

@$@<Line Ray distance implementation@>==@{

template <class R>
extern typename R::FT
squared_distance(
    const Line_3<R> &line,
    const Ray_3<R> &ray)
{
    typedef typename R::RT RT;
    const Point_3<R> & rs =ray.start();
    Vector_3<R> raydir, linedir, normal;
    linedir = line.direction().vector();
    raydir = ray.direction().vector();
    normal = wcross(raydir, linedir);
    Vector_3<R> rs_min_lp = rs-line.point();
    if (is_null(normal))
        return squared_distance_to_line(linedir, rs_min_lp);

    bool crossing;
    RT sdm_sr_l;
    Vector_3<R> perpend2l;
    perpend2l = wcross(linedir, normal);

    sdm_sr_l = wdot(perpend2l, rs_min_lp);
    if (sdm_sr_l < RT(0)) {
        crossing = (RT(wdot(perpend2l, raydir)) >= RT(0));
    } else {
        if (RT(wdot(perpend2l, raydir)) <= RT(0)) {
            crossing = true;
        } else {
            crossing = (sdm_sr_l == RT(0));
        }
    }

    if (crossing)
        return squared_distance_to_plane(normal, rs_min_lp);
    else
        return squared_distance_to_line(linedir, rs_min_lp);
}
@}

@B@<Line Line distance@>

@C@<Declarations@>
@$@<3D squared distance header declarations@>+=@{
@<Line Line distance implementation@>
@}

@C@<Implementation@>

We discern two cases: parallel and non-parallel lines.
For parallel lines, we can take the squared distance from an arbitrary point
on one line to the other line.

Otherwise, the problem can be reduced to the squared distance from a point to a
plane.

@$@<Line Line distance implementation@>==@{

template <class R>
typename R::FT
squared_distance(
    const Line_3<R> &line1,
    const Line_3<R> &line2)
{
    Vector_3<R> dir1, dir2, normal, diff;
    dir1 = line1.direction().vector();
    dir2 = line2.direction().vector();
    normal = wcross(dir1, dir2);
    diff = line2.point() - line1.point();
    if (is_null(normal))
        return squared_distance_to_line(dir2, diff);
    return squared_distance_to_plane(normal, diff);
}
@}




@B@<Point Plane distance@>

@C@<Declarations@>

@$@<3D squared distance 2 header declarations@>+=@{@-
@<Point Plane distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Plane_3<R> & plane,
    const Point_3<R> & pt)
{
    return squared_distance(pt, plane);
}
@}

@C@<Implementation@>

@$@<Point Plane distance implementation@>==@{@-

template <class R>
inline typename R::FT
squared_distance(
    const Point_3<R> & pt,
    const Plane_3<R> & plane)
{
    Vector_3<R> diff(pt-plane.point());
    return squared_distance_to_plane(plane.orthogonal_vector(), diff);
}

@}

@B@<3D Plane Line distance@>

The following routine decides whether a vector lies in a plane. This is useful
for detecting whether a line is parallel to a plane.

@$@<3D squared distance general utilities 2@>==@{

template <class R>
bool
contains_vector(const Plane_3<R> &pl, const Vector_3<R> &vec)
{
    typedef typename R::RT RT;
    return pl.a()*vec.hx() + pl.b()*vec.hy() + pl.c() * vec.hz() == RT(0);
}
@}

@C@<Declarations@>
@$@<3D squared distance 2 header declarations@>+=@{@-
@<Line Plane distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Plane_3<R> & p,
    const Line_3<R> & line)
{
    return squared_distance(line, p);
}
@}

@C@<Implementation@>

If the line is parallel to the plane, we can take the squared distance of an
arbitrary point of the line to the plane. Otherwise the distance is zero.

@$@<Line Plane distance implementation@>==@{@-

template <class R>
extern typename R::FT
squared_distance(
    const Line_3<R> &line,
    const Plane_3<R> &plane)
{
    typedef typename R::FT FT;
    if (contains_vector(plane, line.direction().vector() ))
        return squared_distance(plane, line.point());
    return FT(0);
}
@}

@B@<3D Plane Ray distance@>


@C@<Declarations@>
@$@<3D squared distance 2 header declarations@>+=@{@-
@<Ray Plane distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Plane_3<R> & plane,
    const Ray_3<R> & ray)
{
    return squared_distance(ray, plane);
}
@}

@C@<Implementation@>


@$@<Ray Plane distance implementation@>==@{@-
template <class R>
extern typename R::FT
squared_distance(
    const Ray_3<R> &ray,
    const Plane_3<R> &plane)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    const Point_3<R> &start = ray.start();
//    const Vector_3<R> &end = ray.direction().vector();
    const Point_3<R> &planepoint = plane.point();
    Vector_3<R> start_min_pp = start - planepoint;
    Vector_3<R> end_min_pp = ray.direction().vector();
    const Vector_3<R> &normal = plane.orthogonal_vector();
    RT sdm_rs2pp = wdot(normal, start_min_pp);
    RT sdm_re2pp = wdot(normal, end_min_pp);
    switch (CGAL_NTS sign(sdm_rs2pp)) {
    case -1:
        if (sdm_re2pp > RT(0))
            return FT(0);
        return squared_distance_to_plane(normal, start_min_pp);
    case 0:
    default:
        return FT(0);
    case 1:
        if (sdm_re2pp < RT(0))
            return FT(0);
        return squared_distance_to_plane(normal, start_min_pp);
    }
}
@}
@B@<3D Plane Segment distance@>


@C@<Declarations@>
@$@<3D squared distance 2 header declarations@>+=@{@-
@<Segment Plane distance implementation@>

template <class R>
inline typename R::FT
squared_distance(
    const Plane_3<R> & plane,
    const Segment_3<R> & seg)
{
    return squared_distance(seg, plane);
}
@}

@C@<Implementation@>


@$@<Segment Plane distance implementation@>==@{@-

template <class R>
extern typename R::FT
squared_distance(
    const Segment_3<R> &seg,
    const Plane_3<R> &plane)
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    const Point_3<R> &start = seg.start();
    const Point_3<R> &end = seg.end();
    if (start == end)
        return squared_distance(start, plane);
    const Point_3<R> &planepoint = plane.point();
    Vector_3<R> start_min_pp = start - planepoint;
    Vector_3<R> end_min_pp = end - planepoint;
    const Vector_3<R> &normal = plane.orthogonal_vector();
    RT sdm_ss2pp = wdot(normal, start_min_pp);
    RT sdm_se2pp = wdot(normal, end_min_pp);
    switch (CGAL_NTS sign(sdm_ss2pp)) {
    case -1:
        if (sdm_se2pp >= RT(0))
            return FT(0);
        if (sdm_ss2pp >= sdm_se2pp)
            return squared_distance_to_plane(normal, start_min_pp);
        else
            return squared_distance_to_plane(normal, end_min_pp);
    case 0:
    default:
        return FT(0);
    case 1:
        if (sdm_se2pp <= RT(0))
            return FT(0);
        if (sdm_ss2pp <= sdm_se2pp)
            return squared_distance_to_plane(normal, start_min_pp);
        else
            return squared_distance_to_plane(normal, end_min_pp);
    }
}
@}

@B@<The header files@>

Here we collect all code in the appropriate header files.

@O@<../include/CGAL/squared_distance_3_0.h@>==@{@-
@<cgal_heading@>@(@-
include/CGAL/squared_distance_3_0.h@,@-
sqdistance_3.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_DISTANCE_3_0_H
#define CGAL_DISTANCE_3_0_H

#include <CGAL/Point_3.h>

#include <CGAL/utils.h>
#include <CGAL/enum.h>
#include <CGAL/wmult.h>

CGAL_BEGIN_NAMESPACE

@<3D squared distance general utilities@>
@<3D squared distance 0 header declarations@>

CGAL_END_NAMESPACE


#endif
@}


@O@<../include/CGAL/squared_distance_3_1.h@>==@{@-
@<cgal_heading@>@(@-
include/CGAL/squared_distance_3_1.h@,@-
sqdistance_3.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_DISTANCE_3_1_H
#define CGAL_DISTANCE_3_1_H

#include <CGAL/Segment_3.h>
#include <CGAL/Line_3.h>
#include <CGAL/Ray_3.h>

#include <CGAL/utils.h>
#include <CGAL/Point_3.h>
#include <CGAL/enum.h>
#include <CGAL/wmult.h>
#include <CGAL/squared_distance_3_0.h>

CGAL_BEGIN_NAMESPACE

@<3D squared distance header declarations@>

CGAL_END_NAMESPACE


#endif
@}


@O@<../include/CGAL/squared_distance_3_2.h@>==@{@-
@<cgal_heading@>@(@-
include/CGAL/squared_distance_3_2.h@,@-
sqdistance_3.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_DISTANCE_3_2_H
#define CGAL_DISTANCE_3_2_H

#include <CGAL/Segment_3.h>
#include <CGAL/Line_3.h>
#include <CGAL/Ray_3.h>
#include <CGAL/Plane_3.h>


#include <CGAL/utils.h>
#include <CGAL/Point_3.h>
#include <CGAL/Plane_3.h>
#include <CGAL/enum.h>
#include <CGAL/wmult.h>
#include <CGAL/squared_distance_3_0.h>

CGAL_BEGIN_NAMESPACE

@<3D squared distance general utilities 2@>
@<3D squared distance 2 header declarations@>

CGAL_END_NAMESPACE


#endif
@}

@O@<../include/CGAL/squared_distance_3.h@>==@{@-
@<cgal_heading@>@(@-
include/CGAL/squared_distance_3.h@,@-
sqdistance_3.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_DISTANCE_3_H
#define CGAL_DISTANCE_3_H

#include <CGAL/squared_distance_3_0.h>
#include <CGAL/squared_distance_3_1.h>
#include <CGAL/squared_distance_3_2.h>

#endif
@}

