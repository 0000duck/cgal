\section{Basics}


\subsection{Default Parameterization}

From the user point of view, the simplest entry point to this package
is the following function:

\ccFunction{Parameterizer_traits_3<ParameterizationMesh_3>::Error_code parameterize (ParameterizationMesh_3 * mesh);}
{ Compute a one-to-one mapping from a 3D triangle surface 'mesh' to a
2D circle, using Floater Mean Value Coordinates algorithm. A
one-to-one mapping is guaranteed. The mapping is piecewise linear on
the input mesh triangles. The result is a (u,v) pair of parameter
coordinates for each vertex of the input mesh.
Preconditions:\begin{itemize}
\item 'mesh' must be a surface with one connected component.\item 'mesh' must be a triangular mesh.\end{itemize}
}

The CGAL::parameterize() function provides a default parameterization
method: Floater Mean Value Coordinates~\cite{cgal:f-mvc-03}, with an
arc-length circular border parameterization, and using OpenNL sparse
linear solver~\cite{cgal:l-nmdgp-05}.

The result is stored into the (u,v) fields of the mesh vertices and/or
halfedges.


\subsection{List of Supported Meshes and Concept}

The general definition of input meshes handled by the package is:

\begin{itemize}

\item Triangulated.

\item 2-manifold.

\item Oriented.

\item All surface parameterization methods only deal with topological discs.
The input mesh can be of any genus and have an arbitrary number of
connected components.  If it is not a topological disc, it has to come
with a description of a boundary (a list of vertices) which is the
boundary of a topological disc.  If no boundary is given as input, we
assume that the surface boundary is the longest boundary already
present in the input mesh (the other boundaries are considered as
holes).

Note that this way the user is responsible for cutting a closed mesh
of arbitrary genus (even a topological disc with an intricate seam
cut), as long as this condition is fulfilled.

The package will only parameterize the inside part of the given
boundary, thus only one connected component.

\end{itemize}

The package accesses such meshes through the
\ccc{ParameterizationMesh_3} concept. Among other things, this concept
defines the accessor to the (u,v) values computed by
parameterizations.

The package offers models of the concept
\ccc{ParameterizationMesh_3} with both the 2D Triangulation Data
Structure enriched with 3D points (not yet implemented) and the
Polyhedron:

\ccc{CGAL::Parameterization_polyhedron_adaptor_3}  \\

Note that these interfaces are decorators which add {\em on the fly}
the necessary fields to unmodified CGAL data structures (using STL
maps). For better performances, it is recommended to use CGAL data
structures enriched with the proper fields. See \ccc{Polyhedron_ex}
class in \ccc{polyhedron_ex_parameterization.C} example.


\subsection{Default Parameterization Example}

The code below applies the default parameterization to a
\ccc{Polyhedron_3} mesh (must be a topological disk).
Eventually, it extracts the result from halfedges and prints it.

\begin{ccExampleCode}

// CGAL kernel
typedef CGAL::Cartesian<double>                         Kernel;

// Mesh true type and parameterization adaptors
typedef CGAL::Polyhedron_3<Kernel>                      Polyhedron;
typedef CGAL::Parameterization_polyhedron_adaptor_3<Polyhedron>
                                                        Parameterization_polyhedron_adaptor;

// Defines the error codes
typedef CGAL::Parameterizer_traits_3<Parameterization_polyhedron_adaptor>
                                                        Parameterizer;

int main(int argc,char * argv[])
{
    Polyhedron mesh;

    // read the mesh
    ...

    // The parameterization package needs an adaptor to handle Polyhedron_3 meshes
    // The mesh must be a topological disk
    Parameterization_polyhedron_adaptor mesh_adaptor(&mesh);

    // Floater Mean Value Coordinates parameterization
    Parameterizer::Error_code err = CGAL::parameterize(&mesh_adaptor);
    if (err != Parameterizer::OK)
        fprintf(stderr, "\nFATAL ERROR: parameterization error # %d\n", (int)err);

    if (err == Parameterizer::OK)
    {
        // Raw output: dump (u,v) pairs
        Polyhedron::Vertex_const_iterator pVertex;
        for (pVertex = mesh.vertices_begin();
            pVertex != mesh.vertices_end();
            pVertex++)
        {
            // (u,v) pair is stored in any halfedge
            double u = mesh_adaptor.info(pVertex->halfedge())->uv().x();
            double v = mesh_adaptor.info(pVertex->halfedge())->uv().y();
            printf("(u,v) = (%lf,%lf)\n", u, v);
        }
    }
}

\end{ccExampleCode}

See the complete example in \ccc{Simple_parameterization.C}.


