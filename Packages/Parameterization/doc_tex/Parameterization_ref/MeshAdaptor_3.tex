% +------------------------------------------------------------------------+
% | Reference manual page: MeshAdaptor_3.tex
% +------------------------------------------------------------------------+
% | 23.08.2005   Laurent Saboret, Pierre Alliez
% | Package: Parameterization
% |
\RCSdef{\RCSMeshAdaptorRev}{$Revision$}
\RCSdefDate{\RCSMeshAdaptorDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{MeshAdaptor_3}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries


\ccDefinition

\ccRefName\ is a concept for a 3D surface mesh.
Its main purpose is to allow
the parameterization methods to access meshes on an uniform manner.

A \ccRefName\ surface consists of vertices $V$,
facets $F$ and an incidence relation on them.
No notion of edge is requested.
Vertices represent points in 3d-space. Facets are planar polygons without holes
defined by the circular sequence of vertices along their boundary.
The surface itself can have holes. The vertices
along the boundary of a hole are called {\em border vertices\/}.
A surface is {\em closed\/} if it
contains no border vertices.

The surface must be an
oriented 2-manifold with border vertices, i.e.
the neighborhood of each point on the surface is either
homeomorphic to a disc or to a half disc, except for vertices where
many holes and surfaces with boundary can join.

\ccRefName\ defines the minimum types, data and methods that a mesh must implement
to allow surface parameterization.

\ccRefName\ meshes can have any genus, aridity or number of components.
In the other hand,
as parameterization methods deal only with topological disks, \ccRefName\
defines an interface oriented towards topological disks.


\ccHeading{Design pattern}

\ccRefName\ is an Adaptor (see [GOF95]): it changes the
interface of a 3D mesh to match the interface expected by the parameterization methods.


\ccTypes

The following handles, iterators, and circulators have appropriate
non-mutable counterparts, i.e. \ccc{const_handle},
\ccc{const_iterator}, and \ccc{const_circulator}. The mutable types are
assignable to their non-mutable counterparts.  Both circulators are
assignable to the \ccc{Vertex_iterator}. The iterators are
assignable to the respective handle types. Wherever the handles appear
in function parameter lists, the corresponding iterators can be used as
well.

\ccNestedType{NT}
       {Number type to represent coordinates.}

\ccNestedType{Point_2}
       {2D point that represents (u,v) coordinates computed
        by parameterization methods. Usual methods are expected.}
\ccGlue
\ccNestedType{Point_3}
       {3D point that represents vertices coordinates. Usual methods are expected.}
\ccGlue
\ccNestedType{Vector_2}
       {2D vector. Usual methods are expected.}
\ccGlue
\ccNestedType{Vector_3}
       {3D vector. Usual methods are expected.}

\ccNestedType{Facet}
       {Opaque type representing a facet of the 3D mesh.
        No methods are expected.}
\ccGlue
\ccNestedType{Facet_handle}
       {Handle to a facet. Model of the Handle concept.}
\ccGlue
\ccNestedType{Facet_iterator}
       {Iterator over all mesh facets. Model of the ForwardIterator concept.}

\ccNestedType{Vertex}
       {Opaque type representing a vertex of the 3D mesh.
        No methods are expected.}
\ccGlue
\ccNestedType{Vertex_handle}
       {Handle to a vertex. Model of the Handle concept.}
\ccGlue
\ccNestedType{Vertex_iterator}
       {Iterator over all vertices of a mesh. Model of the ForwardIterator concept.}
\ccGlue
\ccNestedType{Border_vertex_iterator}
       {Iterator over vertices of the mesh's \emph{main boundary}.
        Model of the ForwardIterator concept.}
\ccGlue
\ccNestedType{Vertex_around_facet_circulator}
       {Counter-clockwise circulator over a facet's vertices.
        Model of the BidirectionalCirculator concept.}
\ccGlue
\ccNestedType{Vertex_around_vertex_circulator}
       {Clockwise circulator over the vertices incident to a vertex.
        Model of the BidirectionalCirculator concept.}


\ccCreation

\ccCreationVariable{m}  %% define variable name used by \ccMethod below

No constructor is required.


\ccOperations

The following methods returning a handle, iterator, or circulator have appropriate
non-mutable counterpart methods, i.e. \ccc{const}, returning a \ccc{const_handle},
\ccc{const_iterator}, or \ccc{const_circulator}.

\textbf{MESH INTERFACE:}

\ccMethod{Vertex_iterator mesh_vertices_begin();}
	{Get iterator over first vertex of mesh.}
\ccGlue
\ccMethod{Vertex_iterator  mesh_vertices_end();}
	{Get iterator over past-the-end vertex of mesh.}
\ccGlue
\ccMethod{int  count_mesh_vertices () const;}
	{Count the number of vertices of the mesh.}
\ccGlue
\ccMethod{void  index_mesh_vertices();}
	{Index vertices of the mesh from 0 to count\_mesh\_vertices()-1.}
\ccGlue
\ccMethod{Border_vertex_iterator  mesh_main_border_vertices_begin();}
	{Get iterator over first vertex of mesh's \emph{main boundary}.}
\ccGlue
\ccMethod{Border_vertex_iterator  mesh_main_border_vertices_end ();}
	{Get iterator over past-the-end vertex of mesh's \emph{main boundary}}
\ccGlue
\ccMethod{std::list<Vertex_handle> get_boundary(Vertex_handle seed_vertex);}
	{Return the boundary containing seed\_vertex
	 Return an empty list if not found}
\ccGlue
\ccMethod{Facet_iterator  mesh_facets_begin ();}
	{Get iterator over first facet of mesh}
\ccGlue
\ccMethod{Facet_iterator  mesh_facets_end ();}
	{Get iterator over past-the-end facet of mesh}
\ccGlue
\ccMethod{int  count_mesh_facets () const;}
	{Count the number of facets of the mesh}
\ccGlue
\ccMethod{bool  is_mesh_triangular () const;}
	{Return true of all mesh's facets are triangles}
\ccGlue
\ccMethod{int  count_mesh_halfedges() const;}
	{Count the number of halfedges of the mesh}

\textbf{FACET INTERFACE:}

\ccMethod{Vertex_around_facet_circulator facet_vertices_begin(Facet_handle facet);}
	{Get circulator over facet's vertices}
\ccGlue
\ccMethod{int  count_facet_vertices(Facet_const_handle facet) const;}
	{Count the number of vertices of a facet}

\textbf{VERTEX INTERFACE:}

\ccMethod{Point_3  get_vertex_position (Vertex_const_handle vertex) const;}
	{Get the 3D position of a vertex}
\ccGlue
\ccMethod{Point_2  get_vertex_uv (Vertex_const_handle vertex) const;}
	{Get/set the 2D position (u/v pair) of a vertex. Default value is undefined.}
\ccGlue
\ccMethod{void  set_vertex_uv (Vertex_handle vertex, const Point_2& uv);}{}
\ccGlue
\ccMethod{bool  is_vertex_parameterized (Vertex_const_handle vertex) const;}
	{Get/set "is parameterized" field of vertex. Default value is undefined.}
\ccGlue
\ccMethod{void  set_vertex_parameterized (Vertex_handle vertex, bool parameterized);}{}
\ccGlue
\ccMethod{int  get_vertex_index (Vertex_const_handle vertex) const;}
	{Get/set vertex index. Default value is undefined.}
\ccGlue
\ccMethod{void  set_vertex_index (Vertex_handle vertex, int index);}{}
\ccGlue
\ccMethod{int  get_vertex_tag(Vertex_const_handle vertex) const;}
	{Get/set vertex' all purpose tag. Default value is undefined.}
\ccGlue
\ccMethod{void set_vertex_tag(Vertex_handle vertex, int tag);}{}
\ccGlue
\ccMethod{bool  is_vertex_on_border(Vertex_const_handle vertex) const;}
	{Return true if a vertex belongs to \emph{any mesh's boundary}}
\ccGlue
\ccMethod{bool  is_vertex_on_main_border(Vertex_const_handle vertex) const;}
	{Return true if a vertex belongs to the mesh's \emph{main boundary}}
\ccGlue
\ccMethod{Vertex_around_vertex_circulator vertices_around_vertex_begin(
                            Vertex_handle vertex,
                            Vertex_handle start_position = NULL);}
	{Get circulator over the vertices incident to 'vertex'
	 'start\_position' defines the optional initial position of the circulator}

\ccHasModels

\ccRefIdfierPage{CGAL::Mesh_adaptor_polyhedron_3<Traits>} \\
\ccRefIdfierPage{CGAL::Mesh_adaptor_patch_3<PatchableMeshAdaptor_3>} \\


\ccSeeAlso

\ccRefConceptPage{PatchableMeshAdaptor_3}


\ccExample


This example program instantiates a polyhedron and a polyhedron adaptor using the default
traits class and parameterizes the polyhedron.

\ccIncludeExampleCode{Parameterization/Polyhedron_parameterization1.C}


\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

