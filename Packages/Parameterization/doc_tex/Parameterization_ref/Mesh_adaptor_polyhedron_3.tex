% +------------------------------------------------------------------------+
% | Reference manual page: Mesh_adaptor_polyhedron_3.tex
% +------------------------------------------------------------------------+
% | 13.09.2005   Laurent Saboret, Pierre Alliez
% | Package: Parameterization
% |
\RCSdef{\RCSMeshadaptorpolyhedronRev}{$Revision$}
\RCSdefDate{\RCSMeshadaptorpolyhedronDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Mesh_adaptor_polyhedron_3}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries


\ccDefinition

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

Mesh\_adaptor\_polyhedron\_3 is an adaptor class to access to a Polyhedron 3D mesh using the PatchableMeshAdaptor\_3 interface.

A MeshAdaptor\_3 surface consists of vertices, facets and an incidence relation on them. No notion of edge is requested.

The surface must be an oriented 2-manifold with border vertices.

MeshAdaptor\_3 meshes can have any genus, aridity or number of components.

It can have have any number of boundaries. Its "main border" will be the mesh's longest boundary (if there is at least one boundary).

It has also the ability to support patches and virtual seams. Patches are a subset of a 3D mesh. Virtual seams are the ability to behave exactly as if the surface was "cut" following a certain path.

%END-AUTO(\ccDefinition)

\ccInclude{CGAL/Mesh_adaptor_polyhedron_3.h}


\ccIsModel

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccIsModel)

Model of PatchableMeshAdaptor\_3 concept, whose purpose is to allow the parameterization package to access meshes on an uniform manner.

%END-AUTO(\ccIsModel)


\ccHeading{Design pattern}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccHeading\{Design pattern\})

Mesh\_adaptor\_polyhedron\_3 is an Adaptor (see [GOF95]): it changes the Polyhedron interface to match the PatchableMeshAdaptor\_3 concept.

%END-AUTO(\ccHeading\{Design pattern\})


\ccParameters

The full template declaration is:

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccParameters)

template$<$
class Polyhedron\_3\_$>$
class Mesh\_adaptor\_polyhedron\_3;

%END-AUTO(\ccParameters)


\ccTypes

The following mutable handles, iterators, and circulators have appropriate
non-mutable counterparts, i.e. \ccc{const_handle},
\ccc{const_iterator}, and \ccc{const_circulator}. The mutable types are
assignable to their non-mutable counterparts.  Both circulators are
assignable to the \ccc{Vertex_iterator}. The iterators are
assignable to the respective handle types. Wherever the handles appear
in function parameter lists, the corresponding iterators can be used as
well.

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\ccNestedType{Polyhedron}
{
Export template parameter.
}
\ccNestedType{NT}
{
Number type to represent coordinates.
}
\ccNestedType{Point_2}
{
2D point that represents (u,v) coordinates computed by parameterization methods. Usual methods are expected.
}
\ccNestedType{Point_3}
{
3D point that represents vertices coordinates. Usual methods are expected.
}
\ccNestedType{Vector_2}
{
2D vector. Usual methods are expected.
}
\ccNestedType{Vector_3}
{
3D vector. Usual methods are expected.
}
\ccNestedType{Facet}
{
Opaque type representing a facet of the 3D mesh. No methods are expected.
}
\ccNestedType{Facet_handle}
{
Handle to a facet. Model of the Handle concept.
}
\ccNestedType{Facet_const_handle}
{
}
\ccNestedType{Facet_iterator}
{
Iterator over all mesh facets. Model of the ForwardIterator concept.
}
\ccNestedType{Facet_const_iterator}
{
}
\ccNestedType{Vertex}
{
Opaque type representing a vertex of the 3D mesh. No methods are expected.
}
\ccNestedType{Vertex_handle}
{
Handle to a vertex. Model of the Handle concept.
}
\ccNestedType{Vertex_const_handle}
{
}
\ccNestedType{Vertex_iterator}
{
Iterator over all vertices of a mesh. Model of the ForwardIterator concept.
}
\ccNestedType{Vertex_const_iterator}
{
}
\ccNestedType{Border_vertex_iterator}
{
Iterator over vertices of the mesh "main boundary". Model of the ForwardIterator concept.
}
\ccNestedType{Border_vertex_const_iterator}
{
}
\ccNestedType{Vertex_around_facet_circulator}
{
Counter-clockwise circulator over a facet's vertices. Model of the BidirectionalCirculator concept.
}
\ccNestedType{Vertex_around_facet_const_circulator}
{
}
\ccNestedType{Vertex_around_vertex_circulator}
{
Clockwise circulator over the vertices incident to a vertex. Model of the BidirectionalCirculator concept.
}
\ccNestedType{Vertex_around_vertex_const_circulator}
{
}

%END-AUTO(\ccTypes)


\ccConstants

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccConstants)

None.

%END-AUTO(\ccConstants)


\ccCreation
\ccCreationVariable{mesh}  %% define variable name used by \ccMethod below

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\ccConstructor{Mesh_adaptor_polyhedron_3 (Polyhedron * mesh);}
{
Create an adaptator for an existing Polyhedron\_3 mesh. The input mesh can be of any genus. It can have have any number of boundaries. Its "main border" will be the mesh's longest boundary (if there is at least one boundary).
}

%END-AUTO(\ccCreation)


\ccOperations

The following methods returning a mutable handle, iterator, or circulator have appropriate
non-mutable counterpart methods, i.e. \ccc{const}, returning a \ccc{const_handle},
\ccc{const_iterator}, or \ccc{const_circulator}.

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccOperations)

\ccMethod{Polyhedron* get_adapted_mesh ();}
{
Get the adapted mesh.
}
\ccMethod{const Polyhedron* get_adapted_mesh () const;}
{
}
\ccMethod{Polyhedron::Halfedge_const_handle get_halfedge (Vertex_const_handle source, Vertex_const_handle target) const;}
{
Get halfedge from source and target vertices. Will assert if such an halfedge doesn't exist.
}
\ccMethod{Polyhedron::Halfedge_handle get_halfedge (Vertex_handle source, Vertex_handle target);}
{
}
\ccMethod{const Halfedge_info* info (Halfedge_const_handle halfedge) const;}
{
Access to additional info attached to halfedges.
}
\ccMethod{Halfedge_info* info (Halfedge_const_handle halfedge);}
{
}
\ccMethod{const Vertex_info* info (Vertex_const_handle vertex) const;}
{
Access to additional info attached to vertices.
}
\ccMethod{Vertex_info* info (Vertex_const_handle vertex);}
{
}
\ccMethod{Vertex_iterator mesh_vertices_begin ();}
{
Get iterator over first vertex of mesh.
}
\ccMethod{Vertex_const_iterator mesh_vertices_begin () const;}
{
}
\ccMethod{Vertex_iterator mesh_vertices_end ();}
{
Get iterator over past-the-end vertex of mesh.
}
\ccMethod{Vertex_const_iterator mesh_vertices_end () const;}
{
}
\ccMethod{int count_mesh_vertices () const;}
{
Count the number of vertices of the mesh.
}
\ccMethod{void index_mesh_vertices ();}
{
Index vertices of the mesh from 0 to count\_mesh\_vertices()-1.
}
\ccMethod{Border_vertex_iterator mesh_main_border_vertices_begin ();}
{
Get iterator over first vertex of mesh's "main boundary".
}
\ccMethod{Border_vertex_const_iterator mesh_main_border_vertices_begin () const;}
{
}
\ccMethod{Border_vertex_iterator mesh_main_border_vertices_end ();}
{
Get iterator over past-the-end vertex of mesh's "main boundary".
}
\ccMethod{Border_vertex_const_iterator mesh_main_border_vertices_end () const;}
{
}
\ccMethod{std::list<Vertex_handle> get_boundary (Vertex_handle seed_vertex);}
{
Return the boundary containing seed\_vertex. Return an empty list if not found.
}
\ccMethod{Facet_iterator mesh_facets_begin ();}
{
Get iterator over first facet of mesh.
}
\ccMethod{Facet_const_iterator mesh_facets_begin () const;}
{
}
\ccMethod{Facet_iterator mesh_facets_end ();}
{
Get iterator over past-the-end facet of mesh.
}
\ccMethod{Facet_const_iterator mesh_facets_end () const;}
{
}
\ccMethod{int count_mesh_facets () const;}
{
Count the number of facets of the mesh.
}
\ccMethod{bool is_mesh_triangular () const;}
{
Return true of all mesh's facets are triangles.
}
\ccMethod{int count_mesh_halfedges () const;}
{
Count the number of halfedges of the mesh.
}
\ccMethod{Vertex_around_facet_circulator facet_vertices_begin (Facet_handle facet);}
{
Get circulator over facet's vertices.
}
\ccMethod{Vertex_around_facet_const_circulator facet_vertices_begin (Facet_const_handle facet) const;}
{
}
\ccMethod{int count_facet_vertices (Facet_const_handle facet) const;}
{
Count the number of vertices of a facet.
}
\ccMethod{Point_3 get_vertex_position (Vertex_const_handle vertex) const;}
{
Get the 3D position of a vertex.
}
\ccMethod{Point_2 get_vertex_uv (Vertex_const_handle vertex) const;}
{
Get/set the 2D position (u/v pair) of a vertex. Default value is undefined. (stored in halfedges sharing the same vertex).
}
\ccMethod{void set_vertex_uv (Vertex_handle vertex, const Point_2 & uv);}
{
}
\ccMethod{bool is_vertex_parameterized (Vertex_const_handle vertex) const;}
{
Get/set "is parameterized" field of vertex. Default value is undefined. (stored in halfedges sharing the same vertex).
}
\ccMethod{void set_vertex_parameterized (Vertex_handle vertex, bool parameterized);}
{
}
\ccMethod{int get_vertex_index (Vertex_const_handle vertex) const;}
{
Get/set vertex index. Default value is undefined. (stored in Polyhedron vertex for debugging purpose).
}
\ccMethod{void set_vertex_index (Vertex_handle vertex, int index);}
{
}
\ccMethod{int get_vertex_tag (Vertex_const_handle vertex) const;}
{
Get/set vertex' all purpose tag. Default value is undefined. (stored in halfedges sharing the same vertex).
}
\ccMethod{void set_vertex_tag (Vertex_handle vertex, int tag);}
{
}
\ccMethod{bool is_vertex_on_border (Vertex_const_handle vertex) const;}
{
Return true if a vertex belongs to ANY mesh's boundary.
}
\ccMethod{bool is_vertex_on_main_border (Vertex_const_handle vertex) const;}
{
Return true if a vertex belongs to the UNIQUE mesh's main boundary, ie the mesh's LONGEST boundary
}
\ccMethod{Vertex_around_vertex_circulator vertices_around_vertex_begin (Vertex_handle vertex, Vertex_handle start_position = NULL);}
{
Get circulator over the vertices incident to 'vertex'. 'start\_position' defines the optional initial position of the circulator.
}
\ccMethod{Vertex_around_vertex_const_circulator vertices_around_vertex_begin (Vertex_const_handle vertex, Vertex_const_handle start_position = NULL) const;}
{
}
\ccMethod{int get_vertex_seaming (Vertex_const_handle vertex) const;}
{
Get/set vertex seaming flag. Default value is undefined.
}
\ccMethod{void set_vertex_seaming (Vertex_handle vertex, int seaming);}
{
}
\ccMethod{int get_halfedge_seaming (Vertex_const_handle source, Vertex_const_handle target) const;}
{
Get/set oriented edge's seaming flag, ie position of the oriented edge wrt to the UNIQUE main boundary
}
\ccMethod{void set_halfedge_seaming (Vertex_handle source, Vertex_handle target, int seaming);}
{
}
\ccMethod{Point_2 get_corners_uv (Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set the 2D position (= (u,v) pair) of corners at the "right" of the prev\_vertex -$>$ vertex -$>$ next\_vertex line. Default value is undefined. (stored in incident halfedges).
}
\ccMethod{void set_corners_uv (Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, const Point_2 & uv);}
{
}
\ccMethod{bool are_corners_parameterized (Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set "is parameterized" field of corners at the "right" of the prev\_vertex -$>$ vertex -$>$ next\_vertex line. Default value is undefined. (stored in incident halfedges).
}
\ccMethod{void set_corners_parameterized (Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, bool parameterized);}
{
}
\ccMethod{int get_corners_index (Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set index of corners at the "right" of the prev\_vertex -$>$ vertex -$>$ next\_vertex line. Default value is undefined. (stored in incident halfedges).
}
\ccMethod{void set_corners_index (Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, int index);}
{
}
\ccMethod{int get_corners_tag (Vertex_const_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex) const;}
{
Get/set all purpose tag of corners at the "right" of the prev\_vertex -$>$ vertex -$>$ next\_vertex line. Default value is undefined. (stored in incident halfedges).
}
\ccMethod{void set_corners_tag (Vertex_handle vertex, Vertex_const_handle prev_vertex, Vertex_const_handle next_vertex, int tag);}
{
}

%END-AUTO(\ccOperations)


\ccSeeAlso

\ccRefIdfierPage{CGAL::Mesh_adaptor_patch_3<Traits>}  \\


\ccExample

This example program instantiates a polyhedron and a polyhedron adaptor using the default
traits classes and parameterizes the polyhedron.

\ccIncludeExampleCode{Parameterization/Polyhedron_parameterization1.C}


\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

