% $Id$

\begin{ccClassTemplate} {CGAL_Point_2<R>}
\ccSection{2D Point}

\ccDefinition
An object of the class \ccClassName\ is a point in the two-dimensional
euclidean plane $\E_2$. 


%% \cgal\ defines a symbolic constant \ccStyle{CGAL_ORIGIN}  which denotes
%% the point at the origin. It can be used wherever a point can be used,
%% with the only exception that you can not access its dimension as it is
%% dimensionless.

Remember that \ccStyle{R::RT} and \ccStyle{R::FT} denote a ring type
and a field type. For the representation class
\ccStyle{CGAL_Cartesian<T>} the two types are equivalent. For the
representation class \ccStyle{CGAL_Homogeneous<T>} the ring type is
\ccStyle{R::RT} == \ccStyle{T} and the field type is \ccStyle{R::FT} == 
\ccStyle{CGAL_Quotient<T>}.

\ccCreation
\ccCreationVariable{p}

\ccStyle{#include <CGAL/Point_2.h>}

\ccHidden \ccConstructor{CGAL_Point_2();}
             {introduces an uninitialized variable \ccVar.}

\ccHidden \ccConstructor{CGAL_Point_2(const CGAL_Point_2<R> &q);}
            {copy constructor.}

\ccUnchecked
\ccConstructor{CGAL_Point_2(const R::RT &hx, const R::RT &hy, const R::RT &hw = R::RT(1));}
            {introduces a point \ccVar\ initialized to $(hx/hw,hy/hw)$.
             If the third argument is not explicitely given it defaults
             to \ccStyle{R::RT(1)}.}
\ccDeclaration{CGAL_Point_2(const R::RT &hx, const R::RT &hy, const R::RT &hw);}
\ccDeclaration{CGAL_Point_2(const R::RT &hx, const R::RT &hy);}

\ccOperations
\ccSetTwoOfThreeColumns{5cm}{4cm}

\ccHidden \ccMethod{CGAL_Point_2<R> & operator=(const CGAL_Point_2<R> &q);}
        {Assignment.}

\ccMethod{bool operator==(const CGAL_Point_2<R> &q) const;}
       {Test for equality: Two points are equal, iff their $x$ and $y$ 
        coodinates are equal.}

\ccMethod{bool operator!=(const CGAL_Point_2<R> &q) const;}
       {Test for inequality.}


There are two sets of coordinate access functions, namely to the
homogeneous and to the Cartesian coordinates. They can be used
independently from the chosen representation type \ccStyle{R}.

\ccMethod{R::RT hx() const;}
       {returns the homogeneous $x$ coordinate.}

\ccMethod{R::RT hy() const;}
       {returns the homogeneous $y$ coordinate.}

\ccMethod{R::RT hw() const;}
       {returns the homogenizing  coordinate.}

Here come the Cartesian access functions. Note that you do not loose
information with the homogeneous representation, because then the field
type is a quotient.

\ccMethod{R::FT x() const;}
       {returns the Cartesian $x$ coordinate, that is $hx/hw$.}

\ccMethod{R::FT y() const;}
       {returns the Cartesian $y$ coordinate, that is $hy/hw$.}


The following operations are for convenience and for making this
point class compatible with code for higher dimensional points.
Again they come in a Cartesian and homogeneous flavor.

\ccMethod{R::RT homogeneous(int i) const;}
       {returns the i'th homogeneous coordinate of \ccVar, starting with 0.
        \ccPrecond $0\leq i \leq 2$.}

\ccMethod{R::FT cartesian(int i) const;}
       {returns the i'th Cartesian coordinate of \ccVar, starting with 0.
        \ccPrecond $0\leq i \leq 1$.}

\ccMethod{R::FT operator[](int i) const;}
       {returns \ccStyle{cartesian(i)}.
        \ccPrecond $0\leq i \leq 1$.}

\ccMethod{int dimension() const;}
       {returns the dimension (the constant 2).}

\ccMethod{CGAL_Bbox_2 bbox() const;}
       {returns a bounding box containing \ccVar. Note that bounding boxes
        are not parameterized with whatsoever. }

\ccMethod{CGAL_Point_2<R>  transform(const CGAL_Aff_transformation_2<R> &t) const;}
       {returns the point obtained by applying $t$ on \ccVar.}



The following operations can be applied on points:

\ccFunction{CGAL_Vector_2<R> operator-(const CGAL_Point_2<R> &p,
                                    const CGAL_Point_2<R> &q);}
       {returns the difference vector between \ccStyle{q} and \ccStyle{p}.}

\ccFunction{CGAL_Point_2<R> operator+(const CGAL_Point_2<R> &p,
                                    const CGAL_Vector_2<R> &v);}
       {returns a point obtained by translating \ccStyle{p} by the 
        vector \ccStyle{v}.}

\ccFunction{CGAL_Point_2<R> operator-(const CGAL_Point_2<R> &p,
                                    const CGAL_Vector_2<R> &v);}
       {returns a point obtained by translating \ccStyle{p} by the 
        vector \ccStyle{-v}.}

\ccExample

The following declaration creates two points with Cartesian double coordinates.

\begin{cprog}

  CGAL_Point_2< CGAL_Cartesian<double> > p, q(1.0, 2.0);
\end{cprog} 

The variable {\tt p} is uninitialized and should first be used on 
the left hand side of an assignment. 
\begin{cprog}

  p = q;

  cout << p.x() << "  " << p.y() << endl; 
\end{cprog} 
\end{ccClassTemplate} 

% $Log$
% Revision 1.1  2005/10/06 19:30:21  ameyer
% *** empty log message ***
%
% Revision 1.1.1.1  2001/08/27 17:59:56  spion
% Import from CGAL package
%
% Revision 1.3  1996/07/08 12:19:15  fabri
% *** empty log message ***
%
% Revision 1.2  1996/03/13 15:42:07  fabri
% *** empty log message ***
%
% Revision 1.1  1995/10/19 18:22:12  fabri
% Initial revision
%
