% $Id$

\begin{ccClassTemplate} {CGAL_Line_2<R>}
\ccSection{2D Line}

\ccDefinition
An object \ccStyle{l} of the data type \ccClassName\ is a directed
straight line in the two-dimensional Euclidean plane $\E_2$. It is
defined by the set of points with coordinates $(x,y)$ that satisfy the
equation 
\[ {\mathcal L}:\; a\, x +b\, y +c = 0. \]
 
The line splits $\E_2$ in a {\em positive} and a {\em negative}
side%
.\footnote{See Section~... for the definition of 
\ccStyle{CGAL_Oriented_side}.}
A point $p$ with coordinates $(px, py)$
is on the positive side of \ccStyle{l}, iff
\ccTexHtml{$a\, px + b\, py +c > 0$}{a px + b py + c > 0}, it is
on the negative side of \ccStyle{l}, iff 
\ccTexHtml{$a\, px + b\, py +c < 0$}{a px + b py + c < 0}.

\ccCreation
\ccCreationVariable{l}

\ccStyle{#include <CGAL/Line_2.h>}

\ccHidden \ccConstructor{CGAL_Line_2();}
             {introduces an uninitialized variable \ccVar.}

\ccHidden \ccConstructor{CGAL_Line_2(const CGAL_Line_2<R> &h);}
            {copy constructor.}

\ccConstructor{CGAL_Line_2(const R::RT &a, const R::RT &b, const R::RT &c)}
            {introduces a line \ccVar\ with the line equation $ax +by +c = 0$.}

\ccConstructor{CGAL_Line_2(const CGAL_Point_2<R> &p, const CGAL_Point_2<R> &q);}
            {introduces a line \ccVar\ passing through the points $p$ and $q$. 
             Line \ccVar\ is directed from $p$ to $q$.}

\ccConstructor{CGAL_Line_2(const CGAL_Point_2<R> &p, const CGAL_Direction_2<R>&d)}
            {introduces a line \ccVar\ passing through point $p$ with 
             direction $d$.}

\ccOperations
\ccSetTwoOfThreeColumns{5cm}{4cm}

\ccHidden \ccMethod{CGAL_Line_2<R> & operator=(const CGAL_Line_2<R> &h);}
        {Assignment.}

\ccMethod{bool operator==(const CGAL_Line_2<R> &h) const;}
       {Test for equality: two lines are equal, iff they have a non 
        empty intersection and the same direction.}

\ccMethod{bool operator!=(const CGAL_Line_2<R> &h) const;}
       {Test for inequality.}


\ccMethod{R::RT a() const;}
       {returns the first coefficient of ${\mathcal L}$.}

\ccMethod{R::RT b() const;}
       {returns the second coefficient of ${\mathcal L}$.}

\ccMethod{R::RT c() const;}
       {returns the third coefficient of ${\mathcal L}$.}

\ccMethod{CGAL_Point_2<R> point(int i) const;}
       {returns an arbitrary point on \ccVar. It holds 
        \ccStyle{point(i) == point(j)}, iff \ccStyle{i==j}.
        Furthermore, \ccVar\ is directed from \ccStyle{point(i)}
        to \ccStyle{point(j)}, for all \ccStyle{i} $<$ \ccStyle{j}.}

\ccMethod{CGAL_Direction_2<R> direction() const;}
       {returns the direction of \ccVar.}

\ccMethod{R::FT               x_at_y(const R::FT &y) const;}
       {returns the $x$-coordinate of \ccVar\ at a given $y$-coordinate.
        \ccPrecond \ccVar\ is not horizontal.}

\ccMethod{R::FT               y_at_x(const R::FT &x) const;}
       {returns the $y$-coordinate of \ccVar\ at a given $x$-coordinate.
        \ccPrecond \ccVar\ is not vertical.}

\ccMethod{CGAL_Line_2<R>      perpendicular(const CGAL_Point_2<R> &p) const;}
%       {returns the line perpendicular to \ccVar\ passing through $p$. It is 
%        directed from the intersection point towards $p$.}
        {returns the line perpendicular to \ccVar\ passing through $p$ where the
         direction is the direction of \ccVar\ rotated counterclockwise by
         90 degrees.}

\ccMethod{CGAL_Line_2<R>      opposite() const;}
       {returns the line with opposite direction.}

\ccMethod{CGAL_Point_2<R>    projection(const CGAL_Point_2<R> &p) const;}
       {returns the vertical projection of $p$ on \ccVar.}

\ccMethod{bool is_degenerate() const;}
       {line \ccVar\ is degenerate, if the coefficients \ccStyle{a} and 
        \ccStyle{b} of the line equation are zero.}

\ccMethod{bool is_horizontal() const;}
       {}

\ccMethod{bool is_vertical() const;}
       {}

\ccMethod{CGAL_Oriented_side oriented_side(const CGAL_Point_2<R> &p) const;}
       {returns \ccStyle{CGAL_ON_POSITIVE_SIDE}, 
        \ccStyle{CGAL_ON_ORIENTED_BOUNDARY} or \ccStyle{CGAL_ON_NEGATIVE_SIDE},
        depending where point $p$ is relative to the oriented line \ccVar.
        }


For convenience we provide the following boolean functions:

\ccMethod{bool has_on(const CGAL_Point_2<R> &p) const;}
       {}

\ccMethod{bool has_on_boundary(const CGAL_Point_2<R> &p) const;}
       {returns \ccStyle{has_on()}.}

\ccMethod{bool has_on_positive_side(const CGAL_Point_2<R> &p) const;}
       {}

\ccMethod{bool has_on_negative_side(const CGAL_Point_2<R> &p) const;}
       {}

\ccMethod{CGAL_Line_2<R>  transform(const CGAL_Aff_transformation_2<R> &t) const;}
       {returns the line obtained by applying $t$ on a point on \ccVar\ 
        and the direction of \ccVar.}


\ccImplementation

Lines are implemented as a line equation. You might loose precision,
if you construct them from points or a point and a direction, if the
number type is not exact.

\ccExample
Let us first define two Cartesian two-dimensional points in the Euclidean 
plane $\E_2$. Their
dimension and the fact that they are Cartesian is expressed by
the suffix \ccStyle{_2} and the representation type \ccStyle{CGAL_Cartesian}.

\begin{cprog}

  CGAL_Point_2< CGAL_Cartesian<double> >  p(1.0,1.0), q(4.0,7.0);
\end{cprog} 

To define a line $l$ we write:

\begin{cprog}

  CGAL_Line_2< CGAL_Cartesian<double> > l(p,q);
\end{cprog} 


\end{ccClassTemplate} 

% $Log$
% Revision 1.1  2001/08/27 18:00:36  spion
% Initial revision
%
% Revision 1.2  1996/07/08 12:19:15  fabri
% *** empty log message ***
%
% Revision 1.1  1995/10/19 18:22:12  fabri
% Initial revision
%
