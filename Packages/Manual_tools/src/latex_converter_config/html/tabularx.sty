\newenvironment{tabularx}{\lciTabularxBegin}{\lciTabularxEnd}

\gdef\lcTabularxBorder{1} %% Set this to [1..] to get a table with border [1..]



%% Args: column format string
\newcommand{\lciTabularxBegin}[2]{
  \lcRawHtml{<TABLE WIDTH="}%
  %\lciMultTo{\striptextwidth #1}{100}
  \lciToHtmlWidth{#1}%
  \lcRawHtml{"}%
  \lciIfEqualExpanded{\lcTabularxBorder}{0}%
    {}%
    {\lcRawHtml{ BORDER=}\lcTabularxBorder}%
  \lcRawHtml{>}%
  \newcommand{\lciTabularxColumns}{0}%
  \newcommand{&}{\lciTabularxSkip}%
  \renewcommand{\\}{\lciTabularxNL}%
  \renewcommand{\\*}{\lciTabularxNL}%
  \renewcommand{\\@o}{\lciTabularxNL}%
  \renewcommand{\\*@o}{\lciTabularxNL}%
  \newcommand{\lcTabularxToWrapOrNotToWrap}{}%  
  \newcommand{\lcTabularxToWrapOrNotToWrapOrig}{}%  
  \lciTabularxCountColumns #2\*%  
  \lciReverseStack{\lcTabularxToWrapOrNotToWrap}{\lcTabularxToWrapOrNotToWrapOrig}%
  \lciTabularxContNL
}
%\newcommand{\lciTabularxBegin@om}{\lciTabularxBegin{#2}}

%% Args: a character of the column format string. Parses until \* detected.
\newcommand{\lciTabularxCountColumns}[1]{\lciIfEqual{#C1}{\*}{}{%
    \lciIfEqual{#C1}{l}{\lciAddTo{\lciTabularxColumns}{1}\lciPushStack{\lcTabularxToWrapOrNotToWrap}{\ NOWRAP}} {%
    \lciIfEqual{#C1}{c}{\lciAddTo{\lciTabularxColumns}{1}\lciPushStack{\lcTabularxToWrapOrNotToWrap}{\ NOWRAP}} {%
    \lciIfEqual{#C1}{r}{\lciAddTo{\lciTabularxColumns}{1}\lciPushStack{\lcTabularxToWrapOrNotToWrap}{\ NOWRAP}} {%
    \lciIfEqual{#C1}{X}{\lciAddTo{\lciTabularxColumns}{1}\lciPushStack{\lcTabularxToWrapOrNotToWrap}{}} {%
}}}}\lciTabularxCountColumns}}

%% Args: either \hline, \end, or next character in table entry
\newcommand{\lciTabularxContNL}[1]{\lciIfEqual{#C1}{\hline}{% \hline
        \lciTabularxHline{\lciTabularxColumns}%
    }{\lciIfEqual{#C1}{\end}{% \end{envir}
        \newcommand{\lciNoTabularClosing}{}#1%
    }{% else next character in table entry
        \lcRawHtml{
  <TR>}%
\edef\lcTabularxToWrapOrNotToWrap{\lcTabularxToWrapOrNotToWrapOrig}%
\lciTabularxCont #1}}}

%% Args: either \multicolumn, or next character in table entry
\newcommand{\lciTabularxCont}[1]{%
  \lciIfEqual{#C1}{\multicolumn}%
    {\lciTabularxMulticolumn}%
    {\lcRawHtml{
     <TD ALIGN=LEFT VALIGN=TOP}%
\lciTopStack{\lcTabularxToWrapOrNotToWrap}{\lcTabularxLocalVariable}%
\lciPopStack{\lcTabularxToWrapOrNotToWrap}%
\lcTabularxLocalVariable{}%
\lcRawHtml{>}
#1%
}} % else next character in table entry


%% Args: total number of cols, another \hline, an \end or next char in table
\newcommand{\lciTabularxHline}[2]{%
    \lciIfEqualExpanded{\lcTabularxBorder}{0}{%
        \lcRawHtml{<TR><TD ALIGN=LEFT VALIGN=TOP NOWRAP COLSPAN=#XC1><HR>}%
        %\lcRawHtml{<HR>}%  don't show second <HR>, it looks ugly.
        \lcRawHtml{</TD></TR>}}{}%
    \lciIfEqual{#C2}{\hline}{% \hline omit second \hline, if any.
        \lciTabularxContNL}{\lciTabularxContNL #2}%
}

%% Args: number of cols, column format string, table entry
\newcommand{\lciTabularxMulticolumn}[3]{%
    \lcRawHtml{<TD ALIGN=LEFT VALIGN=TOP NOWRAP COLSPAN=#XC1>
}#3}

\newcommand{\lciTabularxEnd}{\lciIfDefined{\lciNoTabularClosing}{}{\lcRawHtml{
</TD></TR>}}\lcRawHtml{</TABLE>
}%% We rely on the scoping rules of definitions in environments to
  % restore the old definitions of & and \\.
  \gdef\lcTabularxBorder{0}%
}

\newcommand{\lciTabularxNL}{\lcRawHtml{
    </TD></TR>}\lciTabularxContNL}

\newcommand{\lciTabularxSkip}{\lcRawHtml{
        </TD>}\lciTabularxCont}

