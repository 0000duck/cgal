/**************************************************************************
 
  cc_anchor_header
  =============================================================
  Project   : Tools for the CC manual writing task around cc_manual.sty.
  Function  : Annotate in the machine generated HTML documentation from
              cc_extract_html tool all meaningful keywords with the 
              appropriate hyperlinks.
                 This file is the header of a flex program doing this. 
              The flex rules are collected in a file called cc_anchor_rules
              for each run of cc_extract_html tool. The cc_manual_to_html
              script concatenates the cc_anchor_header, the cc_anchor_rules,
              and the cc_anchor_footer to a complete flex program, compiles
              it and applies it to the HTML files.
  System    : flex, cc (gcc)
  Author    : (c) 1997 Lutz Kettner
  Revision  : $Revision$
  Date      : $Date$
 
**************************************************************************/

%{
#include <stdlib.h>
#include <stdio.h>

/* Hack, to get rid of the yywrap. */
#define YY_SKIP_YYWRAP 1
#define yywrap() 1

/* program return code: 0 = o.k., 1 = error, 2 = warning */
int error_code = 0;

/* Is used to count nesting levels during PARAMMODE */
int nesting;

/* Is used to count nesting levels during NOLINKMODE */
int linknesting;

/* find the next occurance of c in s or the '\0' character */
const char* find_char( const char* s, char c) {
    while ( *s && *s != c)
	++s;
    return s;
}

/* reverse find of the prev occurance of c in s or the begining position p */
const char* rfind_char( const char* s, const char* p, char c) {
    while ( s != p && *s != c)
	--s;
    return s;
}

/* print a HTML tag up to and including the '>' */
void print_tag( const char* s) {
    while ( *s && *s != '>') {
	fputc( *s, stdout);
	++s;
    }
    if ( *s)
	fputc( *s, stdout);
}   

/* wraps an anchor around a body. Checks for font changing tags. */
void wrap_anchor( const char* url, const char* body) {
    const char* tag_begin = 0;
    const char* tag_end = 0;
    const char* s = find_char( body, '<');
    if ( *s) {
	++s;
	if ( *s == '/')
	    tag_begin = s + 1;
    }
    s = find_char( body, '\0');
    --s;
    s = rfind_char( s, body, '<');
    if ( *s ==  '<') {
	++s;
	if ( *s != '/')
	    tag_end = s;
    }
    if ( tag_begin) {
	fputs( "</", stdout);
	print_tag( tag_begin);
    }
    fputs( "<A HREF=\"", stdout);
    fputs( url, stdout);
    fputs( "\">", stdout);
    if ( tag_begin) {
	fputc( '<', stdout);
	print_tag( tag_begin);
    }
    fputs( body, stdout);
    if ( tag_end) {
	fputs( "</", stdout);
	print_tag( tag_end);
    }
    fputs( "</A>", stdout);
    if ( tag_end) {
	fputc( '<', stdout);
	print_tag( tag_end);
    }
}

%}

/* One '<' has been detected that starts a template parameter list.  */
/* Scan further until matching '>' has been found.                   */
/* Count nesting parantheses and so forth.                           */
%x PARAMMODE

/* Possibly nested blocks where cross-linking is suppressed. Use     */
/* carefully, since it blocks all kinds of replacements, such as     */
/* links to chapters, citations, references etc.                     */
%x NOLINKMODE

/* Avoid substitutions while within an HTML Tag. */
%x TAGMODE

/* Avoid substitutions while within an HTML Anchor. */
%x ANCHORMODE

/* Avoid substitutions while within a Heading. */
%x HEADINGMODE

letter          [a-zA-Z]
noletter        [^a-zA-Z]
digit           [0-9]
CCletter        [a-zA-Z_]
noCCchar        [^a-zA-Z0-9_]
word            {letter}+
CCidfier        ({CCletter}({CCletter}|{digit})*)
ws              [ \t\n\r]*
par             {ws}("<"[pP]">"{ws})*
glue            {ws}("<"[pP]">"{ws})*"<!GLUE>"{ws}("<"[pP]">"{ws})*
head            "<"[hH][eE][aA][dD]
endhead         "</"[hH][eE][aA][dD]">"
nolinkbegin     "<!NoLinkBegin>"
nolinkend       "<!NoLinkEnd>"
nolinksync      "<!NoLinkSync>"

%%

<PARAMMODE>"&gt;"      {
			   --nesting;
			   if ( ! nesting) {
			       BEGIN( INITIAL);
			       ECHO;
			       fputs( "</A>", stdout);
			   } else
			       yymore();
		       }
<PARAMMODE>"&lt;"      {   ++nesting; yymore(); }
<PARAMMODE>[<(\{\[]    {   ++nesting; yymore(); }
<PARAMMODE>[>)\}\]]    {   --nesting; 
		           if ( nesting < 1) {
			       fputs( "\nwarning: mismatching <>(){}[] in template parameters : `", stderr);
			       fputs( yytext, stderr);
			       fputs( "'\n", stderr);
                               if ( error_code == 0)
                                   error_code = 2;
			       BEGIN( INITIAL);
			       ECHO;
			       fputs( "</A>", stdout);
                           } else
			       yymore();
                       }
<PARAMMODE>.           {   yymore(); }

{nolinkbegin}                  { BEGIN( NOLINKMODE); linknesting = 1; }
{nolinkend}                    { fputs( "\nERROR: Found \\lcNoLinkEnd without a matching \\lcNoLinkBegin.\n", stderr); error_code = 1; }
{nolinksync}                   { ;}
<NOLINKMODE>{nolinkbegin}      { ++linknesting; }
<NOLINKMODE>{nolinkend}        { --linknesting;
                                 if ( ! linknesting) BEGIN( INITIAL);
                               }
<NOLINKMODE>{nolinksync}       { fputs( "\nERROR: \\lcNoLinkSync used in \\lcNoLinkBegin/End block, which indicates missing or runaway \\lcNoLinkEnd.\n", stderr); 
                                 linknesting = 0;
                                 BEGIN( INITIAL);
                                 error_code = 1;
}

<NOLINKMODE>.                  { ECHO;}

{head}(.|[\n])*{endhead}       { ECHO; /* Avoid substitutions in the head */ }

"<"[aA][^0-9a-zA-Z]            { BEGIN( ANCHORMODE); ECHO;}
<ANCHORMODE>"</"[aA]">"        { BEGIN( INITIAL); ECHO;}
<ANCHORMODE>.                  { ECHO;}

"<"[hH][1-6]                   { BEGIN( HEADINGMODE); ECHO;}
<HEADINGMODE>"</"[hH][1-6]">"  { BEGIN( INITIAL); ECHO;}
<HEADINGMODE>.                 { ECHO;}

"<"                            { BEGIN( TAGMODE); ECHO;}
<TAGMODE>">"                   { BEGIN( INITIAL); ECHO;}
<TAGMODE>.                     { ECHO;}


