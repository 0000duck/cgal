% ----------------------------------------------------------------------
% Test document for the CGAL manual LaTeX style:
% 
% 16.08.1995   Lutz Kettner
%
% $Revision$
% $Date$
% ----------------------------------------------------------------------
% The style is compatible with LaTeX2e:
\documentclass[12pt]{article}
\usepackage{latexsym}
\usepackage{amssymb}

% LaTeX:
% \documentstyle[12pt]{article}

%\pagestyle{empty}
\textwidth 15.4cm 
\textheight 24 cm
\topmargin -14mm       
\evensidemargin 3mm 
\oddsidemargin 3mm

\input{cc_manual.sty}

\parindent0em
\setlength{\parskip}{1ex minus 0.9ex}

\sloppy

\title {Test Suite for the cc\_manual.sty\\
        \vspace{5mm}
        \ccRevision}
\author{Lutz Kettner}

\date{\ccDate}

\begin{document}

\maketitle

% ----------------------------------------------------------------------
\section{Introduction}

This document was formerly the reference manual. It has changed now to
a test document. A new reference manual exists which is better
organized.  The remaining part of this document will have rather
arbitrary structure and mostly no explanations whats going on. There
will be no efforts in proof reading or cleaning up this document,
excuse me. The sole purpose of this document is testing of the
possibilities of this style.

If the programming turns out to be too slow, I am not a \TeX\ wizard,
maybe someone can do it better or it can be even switched to an
external tool.

% ----------------------------------------------------------------------
\section{Structuring Macros}

\ccDefinition Here comes the general introductory explanation for a
class etc.

\ccPrecond Specific conditions can be stated as preconditions in any place.

\ccCreation Constructors are defined and explained here.

\ccOperations The complete list of methods and functions (including
operators) are defined here.

\ccImplementation Specific notes about implementation issues that belong
to the user can be given here. These might be space requirements and
runtime statements.

\ccExample How to solve a small but interesting problem with this class.


% ----------------------------------------------------------------------
\begin{ccClass}{Demo_Class}
\ccSection{A Simple Class}

The class with its name is declared by 
\verb"\b"\verb"egin{class}{Demo_Class}". 
For class templates the \verb"\b"\verb"egin{classtemplate}{Demo_Class<...>}"
environment is  designed. See the next section for an example.
The macro \verb"\"\verb"CCsection{"\ldots\verb"}" produces the section
title from above and appends the class name. Note that the special
character ``\_'' has not to be quoted as it is usual within \LaTeX.
In any case, the complete original \CC\ source text is written
without quoting. The formatting macros handle for example the special
characters \_, {\tt <}, {\tt >}, and {\tt \&} as they appear in \CC\
names and the characters \#, \%, \ccHat, and \ccTilde\ as they appear
with operators. See the following example: 
\ccStyle{
    #define %^~ Return_Type<Template_Param, X<Y> > fct_foo( const X<Y> &a);}

This example is created using the {\verb+\CC+}{\tt style} macro
that formats its single parameter in this style.

To achieve this behavior with \TeX\, the \verb"\catcode" values of
some characters has to be changed. So within the \CC\ code 
things like comments with ``\%'' sign will not work. Several macros read a
second parameter with a \TeX\ comment to the declaration. The catcodes
are restored just before this second parameter. A sad sideeffect is
that these changed catcodes will not apply if these macros are invoked
within other macros. In that case, the argument text was just once
parsed from \TeX\ and the catcodes are all fixed before the catcode
changing macro expands.

\ccDefinition 

The class \ccClassName\ does nothing. The formatted name of the class
can be accessed using the macro \verb"\"\verb"classname". The unformatted
name as it was originally written can be accessed using the
\verb"\"\verb"pureclassname" macro.

\ccCreationVariable{p}
\ccCreation

The constructors create a variable \ccVar\ of the class. The
\verb"\"\verb"creationvariable{"\ldots\verb"}" macro sets the name for the
future use. It can be accessed with the \verb"\"\verb"var" or
\verb"\"\verb"purevar" macro.

The constructors are written using the
\verb"\"\verb"constructor{"\ldots\verb"}{"\ldots\verb"}" macro. The first
parameter contains the \CC\ declaration, the second parameter the comments.
The declaration is written in the normal \CC\ fashion, as shown at the end
of the comment. The style formats them as if they are used
to declare a variable for this class. For convinience,
\verb"const"\ldots\verb"&" parameter declarations are eliminated in the
formatting. It makes no difference in the usage of a parameter. If the
type of a constructor, method, or function parameter equals the
current class, it is also omitted. In the case that nothing is left,
the \ccEmptyParameter\ symbol is used. See the copy constructor for an
example. All together we achieve this natural looking descriptions.

\ccStyle{#include< demo_class.h>}

  \ccConstructor{Demo_Class();}{introduces
     a variable \ccVar\ initialized to the default. \CC\ code:
     {\tt Demo\_Class();}. Test CCstyle: \ccStyle{Underscore\_within
     CCstyle}.}

  \ccConstructor{Demo_Class( const Demo_Class &);}{copy
    constructor. \CC\ code: {\tt Demo\_Class(const Demo\_Class \&);}}

  \ccConstructor{Demo_Class( RT hx, RT hy, RT hw);}{arbitrary constructor.
     \CC\ code: {\tt Demo\_Class(RT hx, RT hy, RT hw);}}

The font and style in which the declarations are formatted can be
changed by overwriting the \verb"\ccFont" and \verb"\ccEndFont"
macros. Their default settings are
\verb"\gdef\ccFont{\it}\gdef\ccEndFont{\/}". They are used within a
group, so font changing commands are local. The rest of this document is
formatted using the definitions \verb"\gdef\ccFont{\tt}\gdef\ccEndFont{}".

\gdef\ccFont{\tt}\gdef\ccEndFont{}
  \ccConstructor{Demo_Class( int a, X<Y> &x);}{arbitrary constructor.}

\gdef\ccFont{\it}\gdef\ccEndFont{\/}

Also changable are the special characters the formatting has to
deal with. They are named \verb"\ccUnderscore", \verb"\ccOpenAngle",
\verb"\ccCloseAngle", \verb"\ccAmpersand", \verb"\ccHat", and
\verb"\ccTilde". The symbol for the empty parameter is named
\verb"\ccEmptyParameter".

  \ccOperations
  \ccSetTwoOfThreeColumns{2.8cm}{2.8cm}

The layout of this section can be customized to the width of the
return types and the declarations. The
\verb"\"\verb"threecolumns{"\ldots\verb"}{"\ldots\verb"}" macro sets the
width of the two leading columns of the total three columns. All other
dimensions will be computed.

Note that declarations after the closing parenthesis like {\tt const}
for the implicit class parameter of a method will not be printed
(this might change in the future).
The return value is handled like a parameter type. That means that
{\tt const\ldots\&} declarations are removed, but if the type equals
to the class, it is {\em not} removed.

  \ccMethod{FT   x()  const;}{Cartesian x-coordinate. \CC\ code: {\tt
      FT x() const;}}

  \ccMethod{const FT&   y();}{Cartesian y-coordinate. \CC\ code: {\tt
      const FT\& y();}}

  \ccMethod{Demo_Class   
             transform( const CGAL_HAff_transformation<FT,RT> &t) const;
             }{ Longish declarations forces the comment to start in
             the next line.}

  \ccMethod{Demo_Class   
             longish_function_name( 
                        const CGAL_Aff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name_For_Fun Variable_Also_Long) const;
             }{ Even more longish declarations forces the parameters printed
             one per line. This was the default formatting.}


Reference or pointer parameters can occur on both sides of the
separating space between the return type and the function or method
name. The formatting normalizes them to the left side. This
formatting is not done within the parameters (, but maybe in the
future). An example: 

    \ccFunction{Demo_Class& foo( int& a, int* b);}{}

    \ccFunction{Demo_Class* foo( int& a, int* b);}{}

    \ccFunction{Demo_Class &foo( int &a, int *b);}{}

    \ccFunction{Demo_Class *foo( int &a, int *b);}{}

Operator declarations are formatted as like the operators are
used.  All operators that are allowed to be overloaded in \CC\ are
handled. They are listed in the last section for completeness and
to check the layout. 

Type casting through a conversion operator is the default behavior 
for the formatting routine if the return type before the {\tt 
operator} keyword is empty.

  \ccFunction{ operator int () const;}{Conversion operator.}

  \ccFunction{operator A< FT>() const;}{Conversion operator.}

Sometimes, there is a choice between
implementing an operator as a method or as a function. Both
declarations will produce the same formatting, as demonstrated
with the next two declarations.

  \ccFunction{Demo_Class
        operator+(Demo_Class p, Demo_Class q);}{Declaration via function.}

  \ccMethod{Demo_Class
        operator+(Demo_Class q);}{Declaration via method.}

One can locally activate that the operator declaration is shown as it
is written without operator formatting, {\tt const ...\&}, classname, or
trailing const declarations for methods removal. This can be done with
\verb+\+\verb+ccTagFullDeclarations+ within a scope of braces {\tt
  \{...\}}.

{\ccTagFullDeclarations
  \ccMethod{Demo_Class
        operator+(const Demo_Class& q) const;}{Declaration via method.}
}

There is some laziness allowed in placing spaces around the operator
characters. See the following examples:

\ccMethod{A
    operator+(Demo_Class q);}{\CC\ code: {\tt A operator+(Demo\_Class q);}}

\ccMethod{A
    operator +(Demo_Class q);}{\CC\ code: {\tt A operator +(Demo\_Class q);}}

\ccMethod{A
    operator+ (Demo_Class q);}{\CC\ code: {\tt A operator+ (Demo\_Class q);}}

\ccMethod{A
    operator + (Demo_Class q);}{\CC\ code: {\tt A operator + (Demo\_Class q);}}

The keyword {\tt operator} is reserved, but it can appear as a
substring in another name. See the following examples that this
style can handle such cases:

\ccMethod{A foo_operator(Demo_Class q);}{}

\ccMethod{A noperator(Demo_Class q);}{}

\ccMethod{A operatoro(Demo_Class q);}{}

\ccMethod{A operator_(Demo_Class q);}{}

\ccMethod{A operator0(Demo_Class q);}{}

CGAL will use {\tt typedef}'s and the scope operator to define types.
Here is an example for the scope operator within types.  The scope
operator cannot be used within the function or method name.

  \ccSetTwoOfThreeColumns{5.8cm}{1.8cm}
  \ccFunction{Rep_Class::Nested_Class
        foo(Rep_Class::Nested_Class p, Demo_Class q);}{
         Declaration with scope.}

  \ccFunction{Rep_Class :: Nested_Class
        foo(Rep_Class :: Nested_Class p, Demo_Class q);}{
         The same, surrounded by spaces.}

\end{ccClass}


% ----------------------------------------------------------------------
\begin{ccClassTemplate}{Demo_Class<FT<RT> >}
\ccSection{Demo Class Template}

This class template is given within a
\verb"\be"\verb"gin{classtemplate}{Demo_Class<FT<RT> >}" environment.

\ccCreationVariable{p}
\ccCreation

A current misbehaviour (or feature?) of the structuring macros is that
they have fixed numbers. So the \verb"\"\verb"definition" macro is here
missing.

  \ccConstructor{ Demo_Class();}{ default.}

  \ccConstructor{ Demo_Class( Demo_Class<FT<RT> > q);}{ copy.}

  \ccConstructor{ Demo_Class( A a, B *b);}{ arbitrary.}

\ccOperations
\ccSetTwoOfThreeColumns{4.3cm}{2.3cm}

  \ccMethod{ Demo_Class foo( Demo_Class q);}{
      wrong, without template parameters.}

  \ccFunction{ Demo_Class<FT<RT> > foo( Demo_Class<FT<RT> > q);}{
      right, with template parameters.}

Another example demonstrating a const pointer declaration of a 
class template.

    \ccFunction{Demo_Class& foo( const Class< int>* b);}{}

    \ccFunction{Demo_Class& foo( const Demo_Class< int>* b);}{}

\end{ccClassTemplate}

% ----------------------------------------------------------------------
\section{New Features Introduced with Version 1.8}

\begin{ccClass}{Demo_Class}

A small set of handy abbreviations are added. Here they are all together:

\begin{tabbing}
  dum \= dummyyyyyyyy \= \kill
  \> \verb+\CC+         \> \CC         \\
  \> \verb+\gcc+        \> \gcc        \\
  \> \verb+\nat+        \> \nat        \\
  \> \verb+\real+       \> \real       \\
%  \> \verb+\boxit{A}+   \> \boxit{A}   \\
  \> \verb+\leda+       \> \leda       \\
  \> \verb+\cgal+       \> \cgal       \\
  \> \verb+\protocgal+  \> \protocgal  \\
  \> \verb+\plageo+     \> \plageo  
\end{tabbing}

\def\ccAlternateThreeColumn{\ccTrue}
\ccCreationVariable{p}
\ccSetTwoOfThreeColumns{2.8cm}{2.8cm}

  \ccConstructor{Demo_Class( Paramter1 hx, 
                           Paramter2 hy, 
                           Paramter3 hw, 
                           Paramter4 hw, 
                           Paramter5 hw);}{
     Longish parameter lists will be broken into several lines.
     Therefore, the parameter {\tt $\backslash$CCalternateThreeColumn} was 
     set to {\tt $\backslash$CCtrue}.}

\def\ccAlternateThreeColumn{\ccTrue}

  \ccMethod{Demo_Class   
             longish_naming( 
                        const DGAL_HAff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name Variable_Also_Long) const;
             }{ Here, the alternative formatting was again switched on
                by setting the parameter {\tt 
                $\backslash$CCalternateThreeColumn} to {\tt 
                $\backslash$CCtrue}.}

  \ccMethod{Even_a_long_return_value
             longish_naming( 
                        const DGAL_HAff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name Variable_Also_Long) const;
             }{ Now, a long return value forces the function to start 
                in the next line.}

\def\ccAlternateThreeColumn{\ccFalse}

Function templates are written with the macro \verb+\fu+\verb+nctiontemplate+
that has an additional parameter in front for the template
parameters. They are visible in the manual because the user does not
see them, but the parameters are necessary for the specification
checking tool.

\ccSetTwoOfThreeColumns{2.8cm}{8.7cm}

\ccFunctionTemplate{R}{bool CGAL_is_intersecting( Point< R>, Point<
  R>);}{comment.}

Enum's are formatted similiar to constructors. Exactly one pair of
matching braces has to be in the declaration.

\ccEnum{enum Short { A, B, C};}{ Comment.}

\ccEnum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}{ Comment.}

We can even switch the alternative layout on:

\gdef\ccAlternateThreeColumn{\ccTrue}

\ccEnum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}{ Comment.}

\ccSetTwoOfThreeColumns{3.5cm}{3.5cm}

\ccVariable{long int foo;}{Local variables are possible.}

\ccVariable{long int foo = 15;}{Initialisation.}

\ccVariable{const long int foo = 15;}{Make a constant.}

\ccTypedef{typedef int integer;}{Simple typedef.}

\ccTypedef{typedef List< int>  Integer_list;}{Typedef including template
    parameters.}


\end{ccClass}

Global functions and other global declarations can be written with the 
normal macros that are used within class declarations. For convenience, 
a set of {\em global\/} macros are provided that omit the last comment
parameter. Global declarations are usually commented in the lines
inbetween. So here comes a global function:

\ccGlobalFunction{CGAL_intersection_type CGAL_Intersection_type(
      Polygon_2< R>, Polygon_2< R>);}The same 
as a function template:

\ccGlobalFunctionTemplate{R}{CGAL_intersection_type CGAL_Intersection_type(
      Polygon_2< R>, Polygon_2< R>);}A global enum.

\ccGlobalEnum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}

\ccGlobalVariable{int CGAL_global;}Thats it.



% ----------------------------------------------------------------------
\section{New Features Introduced with Version 1.9}

\begin{ccClass}{Demo_Class}

A set of handy abbreviations has been extended. They need the package
{\tt amssymb} and \LaTeXe.

\begin{tabbing}
  dum \= dummyyyyyyyy \= \kill
  \> \verb+\+\verb+N+        \> \N        \\
  \> \verb+\+\verb+Z+        \> \Z        \\
  \> \verb+\+\verb+R+        \> \R        \\
  \> \verb+\+\verb+E+        \> \E
\end{tabbing}

A \verb+\de+\verb+claration+ accepts one parameter. The style will
ignore it, while the checker tests if it exists one to one in the C++
code.  It is intended for declarations that are somehow implied by the
surrounded text, but should not be explicitly visible. For example,
this example is not visible (smile).

\ccDeclaration{Some arbitary funny *%&_ looking # C++ code declaration()...}

A \verb+\+verb+hidden+ macro can be prepended to each macro with two
parameters.  It will remove the macro and its parameters from the
manual.  Again, the checker tests the macro as usual. Again an
invisible example.

\ccHidden\ccFunction{int foo( double d);}{This is a foo function.}

If these non visible parts of the code should be made visible once,
the \verb+\+\verb+CCmakeAllVisible+ macro switches it on. For
\verb+\+verb+declaration+ the \verb+\+verb+CCstyle+ macro is used. The
\verb+\+verb+hidden+ macro vanishes simply.  The two funny invisible
examples from above are repeated here.

\ccMakeAllVisible

\ccDeclaration{Some arbitary funny *%&_ looking # C++ code declaration()...}

\ccHidden\ccFunction{int foo( double d);}{This is a foo function
    previously hidden.}

The following example demonstrates the new ability to write default
parameters with initializers in parantheses notion of \CC.
\end{ccClass}

\begin{ccClassTemplate}{CGAL_Point_2< R>}
\ccConstructor{CGAL_Point_2(const R::RT &x, const R::RT &y, const R::RT &w = R::RT(1.0));}{blabla}
\end{ccClassTemplate}

A problem has occured in detecting the operator keyword if it was
directly preceded by an {\tt \&} or {\tt *} character. It is fixed as
the following example demonstrates:

\ccFunction{Int &operator+=( Int a, Int b);}{}

%\begin{ccClass}{Demo_class}
% \ccCreationVariable{demo_var}%
%
% \ccConstructor{Demo_class();}{Default constructor creating variable \ccVar.}
%
% \end{ccClass}

The \verb+\+verb+CCstyle+ macro is not appropriate to format multiple lines
of \CC\ code. Use other environments like the {\tt cprog} style.


% ----------------------------------------------------------------------
\section{New Features Introduced with Version 1.13}

A tool called {\tt cgal\_extract\_html} is able to convert the \cgal\
Kernel Manual in a semi automatic fashion to a fully hyperlinked
manual in HTML. A couple of new macros are provided to support these
cases where the automatic coonversion fails, i.e. tables and complex
mathematical formulas are not handled automatically.

Two environments are provided that encapsulates either \TeX\ or HTML
code. These are 

\begin{itemize}
    \item
        \verb+\begin{ccTexOnly} ... \end{ccTexOnly}+ for parts only valid
        in \TeX.
    \item
        \verb+\begin{ccHtmlOnly} ... \end{ccHtmlOnly}+ for parts only valid
        in the HTML manual. Note that this environment modifies the 
        catcodes of a couple of characters. So, do not use this
        environment within a parameter of another \TeX\ macro. On the
        other hand, this allows the use of {\em unmatched} parantheses
        and {\em unknown} macros within the HTML text, the special
        characters are meaningless for \TeX.
\end{itemize}

\TeX\ and HTML code can be written together within one macro.

\begin{itemize}
    \item
        \verb+\ccTexHtml{ TeX code ... }{ HTML code ...}+
\end{itemize}

For convinience a solution is provided that easily includes
hyperlinks with URL's in the \TeX\ source. This macro translates to a
fully HTML anchor with the given URL around the \TeX\ source after the
\TeX\ source has been converted.

\begin{itemize}
    \item
        \verb+\ccAnchor{ URL }{ TeX code ... }+
\end{itemize}

%----------------------------------------------------------------------
\ccTagDefaults
\begin{ccClass}{Demo_Class}
\section{The List of All Operators}

  \ccFunction{Ptr_Class
        operator->(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator[](Demo_Class p, int i);}{}

  \ccFunction{Demo_Class
        operator()(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator()(Demo_Class p, int i);}{}

  \ccFunction{Demo_Class
        operator()(Demo_Class p, int i, int j);}{}

  \ccFunction{Demo_Class
        operator()(Demo_Class p, int i, int j, int k);}{}

  \ccFunction{Demo_Class
        operator()(Demo_Class p,
                   const A& a, B& b, C c, const D& d, Demo_Class
                   e);}{all number and types of parameters are possible.}

  \ccFunction{Demo_Class
        operator++(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator++(Demo_Class p, int);}{The postfix incr.\ operator
        has a hidden {\tt int} parameter that the formatting does not show.}

  \ccFunction{Demo_Class
        operator--(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator--(Demo_Class p, int);}{}

  \ccFunction{Demo_Class
        operator~(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator!(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator-(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator+(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator&(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator*(Demo_Class p);}{}

  \ccMethod{ void*
        operator new( size_t);}{Hidden parameters are not shown. \CC\ code: 
        $\backslash${\tt method\{ void* operator new( size\_t);\}}.}

  \ccMethod{ void
        operator delete( void*, size_t);}{Hidden parameters are not shown.
        \CC\ code: $\backslash${\tt method\{ void operator 
            delete( void*, size\_t);\}}}

  \ccMethod{ void
        operator delete[]( void*, size_t);}{Hidden parameters are not
        shown again. 
        \CC\ code: $\backslash${\tt method\{ void operator
            delete[]( void*, size\_t);\}}}

  \ccFunction{Member_Ptr
        operator->*(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator*(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator/(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator%(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator+(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator-(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator<<(Demo_Class p, int i);}{}

  \ccFunction{Demo_Class
        operator>>(Demo_Class p, int i);}{}

  \ccFunction{Demo_Class
        operator<(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator<=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator>(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator>=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator==(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator!=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator&(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator^(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator|(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator&&(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator||(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator*=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator/=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator%=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator+=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator-=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator<<=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator>>=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator&=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator|=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator^=(Demo_Class p, Demo_Class q);}{}

\end{ccClass}

% ----------------------------------------------------------------------
\section{Test Indentation and Alternate Formatting}

This example tests the indentation and right margin setting
possibilities. Two long declarations with alternative formatting rules
for the function arguments are used. First the  declaration without
any indentation or margins.

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the default formatting. A bit more text is necessary to
  demonstrate the right margin.}

Now with 10mm indentation and 10mm right margin. Note that the
description is also further indented since all dimensions are
calculated from left.

\ccTagDefaults
\def\ind{\hspace*{7mm}}
\ccwIndent=10mm
\ccwRightMargin=10mm

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the default formatting. A bit more text is necessary to
  demonstrate the right margin.}
\renewcommand{\ccLongParamLayout}{\ccTrue}

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the alternative formatting. A bit more text is necessary to
  demonstrate the right margin.}

Show the indentation also for template functions.

\ccFunction{template<class A> int bar(A a);}{A bit more text to
  demonstrate the right margin.}

\renewcommand{\ccLongParamLayout}{\ccFalse}

Check the same alternate indentation with the compatibility mode 
\verb+\renewcommand{\ccAlternateThreeColumn}{\ccFalse}+

\renewcommand{\ccAlternateThreeColumn}{\ccFalse}

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the alternative formatting. A bit more text is necessary to
  demonstrate the right margin.}

Show the indentation also for template functions.

\ccFunction{template<class A> int bar(A a);}{A bit more text to
  demonstrate the right margin.}

\renewcommand{\ccAlternateThreeColumn}{\ccTrue}
\ccwIndent=0mm
\ccwRightMargin=0mm

% ----------------------------------------------------------------------
\section{Test the Setting of the Column Widths by Example Texts}


\ccSetThreeColumns{int}{foo( int i, int j);}{}
\ccFunction{int foo( int i, int j);}{returns gnats$(i,j)$.}

\ccSetThreeColumns{int}{}{returns gnats$(i,j)$.}
\ccFunction{int foo( int i, int j);}{returns gnats$(i,j)$.}

\ccSetThreeColumns{}{foo( int i, int j);}{returns gnats$(i,j)$.}
\ccFunction{int foo( int i, int j);}{returns gnats$(i,j)$.}

Test it with the special characters (changed catcodes) for function
and contructor declarations.  


\ccSetThreeColumns{%#_^}{%#_^f*&*&oo( int i);}{}
\ccSetTwoColumns{%#_^ foo( int i, int j);}{}
\begin{ccClass}{Gnu}
  \ccCreationVariable{g}
  \ccConstructor{Gnu( double d);}{test.}
  \ccFunction{int foo( Gnats<T> gn);}{blablabla.}
\end{ccClass}

Specify a column layout for a function and propagate it to a contructor.

\ccSetThreeColumns{intM}{foo( Gnats<T> gn);M}{}
\ccPropagateThreeToTwoColumns
\begin{ccClass}{Gnu}
  \ccCreationVariable{g}
  \ccConstructor{Gnu( double d);}{test.}
  \ccFunction{int foo( Gnats<T> gn);}{blablabla.}
\end{ccClass}


% ----------------------------------------------------------------------
\section{Check Long Constructor Calls}

\begin{ccClassTemplate}{CBP_Bidirectional_circulator< C, C*
   (C::*next)(), C* (C::*previous)()>} 
\ccCreationVariable{circ}
\ccSetTwoColumns{}{a const circulator \ccVar\ with singular value.}

NOTHING is interesting here.


\ccConstructor{CBP_Bidirectional_circulator();}{%
 a const circulator \ccVar\ with singular value.}

\ccConstructor{CBP_Bidirectional_circulator( const C* ptr);}{a
  const circulator \ccVar\ initialized to point to the element \ccStyle{*ptr}.} 
\end{ccClassTemplate}

% ----------------------------------------------------------------------
\section{Glueing Declarations Together}

\ccFunction{int foo( double x);}{}
\ccGlueDeclarations
\ccFunction{int bar( double x);}{}

\ccFunction{int foo( double x);}{Bla.}
\ccGlueDeclarations
\ccFunction{int bar( double x);}{Blubb blubb.}

\ccFunction{int foo_baaaaaaaarrrr( double x);}{%
     Bla bal blabal blabal blabal blab.}
\ccGlueDeclarations
\ccFunction{int barfoooooooooooooooooo( double x);}{%
    Blubb blubblubb blubblubb blubblubb blubb.}


% ----------------------------------------------------------------------
\section{Nested Classes}

First try, use the scope operator in the class name.

\begin{ccClass}{Base::Derived}
\ccCreationVariable{a}

\ccConstructor{Base::Derived( double x);}{a constructor.}
\ccFunction{Base::Derived foo( Base::Derived b);}{a function.}
\end{ccClass}

% ----------------------------------------------------------------------
\section{Prefix Substitution}

The example illustrates both typical usages (with a fantasy function
that does not exist in \cgal).

\ccSetThreeColumns{CGAL_Point<R>}{CGAL_f( CGAL_Vector<R> v)}{}

\ccStyle{#include <CGAL/point.h>}
\\
\ccFunction{CGAL_Point<R> CGAL_f( CGAL_Vector<R> v);}{%
    the original \cgal\ prefix.}
\vspace{-\parskip}

\begin{tabbing}
  CCimplementationNNNMMMMMMMMMMMMMMMMMMMM \= ImplementationMMMMM \= \kill
  \verb+\def\ccTargetPrefix{}+ \\
  \verb+\renewcommand{\ccTagReplacePrefix}{\ccTrue}+
\end{tabbing}
\def\ccTargetPrefix{}
\renewcommand{\ccTagReplacePrefix}{\ccTrue}
\vspace{-\parskip}

\ccStyle{#include <CGAL/point.h>}
\\
\ccFunction{CGAL_Point<R> CGAL_f( CGAL_Vector<R> v);}{%
    assuming name spaces. {\tt ;-)}}
\vspace{-\parskip}

\begin{tabbing}
  CCimplementationNNNMMMMMMMMMMMMMMMMMMMM \= ImplementationMMMMM \= \kill
  \verb+\def\ccTargetPrefix{GTE}+ \\
  \verb+\renewcommand{\ccTagReplaceInclude}{\ccTrue}+
\end{tabbing}
\def\ccTargetPrefix{GTE}
\renewcommand{\ccTagReplaceInclude}{\ccTrue}
\vspace{-\parskip}

\ccStyle{#include <CGAL/point.h>}
\\
\ccFunction{CGAL_Point<R> CGAL_f( CGAL_Vector<R> v);}{%
    make a Porsche from this declaration.}
\vspace{-\parskip}

\begin{tabbing}
  CCimplementationNNNMMMMMMMMMMMMMMMMMMMM \= ImplementationMMMMM \= \kill
  \verb+\renewcommand{\ccTagReplacePrefix}{\ccFalse}+ \\
  \verb+\renewcommand{\ccTagReplaceInclude}{\ccFalse}+
\end{tabbing}
\renewcommand{\ccTagReplacePrefix}{\ccFalse}
\renewcommand{\ccTagReplaceInclude}{\ccFalse}

% ----------------------------------------------------------------------
\section{A Constructor for a Nested Class}

The method how it should work:

\begin{ccClass}{CGAL_SegmentTree_2d<T1>::SegTree}
\ccCreationVariable{t}
\ccConstructor{CGAL_SegmentTree_2d<T1>::SegTree
(S2dList::const_iterator first);}{constructor.}

\ccMemberFunction{CGAL_SegmentTree_2d<T1>::SegTree
    foo (CGAL_SegmentTree_2d<T1>::SegTree same);}{%
    removal of own type in parameterlist of a member function.} 
\end{ccClass}


The hack I have recommended previously.

\ccFunction{CGAL_SegmentTree_2d<T1>::SegTree
t(S2dList::const_iterator first);}{fake constructor.}

Another check with the trouble making operator in a member function.

\begin{ccClass}{Demo_Class}
\ccCreationVariable{pp}
  \ccMethod{Demo_Class operator+(Demo_Class qq);}{%
      Declaration of an operator as a member function.}
\end{ccClass}



% ----------------------------------------------------------------------
\section{Font Changes within a Declaration}

\ccVariable{\tt k-th\ccFont -dim \tt k-th\ccFont -foo;}{%
    a {\tt k-th}-dimensional variable.}

% ----------------------------------------------------------------------
\begin{ccClass}{Demo_Class}
\section{Customization Tags for the Style}

First, a  declaration  with all default substitution rule active.

\ccCreationVariable{pp}

\ccMemberFunction{Demo_Class operator+(const Demo_Class& qq) const;}{%
      member function.}

Second, all rules switched off.
\ccTagFullDeclarations

\ccMemberFunction{Demo_Class operator+(const Demo_Class& qq) const;}{%
      member function.}

Third, back to the default.
\ccTagDefaults

\ccMemberFunction{Demo_Class operator+(const Demo_Class& qq) const;}{%
      member function.}

\end{ccClass}




\end{document}

% EOF %




