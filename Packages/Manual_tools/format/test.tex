% ----------------------------------------------------------------------
% Documentation for the CGAL manual LaTeX style:
% 
% 16.08.1995   Lutz Kettner
% ----------------------------------------------------------------------
% The style is compatible with LaTeX2e, try:
\documentclass[12pt]{article}
\usepackage{latexsym}
\usepackage{amssymb}

% LaTeX:
% \documentstyle[12pt]{article}

%\pagestyle{empty}
\textwidth 15.4cm 
\textheight 24 cm
\topmargin -14mm       
\evensidemargin 3mm 
\oddsidemargin 3mm

\input{cgal_manual.sty}

\parindent0em
\setlength{\parskip}{1ex minus 0.9ex}

\sloppy

\title {cgal\_manual.sty\\
        The CGAL Kernel User Manual \LaTeX\ style\\
        \vspace{5mm}
        \CCrevision}
\author{Lutz Kettner}

\date{\CCdate}

\begin{document}

\maketitle

% ----------------------------------------------------------------------
\section{Introduction}

The {\tt cgal\_manual}-style was developed with a tight look at the
LEDA manual style. It has two facilities. First, it provides a couple
of macros for structuring the manual as the LEDA manual does. These
are {\tt \string\definition}, {\tt \string\creation}, {\tt
  \string\operations}, {\tt \string\implementation}, {\tt
  \string\example}, and {\tt \string\precond}. There are demonstrated
in the next section.

The second facility of this style deals with the special handling of
\CC\ language features. The style will be used in conjunction with a
tool that extracts a class declaration with all its method and
function declarations and plugs it in a \CC\ header file. Therefore,
pure \CC\ code will stay in several arguments and has to be
reformatted neatly for the manual. Again, the LEDA manual was the
ideal we want to meet. In our case, \TeX\ will do the complete
reformatting as it is written as macros in the style. Another
section below explains all features. Demo classes with and without
template parameters are defined.

The benefit of using \TeX\ is that no other tool has to be invoked
before the final specification is printer ready. Thus, no inconsistent
versions can appear as it is the case e.g.\ for index making
procedures for \TeX. If the programming turns out to be too slow, I am
not a \TeX\ wizard, maybe someone can do it better or it can be even
switched to an external tool.

% ----------------------------------------------------------------------
\section{Structuring Macros}

\definition Here comes the general introductory explanation for a
class etc.

\precond Specific conditions can be stated as preconditions in any place.

\creation Constructors are defined and explained here.

\operations The complete list of methods and functions (including
operators) are defined here.

\implementation Specific notes about implementation issues that belong
to the user can be given here. These might be space requirements and
runtime statements.

\example How to solve a small but interesting problem with this class.


% ----------------------------------------------------------------------
\begin{class}{Demo_Class}
\CCsection{A Simple Class}

The class with its name is declared by 
\verb"\b"\verb"egin{class}{Demo_Class}". 
For class templates the \verb"\b"\verb"egin{classtemplate}{Demo_Class<...>}"
environment is  designed. See the next section for an example.
The macro \verb"\"\verb"CCsection{"\ldots\verb"}" produces the section
title from above and appends the class name. Note that the special
character ``\_'' has not to be quoted as it is usual within \LaTeX.
In any case, the complete original \CC\ source text is written
without quoting. The formatting macros handle for example the special
characters \_, {\tt <}, {\tt >}, and {\tt \&} as they appear in \CC\
names and the characters \#, \%, \CChat, and \CCtilde\ as they appear
with operators. See the following example: 
\CCstyle{
    #define %^~ Return_Type<Template_Param, X<Y> > fct_foo( const X<Y> &a);}

This example is created using the {\verb+\CC+}{\tt style} macro
that formats its single parameter in this style.

To achieve this behavior with \TeX\, the \verb"\catcode" values of
some characters has to be changed. So within the \CC\ code 
things like comments with ``\%'' sign will not work. Several macros read a
second parameter with a \TeX\ comment to the declaration. The catcodes
are restored just before this second parameter. A sad sideeffect is
that these changed catcodes will not apply if these macros are invoked
within other macros. In that case, the argument text was just once
parsed from \TeX\ and the catcodes are all fixed before the catcode
changing macro expands.

\definition 

The class \classname\ does nothing. The formatted name of the class
can be accessed using the macro \verb"\"\verb"classname". The unformatted
name as it was originally written can be accessed using the
\verb"\"\verb"pureclassname" macro.

\creationvariable{p_}
\creation

The constructors create a variable \var\ of the class. The
\verb"\"\verb"creationvariable{"\ldots\verb"}" macro sets the name for the
future use. It can be accessed with the \verb"\"\verb"var" or
\verb"\"\verb"purevar" macro.

The constructors are written using the
\verb"\"\verb"constructor{"\ldots\verb"}{"\ldots\verb"}" macro. The first
parameter contains the \CC\ declaration, the second parameter the comments.
The declaration is written in the normal \CC\ fashion, as shown at the end
of the comment. The style formats them as if they are used
to declare a variable for this class. For convinience,
\verb"const"\ldots\verb"&" parameter declarations are eliminated in the
formatting. It makes no difference in the usage of a parameter. If the
type of a constructor, method, or function parameter equals the
current class, it is also omitted. In the case that nothing is left,
the \CCemptyParameter\ symbol is used. See the copy constructor for an
example. All together we achieve this natural looking descriptions.

\CCstyle{#include< demo_class.h>}

  \constructor{Demo_Class();}{introduces
     a variable \var\ initialized to the default. \CC\ code:
     {\tt Demo\_Class();}. Test CCstyle: \CCstyle{Underscore\_within
     CCstyle}.}

  \constructor{Demo_Class( const Demo_Class &);}{copy
    constructor. \CC\ code: {\tt Demo\_Class(const Demo\_Class \&);}}

  \constructor{Demo_Class( RT hx, RT hy, RT hw);}{arbitrary constructor.
     \CC\ code: {\tt Demo\_Class(RT hx, RT hy, RT hw);}}

The font and style in which the declarations are formatted can be
changed by overwriting the \verb"\CCfont" and \verb"\CCendfont"
macros. Their default settings are
\verb"\gdef\CCfont{\it}\gdef\CCendfont{\/}". They are used within a
group, so font changing commands are local. The rest of this document is
formatted using the definitions \verb"\gdef\CCfont{\tt}\gdef\CCendfont{}".

\gdef\CCfont{\tt}\gdef\CCendfont{}
  \constructor{Demo_Class( int a, X<Y> &x);}{arbitrary constructor.}

\gdef\CCfont{\it}\gdef\CCendfont{\/}

Also changable are the special characters the formatting has to
deal with. They are named \verb"\CCunderscore", \verb"\CCopenangle",
\verb"\CCcloseangle", \verb"\CCampersand", \verb"\CChat", and
\verb"\CCtilde". The symbol for the empty parameter is named
\verb"\CCemptyParameter".

  \operations
  \threecolumns{2.8cm}{2.8cm}

The layout of this section can be customized to the width of the
return types and the declarations. The
\verb"\"\verb"threecolumns{"\ldots\verb"}{"\ldots\verb"}" macro sets the
width of the two leading columns of the total three columns. All other
dimensions will be computed.

Note that declarations after the closing parenthesis like {\tt const}
for the implicit class parameter of a method will not be printed
(this might change in the future).
The return value is handled like a parameter type. That means that
{\tt const\ldots\&} declarations are removed, but if the type equals
to the class, it is {\em not} removed.

  \method{FT   x()  const;}{Cartesian x-coordinate. \CC\ code: {\tt
      FT x() const;}}

  \method{const FT&   y();}{Cartesian y-coordinate. \CC\ code: {\tt
      const FT\& y();}}

  \method{Demo_Class   
             transform( const CGAL_HAff_transformation<FT,RT> &t) const;
             }{ Longish declarations forces the comment to start in
             the next line.}

  \method{Demo_Class   
             longish_function_name( 
                        const CGAL_Aff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name_For_Fun Variable_Also_Long) const;
             }{ Even more longish declarations forces the parameters printed
             one per line. This was the default formatting.}


Reference or pointer parameters can occur on both sides of the
separating space between the return type and the function or method
name. The formatting normalizes them to the left side. This
formatting is not done within the parameters (, but maybe in the
future). An example: 

    \function{Demo_Class& foo( int& a, int* b);}{}

    \function{Demo_Class* foo( int& a, int* b);}{}

    \function{Demo_Class &foo( int &a, int *b);}{}

    \function{Demo_Class *foo( int &a, int *b);}{}

Operator declarations are formatted as like the operators are
used.  All operators that are allowed to be overloaded in \CC\ are
handled. They are listed in the last section for completeness and
to check the layout. 

Type casting through a conversion operator is the default behavior 
for the formatting routine if the return type before the {\tt 
operator} keyword is empty.

  \function{ operator int () const;}{Conversion operator.}

  \function{operator A< FT>() const;}{Conversion operator.}

Sometimes, there is a choice between
implementing an operator as a method or as a function. Both
declarations will produce the same formatting, as demonstrated
with the next two declarations.

  \function{Demo_Class
        operator+(Demo_Class p, Demo_Class q);}{Declaration via function.}

  \method{Demo_Class
        operator+(Demo_Class q);}{Declaration via method.}

There is some laziness allowed in placing spaces around the operator
characters. See the following examples:

\method{A
    operator+(Demo_Class q);}{\CC\ code: {\tt A operator+(Demo\_Class q);}}

\method{A
    operator +(Demo_Class q);}{\CC\ code: {\tt A operator +(Demo\_Class q);}}

\method{A
    operator+ (Demo_Class q);}{\CC\ code: {\tt A operator+ (Demo\_Class q);}}

\method{A
    operator + (Demo_Class q);}{\CC\ code: {\tt A operator + (Demo\_Class q);}}

The keyword {\tt operator} is reserved, but it can appear as a
substring in another name. See the following examples that this
style can handle such cases:

\method{A foo_operator(Demo_Class q);}{}

\method{A noperator(Demo_Class q);}{}

\method{A operatoro(Demo_Class q);}{}

\method{A operator_(Demo_Class q);}{}

\method{A operator0(Demo_Class q);}{}

CGAL will use {\tt typedef}'s and the scope operator to define types.
Here is an example for the scope operator within types.  The scope
operator cannot be used within the function or method name.

  \threecolumns{5.8cm}{1.8cm}
  \function{Rep_Class::Nested_Class
        foo(Rep_Class::Nested_Class p, Demo_Class q);}{
         Declaration with scope.}

  \function{Rep_Class :: Nested_Class
        foo(Rep_Class :: Nested_Class p, Demo_Class q);}{
         The same, surrounded by spaces.}

\end{class}


% ----------------------------------------------------------------------
\begin{classtemplate}{Demo_Class<FT<RT> >}
\CCsection{Demo Class Template}

This class template is given within a
\verb"\be"\verb"gin{classtemplate}{Demo_Class<FT<RT> >}" environment.

\creationvariable{p}
\creation

A current misbehaviour (or feature?) of the structuring macros is that
they have fixed numbers. So the \verb"\"\verb"definition" macro is here
missing.

  \constructor{ Demo_Class();}{ default.}

  \constructor{ Demo_Class( Demo_Class<FT<RT> > q);}{ copy.}

  \constructor{ Demo_Class( A a, B *b);}{ arbitrary.}

\operations
\threecolumns{4.3cm}{2.3cm}

  \method{ Demo_Class foo( Demo_Class q);}{
      wrong, without template parameters.}

  \function{ Demo_Class<FT<RT> > foo( Demo_Class<FT<RT> > q);}{
      right, with template parameters.}

Another example demonstrating a const pointer declaration of a 
class template.

    \function{Demo_Class& foo( const Class< int>* b);}{}

    \function{Demo_Class& foo( const Demo_Class< int>* b);}{}

\end{classtemplate}

% ----------------------------------------------------------------------
\section{New Features Introduced with Version 1.8}

\begin{class}{Demo_Class}

A small set of handy abbreviations are added. Here they are all together:

\begin{tabbing}
  dum \= dummyyyyyyyy \= \kill
  \> \verb+\CC+         \> \CC         \\
  \> \verb+\gg+         \> \gg         \\
  \> \verb+\nat+        \> \nat        \\
  \> \verb+\real+       \> \real       \\
%  \> \verb+\boxit{A}+   \> \boxit{A}   \\
  \> \verb+\leda+       \> \leda       \\
  \> \verb+\cgal+       \> \cgal       \\
  \> \verb+\protocgal+  \> \protocgal  \\
  \> \verb+\plageo+     \> \plageo  
\end{tabbing}

\def\CCalternateThreeColumn{\CCtrue}
\creationvariable{p}
\threecolumns{2.8cm}{2.8cm}

  \constructor{Demo_Class( Paramter1 hx, 
                           Paramter2 hy, 
                           Paramter3 hw, 
                           Paramter4 hw, 
                           Paramter5 hw);}{
     Longish parameter lists will be broken into several lines.
     Therefore, the parameter {\tt $\backslash$CCalternateThreeColumn} was 
     set to {\tt $\backslash$CCtrue}.}

\def\CCalternateThreeColumn{\CCtrue}

  \method{Demo_Class   
             longish_naming( 
                        const DGAL_HAff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name Variable_Also_Long) const;
             }{ Here, the alternative formatting was again switched on
                by setting the parameter {\tt 
                $\backslash$CCalternateThreeColumn} to {\tt 
                $\backslash$CCtrue}.}

  \method{Even_a_long_return_value
             longish_naming( 
                        const DGAL_HAff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name Variable_Also_Long) const;
             }{ Now, a long return value forces the function to start 
                in the next line.}

\def\CCalternateThreeColumn{\CCfalse}

Function templates are written with the macro \verb+\fu+\verb+nctiontemplate+
that has an additional parameter in front for the template
parameters. They are visible in the manual because the user does not
see them, but the parameters are necessary for the specification
checking tool.

\threecolumns{2.8cm}{8.7cm}

\functiontemplate{R}{bool CGAL_is_intersecting( Point< R>, Point<
  R>);}{comment.}

Enum's are formatted similiar to constructors. Exactly one pair of
matching braces has to be in the declaration.

\enum{enum Short { A, B, C};}{ Comment.}

\enum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}{ Comment.}

We can even switch the alternative layout on:

\gdef\CCalternateThreeColumn{\CCtrue}

\enum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}{ Comment.}

\threecolumns{3.5cm}{3.5cm}

\variable{long int foo;}{Local variables are possible.}

\variable{long int foo = 15;}{Initialisation.}

\variable{const long int foo = 15;}{Make a constant.}

\typedef{typedef int integer;}{Simple typedef.}

\typedef{typedef List< int>  Integer_list;}{Typedef including template
    parameters.}


\end{class}

Global functions and other global declarations can be written with the 
normal macros that are used within class declarations. For convenience, 
a set of {\em global\/} macros are provided that omit the last comment
parameter. Global declarations are usually commented in the lines
inbetween. So here comes a global function:

\globalfunction{CGAL_intersection_type CGAL_Intersection_type(
      Polygon_2< R>, Polygon_2< R>);}The same 
as a function template:

\globalfunctiontemplate{R}{CGAL_intersection_type CGAL_Intersection_type(
      Polygon_2< R>, Polygon_2< R>);}A global enum.

\globalenum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}

\globalvariable{int CGAL_global;}Thats it.

\section{New Features Introduced with Version 1.9}

\begin{class}{Demo_Class}

A set of handy abbreviations has been extended. They need the package
{\tt amssymb} and \LaTeXe.

\begin{tabbing}
  dum \= dummyyyyyyyy \= \kill
  \> \verb+\+verb+N+        \> \N        \\
  \> \verb+\+verb+Z+        \> \Z        \\
  \> \verb+\+verb+R+        \> \R        \\
  \> \verb+\+verb+E+        \> \E
\end{tabbing}

A \verb+\de+\verb+claration+ accepts one parameter. The style will
ignore it, while the checker tests if it exists one to one in the C++
code.  It is intended for declarations that are somehow implied by the
surrounded text, but should not be explicitly visible. For example,
this example is not visible (smile).

\declaration{Some arbitary funny *%&_ looking # C++ code declaration()...}

A \verb+\+verb+hidden+ macro can be prepended to each macro with two
parameters.  It will remove the macro and its parameters from the
manual.  Again, the checker tests the macro as usual. Again an
invisible example.

\hidden\function{int foo( double d);}{This is a foo function.}

If these non visible parts of the code should be made visible once,
the \verb+\+\verb+CCmakeAllVisible+ macro switches it on. For
\verb+\+verb+declaration+ the \verb+\+verb+CCstyle+ macro is used. The
\verb+\+verb+hidden+ macro vanishes simply.  The two funny invisible
examples from above are repeated here.

\CCmakeAllVisible

\declaration{Some arbitary funny *%&_ looking # C++ code declaration()...}

\hidden\function{int foo( double d);}{This is a foo function
    previously hidden.}

The following example demonstrates the new ability to write default
parameters with initializers in parantheses notion of \CC.
\end{class}

\begin{classtemplate}{CGAL_Point_2< R>}
\constructor{CGAL_Point_2(const R::RT &x, const R::RT &y, const R::RT &w = R::RT(1.0));}{blabla}
\end{classtemplate}

A problem has occured in detecting the operator keyword if it was
directly preceded by an {\tt \&} or {\tt *} character. It is fixed as
the following example demonstrates:

\function{Int &operator+=( Int a, Int b);}{}

%\begin{class}{Demo_class}
% \creationvariable{demo_var}%
%
% \constructor{Demo_class();}{Default constructor creating variable \var.}
%
% \end{class}

The \verb+\+verb+CCstyle+ macro is not appropriate to format multiple lines
of \CC\ code. Use other environments like the {\tt cprog} style.




% ----------------------------------------------------------------------
\begin{class}{Demo_Class}
\section{The List of All Operators}

  \function{Ptr_Class
        operator->(Demo_Class p);}{}

  \function{Demo_Class
        operator[](Demo_Class p, int i);}{}

  \function{Demo_Class
        operator()(Demo_Class p);}{}

  \function{Demo_Class
        operator()(Demo_Class p, int i);}{}

  \function{Demo_Class
        operator()(Demo_Class p, int i, int j);}{}

  \function{Demo_Class
        operator()(Demo_Class p, int i, int j, int k);}{}

  \function{Demo_Class
        operator()(Demo_Class p,
                   const A& a, B& b, C c, const D& d, Demo_Class
                   e);}{all number and types of parameters are possible.}

  \function{Demo_Class
        operator++(Demo_Class p);}{}

  \function{Demo_Class
        operator++(Demo_Class p, int);}{The postfix incr.\ operator
        has a hidden {\tt int} parameter that the formatting does not show.}

  \function{Demo_Class
        operator--(Demo_Class p);}{}

  \function{Demo_Class
        operator--(Demo_Class p, int);}{}

  \function{Demo_Class
        operator~(Demo_Class p);}{}

  \function{Demo_Class
        operator!(Demo_Class p);}{}

  \function{Demo_Class
        operator-(Demo_Class p);}{}

  \function{Demo_Class
        operator+(Demo_Class p);}{}

  \function{Demo_Class
        operator&(Demo_Class p);}{}

  \function{Demo_Class
        operator*(Demo_Class p);}{}

  \method{ void*
        operator new( size_t);}{Hidden parameters are not shown. \CC\ code: 
        $\backslash${\tt method\{ void* operator new( size\_t);\}}.}

  \method{ void
        operator delete( void*, size_t);}{Hidden parameters are not shown.
        \CC\ code: $\backslash${\tt method\{ void operator 
            delete( void*, size\_t);\}}}

  \method{ void
        operator delete[]( void*, size_t);}{Hidden parameters are not
        shown again. 
        \CC\ code: $\backslash${\tt method\{ void operator
            delete[]( void*, size\_t);\}}}

  \function{Member_Ptr
        operator->*(Demo_Class p);}{}

  \function{Demo_Class
        operator*(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator/(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator%(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator+(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator-(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator<<(Demo_Class p, int i);}{}

  \function{Demo_Class
        operator>>(Demo_Class p, int i);}{}

  \function{Demo_Class
        operator<(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator<=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator>(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator>=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator==(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator!=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator&(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator^(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator|(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator&&(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator||(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator*=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator/=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator%=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator+=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator-=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator<<=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator>>=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator&=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator|=(Demo_Class p, Demo_Class q);}{}

  \function{Demo_Class
        operator^=(Demo_Class p, Demo_Class q);}{}

\end{class}

\end{document}

