% ----------------------------------------------------------------------
% Test document for the CGAL manual LaTeX style:
% 
% 16.08.1995   Lutz Kettner
%
% $Revision$
% $Date$
% ----------------------------------------------------------------------
% The style is compatible with LaTeX2e:
\documentclass[12pt]{article}
\usepackage{latexsym}
\usepackage{amssymb}

% LaTeX:
% \documentstyle[12pt]{article}

%\pagestyle{empty}
\textwidth 15.4cm 
\textheight 24 cm
\topmargin -14mm       
\evensidemargin 3mm 
\oddsidemargin 3mm

\input{cc_manual.sty}

\parindent0em
\setlength{\parskip}{1ex minus 0.9ex}

\sloppy

% ----------------------------------------------------------------------
\title {Test Suite for the cc\_manual.sty}
\author{Lutz Kettner}
\date{\ccRevision. \ccDate}

\begin{document}

\maketitle

% ----------------------------------------------------------------------
\section{Introduction}

This document is a test suite for the {\tt cc\_manual.sty}. It is
arbitrary structured and mostly no introductory explanations will be given.
Each section will test a particularly feature. Sections were written
while developing the style or while debugging. Thanks for bug-reports
made so far and for future reports. Please send bug-reports to {\tt
  kettner@inf.ethz.ch}.


% ----------------------------------------------------------------------
\section{Structuring Macros}

\ccDefinition Here comes the general introductory explanation for a
class etc.

\ccPrecond Specific conditions can be stated as preconditions in any place.

\ccCreation Constructors are defined and explained here.

% ----------------------------------------------------------------------
\section{ccStyle Character Test}

The formatting macros handle for example the special characters \_,
{\tt <}, {\tt >}, and {\tt \&} as they appear in \CC\ names and the
characters \#, \%, \ccHat, and \ccTilde\ as they appear with
operators. See the following example that is printed using the
{\verb+\cc+}{\tt Style} macro:

\ccStyle{
    #define %^~ Return_Type<Template_Param, X<Y> > fct_foo( const X<Y> &a);}

% ----------------------------------------------------------------------
\begin{ccClass}{Demo_Class}
\ccSection{A Simple Class}

\ccCreationVariable{p}

\ccStyle{#include< demo_class.h>}
\ccTwo{Demo_Class p;X}{}

  \ccConstructor{Demo_Class();}{introduces
     a variable \ccVar\ initialized to the default. \CC\ code:
     {\tt Demo\_Class();}. Test ccStyle: \ccStyle{Underscore\_within
     ccStyle}.}

  \ccConstructor{Demo_Class( const Demo_Class &);}{copy
    constructor. \CC\ code: {\tt Demo\_Class(const Demo\_Class \&);}}

\ccThree{Demo_Class}{p.x();}{}

  \ccMethod{FT   x()  const;}{Cartesian x-coordinate. \CC\ code: {\tt
      FT x() const;}}

  \ccMethod{const FT&   y();}{Cartesian y-coordinate. \CC\ code: {\tt
      const FT\& y();}}

  \ccMethod{Demo_Class   
             transform( const CGAL_HAff_transformation<FT,RT> &t) const;
             }{ Longish declarations forces the comment to start in
             the next line.}

  \ccMethod{Demo_Class   
             longish_function_name( 
                        const CGAL_Aff_transformation<FT,RT> &t,
                        const Dummy_Type &q,
                        Long_Type_Name Variable_Also_Long) const;
             }{ Even more longish declarations forces the parameters printed
             one per line. This was the default formatting.}

\end{ccClass}

% ----------------------------------------------------------------------
\section{Spaces Around Pointer * and Reference \& Symbols}

Reference or pointer parameters can occur on both sides of the
separating space between the return type and the function or method
name. The formatting normalizes them to the left side. This
formatting is not done within the parameters (, but maybe in the
future). An example: 

\ccThree{Demo_Class&&}{p.x();}{}

    \ccFunction{Demo_Class& foo( int& a, int* b);}{}
    \ccGlue
    \ccFunction{Demo_Class* foo( int& a, int* b);}{}
    \ccGlue
    \ccFunction{Demo_Class &foo( int &a, int *b);}{}
    \ccGlue
    \ccFunction{Demo_Class *foo( int &a, int *b);}{}

% ----------------------------------------------------------------------
\section{Operator Test}

Type casting through a conversion operator is the default behavior 
for the formatting routine if the return type before the {\tt 
operator} keyword is empty.

\ccThree{Demo_Class&&}{A< FT>(p);}{}

  \ccFunction{ operator int () const;}{Conversion operator.}
    \ccGlue
  \ccFunction{operator A< FT>() const;}{Conversion operator.}

Sometimes, there is a choice between
implementing an operator as a method or as a function. Both
declarations will produce the same formatting, as demonstrated
with the next two declarations.

\begin{ccClass}{Demo_Class}
\ccCreationVariable{p}

  \ccFunction{Demo_Class
        operator+(Demo_Class p, Demo_Class q);}{Declaration via function.}
    \ccGlue
  \ccMethod{Demo_Class
        operator+(Demo_Class q);}{Declaration via method.}

One can locally activate that the operator declaration is shown as it
is written without operator formatting, {\tt const ...\&}, classname, or
trailing const declarations for methods removal. This can be done with
\verb+\+\verb+ccTagFullDeclarations+ within a scope of braces {\tt
  \{...\}}.

{\ccTagFullDeclarations
  \ccMethod{Demo_Class
        operator+(const Demo_Class& q) const;}{Declaration via method.}
}

There is some laziness allowed in placing spaces around the operator
characters. See the following examples:

\ccMethod{A
    operator+(Demo_Class q);}{\CC\ code: {\tt A operator+(Demo\_Class q);}}
    \ccGlue
\ccMethod{A
    operator +(Demo_Class q);}{\CC\ code: {\tt A operator +(Demo\_Class q);}}
    \ccGlue
\ccMethod{A
    operator+ (Demo_Class q);}{\CC\ code: {\tt A operator+ (Demo\_Class q);}}
    \ccGlue
\ccMethod{A
    operator + (Demo_Class q);}{\CC\ code: {\tt A operator + (Demo\_Class q);}}

The keyword {\tt operator} is reserved, but it can appear as a
substring in another name. See the following examples that this
style can handle such cases:

\ccMethod{A foo_operator(Demo_Class q);}{}
    \ccGlue
\ccMethod{A noperator(Demo_Class q);}{}
    \ccGlue
\ccMethod{A operatoro(Demo_Class q);}{}
    \ccGlue
\ccMethod{A operator_(Demo_Class q);}{}
    \ccGlue
\ccMethod{A operator0(Demo_Class q);}{}

A problem has occured in detecting the operator keyword if it was
directly preceded by an {\tt \&} or {\tt *} character. It is fixed as
the following example demonstrates:

\ccFunction{Int &operator+=( Int a, Int b);}{}

\end{ccClass}

%----------------------------------------------------------------------
\ccTagDefaults
\begin{ccClass}{Demo_Class}
\section{The List of All Operators}

  \ccFunction{Ptr_Class
        operator->(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator[](Demo_Class p, int i);}{}

  \ccFunction{Demo_Class
        operator()(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator()(Demo_Class p, int i);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator()(Demo_Class p, int i, int j);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator()(Demo_Class p, int i, int j, int k);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator()(Demo_Class p,
                   const A& a, B& b, C c, const D& d, Demo_Class
                   e);}{all number and types of parameters are possible.}

  \ccFunction{Demo_Class
        operator++(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator++(Demo_Class p, int);}{The postfix incr.\ operator
        has a hidden {\tt int} parameter that the formatting does not show.}

  \ccFunction{Demo_Class
        operator--(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator--(Demo_Class p, int);}{}

  \ccFunction{Demo_Class
        operator~(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator!(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator-(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator+(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator&(Demo_Class p);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator*(Demo_Class p);}{}

  \ccMethod{ void*
        operator new( size_t);}{Hidden parameters are not shown. \CC\ code: 
        $\backslash${\tt method\{ void* operator new( size\_t);\}}.}

  \ccMethod{ void
        operator delete( void*, size_t);}{Hidden parameters are not shown.
        \CC\ code: $\backslash${\tt method\{ void operator 
            delete( void*, size\_t);\}}}

  \ccMethod{ void
        operator delete[]( void*, size_t);}{Hidden parameters are not
        shown again. 
        \CC\ code: $\backslash${\tt method\{ void operator
            delete[]( void*, size\_t);\}}}

  \ccFunction{Member_Ptr
        operator->*(Demo_Class p);}{}

  \ccFunction{Demo_Class
        operator*(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator/(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator%(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator+(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator-(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator<<(Demo_Class p, int i);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator>>(Demo_Class p, int i);}{}

  \ccFunction{Demo_Class
        operator<(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator<=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator>(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator>=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator==(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator!=(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator&(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator^(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator|(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator&&(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator||(Demo_Class p, Demo_Class q);}{}

  \ccFunction{Demo_Class
        operator=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator*=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator/=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator%=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator+=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator-=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator<<=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator>>=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator&=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator|=(Demo_Class p, Demo_Class q);}{}
  \ccGlue
  \ccFunction{Demo_Class
        operator^=(Demo_Class p, Demo_Class q);}{}

\end{ccClass}

% ----------------------------------------------------------------------
\section{Scope Operator in Types}

CGAL will use {\tt typedef}'s and the scope operator to define types.
Here is an example for the scope operator within types.  The scope
operator cannot be used within the function or method name.

  \ccSetTwoOfThreeColumns{5.8cm}{1.8cm}
  \ccFunction{Rep_Class::Nested_Class
        foo(Rep_Class::Nested_Class p, Demo_Class q);}{
         Declaration with scope.}

  \ccFunction{Rep_Class :: Nested_Class
        foo(Rep_Class :: Nested_Class p, Demo_Class q);}{
         The same, surrounded by spaces.}



% ----------------------------------------------------------------------
\begin{ccClassTemplate}{Demo_Class<FT<RT> >}
\ccSection{Demo Class Template}

\ccCreation
\ccCreationVariable{p}

\ccTwo{Demo_Class<FT<RT> > p( A a, B *b);X}{}
  \ccConstructor{ Demo_Class();}{ default.}
  \ccGlue
  \ccConstructor{ Demo_Class( Demo_Class<FT<RT> > q);}{ copy.}
  \ccGlue
  \ccConstructor{ Demo_Class( A a, B *b);}{ arbitrary.}

\ccOperations
\ccThree{Demo_Class<FT<RT> >}{foo( q);}{}

  \ccMethod{ Demo_Class foo( Demo_Class q);}{
      wrong, without template parameters.}

  \ccFunction{ Demo_Class<FT<RT> > foo( Demo_Class<FT<RT> > q);}{
      right, with template parameters.}
\end{ccClassTemplate}

% ----------------------------------------------------------------------
\section{Abbreviations}

The math set symbols need the package
{\tt amssymb} and \LaTeXe.

\begin{tabbing}
  dum \= dummyyyyyyyy \= \kill
  \> \verb+\CC+         \> \CC         \\
  \> \verb+\gcc+        \> \gcc        \\
  \> \verb+\nat+        \> \nat        \\
  \> \verb+\real+       \> \real       \\
  \> \verb+\leda+       \> \leda       \\
  \> \verb+\cgal+       \> \cgal       \\
  \> \verb+\protocgal+  \> \protocgal  \\
  \> \verb+\plageo+     \> \plageo     \\ 
  \> \verb+\+\verb+N+        \> \N        \\
  \> \verb+\+\verb+Z+        \> \Z        \\
  \> \verb+\+\verb+R+        \> \R        \\
  \> \verb+\+\verb+E+        \> \E
\end{tabbing}

% ----------------------------------------------------------------------
\section{Enum's}

Enum's are formatted similiar to constructors. Exactly one pair of
matching braces has to be in the declaration.

\ccTwo{enum Short ( A, B, C);XX}{}

\ccEnum{enum Short { A, B, C};}{ Comment.}

\ccEnum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}{ Comment.}

We can even switch the alternative layout on:

\def\ccLongParamLayout{\ccTrue}

\ccEnum{enum Funny_type_name { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}{ Comment.}

\def\ccLongParamLayout{\ccFalse}


% ----------------------------------------------------------------------
\section{Variables, Constants and Typedefs}

\ccSetTwoOfThreeColumns{3.5cm}{3.5cm}

\ccVariable{long int foo;}{Local variables are possible.}

\ccVariable{long int foo = 15;}{Initialisation.}

\ccVariable{const long int foo = 15;}{Make a constant.}

\ccTypedef{typedef int integer;}{Simple typedef.}

\ccTypedef{typedef List< int>  Integer_list;}{Typedef including template
    parameters.}



% ----------------------------------------------------------------------
\section{Global Declarations}

\ccGlobalFunction{Intersection_type CGAL_intersection_type(
      Polygon_2< R>, Polygon_2< R>);}

\ccGlobalEnum{enum global_enum { A_couple_of_entries,
    one_with_initialisation = 5, another = -3};}

\ccGlobalVariable{int CGAL_global_var;}


% ----------------------------------------------------------------------
\section{Default Parameters in Function Argument Lists}

The following example demonstrates the new ability to write default
parameters with initializers in parantheses notion of \CC.

\begin{ccClassTemplate}{CGAL_Point_2< R>}
\ccConstructor{CGAL_Point_2(const R::RT &x, const R::RT &y, const R::RT &w = R::RT(1.0));}{blabla}
\end{ccClassTemplate}



% ----------------------------------------------------------------------
\section{Test Indentation and Alternate Formatting}

This example tests the indentation and right margin setting
possibilities. Two long declarations with alternative formatting rules
for the function arguments are used. First the  declaration without
any indentation or margins.

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the default formatting. A bit more text is necessary to
  demonstrate the right margin.}

Now with 10mm indentation and 10mm right margin. Note that the
description is also further indented since all dimensions are
calculated from left.

\ccTagDefaults
\def\ind{\hspace*{7mm}}
\ccwIndent=10mm
\ccwRightMargin=10mm

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the default formatting. A bit more text is necessary to
  demonstrate the right margin.}
\renewcommand{\ccLongParamLayout}{\ccTrue}

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the alternative formatting. A bit more text is necessary to
  demonstrate the right margin.}

Show the indentation also for template functions.

\ccFunction{template<class A> int bar(A a);}{A bit more text to
  demonstrate the right margin.}

\renewcommand{\ccLongParamLayout}{\ccFalse}

Check the same alternate indentation with the compatibility mode 
\verb+\renewcommand{\ccAlternateThreeColumn}{\ccFalse}+

\renewcommand{\ccAlternateThreeColumn}{\ccFalse}

\ccFunction{int a_really_long_function_name( double paramter1, double
  paramter2);}{the alternative formatting. A bit more text is necessary to
  demonstrate the right margin.}

Show the indentation also for template functions.

\ccFunction{template<class A> int bar(A a);}{A bit more text to
  demonstrate the right margin.}

\renewcommand{\ccAlternateThreeColumn}{\ccTrue}
\ccwIndent=0mm
\ccwRightMargin=0mm

% ----------------------------------------------------------------------
\section{Test the Setting of the Column Widths by Example Texts}


\ccSetThreeColumns{int}{foo( int i, int j);}{}
\ccFunction{int foo( int i, int j);}{returns gnats$(i,j)$.}

\ccSetThreeColumns{int}{}{returns gnats$(i,j)$.}
\ccFunction{int foo( int i, int j);}{returns gnats$(i,j)$.}

\ccSetThreeColumns{}{foo( int i, int j);}{returns gnats$(i,j)$.}
\ccFunction{int foo( int i, int j);}{returns gnats$(i,j)$.}

Test it with the special characters (changed catcodes) for function
and contructor declarations.  


\ccSetThreeColumns{%#_^}{%#_^f*&*&oo( int i);}{}
\ccSetTwoColumns{%#_^ foo( int i, int j);}{}
\begin{ccClass}{Gnu}
  \ccCreationVariable{g}
  \ccConstructor{Gnu( double d);}{test.}
  \ccFunction{int foo( Gnats<T> gn);}{blablabla.}
\end{ccClass}

Specify a column layout for a function and propagate it to a contructor.

\ccSetThreeColumns{intM}{foo( Gnats<T> gn);M}{}
\ccPropagateThreeToTwoColumns
\begin{ccClass}{Gnu}
  \ccCreationVariable{g}
  \ccConstructor{Gnu( double d);}{test.}
  \ccFunction{int foo( Gnats<T> gn);}{blablabla.}
\end{ccClass}


% ----------------------------------------------------------------------
\section{Check Long Constructor Calls}

\begin{ccClassTemplate}{CBP_Bidirectional_circulator< C, C*
   (C::*next)(), C* (C::*previous)()>} 
\ccCreationVariable{circ}
\ccSetTwoColumns{}{a const circulator \ccVar\ with singular value.}

NOTHING is interesting here.


\ccConstructor{CBP_Bidirectional_circulator();}{%
 a const circulator \ccVar\ with singular value.}

\ccConstructor{CBP_Bidirectional_circulator( const C* ptr);}{a
  const circulator \ccVar\ initialized to point to the element \ccStyle{*ptr}.} 
\end{ccClassTemplate}

% ----------------------------------------------------------------------
\section{Glueing Declarations Together}

\ccFunction{int foo( double x);}{}
\ccGlueDeclarations
\ccFunction{int bar( double x);}{}

\ccFunction{int foo( double x);}{Bla.}
\ccGlueDeclarations
\ccFunction{int bar( double x);}{Blubb blubb.}

\ccFunction{int foo_baaaaaaaarrrr( double x);}{%
     Bla bal blabal blabal blabal blab.}
\ccGlueDeclarations
\ccFunction{int barfoooooooooooooooooo( double x);}{%
    Blubb blubblubb blubblubb blubblubb blubb.}


% ----------------------------------------------------------------------
\section{Nested Classes}

First try, use the scope operator in the class name.

\begin{ccClass}{Base::Derived}
\ccCreationVariable{a}

\ccConstructor{Base::Derived( double x);}{a constructor.}
\ccFunction{Base::Derived foo( Base::Derived b);}{a function.}
\end{ccClass}

% ----------------------------------------------------------------------
\section{Prefix Substitution}

The example illustrates both typical usages (with a fantasy function
that does not exist in \cgal).

\ccSetThreeColumns{CGAL_Point<R>}{CGAL_f( CGAL_Vector<R> v)}{}

\ccStyle{#include <CGAL/point.h>}
\\
\ccFunction{CGAL_Point<R> CGAL_f( CGAL_Vector<R> v);}{%
    the original \cgal\ prefix.}
\vspace{-\parskip}

\begin{tabbing}
  CCimplementationNNNMMMMMMMMMMMMMMMMMMMM \= ImplementationMMMMM \= \kill
  \verb+\def\ccTargetPrefix{}+ \\
  \verb+\renewcommand{\ccTagReplacePrefix}{\ccTrue}+
\end{tabbing}
\def\ccTargetPrefix{}
\renewcommand{\ccTagReplacePrefix}{\ccTrue}
\vspace{-\parskip}

\ccStyle{#include <CGAL/point.h>}
\\
\ccFunction{CGAL_Point<R> CGAL_f( CGAL_Vector<R> v);}{%
    assuming name spaces. {\tt ;-)}}
\vspace{-\parskip}

\begin{tabbing}
  CCimplementationNNNMMMMMMMMMMMMMMMMMMMM \= ImplementationMMMMM \= \kill
  \verb+\def\ccTargetPrefix{GTE}+ \\
  \verb+\renewcommand{\ccTagReplaceInclude}{\ccTrue}+
\end{tabbing}
\def\ccTargetPrefix{GTE}
\renewcommand{\ccTagReplaceInclude}{\ccTrue}
\vspace{-\parskip}

\ccStyle{#include <CGAL/point.h>}
\\
\ccFunction{CGAL_Point<R> CGAL_f( CGAL_Vector<R> v);}{%
    make a Porsche from this declaration.}
\vspace{-\parskip}

\begin{tabbing}
  CCimplementationNNNMMMMMMMMMMMMMMMMMMMM \= ImplementationMMMMM \= \kill
  \verb+\renewcommand{\ccTagReplacePrefix}{\ccFalse}+ \\
  \verb+\renewcommand{\ccTagReplaceInclude}{\ccFalse}+
\end{tabbing}
\renewcommand{\ccTagReplacePrefix}{\ccFalse}
\renewcommand{\ccTagReplaceInclude}{\ccFalse}

% ----------------------------------------------------------------------
\section{A Constructor for a Nested Class}

The method how it should work:

\begin{ccClass}{CGAL_SegmentTree_2d<T1>::SegTree}
\ccCreationVariable{t}
\ccConstructor{CGAL_SegmentTree_2d<T1>::SegTree
(S2dList::const_iterator first);}{constructor.}

\ccMemberFunction{CGAL_SegmentTree_2d<T1>::SegTree
    foo (CGAL_SegmentTree_2d<T1>::SegTree same);}{%
    removal of own type in parameterlist of a member function.} 
\end{ccClass}


The hack I have recommended previously.

\ccFunction{CGAL_SegmentTree_2d<T1>::SegTree
t(S2dList::const_iterator first);}{fake constructor.}

Another check with the trouble making operator in a member function.

\begin{ccClass}{Demo_Class}
\ccCreationVariable{pp}
  \ccMethod{Demo_Class operator+(Demo_Class qq);}{%
      Declaration of an operator as a member function.}
\end{ccClass}



% ----------------------------------------------------------------------
\section{Font Changes within a Declaration}

A global variable declaration.

\ccSetThreeColumns{\tt k-th\ccFont -dim\ }{\tt k-th\ccFont -foo;}{}
\ccVariable{\tt k-th\ccFont -dim \tt k-th\ccFont -foo;}{%
    a {\tt k-th}-dimensional variable.}

A constructor and a member function within a class where the classname
also uses font changing macros.

\begin{ccClass}{\tt k-th\ccFont -dim-Class}
  \ccCreationVariable{v}
  \ccSetThreeColumns{\tt k-th\ccFont -dim-retvalue\ }{v.k-th\ccFont
    -dim-foo( \tt k-th\ccFont -dim-param)\ ;}{}
  \ccSetTwoColumns{\tt k-th\ccFont -dim-Class v( \tt k-th\ccFont
    -dim-param) \ ;}{}
\def\ccTagRmEigenClassName{\ccFalse}
  \ccConstructor{\tt k-th\ccFont -dim-Class();}{The default constructor.}
  \ccConstructor{\tt k-th\ccFont -dim-Class( \tt k-th\ccFont
    -dim-param);}{The custom constructor.}  
  \ccMemberFunction{\tt k-th\ccFont -dim-retvalue \tt k-th\ccFont
    -dim-foo( \tt k-th\ccFont -dim-param);}{a function.}
\def\ccTagRmEigenClassName{\ccTrue}
\end{ccClass}

% ----------------------------------------------------------------------
\begin{ccClass}{Demo_Class}
\section{Customization Tags for the Style}

First, a  declaration  with all default substitution rule active.

\ccCreationVariable{pp}

\ccMemberFunction{Demo_Class operator+(const Demo_Class& qq) const;}{%
      member function.}

Second, all rules switched off.
\ccTagFullDeclarations

\ccMemberFunction{Demo_Class operator+(const Demo_Class& qq) const;}{%
      member function.}

Third, back to the default.
\ccTagDefaults

\ccMemberFunction{Demo_Class operator+(const Demo_Class& qq) const;}{%
      member function.}

\end{ccClass}

% ----------------------------------------------------------------------
\section{Test the removal or inlining of template declarations}

Inlining of template declarations. The default is to format the
template declaration in an extra line. Here the default with a struct
and a global function.

\ccSetThreeColumns{template <class T> T*}{X}{}
\ccSetTwoColumns{template <class T> struct circulator_base \{\};}{}
\ccStruct{template <class T> 
          struct circulator_base {};}{forward.}

\begin{ccClass}{Dummy}
\ccCreationVariable{q}
\ccConstructor{template <class T> 
          Dummy();}{constructor.}
\end{ccClass}

\ccGlobalFunction{template <class T> 
  T* value_type( const circulator_base<T>&);}

Here with the inlining on.

\def\ccTagTemplateInline{\ccTrue}
\ccStruct{template <class T> 
          struct circulator_base {};}{forward.}

\begin{ccClass}{Dummy}
\ccCreationVariable{q}
\ccConstructor{template <class T> 
          Dummy();}{constructor.}
\end{ccClass}

\ccGlobalFunction{template <class T> 
  T* value_type( const circulator_base<T>&);}
\def\ccTagTemplateInline{\ccFalse}

Here with the removal on.

\def\ccTagRmTemplate{\ccTrue}
\ccStruct{template <class T> 
          struct circulator_base {};}{forward.}

\begin{ccClass}{Dummy}
\ccCreationVariable{q}
\ccConstructor{template <class T> 
          Dummy();}{constructor.}
\end{ccClass}

\ccGlobalFunction{template <class T> 
  T* value_type( const circulator_base<T>&);}
\def\ccTagRmTemplate{\ccFalse}

% ----------------------------------------------------------------------
\section{A Function Pointer as an Operator Argument}

\begin{ccClassTemplate}{Demo<T>}
\ccCreationVariable{out}
\ccThree{Ascii_ostream&}{out << ostream& (*f)(ostream&);}{}
\ccThreeToTwo

\ccMethod{Ascii_ostream& operator<<(ostream& (*f)(ostream&));}
{manipulators in streams.}

\end{ccClassTemplate}
% ----------------------------------------------------------------------
\end{document}

% EOF %




