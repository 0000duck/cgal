% ___________________________________________________________________________
% |#########################################################################|
% |                                                                         |
% | The Cgal Kernel Reference Manual Style   cc_manual.sty                  |
% | --------------------------------------------------------                |
% |                                                                         |
% | 03.08.1995   Berlin   Lutz Kettner,  started                            |
% | $Revision$                                                       |
% | $Date$                                            |
% |_________________________________________________________________________|
% |#########################################################################|
% |                                                                         |
% | Table of Contents:                                                      |
% |                                                                         |
% |   o   Page Layout and Page Dimensions                                   |
% |   o   Advanced Customization of the Layout                              |
% |   o   Common Abbreviations                                              |
% |   o   Structuring Macros                                                |
% |   o   C++ Declarations                                                  |
% |   o   Class and Class Member Declarations                               |
% |   o   Global C++ Declarations                                           |
% |   o   HTML Language Support in the Style File                           |
% |                                                                         |
% |   o   Internal Macros, not for Usage in the Manual                      |
% |     * Predicates                                                        |
% |     * Toplevel declaration formatting                                   |
% |     * Formatting of simple C++ code                                     |
% |     * Formatting of operator declarations                               |
% |     * Template declaration separation                                   |
% |     * Parameter list parsing                                            |
% |     * Parameter Parsing                                                 |
% |                                                                         |
% |                                                                         |
% |#########################################################################|

{ \catcode`\$=12
  \def\cs #1$#2${\gdef#1{#2}}%
  \cs\ccRevision$Revision$%
  \cs\ccDate$Date$%
}

% debug option, use only for small files!
%\tracingmacros=1


% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Page Layout and Page Dimensions
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | Dimensions (from the LEDA Manual):
% +--------------------------------------------------------------------------
%\hoffset=-0.5truemm \voffset=0.5truecm
%\hsize=16truecm     \vsize=23.5truecm
%\hsize=13.3truecm   \vsize=19.8truecm

\baselineskip 14pt
\spaceskip  .4em plus .25em minus .25em
\xspaceskip .65em
\parskip 11pt plus 1pt minus 1pt
\parindent 0pt


% +--------------------------------------------------------------------------
% | New Dimensions (for the CGAL Manual):
% | Especially to format all multi column declarations.
% |
% | The dimensions \ccFirst and \ccSecond are set to the appropriate 
% | values. Afterwards, the \ccInitWidths does the rest.
% +--------------------------------------------------------------------------

\newdimen\ccwIndent
\newdimen\ccwRightMargin
\newdimen\ccwFirst
\newdimen\ccwFirstLong
\newdimen\ccwSecond
\newdimen\ccwSecondLong
\newdimen\ccwComment
\newdimen\ccwBetween
\newdimen\ccwParam
\newdimen\ccwParamIndent

\newdimen\ccwFunctionFirst
\newdimen\ccwFunctionSecond
\newdimen\ccwConstructorFirst
\newdimen\ccwConstructorSecond

% init them
% ---------
\ccwIndent             = 0pt
\ccwRightMargin        = 0pt
\ccwBetween            = 0.5cm
\ccwParamIndent        = 1.2cm

\ccwFunctionFirst      = 2.5cm
\ccwFunctionSecond     = 4.5cm
\ccwConstructorFirst   = -1\ccwBetween
\ccwConstructorSecond  = 2.5cm

% This initialisation is called prior to each declaration formatting.
% All boxes will be positioned from left. The exception is the comment
% box which will be flushed to the right (minus right margin).
\newcommand{\ccInitWidths}{%
    \ccwFirstLong              = \textwidth
        \advance\ccwFirstLong   -\ccwIndent
        \advance\ccwFirstLong   -\ccwRightMargin
    \ccwSecondLong             = \ccwFirstLong
        \advance\ccwSecondLong  -\ccwFirst
        \advance\ccwSecondLong  -\ccwBetween
    \ccwComment                = \ccwSecondLong
        \advance\ccwComment     -\ccwSecond
        \advance\ccwComment     -\ccwBetween
    \ccwParam                  = \ccwFirst
        \advance\ccwParam        \ccwIndent
        \advance\ccwParam        \ccwBetween
        \advance\ccwParam        \ccwParamIndent
}
\ccInitWidths   

% define macros for the vertical structuring
% ------------------------------------------
\newcommand{\ccTopSkip}{\smallskip}
\newcommand{\ccReverseTopSkip}{\vspace{-\smallskipamount}}
\newcommand{\ccReturnSkip}{\par\hspace*{\ccwIndent}\hspace*{\ccwFirst}%
                      \hspace*{\ccwBetween}}
\newcommand{\ccMiddleSkip}{\par\hspace*{1cm}\hfill} % aligns commentblock 
                                                    % to the right
\newcommand{\ccBottomSkip}{%
    \par\smallskip
    \def\ccTagBottomBigSkipUsed{\ccFalse}%
}
\newcommand{\ccBottomBigSkip}{%
    \par\bigskip
    \def\ccTagBottomBigSkipUsed{\ccTrue}%
}
\newcommand{\ccReverseBottomSkip}{\vspace{-\smallskipamount}}
\newcommand{\ccReverseBottomBigSkip}{\vspace{-\bigskipamount}}

% A macro to glue declarations together
% -------------------------------------
% We have to distinguish between different layouts in 
% \ccLayoutThreeColumns. One uses \ccBottomSkip, one uses 
% \ccBottomBigSkip. The following tag stores the most recently used.
%\newcommand{\ccTagBottomBigSkipUsed}{\ccFalse}
\def\ccTagBottomBigSkipUsed{\ccFalse}

\newcommand{\ccGlueDeclarations}{%
    \ifnum\ccTagBottomBigSkipUsed=\ccTrue
      \ccReverseBottomBigSkip\vspace{-\parskip}%
    \else
      \ccReverseTopSkip\ccReverseBottomSkip\vspace{-\parskip}%
    \fi
}


% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Advanced Customization of the Layout
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | Customization tags for the style: here are the defaults defined.
% +--------------------------------------------------------------------------
\newcommand{\ccTagChapterAuthor}{}    % true -> the author is shown.
\newcommand{\ccTagReplacePrefix}{}    % true -> prefixes are replaced.
\newcommand{\ccTagReplaceInclude}{}   % true -> include file prefixes
                                      % are replaced when 
                                      % \ccTagReplacePrefix is also true.
\newcommand{\ccAlternateThreeColumn}{}% true -> function paramters are aligned
                                      % below the opening paranthesis, else
                                      % they are aligned in a fixed column.

% Declaration Layout tags
\newcommand{\ccTagRmConstRefPair}{}   % true -> removes const & pairs
                                      % when it appearing in parameters
                                      % and return values.
\newcommand{\ccTagRmEigenClassName}{} % true -> removes own class name
                                      % when it appears in parameter list.
\newcommand{\ccTagOperatorLayout}{}   % true -> format operators
\newcommand{\ccTagRmTrailingConst}{}  % true -> trailing const declarat.
                                      % for member fct's are removed.


\newcommand{\ccTagDefaults}{%
    \def\ccTagChapterAuthor{\ccTrue}%
    \def\ccTagReplacePrefix{\ccFalse}%
    \def\ccTagReplaceInclude{\ccFalse}%
    \def\ccAlternateThreeColumn{\ccTrue}%
    % Declaration Layout tags
    \def\ccTagRmTrailingConst{\ccTrue}%
    \def\ccTagRmEigenClassName{\ccTrue}%
    \def\ccTagRmConstRefPair{\ccTrue}%
    \def\ccTagOperatorLayout{\ccTrue}%
    % portability namings
    \def\CCalternateThreeColumn{\ccTrue}%
}

\newcommand{\ccTagFullDeclarations}{%
    \def\ccTagRmTrailingConst{\ccFalse}%
    \def\ccTagRmEigenClassName{\ccFalse}%
    \def\ccTagRmConstRefPair{\ccFalse}%
    \def\ccTagOperatorLayout{\ccFalse}%
}

% portability namings
\newcommand{\CCalternateThreeColumn}{}

% activate defaults
\ccTagDefaults

% +--------------------------------------------------------------------------
% | Customization of the three columns or two columns layout
% |
% |
% +--------------------------------------------------------------------------
\newdimen\ccwTmp

\newcommand{\ccSetTwoOfThreeColumns}[2]{%
                   \global\ccwFunctionFirst=#1
                   \global\ccwFunctionSecond=#2
}
\newcommand{\ccSetThreeColumns}{\begingroup\ccCatcode\ccSetThreeColumnsX}
\def\ccSetThreeColumnsX #1#2{\endgroup\ccSetThreeColumnsXX{#1}{#2}}
\def\ccSetThreeColumnsXX #1#2#3{%
    \isEmpty{#3}\ifnum\ccBool=\ccTrue
        \setbox0=\hbox{\mbox{\ccStyle{#1}}}\setbox1=\hbox{\mbox{\ccStyle{#2}}}%
        \ccSetTwoOfThreeColumns{\wd0}{\wd1}%
    \else\isEmpty{#2}\ifnum\ccBool=\ccTrue
        \setbox0=\hbox{\mbox{\ccStyle{#1}}}\setbox1=\hbox{\mbox{#3}}%
        \ccwTmp=\textwidth 
        \advance\ccwTmp -\wd0
        \advance\ccwTmp -\wd1
        \advance\ccwTmp -\ccwIndent
        \advance\ccwTmp -\ccwRightMargin
        \advance\ccwTmp -\ccwBetween
        \advance\ccwTmp -\ccwBetween
        \ccSetTwoOfThreeColumns{\wd0}{\ccwTmp}%
    \else\isEmpty{#1}\ifnum\ccBool=\ccTrue
        \setbox0=\hbox{\mbox{\ccStyle{#2}}}\setbox1=\hbox{\mbox{#3}}%
        \ccwTmp=\textwidth 
        \advance\ccwTmp -\wd0
        \advance\ccwTmp -\wd1
        \advance\ccwTmp -\ccwIndent
        \advance\ccwTmp -\ccwRightMargin
        \advance\ccwTmp -\ccwBetween
        \advance\ccwTmp -\ccwBetween
        \ccSetTwoOfThreeColumns{\ccwTmp}{\wd0}%
    \else
        \errmessage{\ccSetThreeColumns expects one empty parameter. Go
        ahead, the old settings will remain active.}%
    \fi\fi\fi
}
\newcommand{\ccSetOneOfTwoColumns}[1]{%
                   \global\ccwConstructorSecond=#1
}
\newcommand{\ccSetTwoColumns}{\begingroup\ccCatcode\ccSetTwoColumnsX}
\def\ccSetTwoColumnsX #1{\endgroup\ccSetTwoColumnsXX{#1}}
\def\ccSetTwoColumnsXX #1#2{%
    \isEmpty{#2}\ifnum\ccBool=\ccTrue
        \setbox0=\hbox{\mbox{\ccStyle{#1}}}%
        \ccSetOneOfTwoColumns{\wd0}%
    \else\isEmpty{#1}\ifnum\ccBool=\ccTrue
        \setbox0=\hbox{\mbox{#2}}%
        \ccwTmp=\textwidth 
        \advance\ccwTmp -\wd0
        \advance\ccwTmp -\ccwIndent
        \advance\ccwTmp -\ccwRightMargin
        \advance\ccwTmp -\ccwBetween % \ccwConstructorFirst = -1\ccwBetween
        \ccSetOneOfTwoColumns{\ccwTmp}%
    \else
        \errmessage{\ccSetTwoColumns expects one empty parameter. Go
        ahead, the old settings will remain active.}%
    \fi\fi
}

\newcommand{\ccPropagateThreeToTwoColumns}{%
    \ccwTmp=\ccwFunctionFirst
    \advance\ccwTmp \ccwFunctionSecond
    \advance\ccwTmp \ccwBetween
    \ccSetOneOfTwoColumns{\ccwTmp}%
}

% portability namings
\newcommand{\threecolumns}{\ccSetTwoOfThreeColumns}
\newcommand{\constructorcolumn}{\ccSetOneOfTwoColumns}

% +--------------------------------------------------------------------------
% | \ccMakeAllVisible:
% | The invisible declaratiniol parts in the manual that are written
% | with \ccDeclaration and \ccHidden are made visible with this macro.
% +--------------------------------------------------------------------------
% If these non visible parts of the code should be made visible once,
% the following macro switches it on.
\newcommand{\ccMakeAllVisible}{%
    \renewcommand{\ccDeclaration}{\ccStyle}%
    \renewcommand{\ccHidden}{}%
}

% +--------------------------------------------------------------------------
% | Formatting styles:
% |
% | The style of the C++ formatting can be customized by redefining the 
% | following macros.
% +--------------------------------------------------------------------------
\newcommand{\ccFont}{\it}   % font or style changing command in which all C++
                        % tokens will be typeset, including the variable names.
\newcommand{\ccEndFont}{\/} % will be used after a C++ text. For slanted fonts,
                        % here should stay \/ macro. The C++ code will be
                        % grouped, so this macros has not to restore the old
                        % font.

% The special characters in typical C++ declarations:
\newcommand{\ccOpenAngle }{\ccEndFont {\tt <}}
\newcommand{\ccCloseAngle}{\ccEndFont {\tt >}}
\newcommand{\ccAmpersand }{\ccEndFont {\tt \&}}
\newcommand{\ccUnderscore}{\raisebox{-.05ex}{\_}\kern.05em}
% \newcommand{\ccUnderscore}{\kern.05em\raisebox{.5ex}{\_}\kern-.1em}
\newcommand{\ccHat       }{{\large $\;\,\hat{}\,\,$}}
\newcommand{\ccTilde     }{{\lower.3ex \hbox{\large$\,\tilde{}\,$}}}
\newcommand{\ccHash      }{{\rm \#}}

% The sign for an empty parameter (i.e. of the type of the current class).
\newcommand{\ccEmptyParameter}{$\diamondsuit$}

% Set the catcodes according to the C++ character set (including operators).
\gdef\ccCatcode    {%
              \catcode`\~=12
              \catcode`\_=12
              \catcode`\^=12
              \catcode`\#=12
              \catcode`\%=12 
}

% +--------------------------------------------------------------------------
% | Replacement of Prefixes
% | 
% | \ccSrcPrefix     contains the old prefix
% | \ccTargetPrefix  contains the new prefix
% | 
% | \ccReplacePrefix #1#2  replaces all prefixes in #1 and applies #2 to
% |                        the partial results that have to be terminated
% |                        by \end.
% +--------------------------------------------------------------------------
\gdef\ccSrcPrefix{CGAL}
\gdef\ccTargetPrefix{CGAL}

\newcommand{\ccReplacePrefix}[2]{%
    \edef\ccPair{{\ccSrcPrefix}{\ccTargetPrefix}}%
    \expandafter\ccReplacePrefixX\ccPair{#1}{#2}%
}

% Does the actual work:  #1 is the old prefix
%                        #2 is the new prefix
%                        #3 the text to process
%                        #4 the macro to be applied to the partial results
\def\ccReplacePrefixX #1#2#3#4{%
    \def\repminusone ##1##2\end{%
        \isEmpty{##2}\ifnum\ccBool=\ccFalse
            \rep ##2\end
        \fi
    }%
    % local macro to do the parsing: ##1 is the text before the old prefix
    %                                ##2 is the text after the old prefix
    \def\rep ##1#1##2\end{% set up a recursive loop
           \def\repbody{\rep ##2\end}%
           \isEmpty{##2}\ifnum\ccBool=\ccTrue
               \isEmpty{##1}\ifnum\ccBool=\ccFalse
                   #4##1\end
               \fi
               \let\repnext=\relax
           \else
               % figure out whether it is a real prefix
               \isPrefixFollowChar{##2}\ifnum\ccBool=\ccTrue
                   \isLastAlpha{##1}\ccInvert
               \else\if
               \fi\fi
               \ifnum\ccBool=\ccTrue  % it is a real prefix
                   \isUnderscore{##2}\ifnum\ccBool=\ccTrue
                       \isEmpty{#2}\ifnum\ccBool=\ccTrue
                           \def\repbody{\repminusone ##2\end}%
                       \fi
                       \isEmpty{##1#2}\ifnum\ccBool=\ccFalse
                           #4##1#2\end
                       \fi
                   \else
                       \ifnum\ccTagReplaceInclude=\ccTrue
                           \isEmpty{#2}\ifnum\ccBool=\ccTrue
                               \def\repbody{\repminusone ##2\end}%
                           \fi
                           \isEmpty{##1#2}\ifnum\ccBool=\ccFalse
                               #4##1#2\end
                           \fi
                       \else
                           #4##1#1\end
                       \fi
                   \fi
               \else
                   \isEmpty{##1#1}\ifnum\ccBool=\ccFalse
                       #4##1#1\end
                   \fi
               \fi
               \let\repnext=\repbody
           \fi
           \repnext
    }%
    % call the above definition with at least one old prefix
    \rep #3#1\end
}

% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Common Abbreviations
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | A handy macro to define macros for RCS entries in a TeX file
% +--------------------------------------------------------------------------
%   #1  the macro name for the RCS entry
%   #2  the RCS entry
\newcommand{\RCSdef}{\begingroup\catcode`\$=12 \RCSdefSet}
{ \catcode`\$=12
    \gdef\RCSdefSet #1$#2${\gdef#1{#2}\endgroup}%
}

% +--------------------------------------------------------------------------
% | Original LEDA Manual macros (shortcuts):
% | Several new shortcuts for CGAL
% |
% | \CC, \gcc, \nat, \real, \boxit
% | \leda, \cgal, \protocgal, \plageo
% +--------------------------------------------------------------------------
% selfmade
\newcommand{\CC}{C\raise.08ex\hbox{\tt ++}}
\newcommand{\gcc}{g\hbox{\tt ++}}
\newcommand{\nat}{\hbox{\rm I\kern-0.045em N}}
\newcommand{\real}{\hbox{\rm I\kern-0.035em R}}
% \def\boxit#1{\vbox{\hrule\hbox{\vrule\kern3pt\vbox{#1}\kern3pt\vrule}\hrule}}
% (older) AMS-TeX style
\newcommand{\R}{\mbox{$\mathbb R$}}  %% zusammen mit usepackage{amssymb}
\newcommand{\N}{\mbox{$\mathbb N$}}  %% zusammen mit usepackage{amssymb}
\newcommand{\Z}{\mbox{$\mathbb Z$}}  %% zusammen mit usepackage{amssymb}
\newcommand{\Q}{\mbox{$\mathbb Q$}}  %% zusammen mit usepackage{amssymb}
\newcommand{\E}{\mbox{$\mathbb E$}}  %% zusammen mit usepackage{amssymb}
% actual AMS-TeX style (according to Kopka LaTeX Ergaenzungsband S.92)
%\def\R{\mbox{$\Bbb{R}$}}  %% zusammen mit usepackage{amssymb}
%\def\N{\mbox{$\Bbb{N}$}}  %% zusammen mit usepackage{amssymb}
%\def\Z{\mbox{$\Bbb{Z}$}}  %% zusammen mit usepackage{amssymb}
%\def\Q{\mbox{$\Bbb{Q}$}}  %% zusammen mit usepackage{amssymb}
%\def\E{\mbox{$\Bbb{E}$}}  %% zusammen mit usepackage{amssymb}

\newcommand{\leda}{{\sc Leda}}
\newcommand{\cgal}{{\sc Cgal}}
\newcommand{\protocgal}{{\sc C++gal}}
\newcommand{\plageo}{{\sc Plageo}}

% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Structuring Macros
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | Structuring macros (similar to LEDA Manual):
% |
% | \ccSection, \definition, \constants, \types, \creation, \operations, 
% | \implementation, \example, \precond, \postcond, \chapterauthor
% +--------------------------------------------------------------------------

\newcommand{\ccChapterAuthor}[1]{%
    \ifnum\ccTagChapterAuthor=\ccTrue
        \noindent\setlength{\unitlength}{1mm}%
        \begin{picture}(0,0)% 
            \put(0,11){{\em #1}}%
        \end{picture}%
    \fi}

\newcommand{\ccSection}[1]{%
                   \section[#1 (\protect\ccPrintSingleTokenSemi
                   \ccPureClassName;)]{#1 (\ccClassName)}
                   \label{#1}}

\newcommand{\ccSubsection}[1]{%
                   \subsection[#1 (\protect\ccPrintSingleTokenSemi
                           \ccPureClassName;)]{#1 (\ccClassName)}
                   \label{#1}}

\newcommand{\ccHeading}[1]{\bigskip\pagebreak[1]
                    {\bf #1}
                    \par\nopagebreak }
\newcommand{\ccCommentHeading}[1]{\par{\it #1}: }


\newcommand{\ccDefinition     }{\ccHeading{Definition}}
\newcommand{\ccParameters     }{\ccHeading{Parameters}}
\newcommand{\ccConstants      }{\ccHeading{Constants}}
\newcommand{\ccTypes          }{\ccHeading{Types}}
\newcommand{\ccCreation       }{\ccHeading{Creation} }
\newcommand{\ccOperations     }{\ccHeading{Operations}}
\newcommand{\ccImplementation }{\ccHeading{Implementation}}
\newcommand{\ccExample        }{\ccHeading{Example}}

\newcommand{\ccPrecond  }{\ccCommentHeading{Precondition}}
\newcommand{\ccPostcond }{\ccCommentHeading{Postcondition}}

% portability namings
\newcommand{\cgalheading}[1]{\ccHeading{#1}}
\newcommand{\cgalcommentheading}[1]{\ccCommentHeading{#1}}
\newcommand{\definition     }{\ccDefinition}
\newcommand{\parameters     }{\ccParameters}
\newcommand{\constants      }{\ccConstants}
\newcommand{\types          }{\ccTypes}
\newcommand{\creation       }{\ccCreation}
\newcommand{\operations     }{\ccOperations}
\newcommand{\implementation }{\ccImplementation}
\newcommand{\example        }{\ccExample}
\newcommand{\precond  }{\ccPrecond}
\newcommand{\postcond }{\ccPostcond}

% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   C++ Declarations
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | \ccStyle
% +--------------------------------------------------------------------------
% Print one parameter in C++ style (including spaces).
\newcommand{\ccStyle}{%
                       \begingroup\ccCatcode\ccStyleX
}
\def\ccStyleX #1{%
                       {\ccFont \ccPrintTokens #1\end\ccEndFont}\endgroup
}

% portability namings
\newcommand{\CCstyle}{\ccStyle}

% +--------------------------------------------------------------------------
% | \ccDeclaration, \ccHidden, \ccUnchecked
% +--------------------------------------------------------------------------
% A \declaration accepts one parameter. The style will ignore it, while
% the checker tests if it exists one to one in the C++ code.
% It is intended for declarations that are somehow implied by the
% surrounded text, but should not be explicitly visible.
\newcommand{\ccDeclaration}{\begingroup\ccCatcode\ccDeclarationX}
\def\ccDeclarationX #1{\endgroup}

% A \hidden macro can be prepended to each macro with two parameters.
% It will remove the macro and its parameters from the manual.
% Again, the checker tests the macro as usual.
\newcommand{\ccHidden}[1]{\begingroup\ccCatcode\ccHiddenX}
\def\ccHiddenX #1{\endgroup\ccHiddenXX}
\long\def\ccHiddenXX #1{}

% An \ccUnchecked macro expands to nothing. It is used by the checker tool
% where it denotes that the following declarations is not subject of any
% check.
\newcommand{\ccUnchecked}{}

% +--------------------------------------------------------------------------
% | \ccGlobalDecl, \ccGlobalContinuation for global declarations
% +--------------------------------------------------------------------------
% \ccGlobalContinuation and \ccGlobalDecl is used to fiddle an empty 
% comment behind the other parameters of a declaration without parsing
% these parameters as arguments (the catcodes are not set yet).
% Compare the normal and the global version of a declaration macro.
\newcommand{\ccGlobalDecl}{\ccFalse}
\newcommand{\ccGlobalContinuation}[1]{%
                       \ifnum\ccGlobalDecl=\ccTrue
                           \def\ccLocalCont{#1{}}
                           \let\continuation=\ccLocalCont
                       \else
                           \def\ccLocalCont{#1}
                           \let\continuation=\ccLocalCont
                       \fi
                       \gdef\ccGlobalDecl{\ccFalse}
                       \continuation
                     }

% +--------------------------------------------------------------------------
% portability namings
\newcommand{\declaration}{\ccDeclaration}
\newcommand{\hidden}{\ccHidden}
\newcommand{\unchecked}{\ccUnchecked}

% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Class and Class Member Declarations
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | \ccClassName, \ccClassTemplateName, \ccVar, \ccPur...
% | \begin{ccClass}, \begin{ccClassTemplate}, \end...
% +--------------------------------------------------------------------------
% predeclare variable names
\newcommand{\ccClassName}{}
\newcommand{\ccClassTemplateName}{}
\newcommand{\ccTemplateParameters}{}
\newcommand{\ccVar}{}
\newcommand{\ccPureClassName}{}
\newcommand{\ccPureClassTemplateName}{}
\newcommand{\ccPureTemplateParameters}{}
\newcommand{\ccPureVar}{}


\newenvironment{ccClass}{%
                   \begingroup\ccCatcode
                   \ccClassX%
               }{
                   \def\ccPureClassName{}%
                   \def\ccPureClassTemplateName{}%
                   \def\ccPureTemplateParameters{}
                   \renewcommand{\ccClassName}{}%
                   \renewcommand{\ccClassTemplateName}{}%
                   \renewcommand{\ccTemplateParameters}{}
                   \def\ccPureVar{}%
                   \renewcommand{\ccVar}{}%
               }

\def\ccClassX #1{%
                   \endgroup
                   \ccClassXX #1<\end}


\def\ccClassXX #1<#2\end{%
                   \def\xparams{#2}\ifx\xparams\empty
                       \ccClassXXX{#1}%
                   \else
                       \errmessage{Template parameters are not allowed
                         in a normal class. Use \begin{classtemplate}
                         instead}>%
                       \ccClassXXX{#1<???>}%
                   \fi}

\def\ccClassXXX #1{%
                   \def\ccPureClassName{#1}%
                   \def\ccPureClassTemplateName{#1}%
                   \renewcommand{\ccClassName}{\hbox{{\ccFont 
                           \ccPrintTokens #1\end\ccEndFont}}}%
                   \renewcommand{\ccClassTemplateName}{\hbox{{\ccFont
                           \ccPrintTokens #1\end\ccEndFont}}}%
               }

\newenvironment{ccClassTemplate}{%
                   \begingroup\ccCatcode
                   \ccClassTemplateX%
               }{
                   \def\ccPureClassName{}%
                   \def\ccPureClassTemplateName{}%
                   \def\ccPureTemplateParameters{}%
                   \renewcommand{\ccClassName}{}%
                   \renewcommand{\ccClassTemplateName}{}%
                   \renewcommand{\ccTemplateParameters}{}
                   \def\ccPureVar{}%
                   \renewcommand{\ccVar}{}%
               }

\def\ccClassTemplateX #1{%
                   \endgroup
                   \ccClassTemplateXX #1<\end}

\def\ccClassTemplateXX #1<#2\end{%
                   \def\xparams{#2}\ifx\xparams\empty
                       \errmessage{Template parameters missed for
                         class template}>%
                       \ccClassTemplateXXX{#1}<???><\end%
                   \else
                       \ccClassTemplateXXX{#1}<#2\end%
                   \fi}

\def\ccClassTemplateXXX #1#2<\end{%
                   \def\ccPureClassName{#1}%
                   \def\ccPureClassTemplateName{#1#2}%
                   \def\ccPureTemplateParameters{#2}%
                   \renewcommand{\ccClassName}{\hbox{{\ccFont
                           \ccPrintTokens #1\end\ccEndFont}}}%
                   \renewcommand{\ccClassTemplateName}{\hbox{{\ccFont
                           \ccPrintTokens #1#2\end\ccEndFont}}}%
                   \renewcommand{\ccTemplateParameters}{\hbox{{\ccFont
                           \ccPrintTokens #2\end\ccEndFont}}}%
               }

% +--------------------------------------------------------------------------
% | \ccCreationVariable, \ccConstructor
% +--------------------------------------------------------------------------
\newcommand{\ccCreationVariable}{%
                   \begingroup\ccCatcode\ccCreationVariableX}

\def\ccCreationVariableX #1{%
                   \endgroup
                   \renewcommand{\ccVar}{{\ccFont\ccPrintTokens #1\end
                                          \ccEndFont}}%
                   \def\ccPureVar{#1}}

\newcommand{\ccConstructor}{%
                   \begingroup\ccCatcode\ccConstructorX}

\def\ccConstructorX #1{%
                   \endgroup
                   \ccConstructorXX{#1}}

\long\def\ccConstructorXX #1#2{%
                   \ccConstructorCall {#2}#1\end}

% +--------------------------------------------------------------------------
% | \ccMemberFunction, \ccMethod, \ccFunction, \ccFunctionTemplate
% +--------------------------------------------------------------------------
% Methods and functions can contain the active character or the comment
% character % of TeX's own character set. Therefore, we assign new
% \catcode values to them and parse the first argument after that, close
% the group and parse the second argument with the \ccFunctionComment macro.
\newcommand{\ccMethod}{\ccMemberFunction}
\newcommand{\ccMemberFunction}{%
                       \begingroup\ccCatcode
                       \ccFunctionX{0}}
\newcommand{\ccFunction}{%
                       \begingroup\ccCatcode
                       \ccFunctionX{1}}

\def\ccFunctionX #1#2{%
                       \endgroup
                       \ccGlobalContinuation{\ccFunctionComment{#1}{#2}}}

\long\def\ccFunctionComment #1#2#3{%
                       \ccFunctionCall{#1}{#3}#2;\end}

% Is getting obsolete!
% A three! parameter macro to format template functions
%   o  The 1st parameter contains the template parameters.
%   o  The 2nd parameter contains the function declaration.
%   o  The 3rd parameter contains the comment.
\newcommand{\ccFunctionTemplate}[1]{\ccFunction}

% +--------------------------------------------------------------------------
% | \ccTypedef, \ccNestedType, \ccVariable, \ccEnum, \ccStruct
% +--------------------------------------------------------------------------
% typedef's, variables, and constants are like functions without parameters.
\newcommand{\ccVariable}{%
                       \begingroup\ccCatcode
                       \ccVariableX
}
\def\ccVariableX #1{%
                       \endgroup
                       \ccGlobalContinuation{\ccVariableXX{#1}}%
}
\long\def\ccVariableXX #1#2{%
                       \ccVariableDeclaration{#2}#1;\end
}
\newcommand{\ccTypedef}{\ccVariable}

\newcommand{\ccNestedType}{%
                       \begingroup\ccCatcode
                       \ccNestedTypeX
}
\def\ccNestedTypeX #1{%
                       \endgroup
                       \ccGlobalContinuation{%
                           \ccNestedTypeXX{#1}}%
}
\long\def\ccNestedTypeXX #1#2{%
                       \ccwFirst  =\ccwConstructorFirst
                       \ccwSecond =\ccwConstructorSecond
                       \ccInitWidths
                       \setbox\returntypebox=\hbox{}%
                       \setbox\callnamebox=\hbox{\ccClassTemplateName
                           \ccFont\ccPrintTokens ::\end}%
                       \setbox\functioncallbox=\hbox{\unhcopy\callnamebox
                           \ \ccFont\ccPrintTokens #1\end}
                       \ccLayoutThreeColumns{}{}{}{#2}%
                     }
% Enum's are formatted like constructors. There is exact one matching
% pair of braces in the declaration.
\newcommand{\ccEnum}{%
                   \begingroup\ccCatcode
                   \catcode`\[=1
                   \catcode`\]=2
                   \catcode`\{=12
                   \catcode`\}=12
                   \ccEnumX}

\begingroup
\catcode`\[=1
\catcode`\]=2
\catcode`\{=12
\catcode`\}=12
\gdef\ccEnumX {#1{#2}#3}[%
                   \endgroup
                   \ccGlobalContinuation[\ccEnumXX[#1\{#2\}#3]]]
\endgroup

\long\def\ccEnumXX #1#2{%
                   \ccEnumDeclaration {#2}#1\end}

% a struct is formatted like an enum (needs the parantheses parsing)
\newcommand{\ccStruct}{%
                   \begingroup\ccCatcode
                   \catcode`\[=1
                   \catcode`\]=2
                   \catcode`\{=12
                   \catcode`\}=12
                   \ccEnumX}

% +--------------------------------------------------------------------------
% portability namings
\newcommand{\pureclassname}{\ccPureClassName}
\newcommand{\puretemplatename}{\ccPureClassTemplateName}
\newcommand{\pureclasstemplatename}{\ccPureClassTemplateName}
\newcommand{\pureparameters}{\ccPureTemplateParameters}
\newcommand{\puretemplateparameters}{\ccPureTemplateParameters}
\newcommand{\classname}{\ccClassName}
\newcommand{\classtemplatename}{\ccClassTemplateName}
\newcommand{\purevar}{\ccPureVar}
\newcommand{\var}{\ccVar}

\newenvironment{class}{\begin{ccClass}}{\end{ccClass}}
\newenvironment{classtemplate}{\begin{ccClassTemplate}}{\end{ccClassTemplate}}

\newcommand{\creationvariable}{\ccCreationVariable}
\newcommand{\constructor}{\ccConstructor}
\newcommand{\method}{\ccMethod}
\newcommand{\function}{\ccFunction}
\newcommand{\functiontemplate}{\ccFunctionTemplate}
\newcommand{\variable}{\ccVariable}
\newcommand{\typedef}{\ccTypedef}
\newcommand{\nestedtype}{\ccNestedType}
\newcommand{\enum}{\ccEnum}
\newcommand{\struct}{\ccStruct}


% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Global C++ Declarations
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% | \ccGlobalFunction, \ccGlobalFunctionTemplate, \ccGlobalEnum, 
% | \ccGlobalTypedef, \ccGlobalVariable
% +--------------------------------------------------------------------------
% All simple macros work also at the global level. The following
% `global' versions are only shortcuts to omit the comment parameter,
% so that global declarations are always commented inbetween and not in
% the last column. Note hat declarations always can extend in the last
% column, so the previous column has not to be reshaped.

\newcommand{\ccGlobalFunction}{\gdef\ccGlobalDecl{\ccTrue}\ccFunction}
\newcommand{\ccGlobalFunctionTemplate}{%
                               \gdef\ccGlobalDecl{\ccTrue}\ccFunctionTemplate}
\newcommand{\ccGlobalEnum    }{\gdef\ccGlobalDecl{\ccTrue}\ccEnum}
\newcommand{\ccGlobalStruct  }{\gdef\ccGlobalDecl{\ccTrue}\ccStruct}
\newcommand{\ccGlobalVariable}{\gdef\ccGlobalDecl{\ccTrue}\ccVariable}
\newcommand{\ccGlobalTypedef }{\gdef\ccGlobalDecl{\ccTrue}\ccTypedef}


% +--------------------------------------------------------------------------
% portability namings
\newcommand{\globalfunction}{\ccGlobalFunction}
\newcommand{\globalfunctiontemplate}{\ccGlobalFunctionTemplate}
\newcommand{\globalenum}{\ccGlobalEnum}
\newcommand{\globalstruct}{\ccGlobalStruct}
\newcommand{\globalvariable}{\ccGlobalVariable}
\newcommand{\globaltypedef}{\ccGlobalTypedef}


% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   HTML Language Support in the Style File
% |
% ###########################################################################

% +--------------------------------------------------------------------------
% | Support macros for HTML manual generation:
% |
% | \begin{ccTexOnly}..., \begin{ccHtmlOnly}..., \ccTexHtml{}{}, \ccAnchor{}{}
% +--------------------------------------------------------------------------

\newcommand{\ccHtmlCatcode}{%
                       \ccCatcode
                       \catcode`\{=12
                       \catcode`\}=12
                       \catcode`\\=12
                  }
\newcommand{\ccHtmlDefCatcode}{%
                       \catcode`\|=0
                       \catcode`\[=1
                       \catcode`\]=2
                       \catcode`\{=12
                       \catcode`\}=12
                       \catcode`\\=12
                  }

\newcommand{\ccTexHtml}[2]{#1}
\newcommand{\ccAnchor}[2]{#2}
\newenvironment{ccTexOnly}{}{}
\newenvironment{ccHtmlOnly}{\begingroup\ccHtmlCatcode \ccParseHtmlOnlyBody}{
                            \endgroup}

%  Take care: catcodes changes a lot here!!
\begingroup
\ccHtmlDefCatcode
|gdef|ccParseHtmlOnlyBody #1\end{ccHtmlOnly}[%
  |csname endccHtmlOnly|endcsname|@checkend[ccHtmlOnly]%
  |expandafter|endgroup|if@endpe|@doendpe|fi
  |if@ignore|global|@ignorefalse|ignorespaces|fi
]
|endgroup


% portability namings
\newcommand{\LatexHtml}{\ccTexHtml}
\newcommand{\Anchor}{\ccAnchor}
\newenvironment{TexOnly}{\begin{ccTexOnly}}{\end{ccTexOnly}}
\newenvironment{HtmlOnly}{\begingroup\ccHtmlCatcode \ParseHtmlOnlyBody}{
                          \endgroup}
%  Take care: catcodes changes a lot here!!
\begingroup
\ccHtmlDefCatcode
|gdef|ParseHtmlOnlyBody #1\end{HtmlOnly}[%
  |csname endHtmlOnly|endcsname|@checkend[HtmlOnly]%
  |expandafter|endgroup|if@endpe|@doendpe|fi
  |if@ignore|global|@ignorefalse|ignorespaces|fi
]
|endgroup


% ___________________________________________________________________________
% ###########################################################################
% |
% |   o   Internal Macros, not for Usage in the Manual
% |
% ###########################################################################
% +--------------------------------------------------------------------------
% |     * Predicates:
% +--------------------------------------------------------------------------
% | isEmpty, isLetter, isUnderscore, hasLeadingSpace, isTemplate,
% | isLastAlpha, isOperator, isParenthesisOperator, isConversionOperator
% |
% | All predicates uses pattern matching of TeX. The original predicate uses
% | a single parameter that should be in braces like in LaTeX. Internally,
% | they use a second, auxiliary macro with pattern matching where the
% | parameter has to be terminated by an \end token.
% |
% | Result is stored in the counter \ccBool. \ccFalse, \ccTrue are also
% | counters that are used in the \ifnum statement to test the result.
% +--------------------------------------------------------------------------

% The counter \ccBool contains the result of a couple of predicates
\newcount\ccBool              % either 0 for false or 1 for true.
\newcount\ccFalse \ccFalse=0  % This must be constant 0 !!!
\newcount\ccTrue  \ccTrue=1   % This must be constant 1 !!!

% A small macro to invert \ccBool
\def\ccInvert {%
    \ifnum\ccBool=\ccFalse \ccBool=\ccTrue \else\ccBool=\ccFalse \fi}

% This macro test wheather its argument is empty or contains only spaces.
\def\isEmpty #1{%
    \isEmptyX #1;\end}
\def\isEmptyX #1#2\end{%
   \def\xparams{#2}\ifx\xparams\empty \ccBool=\ccTrue
       \else \ccBool=\ccFalse \fi}

% This macro test wheather its argument starts (after leading spaces)
% with a valid C++ letter.
\def\isLetter #1{%
    \def\qparams{#1}\ifx\qparams\empty\ccBool=\ccFalse 
        \else\isLetterX #1\end\fi}
\def\isLetterX #1#2\end{%
    \ccBool=\ccFalse
    \ifx#1\_\ccBool=\ccTrue\else
    \ifcat#1A\ccBool=\ccTrue
    \else\ifnum`#1>`/\ifnum`#1<`:\ccBool=\ccTrue \fi\fi
        \if#1_\ccBool=\ccTrue \fi
    \fi\fi}

% Test for a leading underscore, either _ with changed catcode, or \_
\def\isUnderscore #1{%
    \def\qparams{#1}\ifx\qparams\empty\ccBool=\ccFalse 
        \else\isUnderscoreX #1\end\fi}
\def\isUnderscoreX #1#2\end{%
    \ccBool=\ccFalse
    \ifx#1\_\ccBool=\ccTrue\else
        \if#1_\ccBool=\ccTrue \fi
    \fi}

% Test for a leading underscore, either _ with changed catcode, or \_,
% or the / character. Used to validate the character after a prefix.
\def\isPrefixFollowChar #1{%
    \def\qparams{#1}\ifx\qparams\empty\ccBool=\ccFalse 
        \else\isPrefixFollowCharX #1\end\fi}
\def\isPrefixFollowCharX #1#2\end{%
    \ccBool=\ccFalse
    \ifx#1\_\ccBool=\ccTrue\else
        \if#1_\ccBool=\ccTrue \else
            \if#1/\ccBool=\ccTrue\fi
        \fi
    \fi}

% These macros allow the characterwise parsing of an argument, where normally
% the spaces are ignored.
% Here, the first macro can be applied to the rest of the argument and 
% will return \ccTrue in the \ccBool iff the rest starts with a space.
% The second macro will produce a space "\ " iff the rest starts with a space.
% The space of the rest will be skipped automatically in the next round.
\def\hasLeadingSpace #1{%
    \def\qparams{#1}\ifx\qparams\empty\ccBool=\ccFalse 
        \else\compareSpace{#1}#1\end\fi}
\def\compareSpace #1#2#3\end{%
   \def\xxparams{#1}\def\xxxparams{#2#3}\ifx\xxparams\xxxparams\ccBool=\ccFalse
       \else\ccBool=\ccTrue \fi}
\def\testAndCopySpace #1{%
    \def\qparams{#1}\ifx\qparams\empty\else\compareAndCopySpace{#1}#1\end\fi}
\def\compareAndCopySpace #1#2#3\end{%
    \def\xxparams{#1}\def\xxxparams{#2#3}\ifx\xxparams\xxxparams\else\ \fi}

% This macro gets a complete C++ declaration and decides weather
% it starts with a template declaration or not.
\def\isTemplate #1{%
    \isTemplateX #1template\end}
    % Note: these macros has to test for characters directly following
    % the template keyword, because it is allowed as an identifier substring.
\def\isTemplateX #1template#2\end{%
    \isEmpty{#2}\ifnum\ccBool=\ccTrue \ccBool=\ccFalse
    \else\hasLeadingSpace{#2}\ifnum\ccBool=\ccFalse
            \isLetter{#2}\ccInvert
        \fi
    \fi
    \ifnum\ccBool=\ccTrue
        \isEmpty{#1}%
    \fi}

% This macro gets a complete C++ declaration and decides weather
% it is an operator declaration or not.
\def\isOperator #1{%
    \isOperatorX #1operator\end}
    % Note: these macros has to test for characters directly surrounding
    % the operator keyword, because it is allowed as an identifier substring.
\def\isOperatorX #1operator#2\end{%
    \isEmpty{#2}\ifnum\ccBool=\ccTrue \ccBool=\ccFalse
    \else\hasLeadingSpace{#2}\ifnum\ccBool=\ccFalse
            \isLetter{#2}\ccInvert
        \fi
    \fi
    \ifnum\ccBool=\ccTrue
        \isEmpty{#1}\ifnum\ccBool=\ccFalse
            \isLastAlphaX #1\end \ccInvert
        \fi
    \fi}

% Check the last character in the parameter. If it is a character (or _) 
% return \ccTrue, else return \ccFalse. 
\def\isLastAlpha #1{%
    \isEmpty{#1}\ifnum\ccBool=\ccTrue\ccInvert
                \else\isLastAlphaX #1\end
    \fi}
\def\isLastAlphaX #1#2\end{%
    \def\xbody{\isLastAlphaX #2\end}%
    \isLetterX #1\end 
    \def\qqparams{#2}\ifx\qqparams\empty\let\xnext=\relax
    \else\isEmpty{#2}\ifnum\ccBool=\ccTrue \ccInvert
            \let\xnext=\relax
        \else
            \let\xnext=\xbody
        \fi
    \fi
    \xnext}

% This macro gets a complete C++ declaration for an operator and has to
% decide weather it is the parenthesis () operator declaration or not.
\def\isParenthesisOperator #1{%
    \isParenthesisOperatorX #1 ()\end}
\def\isParenthesisOperatorX #1operator#2(#3)#4(#5)#6\end{%
    % if and only if #6 is non empty, we have the () operator.
    \isEmpty{#6}\ccInvert}
    
% This macro gets a complete C++ declaration for an operator and has to
% decide weather it is the conversion operator declaration or not.
\def\isConversionOperator #1{%
    \isConversionOperatorX #1\end}
\def\isConversionOperatorX #1operator#2\end{%
    % if and only if #1 is empty, we have the conversion operator.
    \isEmpty{#1}}
    

% +--------------------------------------------------------------------------
% |     * Toplevel declaration formatting:
% +--------------------------------------------------------------------------
% | Here, constructors, methods, and functions are separated in there
% | building blocks: the return type, their name, and the parameter
% | list. An operator declaration will be detected.
% +--------------------------------------------------------------------------
% This box contains the formatting result. Its width influences the
% column layout for longish declarations.
\newbox\functioncallbox

\newbox\returntypebox     % contains the return type
\newbox\functionnamebox   % contains the function name
\newbox\callnamebox       % contains the fct. name incl. variable for methods
\newbox\trailingconstbox  % contains the trailing const after member functions
                          % or is empty according to \ccTagRmTrailingConst


% Formats a constructor call.
%   o  The 1st parameter contains the comment text (maybe empty).
%   o  The 2st parameter contains the name of the constructor
%   o  The 3rd parameter contains the parameter list (maybe empty).
%   o  The 4th parameter contains the optional const specifier for methods.
% The declaration has to be terminated with "\end".
\def\ccConstructorCall #1#2(#3)#4\end {%
                       % check for template function
                       \isTemplate{#2}\ifnum\ccBool=\ccTrue
                           \ccSeparateTemplate{\ccTemplateLine}{%
                               \constructorcall{#1}}#2(#3)#4\end
                       \else
                         \ccwFirst  =\ccwConstructorFirst
                         \ccwSecond =\ccwConstructorSecond
                         \ccInitWidths
                         \setbox\callnamebox=\hbox{%
                             \ccClassTemplateName\ \ \ccFont\ccVar}%
                         \setbox\functioncallbox=\hbox{\unhcopy\callnamebox
                                   \isEmpty{#3}\ifnum\ccBool=\ccFalse
                                       \ccFont( \ccPrintParamList{#3)#4}%
                                         \ccEndFont)%
                                   \fi
                                   ;}%
                         \setbox\returntypebox=\hbox{}%
                         \ccLayoutThreeColumns{(}{#3)#4}{)}{#1}%
                       \fi
                     }

% Formats a method or a function call.
%   o  The 1st parameter contains a 0 for a method call, a 1 for a function.
%   o  The 2nd parameter contains the comment text (maybe empty).
%   o  The 3rd parameter contains the beginning of the type declaration.
%   o  The 4th parameter contains the rest of the type and the function name.
%   o  The 5th parameter contains the parameter list (maybe empty).
%   o  The 6th parameter contains the optional const specifier for methods.
% The declaration has to be terminated with ";;\end" where the first ";"
% has to be from the original call notation. The 7th parameter is there
% to check for this ";".
\def\ccFunctionCall #1#2#3 #4(#5)#6;#7\end{%
                       \ccwFirst  =\ccwFunctionFirst
                       \ccwSecond =\ccwFunctionSecond
                       \ccInitWidths
                       \def\xparam{#7}\ifx\xparam\empty
                           \errmessage{Missing ";" at the end of the 
                           declaration. A method or function
                           declaration has to end with a ";". 
                           Go ahead, I've inserted one}%
                       \fi
                       % check for template function
                       \isTemplate{#3 #4}\ifnum\ccBool=\ccTrue
                           \ccSeparateTemplate{\ccTemplateLine}{%
                               \ccFunctionCall{#1}{#2}}#3 #4(#5)#6;#7\end
                       \else
                       \def\ccExtendedFormat{\ }% Switches ext. format OFF.
                       \ccSeparateTrailingConst #6)\end
                       \ccBool=\ccTagOperatorLayout\ifnum\ccBool=\ccTrue
                         \isOperator{#3 #4(#5)#6}\ifnum\ccBool=\ccTrue
                           \isConversionOperator{#3 #4(#5)#6}
                           \ifnum\ccBool=\ccTrue
                               \ccPrintConversionOperator #3 #4(#5)#6\end
                           \else
                               \ccSeparateOperator #3 #4\end%
                               \isParenthesisOperator{#3 #4(#5)#6}%
                               \ifnum\ccBool=\ccTrue
                                   \setbox\functioncallbox=\hbox{{\ccFont 
                                       \ccPrintParOperator #1#3 #4(#5)#6\end}}
                               \else
                                   \setbox\functioncallbox=\hbox{{\ccFont 
                                       \ccPrintOperator #1#3 #4(#5)#6\end}}
                               \fi
   
                           \fi
                           \ccBool=\ccTrue
                         \fi
                       \fi
                       \ifnum\ccBool=\ccFalse
                           \ccSeparateFunction{}#3 #4::\end%
                           \setbox\functioncallbox=\hbox{{\ccFont
                               \ifnum#1=0 \ccVar.\fi
                               \unhcopy\functionnamebox(% 
                               \isEmpty{#5}\ifnum\ccBool=\ccFalse
                                   \ \ccPrintParamList{#5)#6}%
                               \fi)\unhcopy\trailingconstbox}}
                       \fi
                       \setbox\callnamebox=\hbox{{\ccFont
                           \ifnum#1=0 \ccVar.\fi
                           \unhbox\functionnamebox}}%
                       \ccLayoutThreeColumns{(}{#5)#6}{)\unhbox
                           \trailingconstbox}{#2}%
                       \fi % from \isTemplate
                     }

\def\ccExtendedFormat{\ }% Default: Extended Format switched OFF.

% Formats a variable, typedef or constant.
%   o  The 1st parameter contains the comment text (maybe empty).
%   o  The 2nd parameter contains the beginning of the type declaration.
%   o  The 3rd parameter contains the rest of the type and the function name.
% The declaration has to be terminated with ";;\end" where the first ";"
% has to be from the original call notation. The 4th parameter is there
% to check for this ";".
\def\ccVariableDeclaration #1#2 #3;#4\end{%
                       \ccwFirst  =\ccwFunctionFirst
                       \ccwSecond =\ccwFunctionSecond
                       \ccInitWidths
                       \def\xparam{#4}\ifx\xparam\empty
                           \errmessage{Missing ";" at the end of the 
                           declaration. A variable, typedef, or constant
                           declaration has to end with a ";". 
                           Go ahead, I've inserted one}%
                       \fi
                       \ccSeparateVariable #2 #3=\end%
                       \setbox\functioncallbox=\hbox{{\ccFont
                           \unhcopy\functionnamebox;}}
                       \setbox\callnamebox=\hbox{{\ccFont
                           \unhbox\functionnamebox}}%
                       \ccLayoutThreeColumns{}{}{}{#1}%
                     }

\def\ccSeparateVariable #1 #2=#3\end{%
                       \ccSeparateFunction{}#1 #2::\end%
                       \def\xparam{#3}\ifx\xparam\empty
                       \else
                           \ccSeparateVariableX #3\end
                       \fi
                     }
\def\ccSeparateVariableX #1=\end{%
                     {\setbox0=\hbox{\unhbox\functionnamebox\ =#1}%
                      \global\setbox\functionnamebox=\hbox{\unhbox0}}%
                    }

% Formats a enum declaration.
%   o  The 1st parameter contains the comment text (maybe empty).
%   o  The 2st parameter contains the `enum' keyword name.
%   o  The 3rd parameter contains the parameter list (maybe empty).
%   o  The 4th parameter contains an optional variable name.
% The declaration has to be terminated with "\end".
\def\ccEnumDeclaration #1#2\{#3\}#4\end {%
                       \ccwFirst  =\ccwConstructorFirst
                       \ccwSecond =\ccwConstructorSecond
                       \ccInitWidths
                       \setbox\returntypebox=\hbox{}%
                       \setbox\callnamebox=\hbox{\ccFont\ccPrintTokens #2\end}%
                       \setbox\functioncallbox=\hbox{\ccFont
                                 \ccPrintTokens #2\end\{\
                                 \isEmpty{#3}\ifnum\ccBool=\ccFalse
                                     \ccPrintParamList{#3)}%
                                 \fi
                                 \};}%
                       \ccLayoutThreeColumns{\ccEndFont\{}{#3)}{\ccEndFont\}}{#1}%
                     }

% Manual layout: generalized three column format
%   o  The 1st parameter contains the opening brace.
%   o  The 2nd parameter contains the parameter list, comma separated,
%        including the closing parantheses which will not be printed.
%   o  The 3rd parameter contains the closing brace. 
%   o  The 4th parameter contains the comment.
% All paramters might be empty.
% Global variables:
%   o  \returntypebox    contains the formatted returntype (maybe empty)
%   o  \callnamebox      contains the function/method/constructorname.
%                        For methods, the variable is just prepended.
%   o  \functioncallbox  contains the complete functioncall incl. parameters
%                        as a oneliner.
\def\ccLayoutThreeColumns #1#2#3#4{%
                       \ccTopSkip
                       \hspace*{\ccwIndent}%
                       \ifdim\ccwFirst>0pt % check for constructors
                           \ifdim\wd\returntypebox>\ccwFirst
                               \unhbox\returntypebox\nopagebreak\ccReturnSkip
                           \else
                               \parbox[t]{\ccwFirst}{\sloppy 
                                   \unhbox\returntypebox}%
                               \hspace*{\ccwBetween}%
                           \fi
                       \fi
                       \ifdim\wd\functioncallbox>\ccwSecondLong
                           % Operators are assumed to fit in \ccwSecondLong.
                           % Otherwise, they are formatted as functions.
                           \ccBool=\ccAlternateThreeColumn
                           \ifnum\ccBool=\ccTrue 
                               \ccBool=\CCalternateThreeColumn
                           \fi
                           \ifnum\ccBool=\ccTrue
                               %  Switches ext. format ON.
                               {\setbox0=\hbox{\ccFont\unhcopy\callnamebox
                                               #1 }%
                                 \global\ccwParam=\wd0}%
                               \ifdim\ccwFirst>0pt % check for constructors
                                 \global\advance\ccwParam \ccwIndent
                                 \global\advance\ccwParam \ccwFirst
                                 \global\advance\ccwParam \ccwBetween
                               \fi
                               \def\ccExtendedFormat{\nopagebreak\\
                                       \hspace*{\ccwParam}}%
                               {\ccFont\unhbox\callnamebox #1 }%
                           \else
                               %  Switches ext. format ON.
                               \def\ccExtendedFormat{\nopagebreak\\
                                       \hspace*{\ccwParam}}%
                               {\ccFont \unhbox\callnamebox #1}%
                               \ccExtendedFormat
                           \fi
                           {\ccFont
                               \isEmpty{#2}\ifnum\ccBool=\ccFalse
                                   \ccPrintParamList{#2}%
                               \fi
                           #3}\hfill
                           \isEmpty{#4}\ifnum\ccBool=\ccFalse
                               \nopagebreak\ccMiddleSkip
                               \parbox[t]{\ccwComment}{\sloppy #4}%
                                   \hspace*{\ccwRightMargin}\hfill
                           \fi
                           \def\ccExtendedFormat{\ }% Switches ext. format OFF.
                           \ccBottomBigSkip
                       \else\ifdim\wd\functioncallbox>\ccwSecond
                           \parbox[t]{\ccwSecondLong}{\unhbox\functioncallbox}%
                           \hfill
                           \isEmpty{#4}\ifnum\ccBool=\ccFalse
                               \nopagebreak\ccMiddleSkip
                               \parbox[t]{\ccwComment}{\sloppy #4}%
                               \hspace*{\ccwRightMargin}\ccBottomBigSkip
                           \else
                               \ccBottomSkip
                           \fi
                        \else
                           \parbox[t]{\ccwSecond}{\unhbox\functioncallbox}%
                           \hspace*{\ccwBetween}%
                           \parbox[t]{\ccwComment}{\sloppy #4}%
                             %\hspace*{\ccwRightMargin}\hfill
                           \ccBottomSkip
                      \fi\fi
                     }


% \ccTemplateLine: extends the \ccLayoutThreeColumns with an additional
% line above the three columns that contains the template declaration
% for functions or methods (if any)
% 
%   #1   the template declaration, delimited with \end
\def\ccTemplateLine #1\end{%
    \ccTopSkip
    \hspace*{\ccwIndent}%
    \ccPrintTokens #1\end \nopagebreak[4]\par
    \ccReverseTopSkip\vspace{-\parskip}%
}


% Set the two boxes, returntype and functionname, for an operator declaration.
\def\ccSeparateOperator #1operator#2\end{%
                       \setbox\returntypebox=\hbox{{\ccFont
                           \ccPrintReturnType #1const.&.\end}}%
                       \setbox\functionnamebox=\hbox{{\ccFont
                           \ccPrintTokens operator#2\end}}%
                     }

% Set the two boxes, returntype and functionname, for a function declaration.
% The part of the declaration has to be terminated with "::\end".
\def\ccSeparateFunction #1#2::#3\end{%
                       \isEmpty{#3}\ifnum\ccBool=\ccTrue
                           \ccSeparateFunctionXX{#1}#2 .\end%
                       \else
                           \hasLeadingSpace{#3}\ifnum\ccBool=\ccTrue
                               \ccSeparateFunction{#1#2:: }#3\end%
                           \else
                               \ccSeparateFunction{#1#2::}#3\end%
                           \fi
                       \fi}


% Set the two boxes, returntype and functionname, for a function declaration.
% This macro scans through the token list space by space. If the operators
% & or * occurs on the right side, they are shifted to the left.
%   o  The 1st parameter is the first part of the type.
%   o  The 2nd parameter is the next part of the type name.
%   o  The 3rd and 4th parameter are the next part of the return type or
%      the name, if #4 is empty. Then, the 3rd parameter is the first
%      character of it.
% The part of the declaration has to be terminated with " .\end".
\def\ccSeparateFunctionXX #1#2 #3#4\end{%
                       \isEmpty{#4}\ifnum\ccBool=\ccTrue 
                           \setbox\returntypebox=\hbox{{\ccFont
                               \ccPrintReturnType #1const.&.\end}}%
                           \setbox\functionnamebox=\hbox{{\ccFont
                               \ccPrintTokens #2\end}}%
                       \else
                           \def\xparams{#1}\ifx\xparams\empty
                               \if#3&%
                                   \ccSeparateFunctionXX{#2#3}#4\end%
                               \else\if#3*%
                                   \ccSeparateFunctionXX{#2#3}#4\end%
                               \else
                                   \ccSeparateFunctionXX{#2 }#3#4\end%
                               \fi\fi
                           \else
                               \if#3&%
                                   \ccSeparateFunctionXX{#1#2#3}#4\end%
                               \else\if#3*%
                                   \ccSeparateFunctionXX{#1#2#3}#4\end%
                               \else
                                   \ccSeparateFunctionXX{#1#2 }#3#4\end%
                               \fi\fi
                           \fi
                       \fi}


% Set the \trailingconstbox appropriately to \ccTagRmTrailingConst.
% If #2 is empty we have found the trailing part in #1,
% else apply this recursivly.
\def\ccSeparateTrailingConst #1)#2\end{%
    \ifnum\ccTagRmTrailingConst=\ccTrue
        \setbox\trailingconstbox=\hbox{}%
    \else
        \isEmpty{#1}\ifnum\ccBool=\ccTrue
            \setbox\trailingconstbox=\hbox{}%
        \else
            \def\xparams{#2}\ifx\xparams\empty
                \setbox\trailingconstbox=\hbox{{ % here is one space !
                    \ccFont\ccPrintTokens #1\end}}%
            \else
                \ccSeparateFunctionXX #2\end
            \fi
        \fi
    \fi
}


% +--------------------------------------------------------------------------
% |     * Formatting of simple C++ code:
% +--------------------------------------------------------------------------
% | \ccPrintChar, \ccPrintSingleToken, \ccPrintTokens
% +--------------------------------------------------------------------------
% Print a character of a C++ declaration. Special handling of _<>&.
\def\ccPrintChar #1{%
                   \if_#1\ccUnderscore
                   \else\ifx\_#1\ccUnderscore
                   \else\if<#1\ccOpenAngle
                   \else\if>#1\ccCloseAngle
                   \else\if&#1\ccAmpersand
                   \else\ifx\&#1\ccAmpersand
                   \else\if^#1\ccHat
                   \else\ifx\^#1\ccHat
                   \else\if###1\ccHash
                   \else\ifx\##1\ccHash
                   \else #1%
                   \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi}

% Print a single C++ token (without spaces inbetween). Skip leading spaces.
% The token has to be delimited by ";".
\def\ccPrintSingleTokenSemi #1;{%
    \ccPrintSingleToken #1\end
}
% Print a single C++ token (without spaces inbetween). Skip leading spaces.
% The token has to be delimited by "\end".
\def\ccPrintSingleToken #1\end{%
    \ifnum\ccTagReplacePrefix=\ccTrue
        \ccReplacePrefix{#1}{\ccPrintSingleTokenX}%
    \else\ccPrintSingleTokenX #1\end
    \fi
}

\def\ccPrintSingleTokenX #1#2\end{%CCtrue
                   \ccPrintChar #1%
                   \def\xbody{\ccPrintSingleTokenX #2\end}%
                   \isEmpty{#2}\ifnum\ccBool=\ccTrue \let\xnext=\relax
                   \else\let\xnext=\xbody\fi
                   \xnext}

% Print C++ tokens (separated with spaces). Skip leading spaces.
% The tokens have to be delimited by "\end".
\def\ccPrintTokens #1\end{%
    \ifnum\ccTagReplacePrefix=\ccTrue
        \ccReplacePrefix{#1}{\ccPrintTokensX}%
    \else\ccPrintTokensX #1\end
    \fi
}
\def\ccPrintTokensX #1#2\end{%
                   \ccPrintChar #1%
                   \def\xbody{\ccPrintTokensX #2\end}%
                   \isEmpty{#2}\ifnum\ccBool=\ccTrue
                       \let\xnext=\relax
                   \else
                       \compareAndCopySpace{#2}#2\end
                       \let\xnext=\xbody
                   \fi
                   \xnext}


% +--------------------------------------------------------------------------
% |     * Formatting of operator declarations:
% +--------------------------------------------------------------------------
% | To distinguish all operators, the number of given parameters is
% | counted and two of the three possible operator characters are used.
% +--------------------------------------------------------------------------
% Formats an operator declaration:
%   o  The first parameter contains a 0 for a method call, a 1 for a function.
%   o  The second parameter contains the return type.
%   o  The third parameter contains the operator name.
%   o  The fourth parameter contains the parameter list (maybe empty).
%   o  The fifth parameter contains the optional const specifier for methods.
% The declaration has to be terminated with "\end".
\def\ccPrintOperator #1#2operator#3(#4)#5\end{%
                       \ifnum#1=0
                           \isEmpty{#4}\ifnum\ccBool=\ccTrue
                               \ccPrintOperatorOne{#1}{\ccVar}{#4}#3\end
                           \else
                               \ccPrintOperatorOne{#1}{\ccVar,}{#4}#3\end
                           \fi
                       \else
                           \ccPrintOperatorOne{#1}{}{#4}#3\end
                       \fi}

% Formats a parenthesis () operator declaration:
%   o  The #1 parameter contains a 0 for a method call, a 1 for a function.
%   o  The #2 parameter contains the return type.
%   o  The #3, #4, #5 parameters have to be empty.
%   o  The #6 parameter contains the parameter list (maybe empty).
%   o  The #7 parameter contains the optional const specifier for methods.
% The declaration has to be terminated with "\end".
\def\ccPrintParOperator #1#2operator#3(#4)#5(#6)#7\end{%
                       \isEmpty{#3}\ifnum\ccBool=\ccFalse\errmessage{Malformed
                           parenthesis operator}\fi
                       \isEmpty{#4}\ifnum\ccBool=\ccFalse\errmessage{Malformed
                           parenthesis operator}\fi
                       \isEmpty{#5}\ifnum\ccBool=\ccFalse\errmessage{Malformed
                           parenthesis operator}\fi
                       \ifnum#1=0
                           \isEmpty{#6}\ifnum\ccBool=\ccTrue
                               \ccPrintOperatorOne{#1}{\ccVar}{#6}()\end
                           \else
                               \ccPrintOperatorOne{#1}{\ccVar,}{#6}()\end
                           \fi
                       \else
                           \ccPrintOperatorOne{#1}{}{#6}()\end
                       \fi}


% Formats a conversion operator.
% Uses the returntypebox and the functioncallbox.
% The declaration ends with "\end".
\def\ccPrintConversionOperator #1operator #2(#3)#4\end{%
                       \setbox\returntypebox=\hbox{{\ccFont
                           \ccPrintTokens #2\end}}
                       \setbox\functioncallbox=\hbox{{\ccFont 
                           \ccPrintTokens #2(\ccVar)\end}}
                       }

% An operator is detected and can be printed.
%   o  The first parameter contains a 0 for a method call, a 1 for a function.
%   o  The second parameter contains the \ccVar if it is a method.
%   o  The third parameter contains the (maybe empty) parameter list.
%   o  The fourth parameter is the first character of the operator.
%   o  The fifth parameter contains the rest of the operator.
% The declaration ends with "\end".
\newcount\operatorerror
{
  \ccCatcode \catcode`\#=6 \catcode`\@=14
  \gdef\ccPrintOperatorOne #1#2#3#4#5\end{@
                       \ccExtractParamList{#2#3)}@
                       \operatorerror=1
                       \isEmpty{#5}\ifnum\ccBool=\ccTrue 
                           @ single character operations
                           \ifcase\NParameters         @ no parameter
                           \or                         @ 1 parameter
                               \if~#4\ccOperatorpraefix{\mbox{\ccTilde}}\fi
                               \if!#4\ccOperatorpraefix{#4\,}\fi
                               \if-#4\ccOperatorpraefix{#4}\fi
                               \if+#4\ccOperatorpraefix{#4}\fi
                               \if&#4\ccOperatorpraefix{\mbox{{\ccFont
                                       \ccAmpersand}}}\fi
                               \if*#4\ccOperatorpraefix{#4}\fi
                           \or                         @ 2 parameters
                               \if*#4\ccOperatorinfix{#4}\fi
                               \if/#4\ccOperatorinfix{\,#4}\fi
                               \if%#4\ccOperatorinfix{\,#4\,}\fi
                               \if+#4\ccOperatorinfix{#4}\fi
                               \if-#4\ccOperatorinfix{#4}\fi
                               \if<#4\ccOperatorinfix{#4}\fi
                               \if>#4\ccOperatorinfix{#4}\fi
                               \if&#4\ccOperatorinfix{\mbox{{ \ccFont
                                       \ccAmpersand} }}\fi
                               \if^#4\ccOperatorinfix{\mbox{\ccHat}}\fi
                               \if|#4\ccOperatorinfix{\;#4\;}\fi
                               \if=#4\ccOperatorinfix{#4}\fi
                               \if,#4\ccOperatorinfix{#4}\fi
                           \else                       @ 3 parameters
                           \fi
                       \else
                           @ two or more character operations
                           \ccPrintOperatorTwo #4#5\end
                       \fi
                       \ifnum\operatorerror=1 \errmessage{Unknown
                           operator detected. Look out for the legal
                           operator overloading in    C++. Maybe, not all
                           operators are currently supported by this
                           style, sorry.  Go ahead, and I format it as
                           a function}@
                           \ifnum#1=0 {\ccFont \ccVar.}\fi
                           \ccPrintTokens operator #4#5\end@
                           (\isEmpty{#3}\ifnum\ccBool=\ccFalse
                               \ccPrintParamList{#3)}\fi
                           )@
                       \fi
                     }

@ An operator with two or more characters is detected and can be printed.
@   o  The first parameter is the first character of the operator.
@   o  The second parameter is the second character of the operator.
@   o  The third parameter contains the rest of the operator.
@ The declaration ends with "\end".
\gdef\ccPrintOperatorTwo #1#2#3\end{@
                   \isEmpty{#3}\ifnum\ccBool=\ccTrue 
                       @ two character operations
                       \ifcase\NParameters         @ no parameter
                       \or                         @ 1 parameter
                           \if-#1\if>#2\ccOperatorpostfix{\:#1\!\!\!#2}\fi\fi
                           \if(#1\if)#2\ccOperatorparX{(}{)}\fi\fi
                           \if+#1\if+#2\ccOperatorpraefix{#1\!#2}\fi\fi
                           \if-#1\if-#2\ccOperatorpraefix{#1\!#2}\fi\fi
                       \or                         @ 2 parameters
                           \if[#1\if]#2\ccOperatorparXX{\ccEndFont{\rm [} 
                                }{\ccEndFont{\rm ]}}\fi\fi
                           \if(#1\if)#2\ccOperatorparXX{( }{)}\fi\fi
                           \if+#1\if+#2\ccOperatorpostfix{#1\!#2}\fi\fi
                           \if-#1\if-#2\ccOperatorpostfix{#1\!#2}\fi\fi
                           \if>#1\if>#2\ccOperatorinfix{#1\!#2}\fi\fi
                           \if<#1\if<#2\ccOperatorinfix{#1\!#2}\fi\fi
                           \if<#1\if=#2\ccOperatorinfix{#1#2}\fi\fi
                           \if>#1\if=#2\ccOperatorinfix{#1#2}\fi\fi
                           \if=#1\if=#2\ccOperatorinfix{#1#2}\fi\fi
                           \if!#1\if=#2\ccOperatorinfix{\;#1\!#2}\fi\fi
                           \if&#1\if&#2\ccOperatorinfix{\mbox{ {\ccFont
                                       \ccAmpersand}}\mbox{{\ccFont
                                       \ccAmpersand} }}\fi\fi
                           \if|#1\if|#2\ccOperatorinfix{\;#1#2\;}\fi\fi
                           \if*#1\if=#2\ccOperatorinfix{\,#1\!#2}\fi\fi
                           \if/#1\if=#2\ccOperatorinfix{\,#1\!#2}\fi\fi
                           \if%#1\if=#2\ccOperatorinfix{\,#1\!#2}\fi\fi
                           \if+#1\if=#2\ccOperatorinfix{\,#1\!#2}\fi\fi
                           \if-#1\if=#2\ccOperatorinfix{\,#1\!#2}\fi\fi
                           \if&#1\if=#2\ccOperatorinfix{\mbox{ {\ccFont
                                       \ccAmpersand}}\!#2}\fi\fi
                           \if|#1\if=#2\ccOperatorinfix{\;#1\!#2}\fi\fi
                           \if^#1\if=#2\ccOperatorinfix{\mbox{\ccHat{}}\!\!
                               #2}\fi\fi
                       \else                       @ 3 parameters
                           \if(#1\if)#2\ccOperatorparXXX{( }{)}\fi\fi
                       \fi
                   \else
                       @ three or more character operations
                       \ifcase\NParameters         @ no parameter
                       \or                         @ 1 parameter
                           \if-#1\if>#2\ccOperatorpostfix{\:#1\!\!\!#2\!
                               #3}\fi\fi
                       \or                         @ 2 parameters
                           \if#1n\if#2e\ccOperatornew{#1#2#3}\fi\fi
                           \if>#1\if>#2\ccOperatorinfix{#1\!#2#3}\fi\fi
                           \if<#1\if<#2\ccOperatorinfix{#1\!#2#3}\fi\fi
                       \else                       @ 3 parameters
                           \if#1d\if#2e\ccOperatordelete{#1#2#3}\fi\fi
                       \fi
                   \fi
                 }
} 


\def\ccOperatorpraefix #1{%
    $#1 \mbox{\unhbox\parameterX}$\operatorerror=0 }
\def\ccOperatorinfix #1{%
    $\mbox{\unhbox\parameterX\ccEndFont} #1 
     \mbox{\unhbox\parameterXX}$\operatorerror=0 }
\def\ccOperatorpostfix #1{%
    $\mbox{\unhbox\parameterX} #1$\operatorerror=0 }
\def\ccOperatorappend #1#2{%
    $\mbox{\unhbox\parameterX} #1#2$\operatorerror=0 }
\def\ccOperatorparX #1#2{%
    \unhbox\parameterX#1#2\operatorerror=0 }
\def\ccOperatorparXX #1#2{%
    \unhbox\parameterX#1\unhbox\parameterXX#2\operatorerror=0 }
\def\ccOperatorparXXX #1#2{%
    \unhbox\parameterX\ccEndFont#1\unhbox\parameterXX,
    \unhbox\parameterXXX#2\operatorerror=0 }
\def\ccOperatornew #1{%
    $ \mbox{{\ccFont #1} \ccClassTemplateName}$\operatorerror=0 }
%    $ * \mbox{{\ccFont ptr\_}\unhbox\parameterX} = \mbox{{\ccFont #1}
%              \ccClassTemplateName}$\operatorerror=0 }
\def\ccOperatordelete #1{%
    $ \mbox{{\ccFont #1} \unhbox\parameterXX}$\operatorerror=0 }


% +--------------------------------------------------------------------------
% |     * Template declaration separation
% +--------------------------------------------------------------------------
% | The input starts with a template declaration. This and including
% | its parameter list will be separated from the rest of the declaration. 
% | The macro in argument #1 will be applied to them, delimited with \end. The 
% | rest will be handed over to the command in argument #2, also delimited
% | with \end.
% +--------------------------------------------------------------------------
%   #1  macro to be applied to the template declaration
%   #2  macro to be applied to the rest of the declaration
%   #3  should be empty
%   #4  the declaration, delimited by \end.

\def\ccSeparateTemplate #1#2#3template#4\end{%
        \nestinglevel=0
        \hasLeadingSpace{#4}\ifnum\ccBool=\ccTrue
            \ccSeparateTemplateX{#1}{#2}{template }#4\end
        \else
            \ccSeparateTemplateX{#1}{#2}{template}#4\end
        \fi}

%   #1  macro to be applied to the template declaration
%   #2  macro to be applied to the rest of the declaration
%   #3  accumulator for the template declaration
%   #4  first character of declaration
%   #5  rest of declaration, delimited by \end.
\def\ccSeparateTemplateX #1#2#3#4#5\end{%
                   \if<#4\advance\nestinglevel by1 \fi
                   \if(#4\advance\nestinglevel by1 \fi
                   \if)#4\advance\nestinglevel by-1 \fi
                   \if>#4\advance\nestinglevel by-1 \fi
                   \ifnum\nestinglevel<1
                       \ifnum\nestinglevel<0
                           \errmessage{Unbalanced angles detected in
                           template parameters of template
                           declaration. I'll try.}%
                       \fi
                       #1#3#4\end #2#5\end
                   \fi
                   \hasLeadingSpace{#5}\ifnum\ccBool=\ccTrue
                       \def\xxbody{\ccSeparateTemplateX{#1}{#2}{#3#4 }#5\end}%
                   \else
                       \def\xxbody{\ccSeparateTemplateX{#1}{#2}{#3#4}#5\end}%
                   \fi
                   \ifnum\nestinglevel<1 \let\xxnext=\relax
                   \else\let\xxnext=\xxbody\fi
                   \xxnext}


% +--------------------------------------------------------------------------
% |     * Parameter list parsing:
% +--------------------------------------------------------------------------
% | Parameter lists are commata separated parameters. Template
% | instantiation nesting is considered. Parentheses nesting 
% | from default initializers are also considered.
% +--------------------------------------------------------------------------

% Print a C++ parameter list (separated with commatas). The output formats
% with a space between commata and the parameter text.
\def\ccPrintParamList #1{%
        \nestinglevel=0
        \ccPrintParamListX{}#1\end}
% Support function:
%   o  The first parameter accumulates the so far parsed first parameter.
%   o  The second parameter contains the next character.
%   o  The third parameter contains the rest.
% The parsing process iterates characterwise.
% The parameter list has to be terminated with "\end".
\def\ccPrintParamListX #1#2#3\end{%
                   \if<#2\advance\nestinglevel by1 \fi
                   \if>#2\advance\nestinglevel by-1 \fi
                   \if(#2\advance\nestinglevel by1 \fi
                   \if)#2\advance\nestinglevel by-1 \fi
                   \if,#2%
                       \ifnum\nestinglevel=0 
                           \ccPrintParameter #1const.&.\end,\ccExtendedFormat
                           \def\xxbody{\ccPrintParamListX{}#3\end}%
                       \else\ifnum\nestinglevel<0
                           \errmessage{Unbalanced angles detected in
                           template types in the C++ parameter list}%
                           \def\xxbody{\ccPrintParamListX{}#3\end}%
                       \else% comma within template parameter detected
                           \hasLeadingSpace{#3}\ifnum\ccBool=\ccTrue
                               \def\xxbody{\ccPrintParamListX{#1#2 }#3\end}%
                           \else
                               \def\xxbody{\ccPrintParamListX{#1#2}#3\end}%
                           \fi
                       \fi\fi
                   \else%  old: \isEmpty{#3}\ifnum\ccBool=\ccTrue
                       \ifnum\nestinglevel<0
                       \ifnum\nestinglevel=-1
                           \ccPrintParameter #1const.&.\end%
                       \else
                           \errmessage{Unbalanced angles detected in
                           template types in the C++ parameter list}%
                       \fi
                       \def\xxbody{\ccPrintParamListX{}#3\end}%
                   \else
                       \hasLeadingSpace{#3}\ifnum\ccBool=\ccTrue
                           \def\xxbody{\ccPrintParamListX{#1#2 }#3\end}%
                       \else
                           \def\xxbody{\ccPrintParamListX{#1#2}#3\end}%
                       \fi
                   \fi\fi
                   % old: \isEmpty{#3}\ifnum\ccBool=\ccTrue 
                   \ifnum\nestinglevel<0 \let\xxnext=\relax
                   \else\let\xxnext=\xxbody\fi
                   \xxnext}


% If an operator is used, a specialized parameter parsing macro counts
% the number of parameters and store the result in the three following boxes.
% \NParameters is one of 0,1,2,3. In the case of 3, there are three or more 
% parameters, as it was possible for the ()-operator. Thei are all together
% stored in \box\parameterXXX.
\newcount\NParameters   % counts number of parameters for operators
\newbox\parameterX      % first parameter
\newbox\parameterXX     % second parameter
\newbox\parameterXXX    % third and rest of parameters

% Extract up to three parameters from a C++ parameter list 
% (separated with commatas) within the \parameterX.. boxes.
\def\ccExtractParamList #1{%
        \nestinglevel=0
        \NParameters=0
        \isEmpty{#1}\ifnum\ccBool=\ccFalse \ccExtractParamListX{}#1\end\fi}
% Support function:
%   o  The first parameter accumulates the so far parsed first parameter.
%   o  The second parameter contains the next character.
%   o  The third parameter contains the rest.
% The parsing process iterates characterwise.
% The parameter list has to be terminated with "\end".
\def\ccExtractParamListX #1#2#3\end{%
                   \if<#2\advance\nestinglevel by1 \fi
                   \if>#2\advance\nestinglevel by-1 \fi
                   \if(#2\advance\nestinglevel by1 \fi
                   \if)#2\advance\nestinglevel by-1 \fi
                   \if,#2%
                       \ifnum\nestinglevel=0 
                           \advance\NParameters by1
                           \ifnum\NParameters=1 \setbox\parameterX=%
                                   \hbox{\ccPrintParameter #1const.&.\end}%
                               \def\xxxbody{\ccExtractParamListX{}#3\end}%
                           \else\advance\NParameters by1
                               \setbox\parameterXX=%
                                   \hbox{\ccPrintParameter #1const.&.\end}%
                               \setbox\parameterXXX=%
                                   \hbox{\ccPrintParamList{#3}}%
                               \def\xxxbody{\relax}%
                           \fi
                       \else\ifnum\nestinglevel<-1
                           \errmessage{Unbalanced angles or parantheses
                           detected in
                           template types in the C++ parameter list}%
                           \def\xxxbody{\ccExtractParamListX{}#3\end}%
                       \else% comma within template parameter detected
                           \hasLeadingSpace{#3}\ifnum\ccBool=\ccTrue
                               \def\xxxbody{\ccExtractParamListX{#1#2 }#3\end}%
                           \else
                               \def\xxxbody{\ccExtractParamListX{#1#2}#3\end}%
                           \fi
                       \fi\fi
                   \else\ifnum\nestinglevel<0
                       \ifnum\nestinglevel=-1
                           \advance\NParameters by1
                           \ifnum\NParameters=1 \setbox\parameterX=%
                                   \hbox{\ccPrintParameter #1const.&.\end}%
                           \else\ifnum\NParameters=2 \setbox\parameterXX=%
                                   \hbox{\ccPrintParameter #1const.&.\end}%
                           \else\setbox\parameterXXX=%
                                   \hbox{\ccPrintParameter #1const.&.\end}%
                           \fi\fi
                       \else
                           \errmessage{Unbalanced angles or
                           parantheses detected in
                           template types in the C++ parameter list}%
                       \fi
                       \def\xxxbody{\ccExtractParamListX{}#3\end}%
                   \else
                       \hasLeadingSpace{#3}\ifnum\ccBool=\ccTrue
                           \def\xxxbody{\ccExtractParamListX{#1#2 }#3\end}%
                       \else
                           \def\xxxbody{\ccExtractParamListX{#1#2}#3\end}%
                       \fi
                   \fi\fi
                   \ifnum\nestinglevel<0 \let\xxxnext=\relax
                       \else\let\xxxnext=\xxxbody\fi
                   \xxxnext}

% +--------------------------------------------------------------------------
% |     * Parameter Parsing:
% +--------------------------------------------------------------------------
% | A single parameter consists of a type and optional of a variable name.
% | If the type contains a "const ... &" pair, it is removed. If the
% | the type is similar to the class that is currently declared, it is
% | also removed. (In that case it might result in an empty parameter
% | if no variable name is given. Then, a dummy "#" is printed instead.
% |
% | The return type of a method or function has no `variable name', so
% | only "const ... &" removal is done and no classname elimination.
% +--------------------------------------------------------------------------
% The parameter parsing macros counts the nesting level of
% template parameter instantiations.
\newcount\nestinglevel
\newcount\xnestinglevel

% Print a parameter where "const ...&" pairs are eliminated. Strips a
% leading type that equals the \ccClassName. It is a four step process:
%   1. strip all in front of a "<" character.
%   2. extract the leading token without any space in it to decide,
%      weather the type given is a templated type or not.
%   3. Compare the leading token with \ccClassName
%   4. If true, strip the possible following template parameter.
% The parameter has to be delimited with "<>\end".
% Ignore leading spaces.
\def\ccPrintOwnClassParameter #1#2<#3#4\end{%
    \ifnum\ccTagRmEigenClassName=\ccFalse
        \ccPrintOwnClassXQX #1#2<#3#4\end%
    \else
        \ifx\ccPureTemplateParameters\empty
            \if>#3%
                \ccPrintOwnClassX  #1#2 \end% no template case
            \else
                \ccPrintOwnClassXQX #1#2<#3#4\end%
            \fi
        \else\if>#3%
            \ccPrintOwnClassX  #1#2 \end% no template case
        \else
            \ccPrintOwnClassXX{#1#2}<#3#4\end% template case ?
        \fi\fi
    \fi
}
\def\ccPrintOwnClassXQX #1#2<>\end{% strip the unneccessary <> from the end
        \ccPrintTokens #1#2\end}
\def\ccPrintOwnClassX #1 #2\end{% check for \ccClassName
        \def\xparams{#1}\ifx\xparams\ccPureClassName
            \isEmpty{#2}\ifnum\ccBool=\ccTrue
                \ccEmptyParameter
            \else
                \ccPrintTokens #2\end%
            \fi
        \else
            \ccPrintTokens #1 #2\end%
        \fi}
\def\ccPrintOwnClassXX #1#2<>\end{% strip the unneccessary <> from the end
        \ccPrintOwnClassXXX {#2}#1 \end}
\def\ccPrintOwnClassXXX #1#2 #3\end{%
        % check \ccClassName in the possible template case
        %   #1 is the parameter tail starting with the template params
        %   #2 is the leading class name
        %   #3 is inbetween and should be empty
        \def\qqparams{#3}\ifx\qqparams\empty
            \def\xparams{#2}\ifx\xparams\ccPureClassName
                \xnestinglevel=0
                \ccPrintOwnClassXXXX #1\end% strip the template parameters
            \else
                \ccPrintTokens #2#1\end% nothing stripped
            \fi
        \else
            \ccPrintTokens #2\ \end
            \ccPrintOwnClassXXX {#1}#3\end
        \fi}
\def\ccPrintOwnClassXXXX #1#2\end{% strip a leading template parameter
                   \if<#1\advance\xnestinglevel by1  \fi
                   \if>#1\advance\xnestinglevel by-1 \fi
                   \ifnum\xnestinglevel=0
                       \isEmpty{#2}\ifnum\ccBool=\ccTrue
                           \ccEmptyParameter
                       \else
                           \ccPrintTokens #2\end%
                       \fi
                       \let\xnext=\relax
                   \else
                       \def\xparams{#2}%
                       \ifx\xparams\empty
                           \errmessage{Mismatching angles in template 
                                       parameter list}%
                       \fi
                       \def\xbody{\ccPrintOwnClassXXXX #2\end}%
                       \let\xnext=\xbody
                   \fi
                   \xnext}


% Print a C++ function or method parameter. Strips a matching
% "const ...&" pair.
% The parameter has to be delimited with "const.&.\end".
\def\ccPrintParameter #1const#2&#3\end{%
    \ifnum\ccTagRmConstRefPair=\ccFalse
        \ccPrintParameterXQ #1const#2&#3\end%
    \else
        \if.#2\isEmpty{#1}\ifnum\ccBool=\ccFalse 
            \ccPrintOwnClassParameter #1<>\end%
            \fi
        \else
            \if&#2\ccPrintParameter #1&#3\end%
            \else
                \if.#3\ccPrintParameterXQ #1const#2&#3\end%
                \else\hasLeadingSpace{#2}\ifnum\ccBool=\ccFalse
                        \isLetter{#2}\ccInvert
                    \fi
                    \ifnum\ccBool=\ccTrue
                        \ccPrintParameter #1#2 #3\end%
                    \else
                        \ccPrintParameterXQ #1const#2&#3\end%
                    \fi
                \fi
            \fi
        \fi
    \fi}

\def\ccPrintParameterXQ #1const.&.\end{\ccPrintOwnClassParameter #1<>\end}

% Print a C++ function or method return type. Strips a matching
% "const ...&" pair.
% The parameter has to be delimited with "const.&.\end".
\def\ccPrintReturnType #1const#2&#3\end{%
    \ifnum\ccTagRmConstRefPair=\ccFalse
        \ccPrintReturnTypeXQ #1const#2&#3\end%
    \else
        \if.#2\isEmpty{#1}\ifnum\ccBool=\ccFalse 
            \ccPrintTokens #1\end%
            \fi
        \else
            \if&#2\ccPrintReturnType #1&#3\end%
            \else
                \if.#3\ccPrintReturnTypeXQ #1const#2&#3\end%
                \else\hasLeadingSpace{#2}\ifnum\ccBool=\ccFalse
                        \isLetter{#2}\ccInvert
                    \fi
                    \ifnum\ccBool=\ccTrue
                        \ccPrintReturnType #1#2 #3\end%
                    \else 
                        \ccPrintReturnTypeXQ #1const#2&#3\end%
                    \fi
                \fi
            \fi
        \fi
    \fi}
\def\ccPrintReturnTypeXQ #1const.&.\end{\ccPrintTokens #1\end}

% ___________________________________________________________________________
% ###########################################################################
% |
% | EOF
% |
% ###########################################################################

