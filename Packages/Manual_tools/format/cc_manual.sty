% +----------------------------------------
% | new commands needed in the new mechamism
% | 03.08.1995   Berlin   Lutz Kettner
% | $Revision$
% | $Date$
% +----------------------------------------

{ \catcode`\$=12
  \def\cs #1$#2${\gdef#1{#2}}
  \cs\CCrevision$Revision$
  \cs\CCdate$Date$
}

%\tracingmacros=1

% +--------------------------------------------------------------------------
% | Dimensions (from the LEDA Manual):
% +--------------------------------------------------------------------------
%\hoffset=-0.5truemm \voffset=0.5truecm
%\hsize=16truecm     \vsize=23.5truecm
%\hsize=13.3truecm   \vsize=19.8truecm

\baselineskip 14pt
\spaceskip  .4em plus .25em minus .25em
\xspaceskip .65em
\parskip 11pt plus 1pt minus 1pt
\parindent 0pt

\newdimen\typewidth          \typewidth=2.5cm
\newdimen\callwidth          \callwidth=4.5cm
\newdimen\callwidthl         \callwidthl=\textwidth  
    \advance\callwidthl        -\typewidth  
    \advance\callwidthl        -0.5cm
\newdimen\extendedindent     \extendedindent=0.6cm
\newdimen\callwidthext       \callwidthext=\callwidthl  
    \advance\callwidthext      -\extendedindent
\newdimen\callindentext      \callindentext=\textwidth  
    \advance\callindentext     -\callwidthext
\newdimen\createwidth        \createwidth=\textwidth
    \advance\createwidth       -1cm
\newdimen\createtextwidth    \createtextwidth=\textwidth
    \advance\createtextwidth   -3cm
\newdimen\descriptwidth      \descriptwidth=\textwidth
    \advance\descriptwidth     -\typewidth
    \advance\descriptwidth     -\callwidth
    \advance\descriptwidth     -0.5cm 
 
% +--------------------------------------------------------------------------
% | Original LEDA Manual macros (shortcuts):
% |
% | \CC, \gg, \nat, \real, \boxit
% +--------------------------------------------------------------------------
\def\CC{C\raise.08ex\hbox{\tt ++}}
\def\gg{g\hbox{\tt ++}}
\def\nat{\hbox{\rm\vrule\kern-0.045em N}}
\def\real{\hbox{\rm\vrule\kern-0.035em R}}
\def\boxit#1{\vbox{\hrule\hbox{\vrule\kern3pt\vbox{#1}\kern3pt\vrule}\hrule}}

% +--------------------------------------------------------------------------
% | Structuring macros (similar to LEDA Manual):
% |
% | \CCsection, \definition, \creation, \operations, \implementation,
% | \example, \precond
% +--------------------------------------------------------------------------

\def\CCsection #1{%
                   \section[#1 (\protect\CCprintSingleToken \pureclassname;)]%
                           {#1 (\classname)}
                   \label{#1}}

\def\definition    {\bigskip\pagebreak[1]
                    {\bf 1. Definition}
                    \par\nopagebreak }

\def\creation      {\bigskip\pagebreak[1]
                    {\bf 2. Creation}
                    \par\nopagebreak }

\def\operations    {\bigskip\pagebreak[1]
                    {\bf 3. Operations}
                    \par\nopagebreak }

\def\implementation {\bigskip\pagebreak[1]
                    {\bf 4. Implementation}
                    \par\nopagebreak }

\def\example       {\bigskip\pagebreak[1]
                    {\bf 5. Example}
                    \par\nopagebreak }

\def\precond {{\it Precondition}: }


% +--------------------------------------------------------------------------
% | C++ declarations for different C++ language elements:
% |
% | \begin{class}, \begin{classtemplate}, \end...
% | \creationvariable, \threecolumns, \constructor, \method, \function
% | \CCstyle
% +--------------------------------------------------------------------------
\newenvironment{class}{%
                   \begingroup\CCcatcode
                   \classX%
               }{
                   \gdef\pureclassname{}%
               }

\def\classX #1{%
                   \endgroup
                   \classXX #1<\end}


\def\classXX #1<#2\end{%
                   \def\xparams{#2}\ifx\xparams\empty
                       \classXXX{#1}%
                   \else
                       \errmessage{Template parameters are not allowed
                         in a normal class. Use \begin{classtemplate}
                         instead}>%
                       \classXXX{#1<???>}%
                   \fi}

\def\classXXX #1{%
                   \gdef\pureclassname{#1}%
                   \gdef\puretemplatename{#1}%
                   \gdef\pureparameters{}%
                   \gdef\classname{\hbox{{\CCfont 
                           \CCprintTokens #1\end\CCendfont}}}%
                   \gdef\classtemplatename{\hbox{{\CCfont
                           \CCprintTokens #1\end\CCendfont}}}%
               }

\newenvironment{classtemplate}{%
                   \begingroup\CCcatcode
                   \classtemplateX%
               }{
                   \gdef\pureclassname{}%
               }

\def\classtemplateX #1{%
                   \endgroup
                   \classtemplateXX #1<\end}

\def\classtemplateXX #1<#2\end{%
                   \def\xparams{#2}\ifx\xparams\empty
                       \errmessage{Template parameters missed for
                         class template}>%
                       \classtemplateXXX{#1}<???><\end%
                   \else
                       \classtemplateXXX{#1}<#2\end%
                   \fi}

\def\classtemplateXXX #1#2<\end{%
                   \gdef\pureclassname{#1}%
                   \gdef\puretemplatename{#1#2}%
                   \gdef\pureparameters{#2}%
                   \gdef\classname{\hbox{{\CCfont
                           \CCprintTokens #1\end\CCendfont}}}%
                   \gdef\classtemplatename{\hbox{{\CCfont
                           \CCprintTokens #1#2\end\CCendfont}}}%
               }


\def\creationvariable {%
                   \begingroup\CCcatcode\creationvariableX}

\def\creationvariableX #1{%
                   \gdef\var{{\CCfont #1\CCendfont}}
                   \gdef\purevar{#1}
                   \endgroup}

\def\threecolumns #1#2{%
                   \global\typewidth=#1
                   \global\callwidth=#2
                   \global\descriptwidth=\textwidth
                   \global\advance\descriptwidth-\typewidth
                   \global\advance\descriptwidth-\callwidth
                   \global\advance\descriptwidth-0.5cm
                   \global\callwidthl=\textwidth 
                   \global\advance\callwidthl-\typewidth
                   \global\advance\callwidthl-0.5cm
                   \global\callwidthext=\callwidthl
                   \global\advance\callwidthext-\extendedindent
                   \global\callindentext=\textwidth 
                   \global\advance\callindentext -\callwidthext
                   }

\def\constructor {%
                   \begingroup\CCcatcode\constructorX}

\def\constructorX #1{%
                   \constructorcall #1\end
                   \endgroup
                   \constructorXX}

\def\constructorXX #1{%
                   \isEmpty{#1}\ifnum\CCbool=\CCfalse
                       \hspace*{1cm}\hfill
                       \parbox[t]{\createtextwidth}{\sloppy #1}\par
                   \fi
                   \bigskip
                   }


% Methods and functions can contain the active character or the comment
% character % of TeX's own character set. Therefore, we assign new
% \catcode values to them and parse the first argument after that, close
% the group and parse the second argument with the \CCcommentX macro.
\def\method {%
                       \begingroup\CCcatcode
                       \functionX{0}}
\def\function {%
                       \begingroup\CCcatcode
                       \functionX{1}}

\def\functionX #1#2{%
                       \smallskip
                       \functioncall{#1}#2;\end
                       \endgroup
                       \CCcomment}

\long\def\CCcommentX #1#2{%
                       \isEmpty{#2}\ifnum\CCbool=\CCfalse
                           #1\parbox[t]{\descriptwidth}{\sloppy #2}\hfill
                       \fi\par
                       \smallskip}

% Print one parameter in C++ style (including spaces).
\def\CCstyle {%
                       \begingroup\CCcatcode\CCstyleX}

\def\CCstyleX #1{%
                       {\CCfont \CCprintTokens #1\end\CCendfont}\endgroup}


% +--------------------------------------------------------------------------
% | Formatting styles:
% |
% | The style of the C++ formatting can be customized by redefining the 
% | following macros.
% +--------------------------------------------------------------------------
\gdef\CCfont{\it}        % font or style changing command in which all C++
                        % tokens will be typeset, including the variable names.
\gdef\CCendfont{\/}      % will be used after a C++ text. For slanted fonts,
                        % here should stay \/ macro. The C++ code will be
                        % grouped, so this macros has not to restore the old
                        % font.

% The special characters in typical C++ declarations:
\gdef\CCopenangle  {\CCendfont {\tt <}}
\gdef\CCcloseangle {\CCendfont {\tt >}}
\gdef\CCampersand  {\CCendfont {\tt \&}}
\gdef\CCunderscore {\_}
\gdef\CChat        {{\large $\;\,\hat{}\,\,$}}
\gdef\CCtilde      {{\lower.3ex \hbox{\large$\,\tilde{}\,$}}}

% The sign for an empty parameter (i.e. of the type of the current class).
\gdef\CCemptyParameter {$\diamondsuit$}

% Set the catcodes according to the C++ character set (including operators).
\gdef\CCcatcode    {%
                       \catcode`\~=12
                       \catcode`\_=12
                       \catcode`\^=12
                       \catcode`\#=12
                       \catcode`\%=12 }


% +--------------------------------------------------------------------------
% | Predicates:
% |
% | isEmpty, isLetter, hasLeadingSpace, isOperator, isParenthesisOperator
% | isConversionOperator
% |
% | All predicates uses pattern matching of TeX. The original predicate uses
% | a single parameter that should be in braces like in LaTeX. Internally,
% | they use a second, auxiliary macro with pattern matching where the
% | parameter has to be terminated by an \end token.
% |
% | Result is stored in the counter \CCbool. \CCfalse, \CCtrue are also
% | counters that are used in the \ifnum statement to test the result.
% +--------------------------------------------------------------------------

% The counter \CCbool contains the result of a couple of predicates
\newcount\CCbool              % either 0 for false or 1 for true.
\newcount\CCfalse \CCfalse=0  % This must be constant 0 !!!
\newcount\CCtrue  \CCtrue=1   % This must be constant 1 !!!

% A small macro to invert \CCbool
\def\CCinvert {%
    \ifnum\CCbool=\CCfalse \CCbool=\CCtrue \else\CCbool=\CCfalse \fi}

% This macro test wheather its argument is empty or contains only spaces.
\def\isEmpty #1{%
    \isEmptyX #1;\end}
\def\isEmptyX #1#2\end{%
   \def\xparams{#2}\ifx\xparams\empty \CCbool=\CCtrue
       \else \CCbool=\CCfalse \fi}

% This macro test wheather its argument starts (after leading spaces) with
% with a valid C++ letter.
\def\isLetter #1{%
    \def\qparams{#1}\ifx\qparams\empty\CCbool=\CCfalse 
        \else\isLetterX #1\end\fi}
\def\isLetterX #1#2\end{%
    \CCbool=\CCfalse
    \ifcat#1A\CCbool=\CCtrue
    \else\ifnum`#1>`/\ifnum`#1<`:\CCbool=\CCtrue \fi\fi
        \if#1_\CCbool=\CCtrue \fi
    \fi}

% These macros allow the characterwise parsing of an argument, where normally
% the spaces are ignored.
% Here, the first macro can be applied to the rest of the argument and 
% will return \CCtrue in the \CCbool iff the rest starts with a space.
% The second macro will produce a space "\ " iff the rest starts with a space.
% The space of the rest will be skipped automatically in the next round.
\def\hasLeadingSpace #1{%
    \def\qparams{#1}\ifx\qparams\empty\CCbool=\CCfalse 
        \else\compareSpace{#1}#1\end\fi}
\def\compareSpace #1#2#3\end{%
   \def\xxparams{#1}\def\xxxparams{#2#3}\ifx\xxparams\xxxparams\CCbool=\CCfalse
       \else\CCbool=\CCtrue \fi}
\def\testAndCopySpace #1{%
    \def\qparams{#1}\ifx\qparams\empty\else\compareAndCopySpace{#1}#1\end\fi}
\def\compareAndCopySpace #1#2#3\end{%
    \def\xxparams{#1}\def\xxxparams{#2#3}\ifx\xxparams\xxxparams\else\ \fi}

% This macro gets a complete C++ declaration and decides weather
% it is an operator declaration or not.
\def\isOperator #1{%
    \isOperatorX{ #1 operator\end}}
    % Note: the macro introduces a leading space to allow the matching process
    % to find in any way the right " operator" string. This is necessary,
    % because "operator" is allowed as a substring in a function name.
\def\isOperatorX #1{\isOperatorXX #1}  % Now, we can match.
\def\isOperatorXX #1 operator#2\end{%
    \isEmpty{#2}\ifnum\CCbool=\CCtrue \CCbool=\CCfalse
    \else\hasLeadingSpace{#2}\ifnum\CCbool=\CCfalse
            \isLetter{#2}\CCinvert
        \fi
    \fi}

% This macro gets a complete C++ declaration for an operator and has to
% decide weather it is the parenthesis () operator declaration or not.
\def\isParenthesisOperator #1{%
    \isParenthesisOperatorX #1 ()\end}
\def\isParenthesisOperatorX #1operator#2(#3)#4(#5)#6\end{%
    % if and only if #6 is non empty, we have the () operator.
    \isEmpty{#6}\CCinvert}
    
% This macro gets a complete C++ declaration for an operator and has to
% decide weather it is the conversion operator declaration or not.
\def\isConversionOperator #1{%
    \isConversionOperatorX #1\end}
\def\isConversionOperatorX #1operator#2\end{%
    % if and only if #1 is empty, we have the conversion operator.
    \isEmpty{#1}}
    

% +--------------------------------------------------------------------------
% | Toplevel declaration formatting:
% |
% | Here, constructors, methods, and functions are separated in there
% | building blocks: the return type, their name, and the parameter
% | list. An operator declaration will be detected.
% +--------------------------------------------------------------------------
\def\constructorcall #1(#2)#3\end {%
                   \isEmpty{#2}\ifnum\CCbool=\CCtrue
                       \mbox{\classtemplatename\ \ \CCfont\purevar ;}%
                   \else\mbox{\classtemplatename
                       \ \ {\CCfont \purevar( \CCprintParamList{#2});}}%
                   \fi\par }

% This box contains the formatting result. Its width influences the
% column layout for longish declarations.
\newbox\functioncallbox

\newbox\returntypebox     % contains the return type
\newbox\functionnamebox   % contains the function name

% Formats a method or a function call.
%   o  The 1st parameter contains a 0 for a method call, a 1 for a function.
%   o  The 2nd parameter contains the beginning of the type declaration.
%   o  The 3rd parameter contains the rest of the type and the function name.
%   o  The 4th parameter contains the parameter list (maybe empty).
%   o  The 5th parameter contains the optional const specifier for methods.
% The declaration has to be terminated with ";;\end" where the first ";"
% has to be from the original call notation. The 6th parameter is there
% to check for this ";".
\def\functioncall #1#2 #3(#4)#5;#6\end{%
                       \def\xparam{#6}\ifx\xparam\empty
                           \errmessage{Missing ";" at the end of the 
                           declaration. A method or function
                           declaration has to end with a ";". 
                           Go ahead, I've inserted one}%
                       \fi
                       \def\CCextendedFormat{\ }% Switches ext. format OFF.
                       \isOperator{#2 #3(#4)#5}\ifnum\CCbool=\CCtrue
                           \isConversionOperator{#2 #3(#4)#5}
                           \ifnum\CCbool=\CCtrue
                               \CCprintConversionOperator #2 #3(#4)#5\end
                           \else
                               \CCseparateOperator #2 #3\end%
                               \isParenthesisOperator{#2 #3(#4)#5}%
                               \ifnum\CCbool=\CCtrue
                                   \setbox\functioncallbox=\hbox{{\CCfont 
                                       \CCprintParOperator #1#2 #3(#4)#5\end}}
                               \else
                                   \setbox\functioncallbox=\hbox{{\CCfont 
                                       \CCprintOperator #1#2 #3(#4)#5\end}}
                               \fi
                           \fi
                       \else
                           \CCseparateFunction{}#2 #3::\end%
                           \setbox\functioncallbox=\hbox{{\CCfont
                               \ifnum#1=0 \purevar.\fi
                               \unhcopy\functionnamebox(% 
                               \isEmpty{#4}\ifnum\CCbool=\CCfalse
                                   \ \CCprintParamList{#4}%
                               \fi)}}
                       \fi
                       \parbox[t]{\typewidth}{\sloppy 
                           \unhbox\returntypebox\hfill}
                       \ifdim\wd\functioncallbox>\callwidthl
                           %  Switches ext. format ON.
                           \def\CCextendedFormat{\\\hspace*{\callindentext}}%
                           % Operators are assumed to fit in \callwidthl.
                           % Otherwise, they are formatted as functions.
                           {\CCfont \ifnum#1=0 
                               \purevar.\fi\unhbox\functionnamebox(}
                           \CCextendedFormat
                           {\CCfont
                               \isEmpty{#4}\ifnum\CCbool=\CCfalse
                                   \CCprintParamList{#4}%
                               \fi
                           )}\hfill
                           \gdef\CCcomment{\CCcommentX{\par
                               \hspace*{1cm}\hfill}}
                           \def\CCextendedFormat{\ }% Switches ext. format OFF.
                       \else\ifdim\wd\functioncallbox>\callwidth 
                           \parbox[t]{\callwidthl}{\unhbox\functioncallbox}
                           \hfill
                           \gdef\CCcomment{\CCcommentX{\par
                               \hspace*{1cm}\hfill}}
                       \else
                           \parbox[t]{\callwidth}{\unhbox\functioncallbox}
                           \hfill
                           \gdef\CCcomment{\CCcommentX{}}
                       \fi\fi
                     }

\def\CCextendedFormat{\ }% Default: Extended Format switched OFF.

% Set the two boxes, returntype and functionname, for an operator declaration.
\def\CCseparateOperator #1operator#2\end{%
                       \setbox\returntypebox=\hbox{{\CCfont
                           \CCprintReturnType #1const.&.\end}}%
                       \setbox\functionnamebox=\hbox{{\CCfont
                           \CCprintTokens operator#2\end}}%
                     }

% Set the two boxes, returntype and functionname, for a function declaration.
% The part of the declaration has to be terminated with "::\end".
\def\CCseparateFunction #1#2::#3\end{%
                       \isEmpty{#3}\ifnum\CCbool=\CCtrue 
                           \CCseparateFunctionXX{#1}#2 .\end%
                       \else
                           \CCseparateFunction{#1#2::}#3\end%
                       \fi}


% Set the two boxes, returntype and functionname, for a function declaration.
% This macro scans through the token list space by space. If the operators
% & or * occurs on the right side, they are shifted to the left.
%   o  The 1st parameter is the first part of the type.
%   o  The 2nd parameter is the next part of the type name.
%   o  The 3rd and 4th parameter are the next part of the return type or
%      the name, if #4 is empty. Then, the 3rd parameter is the first
%      character of it.
% The part of the declaration has to be terminated with " .\end".
\def\CCseparateFunctionXX #1#2 #3#4\end{%
                       \isEmpty{#4}\ifnum\CCbool=\CCtrue 
                           \setbox\returntypebox=\hbox{{\CCfont
                               \CCprintReturnType #1const.&.\end}}%
                           \setbox\functionnamebox=\hbox{{\CCfont
                               \CCprintTokens #2\end}}%
                       \else
                           \def\xparams{#1}\ifx\xparams\empty
                               \if#3&%
                                   \CCseparateFunctionXX{#2#3}#4\end%
                               \else\if#3*%
                                   \CCseparateFunctionXX{#2#3}#4\end%
                               \else
                                   \CCseparateFunctionXX{#2}#3#4\end%
                               \fi\fi
                           \else
                               \if#3&%
                                   \CCseparateFunctionXX{#1 #2#3}#4\end%
                               \else\if#3*%
                                   \CCseparateFunctionXX{#1 #2#3}#4\end%
                               \else
                                   \CCseparateFunctionXX{#1 #2}#3#4\end%
                               \fi\fi
                           \fi
                       \fi}

% +--------------------------------------------------------------------------
% | Formatting of simple C++ code:
% |
% | \CCprintChar, \CCprintSingleToken, \CCprintTokens
% +--------------------------------------------------------------------------
% Print a character of a C++ declaration. Special handling of _<>&.
\def\CCprintChar #1{%
                   \if_#1\CCunderscore
                   \else\if<#1\CCopenangle
                   \else\if>#1\CCcloseangle
                   \else\if&#1\CCampersand
                   \else\if^#1\CChat
                   \else #1%
                   \fi\fi\fi\fi\fi}

% Print a single C++ token (without spaces inbetween). Skip leading spaces.
% The token has to be delimited by "\end".
\def\CCprintSingleToken #1#2;{%
                   \CCprintChar #1%
                   \def\xbody{\CCprintSingleToken #2;}%
                   \isEmpty{#2}\ifnum\CCbool=\CCtrue \let\xnext=\relax
                   \else\let\xnext=\xbody\fi
                   \xnext}

% Print C++ tokens (separated with spaces). Skip leading spaces.
% The tokens have to be delimited by "\end".
\def\CCprintTokens #1#2\end{%
                   \CCprintChar #1%
                   \def\xbody{\CCprintTokens #2\end}%
                   \isEmpty{#2}\ifnum\CCbool=\CCtrue
                       \let\xnext=\relax
                   \else
                       \compareAndCopySpace{#2}#2\end
                       \let\xnext=\xbody
                   \fi
                   \xnext}

% +--------------------------------------------------------------------------
% | Formatting of operator declarations:
% |
% | To distinguish all operators, the number of given parameters is
% | counted and two of the three possible operator characters are used.
% +--------------------------------------------------------------------------
% Formats an operator declaration:
%   o  The first parameter contains a 0 for a method call, a 1 for a function.
%   o  The second parameter contains the return type.
%   o  The third parameter contains the operator name.
%   o  The fourth parameter contains the parameter list (maybe empty).
%   o  The fifth parameter contains the optional const specifier for methods.
% The declaration has to be terminated with "\end".
\def\CCprintOperator #1#2operator#3(#4)#5\end{%
                       \ifnum#1=0
                           \CCprintOperatorOne{#1}{\purevar,}{#4}#3\end
                       \else
                           \CCprintOperatorOne{#1}{}{#4}#3\end
                       \fi}

% Formats a parenthesis () operator declaration:
%   o  The first parameter contains a 0 for a method call, a 1 for a function.
%   o  The second parameter contains the return type.
%   o  The third parameter contains the operator name.
%   o  The fourth parameter contains the parameter list (maybe empty).
%   o  The fifth parameter contains the optional const specifier for methods.
% The declaration has to be terminated with "\end".
\def\CCprintParOperator #1#2operator#3(#4)#5(#6)#7\end{%
                       \isEmpty{#3}\ifnum\CCbool=\CCfalse\errmessage{Malformed
                           parenthesis operator}\fi
                       \isEmpty{#4}\ifnum\CCbool=\CCfalse\errmessage{Malformed
                           parenthesis operator}\fi
                       \isEmpty{#5}\ifnum\CCbool=\CCfalse\errmessage{Malformed
                           parenthesis operator}\fi
                       \ifnum#1=0
                           \CCprintOperatorOne{#1}{\purevar,}{#6}()\end
                       \else
                           \CCprintOperatorOne{#1}{}{#6}()\end
                       \fi}


% Formats a conversion operator.
% Uses the returntypebox and the functioncallbox.
% The declaration ends with "\end".
\def\CCprintConversionOperator #1operator #2(#3)#4\end{%
                       \setbox\returntypebox=\hbox{{\CCfont
                           \CCprintTokens #2\end}}
                       \setbox\functioncallbox=\hbox{{\CCfont 
                           \CCprintTokens #2(\purevar)\end}}
                       }

% An operator is detected and can be printed.
%   o  The first parameter contains a 0 for a method call, a 1 for a function.
%   o  The second parameter contains the \purevar if it is a method.
%   o  The third parameter contains the (maybe empty) parameter list.
%   o  The fourth parameter is the first character of the operator.
%   o  The fifth parameter contains the rest of the operator.
% The declaration ends with "\end".
\newcount\operatorerror
{
  \CCcatcode \catcode`\#=6 \catcode`\@=14
  \gdef\CCprintOperatorOne #1#2#3#4#5\end{@
                       \CCextractParamList{#2#3}@
                       \operatorerror=1
                       \isEmpty{#5}\ifnum\CCbool=\CCtrue 
                           @ single character operations
                           \ifcase\NParameters         @ no parameter
                           \or                         @ 1 parameter
                               \if~#4\CCoperatorpraefix{\mbox{\CCtilde}}\fi
                               \if!#4\CCoperatorpraefix{#4\,}\fi
                               \if-#4\CCoperatorpraefix{#4}\fi
                               \if+#4\CCoperatorpraefix{#4}\fi
                               \if&#4\CCoperatorpraefix{\mbox{{\CCfont
                                       \CCampersand}}}\fi
                               \if*#4\CCoperatorpraefix{#4}\fi
                           \or                         @ 2 parameters
                               \if*#4\CCoperatorinfix{#4}\fi
                               \if/#4\CCoperatorinfix{\,#4}\fi
                               \if%#4\CCoperatorinfix{\,#4\,}\fi
                               \if+#4\CCoperatorinfix{#4}\fi
                               \if-#4\CCoperatorinfix{#4}\fi
                               \if<#4\CCoperatorinfix{#4}\fi
                               \if>#4\CCoperatorinfix{#4}\fi
                               \if&#4\CCoperatorinfix{\mbox{{ \CCfont
                                       \CCampersand} }}\fi
                               \if^#4\CCoperatorinfix{\mbox{\CChat}}\fi
                               \if|#4\CCoperatorinfix{\;#4\;}\fi
                               \if=#4\CCoperatorinfix{#4}\fi
                               \if,#4\CCoperatorinfix{#4}\fi
                           \else                       @ 3 parameters
                           \fi
                       \else
                           @ two or more character operations
                           \CCprintOperatorTwo #4#5\end
                       \fi
                       \ifnum\operatorerror=1 \errmessage{Unknown
                           operator detected. Look out for the legal
                           operator overloading in    C++. Maybe, not all
                           operators are currently supported by this
                           style, sorry.  Go ahead, and I format it as
                           a function}@
                           \ifnum#1=0 {\CCfont \purevar.}\fi
                           \CCprintTokens operator #4#5\end@
                           (\isEmpty{#3}\ifnum\CCbool=\CCfalse
                               \CCprintParamList{#3}\fi
                           )@
                       \fi
                     }

@ An operator with two or more characters is detected and can be printed.
@   o  The first parameter is the first character of the operator.
@   o  The second parameter is the second character of the operator.
@   o  The third parameter contains the rest of the operator.
@ The declaration ends with "\end".
\gdef\CCprintOperatorTwo #1#2#3\end{@
                   \isEmpty{#3}\ifnum\CCbool=\CCtrue 
                       @ two character operations
                       \ifcase\NParameters         @ no parameter
                       \or                         @ 1 parameter
                           \if-#1\if>#2\CCoperatorpostfix{\:#1\!\!\!#2}\fi\fi
                           \if(#1\if)#2\CCoperatorparX{(}{)}\fi\fi
                           \if+#1\if+#2\CCoperatorpraefix{#1\!#2}\fi\fi
                           \if-#1\if-#2\CCoperatorpraefix{#1\!#2}\fi\fi
                       \or                         @ 2 parameters
                           \if[#1\if]#2\CCoperatorparXX{\CCendfont[ }{]}\fi\fi
                           \if(#1\if)#2\CCoperatorparXX{( }{)}\fi\fi
                           \if+#1\if+#2\CCoperatorpostfix{#1\!#2}\fi\fi
                           \if-#1\if-#2\CCoperatorpostfix{#1\!#2}\fi\fi
                           \if>#1\if>#2\CCoperatorinfix{#1\!#2}\fi\fi
                           \if<#1\if<#2\CCoperatorinfix{#1\!#2}\fi\fi
                           \if<#1\if=#2\CCoperatorinfix{#1#2}\fi\fi
                           \if>#1\if=#2\CCoperatorinfix{#1#2}\fi\fi
                           \if=#1\if=#2\CCoperatorinfix{#1#2}\fi\fi
                           \if!#1\if=#2\CCoperatorinfix{\;#1\!#2}\fi\fi
                           \if&#1\if&#2\CCoperatorinfix{\mbox{ {\CCfont
                                       \CCampersand}}\mbox{{\CCfont
                                       \CCampersand} }}\fi\fi
                           \if|#1\if|#2\CCoperatorinfix{\;#1#2\;}\fi\fi
                           \if*#1\if=#2\CCoperatorinfix{\,#1\!#2}\fi\fi
                           \if/#1\if=#2\CCoperatorinfix{\,#1\!#2}\fi\fi
                           \if%#1\if=#2\CCoperatorinfix{\,#1\!#2}\fi\fi
                           \if+#1\if=#2\CCoperatorinfix{\,#1\!#2}\fi\fi
                           \if-#1\if=#2\CCoperatorinfix{\,#1\!#2}\fi\fi
                           \if&#1\if=#2\CCoperatorinfix{\mbox{ {\CCfont
                                       \CCampersand}}\!#2}\fi\fi
                           \if|#1\if=#2\CCoperatorinfix{\;#1\!#2}\fi\fi
                           \if^#1\if=#2\CCoperatorinfix{\mbox{\CChat{}}\!\!
                               #2}\fi\fi
                       \else                       @ 3 parameters
                           \if(#1\if)#2\CCoperatorparXXX{( }{)}\fi\fi
                       \fi
                   \else
                       @ three or more character operations
                       \ifcase\NParameters         @ no parameter
                       \or                         @ 1 parameter
                           \if-#1\if>#2\CCoperatorpostfix{\:#1\!\!\!#2\!
                               #3}\fi\fi
                       \or                         @ 2 parameters
                           \if#1n\if#2e\CCoperatornew{#1#2#3}\fi\fi
                           \if>#1\if>#2\CCoperatorinfix{#1\!#2#3}\fi\fi
                           \if<#1\if<#2\CCoperatorinfix{#1\!#2#3}\fi\fi
                       \else                       @ 3 parameters
                           \if#1d\if#2e\CCoperatordelete{#1#2#3}\fi\fi
                       \fi
                   \fi
                 }
} 


\def\CCoperatorpraefix #1{%
    $#1 \mbox{\unhbox\parameterX}$\operatorerror=0 }
\def\CCoperatorinfix #1{%
    $\mbox{\unhbox\parameterX\CCendfont} #1 
     \mbox{\unhbox\parameterXX}$\operatorerror=0 }
\def\CCoperatorpostfix #1{%
    $\mbox{\unhbox\parameterX} #1$\operatorerror=0 }
\def\CCoperatorappend #1#2{%
    $\mbox{\unhbox\parameterX} #1#2$\operatorerror=0 }
\def\CCoperatorparX #1#2{%
    \unhbox\parameterX#1#2\operatorerror=0 }
\def\CCoperatorparXX #1#2{%
    \unhbox\parameterX#1\unhbox\parameterXX#2\operatorerror=0 }
\def\CCoperatorparXXX #1#2{%
    \unhbox\parameterX\CCendfont#1\unhbox\parameterXX,
    \unhbox\parameterXXX#2\operatorerror=0 }
\def\CCoperatornew #1{%
    $ \mbox{{\CCfont #1} \classtemplatename}$\operatorerror=0 }
%    $ * \mbox{{\CCfont ptr\_}\unhbox\parameterX} = \mbox{{\CCfont #1}
%              \classtemplatename}$\operatorerror=0 }
\def\CCoperatordelete #1{%
    $ \mbox{{\CCfont #1} \unhbox\parameterXX}$\operatorerror=0 }


% +--------------------------------------------------------------------------
% | Parameter list parsing:
% |
% | Parameter lists are commata separated parameters. Template
% | instantiation nesting is considered.
% +--------------------------------------------------------------------------

% Print a C++ parameter list (separated with commatas). The output formats
% with a space between commata and the parameter text.
\def\CCprintParamList #1{%
        \nestinglevel=0
        \CCprintParamListX{}#1\end}
% Support function:
%   o  The first parameter accumulates the so far parsed first parameter.
%   o  The second parameter contains the next character.
%   o  The third parameter contains the rest.
% The parsing process iterates characterwise.
% The parameter list has to be terminated with "\end".
\def\CCprintParamListX #1#2#3\end{%
                   \if<#2\advance\nestinglevel by1 \fi
                   \if>#2\advance\nestinglevel by-1 \fi
                   \if,#2%
                       \ifnum\nestinglevel=0 
                           \CCprintParameter #1const.&.\end,\CCextendedFormat
                           \def\xxbody{\CCprintParamListX{}#3\end}%
                       \else\ifnum\nestinglevel<0
                           \errmessage{Unbalanced angles detected in
                           template types in the C++ parameter list}%
                           \def\xxbody{\CCprintParamListX{}#3\end}%
                       \else% comma within template parameter detected
                           \hasLeadingSpace{#3}\ifnum\CCbool=\CCtrue
                               \def\xxbody{\CCprintParamListX{#1#2 }#3\end}%
                           \else
                               \def\xxbody{\CCprintParamListX{#1#2}#3\end}%
                           \fi
                       \fi\fi
                   \else\def\xxparams{#3}\ifx\xxparams\empty%
                       \ifnum\nestinglevel=0
                           \CCprintParameter #1#2const.&.\end%
                       \else
                           \errmessage{Unbalanced angles detected in
                           template types in the C++ parameter list}%
                       \fi
                       \def\xxbody{\CCprintParamListX{}#3\end}%
                   \else
                       \hasLeadingSpace{#3}\ifnum\CCbool=\CCtrue
                           \def\xxbody{\CCprintParamListX{#1#2 }#3\end}%
                       \else
                           \def\xxbody{\CCprintParamListX{#1#2}#3\end}%
                       \fi
                   \fi\fi
                   \def\xxparams{#3}\ifx\xxparams\empty\let\xxnext=\relax
                   \else\let\xxnext=\xxbody\fi
                   \xxnext}


% If an operator is used, a specialized parameter parsing macro counts
% the number of parameters and store the result in the three following boxes.
% \NParamters is one of 0,1,2,3. In the case of 3, there are three or more 
% parameters, as it was possible for the ()-operator. Thei are all together
% stored in \box\parameterXXX.
\newcount\NParameters   % counts number of parameters for operators
\newbox\parameterX      % first parameter
\newbox\parameterXX     % second parameter
\newbox\parameterXXX    % third and rest of parameters

% Extract up to three parameters from a C++ parameter list 
% (separated with commatas) within the \parameterX.. boxes.
\def\CCextractParamList #1{%
        \nestinglevel=0
        \NParameters=0
        \isEmpty{#1}\ifnum\CCbool=\CCfalse \CCextractParamListX{}#1\end\fi}
% Support function:
%   o  The first parameter accumulates the so far parsed first parameter.
%   o  The second parameter contains the next character.
%   o  The third parameter contains the rest.
% The parsing process iterates characterwise.
% The parameter list has to be terminated with "\end".
\def\CCextractParamListX #1#2#3\end{%
                   \if<#2\advance\nestinglevel by1 \fi
                   \if>#2\advance\nestinglevel by-1 \fi
                   \if,#2%
                       \ifnum\nestinglevel=0 
                           \advance\NParameters by1
                           \ifnum\NParameters=1 \setbox\parameterX=%
                                   \hbox{\CCprintParameter #1const.&.\end}%
                               \def\xxxbody{\CCextractParamListX{}#3\end}%
                           \else\advance\NParameters by1
                               \setbox\parameterXX=%
                                   \hbox{\CCprintParameter #1const.&.\end}%
                               \setbox\parameterXXX=%
                                   \hbox{\CCprintParamList{#3}}%
                               \def\xxxbody{\relax}%
                           \fi
                       \else\ifnum\nestinglevel<0
                           \errmessage{Unbalanced angles detected in
                           template types in the C++ parameter list}%
                           \def\xxxbody{\CCextractParamListX{}#3\end}%
                       \else% comma within template parameter detected
                           \hasLeadingSpace{#3}\ifnum\CCbool=\CCtrue
                               \def\xxxbody{\CCextractParamListX{#1#2 }#3\end}%
                           \else
                               \def\xxxbody{\CCextractParamListX{#1#2}#3\end}%
                           \fi
                       \fi\fi
                   \else\def\xxxparams{#3}\ifx\xxxparams\empty%
                       \ifnum\nestinglevel=0
                           \advance\NParameters by1
                           \ifnum\NParameters=1 \setbox\parameterX=%
                                   \hbox{\CCprintParameter #1#2const.&.\end}%
                           \else\ifnum\NParameters=2 \setbox\parameterXX=%
                                   \hbox{\CCprintParameter #1#2const.&.\end}%
                           \else\setbox\parameterXXX=%
                                   \hbox{\CCprintParameter #1#2const.&.\end}%
                           \fi\fi
                       \else
                           \errmessage{Unbalanced angles detected in
                           template types in the C++ parameter list}%
                       \fi
                       \def\xxxbody{\CCextractParamListX{}#3\end}%
                   \else
                       \hasLeadingSpace{#3}\ifnum\CCbool=\CCtrue
                           \def\xxxbody{\CCextractParamListX{#1#2 }#3\end}%
                       \else
                           \def\xxxbody{\CCextractParamListX{#1#2}#3\end}%
                       \fi
                   \fi\fi
                   \def\xxxparams{#3}\ifx\xxxparams\empty\let\xxxnext=\relax
                       \else\let\xxxnext=\xxxbody\fi
                   \xxxnext}

% +--------------------------------------------------------------------------
% | Parameter Parsing:
% |
% | A single parameter consists of a type and optional of a variable name.
% | If the type contains a "const ... &" pair, it is removed. If the
% | the type is similar to the class that is currently declared, it is
% | also removed. (In that case it might result in an empty parameter
% | if no variable name is given. Then, a dummy "#" is printed instead.
% |
% | The return type of a method or function has no `variable name', so
% | only "const ... &" removal is done and no classname elimination.
% +--------------------------------------------------------------------------
% The parameter parsing macros counts the nesting level of
% template parameter instantiations.
\newcount\nestinglevel
\newcount\xnestinglevel

% Print a parameter where "const ...&" pairs are eliminated. Strips a
% leading type that equals the \classname. It is a four step process:
%   1. strip all in front of a "<" character.
%   2. extract the leading token without any space in it to decide,
%      weather the type given is a templated type or not.
%   3. Compare the leading token with \classname
%   4. If true, strip the possible following template parameter.
% The parameter has to be delimited with "<>\end".
% Ignore leading spaces.
\def\CCprintOwnClassParameter #1#2<#3#4\end{%
        \ifx\pureparameters\empty
            \CCprintOwnClassX  #1#2 \end% no template case
        \else\if>#3%
            \CCprintOwnClassX  #1#2 \end% no template case
        \else
            \CCprintOwnClassXX{#1#2}<#3#4\end% template case ?
        \fi\fi}
\def\CCprintOwnClassX #1 #2\end{% check for \classname
        \def\xparams{#1}\ifx\xparams\pureclassname
            \isEmpty{#2}\ifnum\CCbool=\CCtrue
                \CCemptyParameter
            \else
                \CCprintTokens #2\end%
            \fi
        \else
            \CCprintTokens #1 #2\end%
        \fi}
\def\CCprintOwnClassXX #1#2<>\end{% strip the unneccessary <> from the end
        \CCprintOwnClassXXX {#2}#1 \end}
\def\CCprintOwnClassXXX #1#2 #3\end{%
        % check \classname in the possible template case
        %   #1 is the parameter tail starting with the template params
        %   #2 is the leading class name
        %   #3 is inbetween and should be empty
        \def\qqparams{#3}\ifx\qqparams\empty
            \def\xparams{#2}\ifx\xparams\pureclassname
                \xnestinglevel=0
                \CCprintOwnClassXXXX #1\end% strip the template parameters
            \else
                \CCprintTokens #2#1\end% nothing stripped
            \fi
        \else
            \errmessage{Confusing class name with a space before 
                        the template parameters. The allowed syntax
                        is: name< params... }%
        \fi}
\def\CCprintOwnClassXXXX #1#2\end{% strip a leading template parameter
                   \if<#1\advance\xnestinglevel by1  \fi
                   \if>#1\advance\xnestinglevel by-1 \fi
                   \ifnum\xnestinglevel=0
                       \isEmpty{#2}\ifnum\CCbool=\CCtrue
                           \CCemptyParameter
                       \else
                           \CCprintTokens #2\end%
                       \fi
                       \let\xnext=\relax
                   \else
                       \def\xparams{#2}%
                       \ifx\xparams\empty
                           \errmessage{Mismatching angles in template 
                                       parameter list}%
                       \fi
                       \def\xbody{\CCprintOwnClassXXXX #2\end}%
                       \let\xnext=\xbody
                   \fi
                   \xnext}


% Print a C++ function or method parameter. Strips a matching
% "const ...&" pair.
% The parameter has to be delimited with "const.&.\end".
\def\CCprintParameter #1const#2#3&#4#5\end{%
    \if.#2\CCprintOwnClassParameter #1<>\end%
    \else
        \if&#2\CCprintParameter #1#3&#4#5\end%
        \else
        \CCprintParameter #1#2#3 #4#5\end%
        \fi
    \fi}

% Print a C++ function or method return type. Strips a matching
% "const ...&" pair.
% The parameter has to be delimited with "const.&.\end".
\def\CCprintReturnType #1const#2#3&#4#5\end{%
    \if.#2\CCprintTokens #1\end%
    \else
        \if&#2\CCprintReturnType #1#3&#4#5\end%
        \else
        \CCprintReturnType #1#2#3 #4#5\end%
        \fi
    \fi}


