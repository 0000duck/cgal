% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Section: Smallest Enclosing Ellipses
% Subsec.: Requirements of Traits Classes for 2D Smallest Enclosing Ellipse
% -----------------------------------------------------------------------------
% file  : doc_tex/basic/Optimisation/requirements_Min_ellipse_2.tex
% author: Sven Schönherr <sven@inf.fu-berlin.de>
% -----------------------------------------------------------------------------
% $CGAL_Package: Min_ellipse_2 WIP $
% $Revision$
% $Date$
% =============================================================================

\ccHtmlNoClassToc
\begin{ccHtmlClassFile}{requirements_Min_ellipse_2.html}{%
    Requirements of Traits Classes for 2D Smallest Enclosing Ellipse}
\begin{ccTexOnly}
  \subsection{Requirements of Traits Classes for 2D Smallest Enclosing Ellipse}
  \label{sec:min_ellipse_2_traits_req}
\end{ccTexOnly}
\begin{ccHtmlOnly}
  <H2>Requirements of Traits Classes for 2D Smallest Enclosing Ellipse</H2><P>
\end{ccHtmlOnly}

\cgalSetOptTraitsReqLayout

The class template \ccc{CGAL_Min_ellipse_2} is parameterized with a
\ccc{Traits} class which defines the abstract interface between the
optimisation algorithm and the primitives it uses. The following
requirements catalog lists the primitives, i.e.\ types, member
functions etc., that must be defined for a class that can be used to
parameterize \ccc{CGAL_Min_ellipse_2}.  A traits class implementation
using the \cgal\ 2D kernel is available and described in
Section~\ref{sec:min_ellipse_2_traits_impl_2D_kernel}. In addition, we
provide traits class adapters to user supplied point classes, see
Sections~\ref{sec:min_ellipse_2_traits_adapterC2}
and~\ref{sec:min_ellipse_2_traits_adapterH2}. Both, the implementation
and the adapters, can be used as a starting point for customizing own
traits classes, e.g.\ through derivation and specialization.

% =============================================================================

\ccHtmlNoClassToc
\ccHtmlNoClassLinks
\ccHtmlNoClassIndex
\begin{ccClass}{Traits}
\subsection*{Traits Class (\ccClassTemplateName)}

% -----------------------------------------------------------------------------
\ccDefinition

A class that satisfies the requirements of a traits class for
\ccc{CGAL_Min_ellipse_2} must provide the following primitives.

% -----------------------------------------------------------------------------
\ccTypes

\ccNestedType{Point}{
        The point type must provide default and copy constructor,
        assignment and equality test.}

\ccNestedType{Ellipse}{
        The ellipse type must fulfill the requirements listed below
        in the next section.}

In addition, if I/O is used, the corresponding I/O operators for
\ccc{Point} and \ccc{Ellipse} have to be provided, see topic
\textbf{I/O} in Section~\ref{sec:min_ellipse_2_spec}.

% -----------------------------------------------------------------------------
\ccHeading{Variables}

\ccVariable{ Ellipse  ellipse;}{
        The actual ellipse. This variable is maintained by the algorithm,
        the user should neither access nor modify it directly.}

% -----------------------------------------------------------------------------
\ccCreation
\ccCreationVariable{traits}

Only default and copy constructor are required. Note that further
constructors can be provided.

\ccConstructor{ Traits( );}{A default constructor.}

\ccConstructor{ Traits( const Traits&);}{A copy constructor.}

\end{ccClass}

% =============================================================================

\ccHtmlNoClassToc
\ccHtmlNoClassLinks
\ccHtmlNoClassIndex
\begin{ccClass}{Ellipse}
\subsection*{Ellipse Type (\ccClassTemplateName)}

% -----------------------------------------------------------------------------
\ccDefinition
 
An object of the class \ccClassName\ is an ellipse in two-dimensional
euclidean plane $\E_2$. Its boundary splits the plane into a bounded
and an unbounded side. By definition, an empty \ccClassName\ has no
boundary and no bounded side, i.e.\ its unbounded side equals the
whole plane $\E_2$.

% -----------------------------------------------------------------------------
\ccTypes
 
\ccNestedType{Point}{Point type.}

% -----------------------------------------------------------------------------
\ccCreation
\ccCreationVariable{ellipse}
 
\ccMemberFunction{ void  set( );}{
        sets \ccVar\ to the empty ellipse.}

\ccMemberFunction{ void  set( const Point& p);}{
        sets \ccVar\ to the ellipse containing exactly $\{\mbox{\ccc{p}}\}$.}

\ccMemberFunction{ void  set( const Point& p,
                              const Point& q);}{
        sets \ccVar\ to the ellipse containing exactly the segment
        \ccTexHtml{$\overline{\mbox{\ccc{p}\ccc{q}}}$}{<i>pq</i>}.
        The algorithm guarantees that \ccc{set} is never called
        with two equal points.}

\ccMemberFunction{ void  set( const Point& p,
                              const Point& q,
                              const Point& r);}{
        sets \ccVar\ to the smallest ellipse through \ccc{p},\ccc{q},\ccc{r}.
        The algorithm guarantees that \ccc{set} is never called with
        three collinear points.}

\ccMemberFunction{ void  set( const Point& p,
                              const Point& q,
                              const Point& r,
                              const Point& s);}{
        sets \ccVar\ to the smallest ellipse through
        \ccc{p},\ccc{q},\ccc{r},\ccc{s}. The algorithm guarantees that
        this ellipse exists.}

\ccMemberFunction{ void  set( const Point& p,
                              const Point& q,
                              const Point& r,
                              const Point& s,
                              const Point& t);}{
        sets \ccVar\ to the unique conic through
        \ccc{p},\ccc{q},\ccc{r},\ccc{s},\ccc{t}. The algorithm
        guarantees that this conic is an ellipse.}

% -----------------------------------------------------------------------------
\ccPredicates

\ccMemberFunction{ bool  has_on_unbounded_side( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies properly outside of \ccVar.}

Each of the following predicates is only needed, if the corresponding
predicate of \ccc{CGAL_Min_ellipse_2} is used.

\ccMemberFunction{ CGAL_Bounded_side
                   bounded_side( const Point& p) const;}{
        returns \ccc{CGAL_ON_BOUNDED_SIDE}, \ccc{CGAL_ON_BOUNDARY} or
        \ccc{CGAL_ON_UNBOUNDED_SIDE} iff \ccc{p} lies properly inside,
        on the boundary, or properly outside of \ccVar, resp.}

\ccMemberFunction{ bool  has_on_bounded_side( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies properly inside \ccVar.}

\ccMemberFunction{ bool  has_on_boundary( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies on the boundary
        of \ccVar.}

\ccMemberFunction{ bool  is_empty( ) const;}{
        returns \ccc{true}, iff \ccVar\ is empty (this implies
        degeneracy).}

\ccMemberFunction{ bool  is_degenerate( ) const;}{
        returns \ccc{true}, iff \ccVar\ is degenerate, i.e.\ if
        \ccVar\ is empty or equal to a single point.}

% -----------------------------------------------------------------------------
\ccHeading{I/O}

The following I/O operators are only needed,%
\SaveSpaceByHand{\ccTexHtml{$\!$}{}}
                                             if the corresponding I/O
operators of \ccc{CGAL_Min_ellipse_2} are used.

\ccHtmlNoIndex
\ccFunction{ ostream& operator << ( ostream& os, const Ellipse& ellipse);}{
        writes \ccVar\ to output stream \ccc{os}.}

\ccHtmlNoIndex
\ccFunction{ CGAL_Window_stream&
             operator << ( CGAL_Window_stream& ws, const Ellipse& ellipse);}{
        writes \ccVar\ to window stream \ccc{ws}.}

% -----------------------------------------------------------------------------

\end{ccClass}

% =============================================================================

\end{ccHtmlClassFile}

% ===== EOF ===================================================================
