encodeQpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	
	fd:= fopen(cat(fpath, ".data_r"), WRITE);
	

	m := Dimensions(a)[1]; 
	n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
   
	writeTags(fd, "r", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);

	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeRatMatrix(fd, a, m, n);
 

	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
		fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;

	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeRatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
	        writeRatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;

	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeRatMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;

	fclose(fd);
	
end proc;

encodeLpRatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix, 
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	
	fd:= fopen(cat(fpath, ".data_r"), WRITE);
	

	m := Dimensions(a)[1]; 
	n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "r", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
		
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeRatMatrix(fd, a, m, n);
 

	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
		fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;

	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeRatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
	        writeRatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;

	fclose(fd);
	
end proc;


encodeQpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_f"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "f", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeFloatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeFloatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeFloatMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	fclose(fd);
	
end proc;

encodeLpFloatProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_f"), WRITE);
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	    
	writeTags(fd, "f", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeFloatMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeFloatMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
		
	fclose(fd);
	
end proc;


encodeQpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				d::Matrix, desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_i"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, gen_desc);
	    
	writeTags(fd, "i", 0, isSymmetric(d),
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeIntMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeIntMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
	
	if (Dimensions(d)[1] = n) and (Dimensions(d)[2] = n) then
	        fprintf(fd, "%s", "D\n");
		writeIntMatrix(fd, d, n, n);
	else
	        printf("%s", "wrong dimensions in D\n");
	end if;
	
	fclose(fd);
	
end proc;

encodeLpIntProblem:=proc(a::Matrix, rel::Matrix, b::Matrix, c::Matrix,
				desc::string, gen_desc::string, fpath::string)
	local m, n, i, j, fd, Dimensions;

	Dimensions := LinearAlgebra[Dimensions];
	 
	fd:= fopen(cat(fpath, ".data_i"), WRITE);
	

	m:= Dimensions(a)[1]; n := Dimensions(a)[2];
	
	writeDescription(fd, desc);
	writeDescription(fd, desc);
	    
	writeTags(fd, "i", 1, 1,
		hasEqualitiesOnlyAndFullRank(a, rel, m), 0);
	    
	    
	fprintf(fd, "%s", "dimensions\n");
	fprintf(fd, "%d%s%d%s", m, " ", n, "\n");
	fprintf(fd, "%s", "\n");
	fprintf(fd, "%s", "A\n");
	writeFloatMatrix(fd, a, m, n);
 
	if (Dimensions(rel)[1] = m) and (Dimensions(rel)[2] = 1) then
	        fprintf(fd, "%s", "rel\n");
		#write as row vector
		writeIntMatrixTransposed(fd, rel, m, 1);
	else
	        printf("%s", "wrong dimensions in rel\n");
	end if;
	
	if (Dimensions(b)[1] = m) and (Dimensions(b)[2] = 1) then
	        fprintf(fd, "%s", "b\n");
		#write as row vector
		writeIntMatrixTransposed(fd, b, m, 1);
	else
	        printf("%s", "wrong dimensions in b\n");
	end if;

	if (Dimensions(c)[1] = 1) and (Dimensions(c)[2] = n) then
	        fprintf(fd, "%s", "c\n");
		writeIntMatrix(fd, c, 1, n);
	else
	        printf("%s", "wrong dimensions in c\n");
	end if;
		
	fclose(fd);
	
end proc;


writeRatMatrix:=proc(fileDesc, matrix, m, n)
	local i, j;
	for i from 1 by 1 to m do
	    for j from 1 by 1 to n do
	        if type(matrix[i,j], fraction) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a%s%a", matrix[i,j], "/", 1);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeRatMatrixTransposed:=proc(fileDesc, matrix, m, n)
	local i, j;
	for j from 1 by 1 to n do
	    for i from 1 by 1 to m do
	        if type(matrix[i,j], fraction) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a%s%a", matrix[i,j], "/", 1);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

		 	  
writeFloatMatrix:=proc(fileDesc, matrix, m, n)
	local i, j;
	for i from 1 by 1 to m do
	    for j from 1 by 1 to n do
	        if type(matrix[i,j], float) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeFloatMatrixTransposed:=proc(fileDesc, matrix, m, n)
	local i, j;
	for j from 1 by 1 to n do
	    for i from 1 by 1 to m do
	        if type(matrix[i,j], float) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		elif type(matrix[i,j], integer) then
		    fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;


writeIntMatrix:=proc(fileDesc, matrix, m, n)
	local i, j;
	for i from 1 by 1 to m do
	    for j from 1 by 1 to n do
	        if type(matrix[i,j], integer) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeIntMatrixTransposed:=proc(fileDesc, matrix, m, n)
	local i, j;
	for j from 1 by 1 to n do
	    for i from 1 by 1 to m do
	        if type(matrix[i,j], integer) then
	            fprintf(fileDesc, "%a", matrix[i,j]);
		else
		    printf("%s", "format error");
		end if;
		fprintf(fileDesc, "%s", "\t");
	    end do;
	    fprintf(fileDesc, "%s", "\n");
	end do;
	fprintf(fileDesc, "%s", "\n");
end proc;

writeTags:=proc(fileDesc, inputDataType, isLinear, isSymmetric, hasEqualitiesOnlyAndFullRank, isInStandardForm) 
	fprintf(fileDesc, "%s", "tags\n");
	fprintf(fileDesc, "%s\t\t%s\n", "input_data_type", inputDataType);
	fprintf(fileDesc, "%s\t\t%d\n", "is_linear", isLinear);
	fprintf(fileDesc, "%s\t\t%d\n", "is_symmetric", isSymmetric);
	fprintf(fileDesc, "%s\t%d\n", "has_equalities_only_and_full_rank", hasEqualitiesOnlyAndFullRank);
	fprintf(fileDesc, "%s\t%d\n", "is_in_standard_form", isInStandardForm);
	fprintf(fileDesc, "\n");
end proc;

writeDescription:=proc(fileDesc, desc)
	local q, r, i, line;
	line := 79;
	q := iquo(length(desc), line);
	r := irem(length(desc), line);
	for i from 1 by 1 to q do
	    fprintf(fileDesc, "%s%s%s", "#", desc[(i-1)*line+1 .. i*line], "\n");
	end do; 
	if (r > 0) then
	    fprintf(fileDesc, "%s%s%s", "#", desc[q*line+1 .. length(desc)],
	        "\n");
	fi;
	fprintf(fileDesc, "%s", "\n");
end proc;

isLinear:=proc(D, n)
	local zero, ret;
	
	zero := LinearAlgebra[ZeroMatrix](n,n);
	if (LinearAlgebra[Equal](D,zero)) then
		ret := 1;
	else
		ret := 0;
	fi;
	return ret;
end proc;

hasEqualitiesOnlyAndFullRank:=proc(a, relop, m)
	local zero, ret;
	
	zero:=LinearAlgebra[ZeroMatrix](m,1);
	if (LinearAlgebra[Equal](relop, zero) and 
	    LinearAlgebra[Rank](a) = m) then
	    ret := 1;
	else
	    ret := 0;
	fi;
	return ret;
end proc;
	
isSymmetric:=proc(D)
	local ret;
	if (LinearAlgebra[Equal](D, LinearAlgebra[Transpose](D))) then	
		ret := 1;
	else
		ret := 0;
	fi;
	return ret;
end proc;
