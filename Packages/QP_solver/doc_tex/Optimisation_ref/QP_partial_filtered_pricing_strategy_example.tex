%%% Automatically generated by cc2tex
\documentclass{article}
\usepackage{realA4,colordvi,alltt}
\pagestyle{empty}

%% ----- cc2tex color definition -----
%% for color print
\def\RED#1{\Mahogany{#1}}
\def\BLUE#1{\Orchid{#1}}
\def\LBLUE#1{\MidnightBlue{#1}}
\def\MBLUE#1{\Periwinkle{#1}}
\def\GBLUE#1{\CadetBlue{#1}}
\def\BLACK#1{\Black{#1}}
\def\TAN#1{\Tan{#1}}
\def\VIOLET#1{\Blue{#1}}
\def\MAGENTA#1{\Thistle{#1}}
\def\BROWN#1{\Plum{#1}}
\def\GRAY#1{\Gray{#1}}
\def\GREEN#1{\OliveGreen{#1}}

\begin{document}
\Large\vspace*{-2cm}\setlength{\oddsidemargin}{-15mm}\setlength{\evensidemargin}{-15mm}
\begin{alltt}
\textbf{\MAGENTA{#include <CGAL/QP_solver.h>}}
\textbf{\MAGENTA{#include <CGAL/QP_full_exact_pricing.h>}}
\textbf{\MAGENTA{#include <CGAL/QP_partial_exact_pricing.h>}}
\textbf{\MAGENTA{#include <CGAL/QP_full_filtered_pricing.h>}}
\textbf{\MAGENTA{#include <CGAL/QP_partial_filtered_pricing.h>}}
\textbf{\MAGENTA{#include <CGAL/_QP_solver/Double.h>}}
\textbf{\MAGENTA{#include <iostream>}}

\textbf{\BLUE{typedef}}  \textbf{\GBLUE{double}}               IT;
\textbf{\BLUE{typedef}}  std::vector<IT>\textbf{\BROWN{      Point;}}
\textbf{\BLUE{typedef}}  std::vector<Point>\textbf{\BROWN{  Matrix;}}

\textbf{\MBLUE{template < class Point >}} 
\textbf{\BLUE{class}}\textbf{\BROWN{ PD_D_row_iterator}} \begin{math}\{\end{math}

  \textsl{\RED{// types needed for iterators}}
  \textbf{\BLUE{typedef}}  std::random_access_iterator_tag\textbf{\BROWN{                iterator_category;}}
  \textbf{\BLUE{typedef}}  ptrdiff_t\textbf{\BROWN{                                      difference_type;}}
  \textbf{\BLUE{typedef}}  \textbf{\BLUE{typename}} Point::value_type\textbf{\BROWN{                     value_type;}}
  \textbf{\BLUE{typedef}}  value_type*\textbf{\BROWN{                                    pointer;}}
  \textbf{\BLUE{typedef}}  value_type&\textbf{\BROWN{                                    reference;}}

  \textbf{\BLUE{typedef}}  \textbf{\BLUE{typename}} std::vector<Point>::const_iterator\textbf{\BROWN{    Point_it;}}
  \textsl{\RED{// coordinate type of points}}
  \textbf{\BLUE{typedef}}  \textbf{\BLUE{typename}} Point::value_type\textbf{\BROWN{                     CT;}}

  \textsl{\RED{// data members}}
  Point_it      points;       \textsl{\RED{// iterator referring to C matrix}}
  \textbf{\GBLUE{int}}           i;            \textsl{\RED{// row index}}
  \textbf{\GBLUE{int}}           j;            \textsl{\RED{// column index}}

\textbf{\VIOLET{public}}:
  \textbf{\BROWN{PD_D_row_iterator}}( Point_it it, \textbf{\GBLUE{int}} row) : points( it), i( row), j( 0) \begin{math}\{\end{math} \begin{math}\}\end{math}
  
  CT  \textbf{\BROWN{operator *}} ( ) \begin{math}\{\end{math}
    \textbf{\VIOLET{return}} std::inner_product( points[ i].begin( ), points[ i].end( ),
      points[ j].begin( ), CT( ));
  \begin{math}\}\end{math}
  
  \textsl{\RED{// other operators required for random access iterators}}
  \textsl{\RED{// ...}}
  
\begin{math}\}\end{math};

\textbf{\MBLUE{template < class Point >}}
\textbf{\BLUE{class}}\textbf{\BROWN{ PD_D_iterator}} \begin{math}\{\end{math}

  \textsl{\RED{// types needed for iterators}}
  \textbf{\BLUE{typedef}}  std::random_access_iterator_tag\textbf{\BROWN{                iterator_category;}}
  \textbf{\BLUE{typedef}}  ptrdiff_t\textbf{\BROWN{                                      difference_type;}}
  \textbf{\BLUE{typedef}}  PD_D_row_iterator<Point>\textbf{\BROWN{                       value_type;}}
  \textbf{\BLUE{typedef}}  value_type*\textbf{\BROWN{                                    pointer;}}
  \textbf{\BLUE{typedef}}  value_type&\textbf{\BROWN{                                    reference;}}

  \textbf{\BLUE{typedef}}  \textbf{\BLUE{typename}} std::vector<Point>::const_iterator\textbf{\BROWN{    Point_it;}}
  \textbf{\BLUE{typedef}}  PD_D_row_iterator<Point>\textbf{\BROWN{                       Row_it;}}
  
  \textsl{\RED{// data members}}
  Point_it      points;       \textsl{\RED{// iterator referring to C matrix}}
  \textbf{\GBLUE{int}}           i;            \textsl{\RED{// row index}}
  
\textbf{\VIOLET{public}}:
  \textbf{\BROWN{PD_D_iterator}}( Point_it it) : points( it), i( 0) \begin{math}\{\end{math} \begin{math}\}\end{math}
  
  Row_it  \textbf{\BROWN{operator *}} ( ) \begin{math}\{\end{math} \textbf{\VIOLET{return}} Row_it( points, i);\begin{math}\}\end{math}
  
  \textsl{\RED{// other operators required for random access iterators}}
  \textsl{\RED{// ...}}
  
\begin{math}\}\end{math};


\textbf{\BLUE{typedef}}  CGAL::QP_transform_iterator_1< Matrix::const_iterator>\textbf{\BROWN{  Vector_iterator;}}

\textbf{\BLUE{struct}}\textbf{\BROWN{ QPSolverTraits}} \begin{math}\{\end{math}
    \textbf{\BLUE{typedef}}  GMP::Double\textbf{\BROWN{                         ET;}}
    \textbf{\BLUE{typedef}}  Vector_iterator\textbf{\BROWN{                     A_iterator;}}
    \textbf{\BLUE{typedef}}  CGAL::QP_const_value_iterator<IT>\textbf{\BROWN{  B_iterator;}}
    \textbf{\BLUE{typedef}}  CGAL::QP_const_value_iterator<IT>\textbf{\BROWN{  C_iterator;}}
    \textbf{\BLUE{typedef}}  PD_D_iterator<Point>\textbf{\BROWN{                D_iterator;}}

    \textbf{\BLUE{enum}}\textbf{\BROWN{ Row_type}} \begin{math}\{\end{math} LESS_EQUAL, EQUAL, GREATER_EQUAL\begin{math}\}\end{math};
    \textbf{\BLUE{typedef}}  CGAL::QP_const_value_iterator<Row_type>\textbf{\BROWN{  Row_type_iterator;}}
    
    \textbf{\BLUE{typedef}}  CGAL::Tag_false\textbf{\BROWN{  Is_linear;}}
    \textbf{\BLUE{typedef}}  CGAL::Tag_true\textbf{\BROWN{   Is_symmetric;}}
    \textbf{\BLUE{typedef}}  CGAL::Tag_true\textbf{\BROWN{   Has_full_row_rank;}}
    \textbf{\BLUE{typedef}}  CGAL::Tag_false\textbf{\BROWN{  Use_perturbation;}}
\begin{math}\}\end{math};

\textbf{\BLUE{typedef}} CGAL::QP_solver<QPSolverTraits>\textbf{\BROWN{     Solver;}}

\textbf{\GBLUE{int}} \textbf{\BROWN{main}}( \textbf{\GBLUE{int}} argc, \textbf{\GBLUE{char}}** argv)
\begin{math}\{\end{math}
  Matrix  A( 6);
  Matrix  C( 6);

  \textsl{\RED{// constraint matrix A, column by column}}
  A[ 0].push_back( 1); A[ 1].push_back( 1); A[ 2].push_back( 1);
  A[ 0].push_back( 0); A[ 1].push_back( 0); A[ 2].push_back( 0);
  A[ 3].push_back( 0); A[ 4].push_back( 0); A[ 5].push_back( 0);
  A[ 3].push_back( 1); A[ 4].push_back( 1); A[ 5].push_back( 1);

  \textsl{\RED{// point matrix C, column by column }}
  C[ 0].push_back(  2); C[ 1].push_back(  6); C[ 2].push_back(  5);
  C[ 0].push_back(  2); C[ 1].push_back(  1); C[ 2].push_back(  5);
  
  C[ 3].push_back( -7); C[ 4].push_back( -9); C[ 5].push_back( -6);
  C[ 3].push_back( -4); C[ 4].push_back( -7); C[ 5].push_back( -7);      

  \textsl{\RED{// configure partial filtered pricing strategy with default template}}
  \textsl{\RED{// parameters}}
  CGAL::QP_partial_filtered_pricing<QPSolverTraits>  strategy;
  
  \textsl{\RED{// solve qp with (explicit) partial filtered pricing strategy}}
  Solver       qp( 6, 2, Vector_iterator( A.begin()),
                   QPSolverTraits::B_iterator(1.0),
                   QPSolverTraits::C_iterator(0.0),
                   QPSolverTraits::D_iterator(C.begin()),
                   QPSolverTraits::Row_type_iterator(QPSolverTraits::EQUAL),
                   strategy);
  
  \textsl{\RED{// query solution, if qp is optimal                                     }}
  \textbf{\VIOLET{if}} (qp.status() == Solver::OPTIMAL) \begin{math}\{\end{math}
    Solver::Variable_value_iterator v_it;
    Solver::Variable_value_iterator e_it = qp.variables_value_end(); 
    \textbf{\VIOLET{for}} (\textbf{\GBLUE{int}} i = 0, v_it = qp.variables_value_begin(); v_it != e_it; ++v_it, ++i) \begin{math}\{\end{math}
      std::cout << \TAN{"x["} << i << \TAN{"]= "} << *v_it << std::endl;
    \begin{math}\}\end{math}
  \begin{math}\}\end{math}                           
  \textbf{\VIOLET{return}} 0;
\begin{math}\}\end{math}\end{alltt}
\end{document}
%% EOF
