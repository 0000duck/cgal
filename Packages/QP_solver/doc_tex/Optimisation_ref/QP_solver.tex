% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Section: Smallest Enclosing Sphere
% =============================================================================

\begin{ccRefClass}{QP_solver<Traits>}
\ccIndexSubitem[t]{sphere}{smallest enclosing sphere of spheres}
\ccIndexSubitem[t]{smallest enclosing}{sphere of spheres}
\ccIndexSubitem[t]{bounding volumes}{smallest enclosing sphere of spheres}
\ccIndexSubitemSeeAlso[t]{circle}{smallest enclosing sphere of spheres}

% -----------------------------------------------------------------------------
\ccDefinition
An object of the class \ccRefName\ is a data structure that represents
a vector $x$ attaining the minimum of the convex quadratic objective
function $f(x)=c^{T}x+x^{T}Dx$, $x \in \R^{n}$, on a domain $R \subset
\R^{n}$ given as the intersection $R=\{ x\in\R^n \mid \mbox{$Ax\leq b,
x\ge 0$}\}$ of halfspaces and hyperplanes,
\begin{eqnarray*}
\mbox{(QP)}&\mbox{minimize} & c^{T}x+x^{T}Dx \\
&\mbox{subject to}   & Ax \leq b \\
&& x \geq 0.
\end{eqnarray*}
Here, $A \in \R^{m \times n}$, $b \in \R^{m}$, $c \in \R^{n}$, and in
addition, the matrix $D \in \R^{n \times n}$ is positive-semidefinite.
A vector $x \in \R^{n}$ is said to be a \emph{feasible solution} if $x
\in R$; a feasible solution $x$ is called an \emph{optimal feasible
solution} if $f(x')\geq f(x)$ for all $x'\in R$.  If $R=\emptyset$ the
quadratic program is said to be \emph{infeasible}; it is
\emph{feasible} if $\R\not=\emptyset$.  If $f$ is bounded from below
on $R$, the quadratic program is called \emph{bounded}, otherwise
\emph{unbounded}.  A quadratic program that is feasible and bounded
has an optimal feasible solution (which need not be unique), and we
call the program \emph{optimally solvable} (\emph{optimal} for short).
Corresponding to this, an object of the class \ccRefName\ has a
\emph{status} that indicates whether the quadratic program (QP) is
infeasible, unbounded, or optimal.  A \emph{feasible solution} of (QP)
can be specified by a subset $B\subseteq\{1,\ldots,n\}$ of the
variables and their values $x_{B}$ in such a way that all variables
$\{1,\ldots,n\}\setminus B$ have value zero; in this case, the
variables in $B$ are said to be \emph{basic} and the variables in
$\{1,\ldots,n\}\setminus B$ are called \emph{nonbasic}.  (Nonbasic
variables always have value zero; a basic variable might have value
zero.)
%
%An optimal feasible solution need not be unique.

The algorithm determines the status of the quadratic program; if the
status is solvable, an optimal feasible solution $\tilde{x}$ is
computed together with the value $f(\tilde{x})$.  The optimal feasible
solution $\tilde{x}$ is, as described above, characterized by some set
$B \subseteq \{1,\ldots,n\}$ and the values $\tilde{x}_{B}$.  In order
to improve performance, the algorithm can be tailored to specific
instances of the quadratic program.  In particular, if the program is
known to be linear (i.e., $D=0$) or symmetric (meaning $D^{T}=D$), or
if the constraint matrix $A$ is known to have full row rank then
compile-time flags in the traits class \ccc{Traits} can be used to
specialize the algorithm; the examples below illustrate this.

The solver's underlying algorithm is an \emph{iterative method}; after
having found an initial feasible solution the algorithm steps from
feasible solution to feasible solution, always improving the solution.
An internal aspect of the algorithm that can be tailored to specific
situations is the \emph{pricing strategy}.  The \emph{pricing step} of
the solver's algorithm determines whether or not the current solution
is optimal; if the current solution is not optimal, the pricing step
finds a way of improving the current solution. The pricing strategy
determines which improved solution is taken for the next iteration.

Four ready-to-use pricing strategies are provided: \emph{full exact
pricing}, \emph{full filtered pricing}, \emph{partial exact pricing}
and \emph{partial filtered pricing}; the first one is the default
strategy and the last one the most sophisticated one.  This set of
pricing strategies can be extended by user-provided, customized
pricing strategies, see the documentation of class
\ccc{QP_pricing_stratgey<Traits>}.

Technically, the entries $x_i$, $i\in\{1,\ldots,n\}$, of a feasible
solution $x$ are represented as quotients over the number type
\ccc{ET}; if the (implicit) conversion from the element types of $A$,
$b$, $c$ and $D$ to \ccc{ET} is lossless then feasible solutions
represent exact values (and in particular, the optimal feasible
solution computed by the solver is an exact optimal feasible solution
to the original problem).

For the two filtered pricing strategies, an inexact (fast) number type
\ccc{NT} can be specified, such that performance of the pricing step
is substantially increased and still exact solutions are obtained.
Partial pricing strategies work best for quadratic programs with high
\emph{variables-to-constraints} ratio.  If, in addition, the inexact
number type \ccc{NT} is considerably faster than the number type
\ccc{ET}, the \emph{partial filtered} pricing strategy, which combines
filtered and partial pricing, is the pricing strategy of choice.
   

\ccInclude{CGAL/QP_solver.h}


\ccRequirements
\ccIndexRequirements

The class \ccRefName\ expects a model of the concept
\ccc{QPSolverTraits} as its template argument.

\ccTypes \ccIndexClassTypes

\ccNestedType{ET}{a typedef to \ccc{Traits::ET}.}

\ccNestedType{A_iterator}{a typedef to \ccc{Traits::A_iterator}.}

\ccNestedType{B_iterator}{a typedef to \ccc{Traits::B_iterator}.}

\ccNestedType{C_iterator}{a typedef to \ccc{Traits::C_iterator}.}

\ccNestedType{D_iterator}{a typedef to \ccc{Traits::D_iterator}.}

\ccNestedType{Row_type}{is a typedef to \ccc{Traits::Row_type}.}

\ccNestedType{Row_type_iterator}{is a typedef to
\ccc{Traits::Row_type_iterator}.}

\ccNestedType{Is_linear}{a typedef to \ccc{Traits::Is_linear}.}

\ccNestedType{Is_symmetric}{a typedef to \ccc{Traits::Is_symmetric}.}

\ccNestedType{Has_full_row_rank}{is a typedef to
\ccc{Traits::Has_full_row_rank}.}

\ccNestedType{Use_perturbation}{is a typedef to
\ccc{Traits::Use_perturbation}.}

\ccNestedType{Pricing_strategy}{a typedef to
\ccc{QP_pricing_strategy<Traits>}. \ccc{Pricing_strategy} is a base
class of all read-to-use pricing strategies, and also of all
user-provided pricing strategies.}

\ccNestedType{Quotient}{a typedef to \ccc{CGAL::Quotient<Traits::ET>}}

\ccNestedType{Basic_variable_value_iterator}{}

\ccNestedType{Basic_variable_index_iterator}{}

\ccNestedType{Variable_value_iterator}{}

\ccNestedType{Lambda_value_iterator}{}


%The following enum type is provided by the the class \ccRefName\ :

\ccEnum{enum Status { INFEASIBLE, UNBOUNDED, OPTIMAL };}{enumeration used to
indicate the status of a quadratic program.}


\ccCreation
\ccIndexClassCreation
\ccCreationVariable{qp}

\ccConstructor{( int n, int m, A_iterator a_it,
B_iterator b_it, C_iterator c_it, D_iterator d_it,
Row_type_iterator r_it,
Pricing_strategy& strategy = QP_full_exact_pricing<Traits>());}
{creates a variable of type \ccRefName\ and solves the quadratic program.
\ccRequire $(m,n)$ is the dimension of the constraint matrix $A$,
$(n,n)$ is the dimension of $D$ and $D$ is
positive-semidefinite. Furthermore, $n >0$ is required.
See also \ccc{QPSolverTraits}.}

\ccConstructor{( A_iterator a_it, B_iterator b_f_it,
B_iterator b_e_it, C_iterator c_f_it, C_iterator c_e_it, D_iterator d_it,
Row_type_iterator r_it,
Pricing_strategy& strategy = QP_full_exact_pricing<Traits>());}
{creates a variable of type \ccRefName\ and solves the quadratic program.
\ccRequire $\left|\right.\left[\right.$
\ccc{b_f_it, b_e_it}$)\left|\right.=m$ and 
$\left|\right.\left[\right.$
\ccc{c_f_it, c_e_it}$)\left|\right.=n$.
The dimension of the constraint matrix $A$ is $(m,n)$, the dimension of
$D$ is $(n,n)$ and $D$ is 
positive-semidefinite. Furthermore, $n >0$ is required.
See also \ccc{QPSolverTraits}.}


\ccUnchecked

\ccAccessFunctions
\begin{ccIndexMemberFunctions}
\ccIndexMemberFunctionGroup{access}

\ccMemberFunction{Status status() const;}{returns the status of the quadratic
program.}

\ccMemberFunction{Quotient  solution( ) const;}{ returns the optimal value
of the quadratic program as a quotient over \ccc{ET}.}

\ccMemberFunction{Basic_variable_value_iterator 
basic_variables_value_begin( ) const;}{returns a const-iterator referring
to the first value of the vector $x_{B}$.}

\ccMemberFunction{Basic_variable_value_iterator 
basic_variables_value_end( ) const;}{returns the corresponding
past-the-end const-iterator.}

\ccMemberFunction{Basic_variable_index_iterator
basic_variables_index_begin( ) const;}{returns a const-iterator referring
to the first index in the set $B$.}

\ccMemberFunction{Basic_variable_index_iterator
basic_variables_index_end  ( ) const;}{returns the corresponding
past-the-end const-iterator.}

\ccMemberFunction{Variable_value_iterator
variables_value_begin() const;}{returns a const-iterator referring to the first
variable in the user defined order.}

\ccMemberFunction{Variable_value_iterator
variables_value_end() const;}{returns the corresponding
past-the-end const-iterator.}


\begin{ccAdvanced}    
\ccHeading{Access to $\lambda$}

\ccMemberFunction{Lambda_value_iterator
    lambda_value_begin( ) const;}{returns a const-iterator referring to the
    $\lambda$ associated with the first constraint in user defined order of the
    constraints.}

\ccMemberFunction{Lambda_value_iterator
    lambda_value_end( ) const;}{returns the corresponding pas-the-end
    const-iterator.}
\end{ccAdvanced}
    
\ccHeading{Access to quadratic program}

\ccMemberFunction{int  number_of_variables  ( ) const;}{returns the number of
variables of the quadratic program as specified in constructor.}

\ccMemberFunction{int  number_of_constraints( ) const;}{returns the number of
constraints of the quadratic program as specified in constructor.}

\ccMemberFunction{A_iterator  a_begin( ) const;}{returns a const-random access
iterator referring to the first column of the matrix $A$.}

\ccMemberFunction{A_iterator  a_end( ) const;}{returns a const-random access
iterator referring to the last column of of the matrix $A$.}

\ccMemberFunction{B_iterator  b_begin( ) const;}{returns a const-random access
iterator referring to the first entry of the vector $b$.}

\ccMemberFunction{B_iterator  b_end( ) const;}{returns a const-random access
iterator referring to the last entry of the vector $b$.}

\ccMemberFunction{C_iterator  c_begin( ) const;}{returns a const-random access
iterator referring to the first entry of the vector $c$.}

\ccMemberFunction{C_iterator  c_end( ) const;}{returns a const-random access
iterator referring to the last entry of the vector $c$.}

\ccMemberFunction{D_iterator  d_begin( ) const;}{returns a const-random access
iterator referring to the first row of the matrix $D$.}

\ccMemberFunction{D_iterator  d_end( ) const;}{returns a const-random access
iterator referring to the last row of the matrix $D$.}

\ccMemberFunction{Row_type_iterator  row_type_begin( ) const;}{returns a
const-random access iterator referring to the first entry of the row
type vector.}

\ccMemberFunction{Row_type_iterator  row_type_end( ) const;}{returns a
const-random access iterator referring to the last entry of the row
type vector.}
% -----------------------------------------------------------------------------
\ccPredicates
\ccIndexMemberFunctionGroup{predicates}

\ccMemberFunction{bool  is_basic( int j) const;}{returns \ccc{true} if
variable $x_{j}$, $j \in \left[n\right]$ is basic.}

% -----------------------------------------------------------------------------
\ccModifiers
\ccIndexMemberFunctionGroup{modifiers}



% -----------------------------------------------------------------------------
\ccHeading{Validity Check}
\ccIndexMemberFunctionGroup{validity check}
%\ccIndexSubitem[t]{validity check}{\ccc{Min_sphere_d}}
An object \ccVar\ is valid, iff \ccc{qp.status} is one of the following
three values and their corresponding requirements are met. Let
$R:=\{x \in \R^{n}\left|\right. Ax \leq b\}$.
\begin{description}
\item[OPTIMAL:] Let $x^{*}$ denote the solvers solution, then 
$Ax^{*} \leq b$ and $f(x^{*}) \leq f(x)$ for all $x \in R$ must hold.
\item[INFEASIBLE:] $R = \emptyset$.
\item[UNBOUNDED:] There exists a feasible solution $x \in \R^{n}$ such that
$Ax \leq b$ and there exists $q \in \R^{n}$ such that
  \begin{itemize}
    \item $q \leq 0$
    \item $Aq = 0$
    \item $q^{T}Dq=0$
    \item $(c^{T} + 2x^{T}D)q > 0$
  \end{itemize}
holds.
\end{description}

\ccMemberFunction{ bool is_solution_valid() const;}{ returns \ccc{true}, iff
  \ccVar\ is valid.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}
\ccIndexMemberFunctionGroup{miscellaneous}


\end{ccIndexMemberFunctions}


% -----------------------------------------------------------------------------
\ccSeeAlso
%
    \ccRefIdfierPage{CGAL::QP_full_exact_pricing<Traits>}\\
    \ccRefIdfierPage{CGAL::QP_full_filtered_pricing<Traits, NT, ET2NT>}\\
    \ccRefIdfierPage{CGAL::QP_partial_exact_pricing<Traits>}\\
    \ccRefIdfierPage{CGAL::QP_partial_filtered_pricing<Traits, NT, ET2NT>}\\
% -----------------------------------------------------------------------------

\ccImplementation
\ccIndexImplementation
%\ccIndexSubitem[t]{incremental algorithm}{\ccc{Min_sphere_of_spheres_d}}
%\ccIndexSubitem[t]{farthest-first heuristic}{\ccc{Min_sphere_of_spheres_d}}

The current implementation does not guarantee termination for all
instances; in rare cases, the algorithm cycles forever.  (Termination
can always be guaranteed by using symbolic perturbation, and this
feature will be added in a future release.)

\ccExample
\ccIncludeVerbatim{Optimisation_ref/QP_solver_example.C}

\end{ccRefClass}

% ===== EOF ===================================================================

