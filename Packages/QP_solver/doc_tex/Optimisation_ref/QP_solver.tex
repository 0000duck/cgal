% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Section: Smallest Enclosing Sphere
% =============================================================================

\begin{ccRefClass}{QPE_solver<Traits>}
\ccIndexSubitem[t]{sphere}{smallest enclosing sphere of spheres}
\ccIndexSubitem[t]{smallest enclosing}{sphere of spheres}
\ccIndexSubitem[t]{bounding volumes}{smallest enclosing sphere of spheres}
\ccIndexSubitemSeeAlso[t]{circle}{smallest enclosing sphere of spheres}

% -----------------------------------------------------------------------------
\ccDefinition
An object of the class \ccRefName\ is a data structure that
represents a vector $x$ attaining the minimum of the convex quadratic objective
function $f(x)=c^{T}x+x^{T}Dx$, $x \in \R^{n}$, on a domain $R \subset \R^{n}$
given as the intersection of half spaces and hyperplanes,
\begin{eqnarray*}
(QP)&minimize & c^{T}x+x^{T}Dx \\
&s.t.     & Ax \leq b \\
&& x \geq 0.
\end{eqnarray*}
Here, $A \in \R^{m \times n}$, $b \in \R^{m}$, $c \in \R^{n}$ and
$D \in \R^{n \times n}$ is positive-semidefinite.
A vector $x \in \R^{n}$ is said to be a \emph{feasible solution}
if $x \in R$; if $R=\emptyset$ the quadratic program is said to be
\emph{infeasible}. If $f(x)$ is bounded from
below on $R$, the quadratic program is said to be \emph{bounded}, otherwise
\emph{unbounded}. An object of the class \ccRefName\ has a \emph{status} that
is either infeasible, unbounded or optimal.  
A \emph{feasible solution} is characterized by a
subset $B\subseteq\left[n\right]$, of the variables
and their values $x_{B}$;
variables in $B$ are said to be \emph{basic}, \emph{nonbasic} otherwise. 
Nonbasic variables always have value zero. An optimal feasible solution
need not be unique.

The algorithm determines the status of the quadratic program; if the status is
optimal, the optimal value $f(x)$ and a set $B \subseteq \left[n\right]$
together with the values $x_{B}$ is computed. Except in rare
cases, the default algorithm terminates. Termination can always be guaranteed
by using symbolic perturbation. The algorithm can be tailored to specific
instances of the quadratic program, each associated with a gain in performance.
These specific
instances comprise the linear case $D=0$, the symmetric case $D^{T}=D$, as
well as the case where the constraint matrix $A$ is known to have full row rank.   

The algorithm used is an \emph{iterative method}; after having found an initial
feasible solution the algorithm steps from feasible solution to feasible
solution, always improving the solution.
An internal aspect of the algorithm that can be tailored to specific situations
is the \emph{pricing strategy}.
The \emph{pricing step} of the solvers algorithm consists of determining 
whether the current solution is optimal; if the current solution is not optimal
the pricing step finds a way of improving the current solution. The pricing
strategy determines which improved solution is taken.


Four ready-to-use pricing strategies are provided: \emph{full exact pricing},
\emph{full filtered pricing}, \emph{partial exact pricing} and
\emph{partial filtered pricing};
the first one is the default strategy and the last one the most sophisticated
one.
This set of pricing strategies can be extended by user provided pricing
strategies by means of inheritance.

Every feasible solution to the quadratic program  is represented as a
quotient over the configurable type \ccc{ET}, such that exact
solutions are computed, if (implicit)
conversion from the element types of $A$, $b$, $c$ and $D$ to \ccc{ET}
is lossless. For the two filtered pricing strategies an inexact (fast) number
type \ccc{NT} can be specified, such that performance of the pricing step is
substantially increased and still exact solutions are obtained.
Partial pricing strategies work best
for quadratic programs with high \emph{variables-to-constraints} ratio.
If, in addition, the inexact number type \ccc{NT} is considerably faster
than the number type \ccc{ET}, then the \emph{partial filtered} pricing
strategy, which combines filtered and partial pricing,
is the pricing strategy of choice.  
   

\ccInclude{CGAL/QPE_solver.h}


\ccRequirements
\ccIndexRequirements

The class \ccRefName\ expects a model of the concept
\ccc{QPESolverTraits} as its template argument.

\ccTypes \ccIndexClassTypes

\ccNestedType{ET}{a typedef to \ccc{Traits::ET}.}

\ccNestedType{A_iterator}{a typedef to \ccc{Traits::A_iterator}.}

\ccNestedType{B_iterator}{a typedef to \ccc{Traits::B_iterator}.}

\ccNestedType{C_iterator}{a typedef to \ccc{Traits::C_iterator}.}

\ccNestedType{D_iterator}{a typedef to \ccc{Traits::D_iterator}.}

\ccNestedType{Row_type}{is a typedef to \ccc{Traits::Row_type}.}

\ccNestedType{Row_type_iterator}{is a typedef to
\ccc{Traits::Row_type_iterator}.}

\ccNestedType{Is_linear}{a typedef to \ccc{Traits::Is_linear}.}

\ccNestedType{Is_symmetric}{a typedef to \ccc{Traits::Is_symmetric}.}

\ccNestedType{Has_full_row_rank}{is a typedef to
\ccc{Traits::Has_full_row_rank}.}

\ccNestedType{Use_perturbation}{is a typedef to
\ccc{Traits::Use_perturbation}.}

\ccNestedType{Pricing_strategy}{a typedef to
\ccc{QPE_pricing_strategy<Traits>}. \ccc{Pricing_strategy} is the base class
of all read-to-use pricing strategies.}

\ccNestedType{Quotient}{a typedef to \ccc{CGAL::Quotient<Traits::ET>}}

\ccNestedType{Basic_variable_value_iterator}{}

\ccNestedType{Basic_variable_index_iterator}{}

\ccNestedType{Variable_value_iterator}{}

\ccNestedType{Lambda_value_iterator}{}


The following enum type is provided by the the class \ccRefName\ :

\ccEnum{enum Status { INFEASIBLE, UNBOUNDED, OPTIMAL };}{enumeration used to
indicate the status of a quadratic program.}


\ccCreation
\ccIndexClassCreation
\ccCreationVariable{qp}

\ccConstructor{( int n, int m, A_iterator a_it,
B_iterator b_it, C_iterator c_it, D_iterator d_it,
Row_type_iterator r_it,
Pricing_strategy& strategy = QPE_full_exact_pricing<Traits>());}
{creates a variable of type \ccRefName\ and solves the quadratic program.
\ccRequire $(m,n)$ is the dimension of the constraint matrix $A$,
$(n,n)$ is the dimension of $D$ and $D$ is
positive-semidefinite. Furthermore, $n >0$ is required.
See also \ccc{QPESolverTraits}.}

\ccConstructor{( A_iterator a_it, B_iterator b_f_it,
B_iterator b_e_it, C_iterator c_f_it, C_iterator c_e_it, D_iterator d_it,
Row_type_iterator r_it,
Pricing_strategy& strategy = QPE_full_exact_pricing<Traits>());}
{creates a variable of type \ccRefName\ and solves the quadratic program.
\ccRequire $\left|\right.\left[\right.$
\ccc{b_f_it, b_e_it}$)\left|\right.=m$ and 
$\left|\right.\left[\right.$
\ccc{c_f_it, c_e_it}$)\left|\right.=n$.
The dimension of the constraint matrix $A$ is $(m,n)$, the dimension of
$D$ is $(n,n)$ and $D$ is 
positive-semidefinite. Furthermore, $n >0$ is required.
See also \ccc{QPESolverTraits}.}


\ccUnchecked

\ccAccessFunctions
\begin{ccIndexMemberFunctions}
\ccIndexMemberFunctionGroup{access}

\ccMemberFunction{Status status() const;}{returns the status of the quadratic
program.}

\ccMemberFunction{Quotient  solution( ) const;}{ returns the optimal value
of the quadratic program as a quotient over \ccc{ET}.}

\ccMemberFunction{Basic_variable_value_iterator 
basic_variables_value_begin( ) const;}{returns a const-iterator referring
to the first value of the vector $x_{B}$.}

\ccMemberFunction{Basic_variable_value_iterator 
basic_variables_value_end( ) const;}{returns the corresponding
past-the-end const-iterator.}

\ccMemberFunction{Basic_variable_index_iterator
basic_variables_index_begin( ) const;}{returns a const-iterator referring
to the first index in the set $B$.}

\ccMemberFunction{Basic_variable_index_iterator
basic_variables_index_end  ( ) const;}{returns the corresponding
past-the-end const-iterator.}

\ccMemberFunction{Variable_value_iterator
variables_value_begin() const;}{returns a const-iterator referring to the first
variable in the user defined order.}

\ccMemberFunction{Variable_value_iterator
variables_value_end() const;}{returns the corresponding
past-the-end const-iterator.}


\begin{ccAdvanced}    
\ccHeading{Access to $\lambda$}

\ccMemberFunction{Lambda_value_iterator
    lambda_value_begin( ) const;}{returns a const-iterator referring to the
    $\lambda$ associated with the first constraint in user defined order of the
    constraints.}

\ccMemberFunction{Lambda_value_iterator
    lambda_value_end( ) const;}{returns the corresponding pas-the-end
    const-iterator.}
\end{ccAdvanced}
    
\ccHeading{Access to quadratic program}

\ccMemberFunction{int  number_of_variables  ( ) const;}{returns the number of
variables of the quadratic program as specified in constructor.}

\ccMemberFunction{int  number_of_constraints( ) const;}{returns the number of
constraints of the quadratic program as specified in constructor.}

\ccMemberFunction{A_iterator  a_begin( ) const;}{returns a const-random access
iterator referring to the first column of the matrix $A$.}

\ccMemberFunction{A_iterator  a_end( ) const;}{returns a const-random access
iterator referring to the last column of of the matrix $A$.}

\ccMemberFunction{B_iterator  b_begin( ) const;}{returns a const-random access
iterator referring to the first entry of the vector $b$.}

\ccMemberFunction{B_iterator  b_end( ) const;}{returns a const-random access
iterator referring to the last entry of the vector $b$.}

\ccMemberFunction{C_iterator  c_begin( ) const;}{returns a const-random access
iterator referring to the first entry of the vector $c$.}

\ccMemberFunction{C_iterator  c_end( ) const;}{returns a const-random access
iterator referring to the last entry of the vector $c$.}

\ccMemberFunction{D_iterator  d_begin( ) const;}{returns a const-random access
iterator referring to the first row of the matrix $D$.}

\ccMemberFunction{D_iterator  d_end( ) const;}{returns a const-random access
iterator referring to the last row of the matrix $D$.}

\ccMemberFunction{Row_type_iterator  row_type_begin( ) const;}{returns a
const-random access iterator referring to the first entry of the row
type vector.}

\ccMemberFunction{Row_type_iterator  row_type_end( ) const;}{returns a
const-random access iterator referring to the last entry of the row
type vector.}
% -----------------------------------------------------------------------------
\ccPredicates
\ccIndexMemberFunctionGroup{predicates}

\ccMemberFunction{bool  is_basic( int j) const;}{returns \ccc{true} if
variable $x_{j}$, $j \in \left[n\right]$ is basic.}

% -----------------------------------------------------------------------------
\ccModifiers
\ccIndexMemberFunctionGroup{modifiers}



% -----------------------------------------------------------------------------
\ccHeading{Validity Check}
\ccIndexMemberFunctionGroup{validity check}
%\ccIndexSubitem[t]{validity check}{\ccc{Min_sphere_d}}
An object \ccVar\ is valid, iff \ccc{qp.status} is one of the following
three values and their corresponding requirements are met. Let
$R:=\{x \in \R^{n}\left|\right. Ax \leq b\}$.
\begin{description}
\item[OPTIMAL:] Let $x^{*}$ denote the solvers solution, then 
$Ax^{*} \leq b$ and $f(x^{*}) \leq f(x)$ for all $x \in R$ must hold.
\item[INFEASIBLE:] $R = \emptyset$.
\item[UNBOUNDED:] There exists a feasible solution $x \in \R^{n}$ such that
$Ax \leq b$ and there exists $q \in \R^{n}$ such that
  \begin{itemize}
    \item $q \leq 0$
    \item $Aq = 0$
    \item $q^{T}Dq=0$
    \item $(c^{T} + 2x^{T}D)q > 0$
  \end{itemize}
holds.
\end{description}

\ccMemberFunction{ bool is_solution_valid() const;}{ returns \ccc{true}, iff
  \ccVar\ is valid.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}
\ccIndexMemberFunctionGroup{miscellaneous}


\end{ccIndexMemberFunctions}


% -----------------------------------------------------------------------------
\ccSeeAlso
%
    \ccRefIdfierPage{CGAL::QPE_full_exact_pricing<Traits>}\\
    \ccRefIdfierPage{CGAL::QPE_full_filtered_pricing<Traits, NT, ET2NT>}\\
    \ccRefIdfierPage{CGAL::QPE_partial_exact_pricing<Traits>}\\
    \ccRefIdfierPage{CGAL::QPE_partial_filtered_pricing<Traits, NT, ET2NT>}\\
% -----------------------------------------------------------------------------

\ccImplementation
\ccIndexImplementation
%\ccIndexSubitem[t]{incremental algorithm}{\ccc{Min_sphere_of_spheres_d}}
%\ccIndexSubitem[t]{farthest-first heuristic}{\ccc{Min_sphere_of_spheres_d}}


\ccExample
\ccIncludeVerbatim{Optimisation_ref/QPE_solver_example.C}

\end{ccRefClass}

% ===== EOF ===================================================================

