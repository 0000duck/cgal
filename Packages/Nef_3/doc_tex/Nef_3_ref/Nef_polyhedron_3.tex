% +------------------------------------------------------------------------+
% | Reference manual page: Nef_polyhedron_3.tex
% +------------------------------------------------------------------------+
% | 26.02.2004   Peter Hachenberger
% | Package: Nef_3
% | 
\RCSdef{\RCSNef_3Rev}{$Revision$}
\RCSdefDate{\RCSNef_3Date}{$Date$}
% +------------------------------------------------------------------------+

\ccRefPageBegin

% RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+

\begin{ccRefClass}{Nef_polyhedron_3<Traits>}

\ccDefinition

An instance of data type \ccc{Nef_polyhedron_3<Traits>} is a subset of the
3-dimensional space that is the result of forming complements and intersections
starting from a finite set \ccc{H} of
3-dimensional halfspaces. \ccc{Nef_polyhedron_3} is closed under all binary set
operations, i.e. \ccc{intersection}, \ccc{union}, \ccc{difference},
\ccc{complement}, and under the topological operations \ccc{boundary},
\ccc{closure}, and \ccc{interior}.

Nef_S2
Extended_kernel

\ccInclude{CGAL/Nef_polyhedron_3.h}

\ccParameters

\begin{tabbing}
\ccc{template <} \=\ccc{class Nef_polyhedronTraits_3,}\\
                 \>\ccc{class Nef_polyhedronItems_3 = CGAL::SNC_items_3,}\\
    \ccc{class Nef_polyhedron_3;}
\end{tabbing}

The first parameter requires one of the following exact kernels:
\ccc{Homogeneous}, \ccc{Simple_homogeneous}, \ccc{Extended_homogeneous_3} 
parametrized with \ccc{Gmpz}, \ccc{leda_integer} or any other number type
modeling \Z, or \ccc{Cartesian}, \ccc{Simple_cartesian}, 
\ccc{Extended_cartesian_3} parametrized with \ccc{Gmpq}, \ccc{leda_rational},
\ccc{Quotient<Gmpz>} or any other number type modeling \Q.

The second parameter expects a model of the concept \ccc{Nef_polyhedronItems_3}.
By default, the class \ccc{CGAL::SNC_items} is preseleted.

\ccTypes

\ccTwo{Nef_polyhedron_3<Traits>::SHalfedge_around_svertex_const_circulator}{}

\ccNestedType{Traits}{traits class selected for \ccc{Nef_polyhedronTraits_3}.}
\ccGlue
\ccNestedType{Items}{items class selected for \ccc{Nef_polyhedronItems_3}.}

\ccNestedType{Size_type}{size type of \ccc{Nef_polyhedron_3}.}

\ccNestedType{Mark} {}

\ccNestedType{Vertex_const_handle}{non-mutable handle to a vertex.}
\ccGlue
\ccNestedType{Halfedge_const_handle}{non-mutable handle to a halfedge.}
\ccGlue
\ccNestedType{Halffacet_const_handle}{non-mutable handle to a halffacet.}
\ccGlue
\ccNestedType{Volume_const_handle}{non-mutable handle to a volume.}
\ccGlue
\ccNestedType{SVertex_const_handle}{non-mutable handle to a svertex.}
\ccGlue
\ccNestedType{SHalfedge_const_handle}{non-mutable handle to a shalfedge.}
\ccGlue
\ccNestedType{SHalfloop_const_handle}{non-mutable handle to a shalfloop.}
\ccGlue
\ccNestedType{SFace_const_handle}{non-mutable handle to a sface.}

\ccNestedType{Vertex_const_iterator}{non-mutable iterator over all vertices.}
\ccGlue
\ccNestedType{Halfedge_const_iterator}{non-mutable iterator over all halfeges.}
\ccGlue
\ccNestedType{Halffacet_const_iterator}{non-mutable iterator over all halffacets.}
\ccGlue
\ccNestedType{Volume_const_iterator}{non-mutable iterator over all volumes.}
\ccGlue
\ccNestedType{SVertex_const_iterator}{non-mutable iterator over all svertices.}
\ccGlue
\ccNestedType{SHalfedge_const_iterator}{non-mutable iterator over all shalfedges.}
\ccGlue
\ccNestedType{SHalfloop_const_iterator}{non-mutable iterator over all shalfloops.}
\ccGlue
\ccNestedType{SFace_const_iterator}{non-mutable iterator over all sfaces.}

\ccNestedType{SHalfedge_around_svertex_const_circulator}{non-mutable circulator of shalfedges around a svertex (cw).}
\ccGlue
\ccNestedType{SHalfedge_around_sface_const_circulator}{non-mutable circulator of shalfedges around a sface (ccw).}
\ccGlue
\ccNestedType{SHalfedge_aroud_facet_const_circulator}{non-mutable circulator of shalfedges around a halffacet (ccw).}
\ccGlue
\ccNestedType{SFace_cycle_const_iterator}{non-mutable iterator over the cylces of a sface.}
\ccGlue
\ccNestedType{Halffacet_cycle_const_iterator}{non-mutable iterator over the cylces of a halffacet.}
\ccGlue
\ccNestedType{Shell_entry_const_iterator}{non-mutable iterator providing an entry to each shell. }

\ccNestedType{Object_handle}{a generic handle to an object. 
  The kind of object \ccc{(vertex, halfedge, halffacet, volume, 
    svertex, shalfedge, shalfloop, sface)} can 
  be determined and the object can be assigned to a corresponding
  handle by one of the following functions:\\
  \ccc{bool assign(Vertex_const_handle& h, Object_handle)}\\
  \ccc{bool assign(Halfedge_const_handle& h, Object_handle)}\\
  \ccc{bool assign(Halffacet_const_handle& h, Object_handle)}\\
  \ccc{bool assign(Volume_const_handle& h, Object_handle)}\\
  \ccc{bool assign(SVertex_const_handle& h, Object_handle)}\\
  \ccc{bool assign(SHalfedge_const_handle& h, Object_handle)}\\
  \ccc{bool assign(SHalfloop_const_handle& h, Object_handle)}\\
  \ccc{bool assign(SFace_const_handle& h, Object_handle)}\\
  where each function returns \ccc{true} iff the assignment to
  \ccc{h} could be accomplished. }

\ccNestedType{Point_3}{location of vertices.}
\ccGlue
\ccNestedType{Segment_3}{segment represented by a halfedge.}
\ccGlue
\ccNestedType{Vector_3}{direction of a halfedge.}
\ccGlue
\ccNestedType{Plane_3}{plane of a halffacet lies in.}
\ccGlue
\ccNestedType{Aff_transformation_3}{affine transformation.}

\ccEnum{enum Boundary { EXCLUDED,  INCLUDED }}{construction selection.}
\ccGlue
\ccEnum{enum Content { EMPTY,  COMPLETE }}{construction selection.}

\ccNestedType{Nef_polyhedron_S2}{a sphere map.}

\ccNestedType{Polyhedron}{a polyhedral surface.}


\ccCreation
\ccCreationVariable{N}

\ccThree{}{}{}
\ccThreeToTwo

\ccConstructor{Nef_polyhedron_3(Content space = EMPTY);} {
  creates a Nef polyhedron and initializes it to the empty 
  set if \ccc{plane == EMPTY}
  and to the whole space if \ccc{space == COMPLETE}.}

\ccConstrcutor{Nef_polyhedron_3(const Plane_3& p, 
                                Boundary b = INCLUDED);}{
  creates a Nef polyhedron containing the halfspace left of
  \ccc{p} including \ccc{p} if \ccc{b==INCLUDED}, excluding \ccc{p}
  if \ccc{b==EXCLUDED}.}

\ccConstrcutor{Nef_polyhedron_3(Polyhedron& P);}{
  creates a Nef polyhedron, which represents the same point set as 
  the polyhedral surface \ccc{P} does.}

\ccConstrcutor{Nef_polyhedron_3(const char* filename);}{
  loads a Nef polyhedron from the \ccc}filename}.}


\ccOperations

\ccMethod{bool is_empty() const;}{returns true, if \ccVar\ is the 
                                  empty point set.}
\ccGlue
\ccMethod{bool is_space() const;}{returns true, if \ccVar\ is the 
                                  complete 3D space.}
\ccGlue
\ccMethod{bool is_simple() const;}{return true, if \ccVar\ is a 2-manifold.}

\ccMethod{bool is_valid() const;}{checks the integrity of \ccVar\.}

\ccMethod{bool operator==(const Nef_polyhedron_3<Traits>& N1) const;}
{returns true, if \ccVar\ and N1 comprise the same point sets.}
\ccMethod{bool operator!=(const Nef_polyhedron_3<Traits>& N1) const;}
{returns true, if \ccVar\ and N1 comprise different point sets. }
\ccMethod{bool operator<(const Nef_polyhedron_3<Traits>& N1) const;}
{returns true, if \ccVar\ is a proper subset of N1. }
\ccMethod{bool operator>(const Nef_polyhedron_3<Traits>& N1) const;}
{returns true, if \ccVar\ is a proper superset of N1. }
\ccMethod{bool operator<=(const Nef_polyhedron_3<Traits>& N1) const;}
{returns true, if \ccVar\ is a subset of N1. }
\ccMethod{bool operator>=(const Nef_polyhedron_3<Traits>& N1) const;}
{returns true, if \ccVar\ is a superset of N1. }

\ccMethod{Size_type number_of_vertices() const;}
{returns the number of vertices.}  
\ccMethod{Size_type number_of_halfedges() const;}
{return the number of halfedges.} 
\ccMethod{Size_type number_of_edges() const;}
{returns the number of halfedge pairs.}     
\ccMethod{Size_type number_of_halffacets() const;}
{returns the number of halffacets.}   
\ccMethod{Size_type number_of_facets() const;}
{returns the number of halffacet pairs.}    
\ccMethod{Size_type number_of_volumes() const;}
{returns the number of volumes.}   

\ccMethod{Nef_polyhedron_3<Traits> complement() const;}
{returns the complement of \ccVar\.}
\ccMethod{Nef_polyhedron_3<Traits> interior() const;}
{returns the interior of \ccVar\.}
\ccMethod{Nef_polyhedron_3<Traits> boundary() const;}
{returns the boundary of \ccVar\.}
\ccMethod{Nef_polyhedron_3<Traits> closure() const;}
{returns the closure of \ccVar\.}
\ccMethod{Nef_polyhedron_3<Traits> regularization() const;}
{returns the regularization, i.e. the closure of the interior, of \ccVar\.}

\ccMethod{void operator!();}
{returns the complement of \ccVar\.}

\ccMethod{Nef_polyhedron_3<Traits> intersection(const Nef_polyhedron_3<Traits>& N1) const;}
{return the intersection of \ccVar\ and N1.}
\ccMethod{Nef_polyhedron_3<Traits> join(const Nef_polyhedron_3<Traits>& N1) const;}
{return the union of \ccVar\ and N1. (Note that ''union'' is a C++ keyword and cannot be used for this operation.)}
\ccMethod{Nef_polyhedron_3<Traits> difference(const Nef_polyhedron_3<Traits>& N1) const;}
{return the difference between \ccVar\ and N1.}
\ccMethod{Nef_polyhedron_3<Traits> symmetric_difference(const Nef_polyhedron_3<Traits>& N1) const;}
{return the symmetric difference of \ccVar\ and N1.}

\ccMethod{Nef_polyhedron_3<Traits> operator*(const Nef_polyhedron_3<Traits>& N1) const;}
{return the intersection of \ccVar\ and N1.}
\ccMethod{Nef_polyhedron_3<Traits> operator+(const Nef_polyhedron_3<Traits>& N1) const;}{}
{return the union of \ccVar\ and N1.}
\ccMethod{Nef_polyhedron_3<Traits> operator-(const Nef_polyhedron_3<Traits>& N1) const;}{}
{return the difference between \ccVar\ and N1.}
\ccMethod{Nef_polyhedron_3<Traits> operator^(const Nef_polyhedron_3<Traits>& N1) const;}{}
{return the symmetric difference of \ccVar\ and N1.}

\ccMethod{void operator*=(const Nef_polyhedron_3<Traits>& N1);}{}
\ccMethod{void operator+=(const Nef_polyhedron_3<Traits>& N1);}{}
\ccMethod{void operator-=(const Nef_polyhedron_3<Traits>& N1);}{}
\ccMethod{void operator^=(const Nef_polyhedron_3<Traits>& N1);}{}

\ccMethod{Object_handle locate(const Point_3& p) const;}
{returns a generic handle to the object (vertex, edge, facet or volume) that
  contains the point p in its relative interior.}
%\ccMethod{bool contains(Object_handle h) const;}{}
%\ccMethod{bool contained_in_boundary(Object_handle h) const;}{}

\ccMethod{void clear(Content space = EMPTY);}
{make \ccVar\ the empty set if \ccc{space == EMPTY} and
 the complete 3D space if \ccc{space == COMPLETE}.}

\ccMethod{void transform(const Aff_transformation_3& aff);}{}

\ccMethod{void dump() const;}{}
\ccMethod{void convert_to_Polyhedron(Polyhedron& P) const;}{}
\ccMethod{Nef_polyhedron_S2 get_sphere_map(Vertex_const_iterator v) const;}{}

\ccMethod{Mark mark(Vertex_const_handle v) const;}{}
\ccMethod{Mark mark(Halfedge_const_handle e) const;}{}
\ccMethod{Mark mark(Halffacet_const_handle f) const;}{}
\ccMethod{Mark mark(Volume_const_handle c) const;}{}

\ccMethod{Vertex_const_iterator   vertices_begin() const;}{} 
\ccMethod{Vertex_const_iterator   vertices_end()   const;}{}
\ccMethod{Halfedge_const_iterator halfedges_begin()const;}{}
\ccMethod{Halfedge_const_iterator halfedges_end()  const;}{}
\ccMethod{Halffacet_const_iterator halffacets_begin() const;}{}
\ccMethod{Halffacet_const_iterator halffacets_end() const;}{}
\ccMethod{Volume_const_iterator   volumes_begin() const;}{}
\ccMethod{Volume_const_iterator   volumes_end()   const;}{}
\ccMethod{Shell_entry_const_iterator shells_begin(Volume_const_handle c) const;}{}
\ccMethod{Shell_entry_const_iterator shells_end(Volume_const_handle c) const;}{}

\ccMethod{Vertex_const_handle vertex(Halfedge_const_handle e) const;}{}
\ccMethod{Halfedge_const_handle twin(Halfedge_const_handle e) const;}{}
\ccMethod{Vertex_const_handle source(Halfedge_const_hnalde e) const;}{}
\ccMethod{Vertex_const_handle target(Halfedge_const_handle e) const;}{}
\ccMethod{SFace_const_handle sface(Halfedge_const_handle e) const;}{}

\ccMethod{Vertex_const_handle vertex(SHalfedge_const_handle e) const;}{}
\ccMethod{SHalfedge_const_handle twin(SHalfedge_const_handle e) const;}{}
\ccMethod{Vertex_const_handle source(SHalfedge_const_handle e) const;}{}
\ccMethod{Vertex_const_handle target(SHalfedge_const_handle e) const;}{}
\ccMethod{SHalfedge_const_handle previous(SHalfedge_const_handle e) const;}{}
\ccMethod{SHalfedge_const_handle next(SHalfedge_const_handle e) const;}{}
\ccMethod{Halffacet_const_handle facet(SHalfedge_const_handle e) const;}{}
\ccMethod{SFace_const_handle sface(SHalfedge_const_handle e) const;}{}
\ccMethod{Halfedge_const_handle ssource(SHalfedge_const_handle e) const;}{}
\ccMethod{Halfedge_const_handle starget(SHalfedge_const_handle e) const;}{}

\ccMethod{SHalfloop_const_handle twin( SHalfloop_const_handle l) const;}{}
\ccMethod{Halffacet_const_handle facet( SHalfloop_const_handle l) const;}{}
\ccMethod{Vertex_const_handle vertex( SHalfloop_const_handle l) const;}{}
\ccMethod{SFace_const_handle sface( SHalfloop_const_handle l) const;}{}

\ccMethod{Vertex_const_handle vertex(SFace_const_handle f) const;}{}
\ccMethod{Volume_const_handle volume(SFace_const_handle f) const;}{}

\ccMethod{Halffacet_const_handle twin(Halffacet_const_handle f) const;}{}
\ccMethod{Volume_const_handle volume(Halffacet_const_handle f) const;}{}
\ccMethod{SFace_const_handle adjacent_sface(Halffacet_const_handle f) const;}{}

\ccMethod{void visit_shell_objects(SFace_const_handle f, Visitor& V) const;}{}

\ccMethod{const Point_3& point(Vertex_const_handle v) const;}{}
\ccMethod{Segment_3 segment(Halfedge_const_handle e) const;}{}
\ccMethod{Vector_3 vector(Halfedge_const_handle e) const;}{}
\ccMethod{const Plane_3& plane(Halffacet_const_handle f) const;}{}

\ccMethod{static bool is_standard(const Vertex_const_handle v);}{}
\ccMethod{static bool is_standard(const Halffacet_const_handle v);}{}
\ccMethod{static bool is_standard_kernel() { return Infi_box::standard_kernel();}{}
\ccMethod{static bool is_extended_kernel() { return Infi_box::extended_kernel();}{}
\ccMethod{static void set_size_of_infimaximal_box(const typename Infi_box::NT& size);}{}

\end{ccRefClass}

% +------------------------------------------------------------------------+
% RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+