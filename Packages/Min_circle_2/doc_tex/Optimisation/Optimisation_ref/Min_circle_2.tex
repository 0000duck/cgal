% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Class  : CGAL::Min_circle_2<Traits>
% -----------------------------------------------------------------------------
% file  : doc_tex/basic/Optimisation/Optimisation_ref/Min_circle_2.tex
% author: Bernd Gärtner, Sven Schönherr <sven@inf.ethz.ch>
% -----------------------------------------------------------------------------
% $CGAL_Chapter: Geometric Optimisation $
% $CGAL_Package: Min_circle_2 WIP $
% $Revision$
% $Date$
% =============================================================================

\begin{ccRefClass}{Min_circle_2<Traits>}

\ccSaveThreeColumns
\cgalMinCircleLayout

% -----------------------------------------------------------------------------
\ccDefinition

An object of the class \ccRefName\ is the unique circle of smallest area
enclosing a finite set of points in two-dimensional Euclidean space~$\E_2$.
For a point set $P$ we denote by $mc(P)$ the smallest circle that contains
all points of $P$. Note that $mc(P)$ can be degenerate,
i.e.~$mc(P)=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$ if
$P=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$ and $mc(P)=\{p\}$ if
$P=\{p\}$.

An inclusion-minimal subset $S$ of $P$ with $mc(S)=mc(P)$ is called a
\emph{support set}, the points in $S$ are the \emph{support points}.
A support set has size at most three, and all its points lie on the
boundary of $mc(P)$. In general, neither the support set nor its size
are necessarily unique.

The underlying algorithm can cope with all kinds of input, e.g.~$P$ may be
empty or points may occur more than once. The algorithm computes a support
set $S$ which remains fixed until the next insert or clear operation.

\ccInclude{CGAL/Min_circle_2.h}

% -----------------------------------------------------------------------------
\ccRequirements

The template parameter \ccc{Traits} is a model for \ccc{Min_circle_2_traits}.

We provide the model \ccc{Min_circle_2_traits_2} using the two-dimensional
\cgal~kernel.

% -----------------------------------------------------------------------------
\ccTypes

\ccSetTwoColumns{\ccRefName:: Circle}{}

\ccNestedType{ Point }{ typedef to \ccc{Traits::Point }.}

\ccNestedType{ Circle}{ typedef to \ccc{Traits::Circle}.}

\ccNestedType{ Point_iterator}{
        non-mutable model of the \stl\ concept \emph{BidirectionalIterator}
        with value type \ccc{Point}. Used to access the points
        of the smallest enclosing circle.}

\ccNestedType{ Support_point_iterator}{
        non-mutable model of the \stl\ concept \emph{RandomAccessIterator}
        with value type \ccc{Point}. Used to access the support points
        of the smallest enclosing circle.}

\ccPropagateThreeToTwoColumns

% -----------------------------------------------------------------------------
\ccCreation
\ccCreationVariable{min_circle}

A \ccRefName\ object can be created from an arbitrary point set $P$ and by
specialized construction methods expecting no, one, two or three points as
arguments. The latter methods can be useful for reconstructing $mc(P)$ from
a given support set $S$ of $P$.

\ccConstructor{ template < class InputIterator >
                Min_circle_2( InputIterator  first,
                              InputIterator  last,
                              bool           randomize,
                              Random&        random    = CGAL::default_random,
                              const Traits&  traits    = Traits()   );}{
        creates a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to $mc(P)$ with $P$ being the set of points
        in the range [\ccc{first},\ccc{last}). If \ccc{randomize} is
        \ccc{true}, a random permutation of $P$ is computed in
        advance, using the random numbers generator \ccc{random}.
        Usually, this will not be necessary, however, the algorithm's
        efficiency depends on the order in which the points are
        processed, and a bad order might lead to extremely poor
        performance (see example below).
        \ccPrecond The value type of \ccc{first} and \ccc{last}
        is \ccc{Point}.}

\ccConstructor{ Min_circle_2( const Traits&  traits = Traits());}{
        creates a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to
        $mc(\mbox{\ccTexHtml{$\emptyset$}{&Oslash;}})$, the empty set.
        \ccPostcond  \ccVar\ccc{.is_empty()} = \ccc{true}.}

\ccConstructor{ Min_circle_2( const Point&   p,
                              const Traits&  traits = Traits());}{
        creates a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to $mc(\{p\})$, the set $\{p\}$.
        \ccPostcond  \ccVar\ccc{.is_degenerate()} = \ccc{true}.}

\ccConstructor{ Min_circle_2( const Point&   p1,
                              const Point&   p2,
                              const Traits&  traits = Traits());}{
        creates a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to $mc(\{p1,p2\})$, the circle with diameter
        equal to the segment connecting $p1$ and $p2$.}

\ccConstructor{ Min_circle_2( const Point&   p1,
                              const Point&   p2,
                              const Point&   p3,
                              const Traits&  traits = Traits());}{
        creates a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to $mc(\{p1,p2,p3\})$.}

% -----------------------------------------------------------------------------
\ccAccessFunctions

\ccMemberFunction{ int  number_of_points( ) const;}{
        returns the number of points of \ccVar, i.e.\ $|P|$.}

\ccMemberFunction{ int  number_of_support_points( ) const;}{
        returns the number of support points of \ccVar, i.e.\ $|S|$.}

\ccGlueBegin
\ccMemberFunction{ Point_iterator  points_begin() const;}{
        returns an iterator referring to the first point of \ccVar.}
%
\ccMemberFunction{ Point_iterator  points_end() const;}{
        returns the corresponding past-the-end iterator.}
\ccGlueEnd

\ccGlueBegin
\ccMemberFunction{ Support_point_iterator  support_points_begin() const;}{
        returns an iterator referring to the first support point of \ccVar.}
%
\ccMemberFunction{ Support_point_iterator  support_points_end() const;}{
        returns the corresponding past-the-end iterator.}
\ccGlueEnd

\ccMemberFunction{ const Point&  support_point( int i) const;}{
        returns the \ccc{i}-th support point of \ccVar. Between two
        modifying operations (see below) any call to
        \ccVar\ccc{.support_point(i)} with the same \ccc{i} returns
        the same point.
        \ccPrecond $0 \leq i< \mbox{\ccVar\ccc{.number_of_support_points()}}$.}

\ccMemberFunction{ const Circle&  circle( ) const;}{
        returns the current circle of \ccVar.}

% -----------------------------------------------------------------------------
\ccPredicates

By definition, an empty \ccClassTemplateName\ has no boundary and no
bounded side, i.e.\ its unbounded side equals the whole space $\E_2$.

\ccMemberFunction{ CGAL::Bounded_side
                   bounded_side( const Point& p) const;}{
        returns \ccGlobalScope\ccc{ON_BOUNDED_SIDE},
        \ccGlobalScope\ccc{ON_BOUNDARY}, or
        \ccGlobalScope\ccc{ON_UNBOUNDED_SIDE} iff \ccc{p} lies properly
        inside, on the boundary of, or properly outside of \ccVar, resp.}

\ccMemberFunction{ bool  has_on_bounded_side( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies properly inside \ccVar.}

\ccMemberFunction{ bool  has_on_boundary( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies on the boundary
        of \ccVar.}

\ccMemberFunction{ bool  has_on_unbounded_side( const Point& p) const;}{
        returns \ccc{true}, iff \ccc{p} lies properly outside of \ccVar.}

\ccMemberFunction{ bool  is_empty( ) const;}{
        returns \ccc{true}, iff \ccVar\ is empty (this implies
        degeneracy).}

\ccMemberFunction{ bool  is_degenerate( ) const;}{
        returns \ccc{true}, iff \ccVar\ is degenerate,
        i.e.~if \ccVar\ is empty or equal to a single point, equivalently
        if the number of support points is less than 2.}

% -----------------------------------------------------------------------------
\ccModifiers

New points can be added to an existing \ccVar, allowing to build $mc(P)$
incrementally, e.g.~if $P$ is not known in advance. Compared to the direct
creation of $mc(P)$, this is not much slower, because the construction
method is incremental itself.

\ccMemberFunction{ void  insert( const Point& p);}{
        inserts \ccc{p} into \ccVar\ and recomputes the smallest
        enclosing circle.}

\ccMemberFunction{ template < class InputIterator >
                   void  insert( InputIterator  first,
                                 InputIterator  last );}{
        inserts the points in the range [\ccc{first},\ccc{last})
        into \ccVar\ and recomputes the smallest enclosing circle by
        calling \ccc{insert(p)} for each point \ccc{p} in
        [\ccc{first},\ccc{last}).
        \ccPrecond  The value type of \ccc{first} and \ccc{last} is
        \ccc{Point}.}

\ccMemberFunction{ void clear( );}{
        deletes all points in \ccVar\ and sets \ccVar\ to the empty set.
        \ccPostcond  \ccVar\ccc{.is_empty()} = \ccc{true}.}

% -----------------------------------------------------------------------------
\ccHeading{Validity Check}

An object \ccVar\ is valid, iff
\begin{itemize}
  \item \ccVar\ contains all points of its defining set $P$,
  \item \ccVar\ is the smallest circle spanned by its support set $S$, and
  \item $S$ is minimal, i.e.\ no support point is redundant.
\end{itemize}
The following function is mainly intended for
debugging user supplied traits classes but also for convincing the
anxious user that the traits class implementation is correct.

\ccMemberFunction{ bool is_valid( bool verbose = false,
                                  int  level   = 0    ) const;}{
      returns \ccc{true}, iff \ccVar\ is valid. If \ccc{verbose}
      is \ccc{true}, some messages concerning the performed checks
      are written to standard error stream. The second parameter
      \ccc{level} is not used, we provide it only for consistency
      with interfaces of other classes.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}

\def\ccTagRmConstRefPair{\ccFalse}

\ccMemberFunction{ const Traits&  traits( ) const;}{
        returns a const reference to the traits class object.}

\def\ccTagRmConstRefPair{\ccTrue}

% -----------------------------------------------------------------------------
\ccHeading{I/O}

\ccFunction{ std::ostream&
             operator << ( std::ostream& os,
                           const Min_circle_2<Traits>& min_circle);}{
        writes \ccVar\ to output stream \ccc{os}.
        \ccRequire  The output operator is defined for \ccc{Point}
        (and for \ccc{Circle}, if pretty printing is used).}

\ccFunction{ std::istream&
             operator >> ( std::istream& is,
                           Min_circle_2<Traits> min_circle&);}{
        reads \ccVar\ from input stream \ccc{is}.
        \ccRequire  The input operator is defined for \ccc{Point}.}

\ccInclude{CGAL/IO/Window_stream.h}

\ccFunction{ CGAL::Window_stream&
             operator << ( CGAL::Window_stream& ws,
                           const Min_circle_2<Traits>& min_circle);}{
        writes \ccVar\ to window stream \ccc{ws}.
        \ccRequire  The window stream output operator is defined for
        \ccc{Point} and \ccc{Circle}.}

% -----------------------------------------------------------------------------
\ccSeeAlso

\ccRefIdfierPage{CGAL::Min_ellipse_2<Traits>}\\
\ccRefIdfierPage{CGAL::Min_sphere_d<Traits>}\\[1ex]
\ccRefIdfierPage{CGAL::Min_circle_2_traits_2<R>}\\[1ex]
\ccRefIdfierPage{Min_circle_2_traits}

% -----------------------------------------------------------------------------
\ccImplementation

We implement the algorithm of Welzl, with move-to-front
heuristic~\cite{w-sedbe-91a}. The whole implementation is described
in~\cite{gs-seceg-98}.

If randomization is chosen, the creation time is almost always linear in
the number of points. Access functions and predicates take constant time,
inserting a point might take up to linear time, but substantially less than
computing the new smallest enclosing circle from scratch. The clear
operation and the check for validity each takes linear time.

% -----------------------------------------------------------------------------
\ccExample

To illustrate the creation of \ccRefName\ and to show that
randomization can be useful in certain cases, we give an example.

\ccTexHtml{\small}{}
\begin{verbatim}
#include <CGAL/Gmpz.h>
#include <CGAL/Homogeneous.h>
#include <CGAL/Point_2.h>
#include <CGAL/Min_circle_2.h>
#include <CGAL/Min_circle_2_traits_2.h>

typedef  CGAL::Gmpz                      NT;
typedef  CGAL::Homogeneous<NT>           R;
typedef  R::Point_2                      Point;
typedef  CGAL::Min_circle_2_traits_2<R>  Traits;
typedef  CGAL::Min_circle_2<Traits>      Min_circle;

int main()
{
    int     n = 1000;
    Point*  P = new Point[ n];

    for ( int i = 0; i < n; ++i)
        P[ i] = Point( (i%2 == 0 ? i : -i), 0);
    // (0,0), (-1,0), (2,0), (-3,0), ...

    Min_circle  mc1( P, P+n);           // very slow
    Min_circle  mc2( P, P+n, true);     // fast

    delete[] P;
    return( 0);
}
\end{verbatim}
\ccTexHtml{\normalsize}{}

% -----------------------------------------------------------------------------

\ccRestoreThreeColumns

\end{ccRefClass}

% ===== EOF ===================================================================
