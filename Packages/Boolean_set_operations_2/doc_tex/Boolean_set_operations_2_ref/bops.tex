\ccRefPageBegin
\label{ref_boolean_operations}

\ccInclude{CGAL/Bops_regularized_bops.h}

% ============================================================================
\begin{ccRefFunction}{do_intersect}

\ccThree{bool}{do_intersect}{}
\ccThreeToTwo

\ccDefinition

\ccInclude{CGAL/IO/Boolean_set_operations.h}

Each one of the following functions returns \ccc{true} if the two given
polygons \ccc{p1} and \ccc{p2} intersect in their interior,
and \ccc{false} otherwise. The set of these functions can be divided
into two subsets. Members of the first subset accept two arguments
each represents a polygon.

\ccGlobalFunction{bool do_intersect(const Type1 & p1, const Type2 & p2);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{Polygon_2} & 
\ccc{General_polygon_with_holes_2}\\ 
\hline
\ccc{General_polygon_with_holes_2} &
\ccc{Polygon_2}\\ 
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_with_holes_2}\\ 
\hline
\ccc{General_polygon_with_holes_2} &
\ccc{General_polygon_2}\\ 
\hline
\ccc{General_polygon_with_holes_2} &
\ccc{General_polygon_with_holes_2}\\
\hline
\end{tabular}

Memebers of the second subset accept three arguments. The first two
represent two polygons respectively and the third is a dummy instance of
the traits class used to identify the Traits template parameter.

\ccGlobalFunction{bool do_intersect(const Type1 & p1, const Type2 & p2,
                                    Traits & traits);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Traits::Polygon_2} &
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_2} &
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} &
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} &
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\end{tabular}

\ccGlobalFunction{template <class Kernel, class Container>
bool do_intersect(const Polygon_2<Kernel, Container> & p1,
                  const Polygon_2<Kernel, Container> & p2);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container>
bool do_intersect(const Polygon_2<Kernel, Container> & p1,
                  const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p2);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container>
bool do_intersect(const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p1,
                  const Polygon_2<Kernel, Container> & p2);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool do_intersect(const General_polygon_2<Traits> & p1,
                  const General_polygon_2<Traits> & p2);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool do_intersect(const General_polygon_2<Traits> & p1,
                  const General_polygon_with_holes_2<General_polygon_2<Traits> > & p2);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool do_intersect(const General_polygon_with_holes_2<General_polygon_2<Traits> > & p1,
                  const General_polygon_2<Traits> & p2);}
\ccGlue
\ccGlobalFunction{template <class Polygon>
bool do_intersect(const General_polygon_with_holes_2<Polygon> & p1,
                  const General_polygon_with_holes_2<Polygon> & p2);}

% \ccGlobalFunction{template <class Traits>
% bool do_intersect(const Traits::Polygon_2 & p1,
%                   const Traits::Polygon_2 & p2);}
% \ccGlue
% \ccGlobalFunction{template <class Traits>
% bool do_intersect(const Traits::Polygon_2 & p1,
%                   const Traits::Polygon_with_holes_2 & p2);}
% \ccGlue
% \ccGlobalFunction{template <class Traits>
% bool do_intersect(const Traits::Polygon_with_holes_2 & p1,
%                   const Traits::Polygon_2 & p2);}
% \ccGlue
% \ccGlobalFunction{template <class Traits>
% bool do_intersect(const Traits::Polygon_with_holes_2 & p1,
%                   const Traits::Polygon_with_holes_2 & p2);}
% 
\ccGlobalFunction{template <class Traits>
bool do_intersect(const Traits::Polygon_2 & p1,
                  const Traits::Polygon_2 & p2,
                  Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool do_intersect(const Traits::Polygon_2 & p1,
                  const Traits::Polygon_with_holes_2 & p2,
                  Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool do_intersect(const Traits::Polygon_with_holes_2 & p2
                  const Traits::Polygon_2 & p1,
                  Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool do_intersect(const Traits::Polygon_with_holes_2 & p1,
                  const Traits::Polygon_with_holes_2 & p2,
                  Traits & traits);}

\ccSeeAlso
\ccRefIdfierPage{CGAL::intersection}\\
\ccRefIdfierPage{CGAL::join}\\
\ccRefIdfierPage{CGAL::difference}\\
\ccRefIdfierPage{CGAL::symmetric_difference}

\end{ccRefFunction}
% ============================================================================
\begin{ccRefFunction}{intersection}

\ccThree{OutputIterator}{intersection}{}
\ccThreeToTwo

\ccDefinition

\ccInclude{CGAL/IO/Boolean_set_operations.h}

Each one of the following functions computes the intersection of
two given polygons \ccc{p1} and \ccc{p2}, inserts the
resulting polygons with holes into an output container through a given
output iterator \ccc{oi}, and returns the output iterator. The value
type of the \ccc{OutputIterator} is \ccc{General_polygon_with_holes_2}.

The set of these functions can be divided into two subsets. Members of
the first subset accept three arguments. The first two represent
polygons respectively and the third is an output iterator.

\ccGlobalFunction{
OutputIterator intersection(const Type1 & p1, const Type2 & p2,
                            OutputIterator oi);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_with_holes_2}\\
\hline
\ccc{Polygon_with_holes_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\end{tabular}

Memebers of the second subset accept four arguments. The first two
represent two polygons respectively, the third is an output iterator,
and fourth is a dummy instance of the traits class used to identify
the  Traits template parameter.

\ccGlobalFunction{
OutputIterator intersection(const Type1 & p1, const Type2 & p2,
                            OutputIterator oi, Traits & traits);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\end{tabular}

\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator intersection(const Polygon_2<Kernel, Container> & p1,
                            const Polygon_2<Kernel, Container> & p2,
                            OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator intersection(const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p1,
                            const Polygon_2<Kernel, Container> & p2,
                            OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator intersection(const Polygon_2<Kernel, Container> & p1,
                            const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p2,
                            OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const General_polygon_2<Traits> & p1,
                            const General_polygon_2<Traits> & p2,
                            OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const General_polygon_with_holes_2<General_polygon_2<Traits> > & p1,
                            const General_polygon_2<Traits> & p2,
                            OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const General_polygon_2<Traits> & p1,
                            const General_polygon_with_holes_2<General_polygon_2<Traits> > & p2,
                            OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Polygon, class OutputIterator>
OutputIterator intersection(const General_polygon_with_holes_2<Polygon> & p1,
                            const General_polygon_with_holes_2<Polygon> & p2,
                            OutputIterator oi);}

\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const Traits::Polygon_2 & p1,
                            const Traits::Polygon_2 & p2,
                            OutputIterator oi,
                            Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const Traits::Polygon_2 & p1,
                            const Traits::Polygon_with_holes_2 & p2,
                            OutputIterator oi,
                            Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const Traits::Polygon_with_holes_2 & p2,
                            const Traits::Polygon_2 & p1,
                            OutputIterator oi,
                            Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator intersection(const Traits::Polygon_with_holes_2 & p1,
                            const Traits::Polygon_with_holes_2 & p2,
                            OutputIterator oi,
                            Traits & traits);}
  
\ccGlobalFunction{template <class InputIterator, class OutputIterator>
OutputIterator intersection(InputIterator & begin, InputIterator & end,
                            OutputIterator oi,
                            Traits & traits);}
{Computes the intersection of the general polygons (or general polygons with
holes) in the given range. (The value type of the input iterator is
used to distinguish between the two.) The result, represented by a set
of general poygon with holes, is inserted into an output container
through a given output iterator \ccc{oi}. The output iterator is
returned. The value type of the \ccc{OutputIterator} is
\ccc{General_polygon_with_holes_2}.}

\ccGlobalFunction{template <class InputIterator1, class InputIterator2,
		  class OutputIterator>
OutputIterator intersection(InputIterator1 & pgn_begin1,
                            InputIterator1 & pgn_end1,
                            InputIterator2 & pgn_begin2,
	                    InputIterator2 & pgn_end2,
		            OutputIterator oi);}
{Computes the intersection of the general polygons and general polygons
with holes in the given two ranges. The result, represented by a set
of general poygon with holes, is inserted into an output container
through a given output iterator \ccc{oi}. The output iterator is
returned. The value type of the \ccc{OutputIterator} is
\ccc{General_polygon_with_holes_2}.}

\ccSeeAlso
\ccRefIdfierPage{CGAL::do_intersect}\\
\ccRefIdfierPage{CGAL::join}\\
\ccRefIdfierPage{CGAL::difference}\\
\ccRefIdfierPage{CGAL::symmetric_difference}

\end{ccRefFunction}
% ============================================================================
\begin{ccRefFunction}{join}

\ccThree{OutputIterator}{join}{}
\ccThreeToTwo

\ccDefinition

\ccInclude{CGAL/IO/Boolean_set_operations.h}

Each one of the following functions computes the union of two
given polygons \ccc{p1} and \ccc{p2}. If the two given
polygons overlap, it returns \ccc{true} and places the resulting
polygon in \ccc{p}. Otherwise, it returns \ccc{false}.

The set of these functions can be divided into two subsets. Members of
the first subset accept three arguments. The first two represent
polygons respectively and the third is a place holder for the
resulting polygon with holes if exists.

\ccGlobalFunction{
bool join(const Type1 & p1, const Type2 & p2,
	  General_polygon_with_holes_2 & p);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_with_holes_2}\\
\hline
\ccc{Polygon_with_holes_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\end{tabular}

Memebers of the second subset accept four arguments. The first two
represent two polygons respectively, the third is a place holder for the
resulting polygon with holes if exists, and fourth is a dummy instance
of the traits class used to identify the  Traits template parameter.

\ccGlobalFunction{
bool join(const Type1 & p1, const Type2 & p2,
	  Traits::Polygon_with_holes_2 & p, Traits & traits);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\end{tabular}

\ccGlobalFunction{template <class Kernel, class Container>
bool join(const Polygon_2<Kernel, Container> & p1,
          const Polygon_2<Kernel, Container> & p2,
	  General_polygon_with_holes_2<Polygon_2<Kernel, Container> > & p);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container>
bool join(const Polygon_2<Kernel, Container> & p1,
          const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p2,
	  General_polygon_with_holes_2Polygon_2<Kernel, Container> > & p);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container>
bool join(const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p2,
          const Polygon_2<Kernel, Container> & p1,
	  General_polygon_with_holes_2Polygon_2<Kernel, Container> > & p);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool join(const General_polygon_2<Traits> & p1,
          const General_polygon_2<Traits> & p2,
	  General_polygon_with_holes_2<General_polygon_2<Traits> > & p);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool join(const General_polygon_2<Traits> & p1,
          const General_polygon_with_holes_2<General_polygon_2<Traits> > & p2,
	  General_polygon_with_holes_2<General_polygon_2<Traits> > & p);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool join(const General_polygon_with_holes_2<General_polygon_2<Traits> > & p2,
          const General_polygon_2<Traits> & p1,
	  General_polygon_with_holes_2<General_polygon_2<Traits> > & p);}
\ccGlue
\ccGlobalFunction{template <class Polygon>
bool join(const General_polygon_with_holes_2<Polygon> & p1,
          const General_polygon_with_holes_2<Polygon> & p2,
	  Traits::Polygon_with_holes_2 & p);}

\ccGlobalFunction{template <class Traits>
bool join(const Traits::Polygon_2 & p1,
          const Traits::Polygon_2 & p2,
	  Traits::Polygon_with_holes_2 & p,
          Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool join(const Traits::Polygon_2 & p1,
          const Traits::Polygon_with_holes_2 & p2,
	  Traits::Polygon_with_holes_2 & p,
          Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool join(const Traits::Polygon_with_holes_2 & p2,
          const Traits::Polygon_2 & p1,
	  Traits::Polygon_with_holes_2 & p,
          Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits>
bool join(const Traits::Polygon_with_holes_2 & p1,
          const Traits::Polygon_with_holes_2 & p2,
	  Traits::Polygon_with_holes_2 & p,
          Traits & traits);}

\ccGlobalFunction{template <class InputIterator, class OutputIterator>
OutputIterator join(InputIterator & begin, InputIterator & end,
                    OutputIterator oi);}
{Computes the union of the general polygons (or general polygons with
holes) in the given range. (The value type of the input iterator is
used to distinguish between the two.) The result, represented by a set
of general poygon with holes, is inserted into an output container
through a given output iterator \ccc{oi}. The output iterator is
returned. The value type of the \ccc{OutputIterator} is
\ccc{General_polygon_with_holes_2}.}

\ccGlobalFunction{template <class InputIterator1, class InputIterator2,
		  class OutputIterator>
OutputIterator join(InputIterator1 & pgn_begin1, InputIterator1 & pgn_end1,
                    InputIterator2 & pgn_begin2, InputIterator2 & pgn_end2,
		    OutputIterator oi);}
{Computes the union of the general polygons and general polygons
with holes in the given two ranges. The result, represented by a set
of general poygon with holes, is inserted into an output container
through a given output iterator \ccc{oi}. The output iterator is
returned. The value type of the \ccc{OutputIterator} is
\ccc{General_polygon_with_holes_2}.}

\ccSeeAlso
\ccRefIdfierPage{CGAL::do_intersect}\\
\ccRefIdfierPage{CGAL::intersection}\\
\ccRefIdfierPage{CGAL::difference}\\
\ccRefIdfierPage{CGAL::symmetric_difference}

\end{ccRefFunction}
% ============================================================================
\begin{ccRefFunction}{difference}

\ccThree{OutputIterator}{difference}{}
\ccThreeToTwo

\ccDefinition

\ccInclude{CGAL/IO/Boolean_set_operations.h}

Each one of the following functions computes the difference
between two given polygons \ccc{p1} and \ccc{p2}, and inserts
the resulting polygons with holes into an output container through the
output iterator \ccc{oi}. The value type of the \ccc{OutputIterator}
is \ccc{General_polygon_with_holes_2}.

The set of these functions can be divided into two subsets. Members of
the first subset accept three arguments. The first two represent
polygons respectively and the third is an output iterator.

\ccGlobalFunction{
OutputIterator intersection(const Type1 & p1, const Type2 & p2,
                            OutputIterator oi);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_with_holes_2}\\
\hline
\ccc{Polygon_with_holes_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\end{tabular}

Memebers of the second subset accept four arguments. The first two
represent two polygons respectively, the third is an output iterator,
and fourth is a dummy instance of the traits class used to identify
the  Traits template parameter.

\ccGlobalFunction{
OutputIterator intersection(const Type1 & p1, const Type2 & p2,
                            OutputIterator oi, Traits & traits);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\end{tabular}

\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator difference(const Polygon_2<Kernel, Container> & p1,
                          const Polygon_2<Kernel, Container> & p2,
                          OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator difference(const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p1,
                          const Polygon_2<Kernel, Container> & p2,
                          OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator difference(const Polygon_2<Kernel, Container> & p1,
                          const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p2,
                          OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const General_polygon_2<Traits> & p1,
                          const General_polygon_2<Traits> & p2,
                          OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const General_polygon_with_holes_2<General_polygon_2<Traits> > & p1,
                          const General_polygon_2<Traits> & p2,
                          OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const General_polygon_2<Traits> & p1,
                          const General_polygon_with_holes_2<General_polygon_2<Traits> > & p2,
                          OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Polygon, class OutputIterator>
OutputIterator difference(const General_polygon_with_holes_2<Polygon> & p1,
                          const General_polygon_with_holes_2<Polygon> & p2);}

\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const Traits::Polygon_2 & p1,
                          const Traits::Polygon_2 & p2,
                          OutputIterator oi,
                          Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const Traits::Polygon_2 & p1,
                          const Traits::Polygon_with_holes_2 & p2,
                          OutputIterator oi,
                          Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const Traits::Polygon_with_holes_2 & p2,
                          const Traits::Polygon_2 & p1,
                          OutputIterator oi,
                          Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator difference(const Traits::Polygon_with_holes_2 & p1,
                          const Traits::Polygon_with_holes_2 & p2,
                          OutputIterator oi,
                          Traits & traits);}

\ccSeeAlso
\ccRefIdfierPage{CGAL::do_intersect}\\
\ccRefIdfierPage{CGAL::intersection}\\
\ccRefIdfierPage{CGAL::join}\\
\ccRefIdfierPage{CGAL::symmetric_difference}

\end{ccRefFunction}
% ============================================================================
\begin{ccRefFunction}{symmetric_difference}

\ccThree{OutputIterator}{symmetric_difference}{}
\ccThreeToTwo

\ccDefinition

\ccInclude{CGAL/IO/Boolean_set_operations.h}

Each one of the following functions computes the symmetric
difference between two given polygons \ccc{p1} and \ccc{p2},
and inserts the resulting polygons with holes into an output container
through the output iterator \ccc{oi}. The value type of the
\ccc{OutputIterator} is \ccc{General_polygon_with_holes_2}.

The set of these functions can be divided into two subsets. Members of
the first subset accept three arguments. The first two represent
polygons respectively and the third is an output iterator.

\ccGlobalFunction{
OutputIterator intersection(const Type1 & p1, const Type2 & p2,
                            OutputIterator oi);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{Polygon_2} & 
\ccc{Polygon_with_holes_2}\\
\hline
\ccc{Polygon_with_holes_2} & 
\ccc{Polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_2}\\
\hline
\ccc{General_polygon_with_holes_2} & 
\ccc{General_polygon_with_holes_2}\\
\hline
\end{tabular}

Memebers of the second subset accept four arguments. The first two
represent two polygons respectively, the third is an output iterator,
and fourth is a dummy instance of the traits class used to identify
the  Traits template parameter.

\ccGlobalFunction{
OutputIterator intersection(const Type1 & p1, const Type2 & p2,
                            OutputIterator oi, Traits & traits);}
\begin{tabular}{|l|l|}
\hline
\textbf{Arg 1 Type} & \textbf{Arg 2 Type}\\
\hline
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_2}\\
\hline
\ccc{Traits::Polygon_with_holes_2} & 
\ccc{Traits::Polygon_with_holes_2}\\
\hline
\end{tabular}

\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator symmetric_difference(const Polygon_2<Kernel, Container> & p1,
                                    const Polygon_2<Kernel, Container> & p2,
                                    OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator symmetric_difference(const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p1,
                                    const Polygon_2<Kernel, Container> & p2,
                                    OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Kernel, class Container, class OutputIterator>
OutputIterator symmetric_difference(const Polygon_2<Kernel, Container> & p1,
                                    const General_polygon_with_holes_2<Polygon_2<Kernel,Container> > & p2,
                                    OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const General_polygon_2<Traits> & p1,
                                    const General_polygon_2<Traits> & p2,
                                    OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const General_polygon_with_holes_2<General_polygon_2<Traits> > & p1,
                                    const General_polygon_2<Traits> & p2,
                                    OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const General_polygon_2<Traits> & p1,
                                    const General_polygon_with_holes_2<General_polygon_2<Traits> > & p2,
                                    OutputIterator oi);}
\ccGlue
\ccGlobalFunction{template <class Polygon, class OutputIterator>
OutputIterator 
symmetric_difference(const General_polygon_with_holes_2<Polygon> & p1,
                     const General_polygon_with_holes_2<Polygon> & p2,
                     OutputIterator oi);}

\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const Traits::Polygon_2 & p1,
                                    const Traits::Polygon_2 & p2,
                                    OutputIterator oi,
                                    Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const Traits::Polygon_2 & p1,
                                    const Traits::Polygon_with_holes_2 & p2,
                                    OutputIterator oi,
                                    Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const Traits::Polygon_with_holes_2 & p2,
                                    const Traits::Polygon_2 & p1,
                                    OutputIterator oi,
                                    Traits & traits);}
\ccGlue
\ccGlobalFunction{template <class Traits, class OutputIterator>
OutputIterator symmetric_difference(const Traits::Polygon_with_holes_2 & p1,
                                    const Traits::Polygon_with_holes_2 & p2,
                                    OutputIterator oi,
                                    Traits & traits);}

\ccSeeAlso
\ccRefIdfierPage{CGAL::do_intersect}\\
\ccRefIdfierPage{CGAL::intersection}\\
\ccRefIdfierPage{CGAL::join}\\
\ccRefIdfierPage{CGAL::difference}

\end{ccRefFunction}
\ccRefPageEnd
