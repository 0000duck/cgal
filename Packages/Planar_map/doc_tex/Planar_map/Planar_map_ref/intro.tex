% +------------------------------------------------------------------------+
% | Reference manual chapter: planar_ref.tex (Planar Map)
% +------------------------------------------------------------------------+
% | 
% | Package: pm (Planar Map)
% | 
% +------------------------------------------------------------------------+

%+----------------------------------------------------------------------------80
%| update log
%|
%| 01 Jun 2000 - Shai Hirsch
%|    Separated from planar.tex (See previous changes in change log there).
%|     
%+----------------------------------------------------------------------------80


% +========================================================================+
%   Introduction
% +========================================================================+
\clearpage
\section{Planar Map Reference Pages}
\ccRefLabel{Pm_Ref_intro}
\subsection*{Introduction}

A planar subdivision (or planar map) is an embedding of a planar 
topological map $T$ 
into the plane, such that each edge of $T$ is embedded as a
bounded $x$-monotone curve and each vertex is embedded as a planar point.
In this embedding no
edge intersects another edge interior.

A {\em face} of the subdivision is a maximal connected region of the
plane that does not contain any vertex or edge. 
We consider a face to be open, and its boundary is
formed by vertices and halfedges of the subdivision.
The halfedges are oriented around a face so that the face they bound
is to their left. This means that halfedges on the outer boundary
of a face are traversed in counterclockwise order, and halfedges on the inner
boundaries (holes) of a face are traversed in clockwise order. Edges around a
vertex are also traversed in clockwise order. 

\subsection*{Planar Map Traits}
The planar map class is parameterized with the
interface class \ccStyle{Planar_map_traits} which defines the abstract interface
between planar maps and the primitives they use. 

We supply a default traits class for exact arithmetic ---
\ccStyle{Pm_segment_exact_traits<R>} % and a class for finite
%precision arithmetic --- \ccStyle{Pm_segment_epsilon_traits<R>},
where \ccStyle{R} is the kernel representation type
(\ccc{Homogeneous} or \ccc{Cartesian}).  There is also a class
for finite precision arithmetic --- \ccStyle{Pm_segment_epsilon_traits<R>},
which is not recommended unless it is known that robustness issues will not
arise. 
Both traits handle
finite line segments in the plane
and use the CGAL kernel (\ccStyle{Point} is of type 
\ccStyle{Point_2<R>} and \ccStyle{X_curve} is of type
\ccStyle{Segment_2<R>}).
We also supply a traits class that uses LEDA's rational kernel and makes use
of its efficient predicates. The different supplied traits classes are described at the end of this chapter.

The \ccc{Arrangement_2_traits} 
concept\lcTex{ (\ccRefPage{Arrangement_2_traits})} is a refinement of the \ccc{Planar_map_traits} concept.
Therefore, all models of the former are models of the latter. 
There are several supplied traits classes for the \ccc{Arrangement} which the user can use. 
These classes are described at the end of Chapter \ref{I1_ChapterArrangement_2}
(\ccc{2D Arrangements}).


\begin{ccAdvanced}
\subsection*{Point Location Strategies}
The \ccClassTemplateName\ class has a point location function
(namely, the \ccc{locate} function that determines which feature of the map 
contains a given query point)
which is also used internally in the \ccc{insert} function.
The planar map users can define which algorithm to use in the
point location queries. This is done with a {\em point location class}
passed to the map in the constructor. The class passed should be derived
from the base class \ccc{Pm_point_location_base} which is a
(\ccc{pure virtual}) base class that defines the interface between the 
algorithm
implemented by the users and the planar map. This follows the 
known {\it Strategy}
pattern ~\cite{ghjv-dpero-95}. The indirection overhead due to the virtual functions is
negligible since the optimal point location algorithm 
(e.g., the one implemented in our default strategy) takes $\Theta(\log n)$ time.  

We have derived three concrete classes for point location strategies,
the {\it default\/} strategy, based on trapezoidal decomposition of the map,
the {\it naive\/} strategy, which goes over all the vertices and halfedges
of the planar map and the {\it walk-along-a-line strategy\/}, which improves
the {\it naive\/} one by ``walking'' only along the zone of the vertical ray emanating
from the query point. All three strategies are classes
that inherit \ccc{Pm_point_location_base<Planar_map>}.
More details are give in sections 
  \ccc{Pm_default_point_location<Planar_map>}\lcTex{
  (\ccRefPage{CGAL::Pm_default_point_location<Planar_map>})}, 
  \ccc{Pm_naive_point_location<Planar_map>}\lcTex{ 
  (\ccRefPage{CGAL::Pm_naive_point_location<Planar_map>})} and
  \ccc{Pm_walk_along_a_line_point_location<Planar_map>}\lcTex{
  (\ccRefPage{CGAL::Pm_walk_along_a_line_point_location<Planar_map>})}.

In order for the advanced user to write a model of a~\ccRefName\ the user's class should inherit the \cgal\/ supplied class 
\ccc{Pm_point_location_base<Planar_map>}.

\paragraph{Trade-off Issues}
The main trade-off among the three strategies implemented, is between
time and storage. Using the naive or walk strategies takes more
time but saves storage space.

Another trade-off depends on the need for point location queries compared
to the need for other functions. If the users do not need point location 
queries, but do need other modifying functions (e.g., \ccc{remove_edge}, 
\ccc{split_edge} and \ccc{merge_edge}) then using the naive or walk strategies
is preferable. Note that using the \ccc{insert} function invokes the
point location query, therefore when using the naive or walk strategies it
is recommended to use the specialized insertion functions : 
\ccc{insert_in_face_interior}, \ccc{insert_from_vertex} and 
\ccc{insert_at_vertices}.
For example, when using the planar map to represent polygons (e.g., when
computing boolean operations on polygons) it might be preferable to use
the walk strategy with the specialized insertion functions. 

There are two modes of the {\it default\/} strategy which enables the user
to choose whether preprocessing should be performed or not (read more in
the section stated above).
There is a trade-off between the those two modes. If
preprocessing is not used, the building of the structure is faster. However,
for some input sequences the structure might be unbalanced and therefore 
queries and updates might take longer, especially, if many removal and split 
operation are performed.
\end{ccAdvanced}

\begin{ccAdvanced}
\subsection*{Bounding box strategies}
The planar map can support infinite objects. In such cases a special utility, namely a \ccc{bounding box} is used. 
Analogous to the point location strategy the users can define which algorithm 
will be used to update and query the map's bounding box. However, if such a
behavior is not expected or wanted the user can ignore the bounding box
or choose the \ccStyle{Pm_unbounding_box}, which is also the default one used by the planar map.

Defining the bounding box algorithm is done with a {\em bounding box} class
passed to the map in the constructor. The class passed should be a model of the
concept \ccc{Planar_map_bounding_box}. The \ccc{bounding box} class should be
derived from the base class \ccStyle{Pm_bounding_box_base<Planar_map>} which is a
(\ccc{pure virtual}) base class that defines the interface between the algorithm
implemented and the planar map according to the requirements of the above concept.
All concrete classes for bounding box strategies, namely the
{\em unbounding box strategy} and the {\em dynamic open strategy} 
stand up to these criteria 
%are models of the concept \ccc{Planar_map_bounding_box}. These classes were
%implemented as classes that inherit from the base class
% \ccc{Pm_bounding_box_base<Planar_map>}.

The following sections list and describe the \ccc{Planar_map_bounding_box}
concept and the supplied bounding box strategies which model this concept:
\ccc{Planar_map_bounding_box}\lcTex{ (\ccRefPage{Planar_map_bounding_box})}, 
\ccc{Pm_unbounding_box<Planar_map>}\lcTex{ (\ccRefPage{CGAL::Pm_unbounding_box<Planar_map>})}
and
\ccc{Pm_dynamic_open_bounding_box<Planar_map>}\lcTex{
(\ccRefPage{CGAL::Pm_dynamic_open_bounding_box<Planar_map>})}.

\paragraph{Trade-off Issues}
The main trade-off issues between the different strategies
implemented are concerned with functionality and time efficiency. 

The unbounding box is efficient in time though compared to 
the others it is limited to bounded curves traits, e.g., circle traits or
line segment traits.
This means that if the users want to work with, say, straight lines the unbounding
box will not work.
To the other extreme, if one chooses the dynamic bounding box and queries a 
point 
outside the bounded area then this might cause the whole bounding box to be 
modified. The requirement may be of a linear time (in the number of curves).
In addition to that, in order to ensure that the bounding box is
large enough, the traits has to supply 
additional functions, namely to model the \ccc{Pm_bounding_box_traits} concept
(which is a refinement of the \ccc{Planar_map_traits} concept).
%, namely to model the planar ray shoot traits concept.

%% add \ccInheritFrom{Pm_bounding_box_base<Planar_map>} to each
%% of these classes

\end{ccAdvanced}
\begin{ccAdvanced}
\subsection*{I/O functions}
The \ccc{Planar map} package supports I/O functions, which include reading a planar map representation from 
the standard input or writing it to the standard output, 
and also sending a planar map to a graphic stream.

The motivation for using I/O functions is not only to be able to draw 
the planar map to a window for instance, 
but also to be capable to save planar maps in a text file by writing it 
and reloading it from a text file by reading it. 

The format of the output file is defined in a way the reading function will be 
able to constructs the planar map by updating directly the \ccc{Dcel} without 
using the insertion functions of the \ccc{Planar map}. 
Consequently, the reading function constructs the planar map very 
efficiently, and hence users who would like to save their planar map and reload 
it have to construct their planar map by the insertion functions only once, 
after saving the planar map to a text file it can be reloaded very efficiently 
when needed.

When users would like to read their planar map from the standard input or print 
it to the standard output, they may simply use the \ccc{Extractor} (\ccc{ >> }) 
and \ccc{Insertor} (\ccc{ << }) operators defined for \ccc{Planar map} 
respectively. 
If users add attributes to their planar map components, reading (resp. writing) planar map would 
be done by inheriting the class \ccStyle{Pm_file_scanner} (resp. \ccStyle{Pm_file_writer} ) 
and overriding all the relevant function for scanning (resp. writing) 
the planar map components. 

After the definition of the inherited class users have to call the function 
\ccStyle{read} of \ccc{Planar map} (resp. the global function \ccStyle{write_pm} ) with the inherited class as a parameter.

The ability of sending the \ccc{Planar map} into a graphic stream as 
\ccStyle{leda_window}, Postscript file or Geomview is also provided, 
users simply have to use the Insertor operator operated on the graphic stream and their planar map. 
When users would like to add attributes to their planar map components and 
send their planar maps to a graphic stream, they have to inherit the class 
\ccStyle{Pm_drawer} and then call the global function \ccStyle{draw_pm} 
with this class and their planar map as parameters.

\paragraph{Format}
\ccRefLabel{Pm_IO_format}
The chosen format does not follow an existing standard format. 
Generally, the format contains lists of the components of 
\ccc{Planar map} followed by each other, 
and for each component we write its associative geometric information and 
some topological information in order to be able to update 
the \ccc{Dcel} efficiently. The format is detailed below:

\begin{enumerate}
\item The data begins with a line of three integer values specifying the number of vertices, 
halfedges and faces the \ccc{Planar map} has.
\item The vertices list: each component in the vertices list contains the point of its associative vertex.
\item The halfedges list: each halfedge component is written by an index indicating the vertex origin 
of the halfedge, and a curve specifying the halfedge's curve.
\item The faces list: each component in the faces list contains its outer boundary, 
if the face is bounded, and a list of its holes which can be empty in case the face 
has no holes. The format of the outer boundary is the number of halfedges of its connected 
component followed by the indices indicating the halfedges of that component, those indices 
have the same order of the halfedges on the connected component. 
The format of the list of the holes is first the number of holes followed by the connected 
components per each hole, the format of each connected components resembles the format 
of the outer boundary specified above.
\item Lines begining with '\#' serve as comments and are ignored.
\item The format does not differentiate between spaces and new lines, 
except new lines which belong to commented lines. 
And hence, writing the planar in one single line having no comments is also considered legal. 
If users would like to keep the commented lines, they may write all the 
components between two consecutive commented lines in one single line.

\end{enumerate}

\ccExample {of usage in I/O functions}
\ccIncludeExampleCode{Planar_map/example9.cin}

The example above presents a planar map containing one triangle with the coordinates 
{\em (0,0)}, {\em (1,1)} and {\em (2,0)}. 
The \ccc{Planar map} instance that was used to produce this example was templated 
with the \ccStyle{Pm_segment_exact_traits} class, which was templated with the representation 
class \ccStyle{Cartesian<leda_rational>}.
The first line specifying that the planar map has three vertices, six halfedges, 
and 2 faces (the triangle and the unbounded face). 
The list of vertices each represented by its associated point follows, as shown in the 
output example. 
The next list is the one of halfedges, each component is represented by one 
index (between 0 to 2) of the vertices 
list and its associated segment. 
The faces list is presented next. It starts with the \ccStyle{unbounded face} 
having one hole which is the triangle, this connected component specifies that the hole has three halfedges with 
the indices 4, 0 and 3. The next face presenting the triangle is written in the same way.

The current format may not be comfortable for a user to read, because the usage of indices. 
There is a possibility to define a verbose format which contains instead of 
indices, the components themselves, and hence the user has the option to have a format which is easy for human to read.
This format cannot be scanned by the reading functions of \ccc {Planar map}.

\ccExample {of user defined I/O functions}
\label{PM_sec:example10}

The following program demonstrates the usage of I/O functions while users have 
an additional attribute in their planar map.
The attribute chosen here is adding color to a \ccStyle{Vertex}.
First the program extends the \ccc{Dcel} to that maintain attribute.
Second, the program extends the \ccc{Pm_file_writer} class to handle the newly 
defined \ccStyle{vertex}. 
It simply overrides the functions for writing a vertex to print the color of the vertex as well. 
Finally, the main function defines an empty \ccc{Planar map},  
reads it from the standard input stream, and then set all vertices colors. It then defines an object of its extended writer class and 
parameterize the function \ccc{write_pm} with that object.

\ccIncludeExampleCode{Planar_map/example10.C}

The input of the program is a text file presenting the \ccc{Planar map}:
\ccIncludeExampleCode{Planar_map/example10.cin}

The output is the \ccc{Planar map} written in both formats, non verbose and verbose. In addition the two lists 
(non verbose and verbose) of halfedges are written.
\ccIncludeExampleCode{Planar_map/example10_output.txt}

More details are given in sections
\ccc{File_header}\lcTex{
   (\ccRefPage{CGAL::File_header})},
\ccc{Pm_file_scanner<Planar_map>}\lcTex{
   (\ccRefPage{CGAL::Pm_file_scanner<Planar_map>})}, 
\ccc{Pm_file_writer<Planar_map>}\lcTex{ 
   (\ccRefPage{CGAL::Pm_file_writer<Planar_map>})} and
\ccc{Pm_drawer<Planar_map>}\lcTex{
   (\ccRefPage{CGAL::Pm_drawer<Planar_map>})}.

\end{ccAdvanced}

\begin{ccTexOnly}

\subsection*{Concepts}
\ccRefConceptPage{Planar_map_point_location}\\
\ccRefConceptPage{Planar_map_bounding_box}\\
\ccRefConceptPage{Planar_map_DCEL}\\
\ccRefConceptPage{Planar_map_DCEL::Vertex}\\
\ccRefConceptPage{Planar_map_DCEL::Halfedge}\\
\ccRefConceptPage{Planar_map_traits}\\
\ccRefConceptPage{Pm_bounding_box_traits}

\subsection*{Classes}

\ccRefIdfierPage{CGAL::Planar_map_2<Dcel,Traits>}\\
\ccRefIdfierPage{CGAL::Pm_default_point_location<Planar_map>}\\
\ccRefIdfierPage{CGAL::Pm_naive_point_location<Planar_map>}\\
\ccRefIdfierPage{CGAL::Pm_walk_along_a_line_point_location<Planar_map>}\\
%\ccc{Planar_map_2<Dcel, Traits>::Vertex}\\
%\ccc{Planar_map_2<Dcel, Traits>::Halfedge}\\
%\ccc{Planar_map_2<Dcel, Traits>::Face}\\
\ccRefIdfierPage{CGAL::Pm_unbounding_box<Planar_map>}\\
\ccRefIdfierPage{CGAL::Pm_dynamic_open_bounding_box<Planar_map>}\\
\ccRefIdfierPage{CGAL::Pm_dcel<V,H,F>}\\
\ccRefIdfierPage{CGAL::Pm_segment_exact_traits<R>}\\
\ccRefIdfierPage{CGAL::Pm_segment_epsilon_traits<R>}\\
\ccRefIdfierPage{CGAL::Pm_leda_segment_exact_traits}\\
\ccRefIdfierPage{CGAL::Pm_straight_exact_traits<R>}\\
\ccRefIdfierPage{CGAL::File_header}\\
\ccRefIdfierPage{CGAL::Pm_file_scanner<Planar_map>}\\
\ccRefIdfierPage{CGAL::Pm_file_writer<Planar_map>}\\
\ccRefIdfierPage{CGAL::Pm_drawer<Planar_map, Window>}\\


\subsection*{Functions}

\ccRefIdfierPage{CGAL::write_pm<Planar_map,Writer>(Planar_map pm, Writer& writer, ostream& o);}\\
\ccRefIdfierPage{CGAL::draw_pm<Planar_map,Drawer,Window>(Planar_map pm, Drawer& dr, Window& w);}\\


%\ccc{Topological_map<Dcel>}\\
%\ccc{Tpm_face_base}

\end{ccTexOnly}    



