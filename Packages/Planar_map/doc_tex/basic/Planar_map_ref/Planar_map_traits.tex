% +------------------------------------------------------------------------+
% | Reference manual page: Planar_map_traits.tex (Planar_map)
% +------------------------------------------------------------------------+
% | 
% | Package: pm (Planar_map_2)
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+

\begin{ccRefConcept}{PlanarMapTraits_2}
\label{PM_sec:req:interface} 
 
%\label{I1_S}} 
   
   A model for the \ccRefName\ concept must provide the following types and
   operations. It defines the geometric types and primitive operations used
   in the planar map data structure \ccc{Planar_map_2<Dcel,Traits>}.

\ccCreationVariable{pm_traits}


\ccDefinition
    A class \ccClassTemplateName\ that satisfies the requirements of an
    interface class for a planar map class must provide the following types
    and operations. 

\ccTypes

    The geometric types defined below must have a default constructor,
    copy constructor, assignment operator and \ccStyle{operator==}.
    
    \ccNestedType{Point_2}{A type that holds the position of a vertex in
    the plane.}
    
    \ccNestedType{X_curve_2}{A type that holds an $x$-monotone curve in the
    plane.}

\ccHeading{Categories}
    
    \ccNestedType{Has_left_category}{A boolean category that indicates
     whether the method
     \ccc{curve_compare_at_x_left()} is required or
     alternatively the methods
     \ccc{point_reflect_in_x_and_y()} and
     \ccc{curve_reflect_in_x_and_y()} are required. It must be either
     \ccc{Tag_true} or \ccc{Tag_false}.}

\ccHeading{Enumerations}

    \ccEnum{enum Comparison_result {SMALLER, EQUAL, LARGER};}
    {a constant describing the relative position between objects.}
    
    \ccEnum{enum Curve_point_status {UNDER_CURVE = -1,
                                     CURVE_NOT_IN_RANGE ,
                                     ABOVE_CURVE ,
                                     ON_CURVE};
    }
    {a constant describing the relative position between a curve and a point.}

\ccCreation
    
% Only a default constructor is required. Note that further constructors
% can be provided.

    \ccConstructor{Traits();}
    {A default constructor.}

    \ccOperations
%    \ccSetTwoOfThreeColumns{4cm}{4cm}

%predicates
%----------
    \ccMethod{Comparison_result compare_x(const Point_2& p0,
                                          const Point_2& p1);}
    {compares the \ccStyle{x}-coordinates of $p0$ and $p1$.  Returns
    \ccStyle{LARGER} if $x(p0) > x(p1)$; \ccStyle{SMALLER} if $x(p0) < x(p1)$;
    \ccStyle{EQUAL} otherwise.}
    
    \ccMethod{Comparison_result compare_xy(const Point_2& p0,
                                           const Point_2& p1);}
    {compares lexigoraphically the two points $p0$ and $p1$ by their
    \ccStyle{x}-coordinates, then by their \ccStyle{y}-coordinates.
    Returns \ccStyle{LARGER} if $x(p1) > x(p2)$, or if
                        $x(p1) = x(p2)$ and $y(p1) > y(p2)$; 
    \ccStyle{SMALLER} if $x(p1) < x(p2)$, or if $x(p1) = x(p2)$ and
                      $y(p1) < y(p2)$;
    \ccStyle{EQUAL} otherwise.}

    \ccMethod{bool curve_is_vertical(const X_curve_2& cv);} 
   {returns \ccStyle{true} if \ccStyle{cv} is a vertical segment, and
    \ccStyle{false} otherwise.}
        
    \ccMethod{bool curve_is_in_x_range( const X_curve_2& cv,
       const Point_2& pnt );}
    {returns \ccStyle{true} if \ccStyle{pnt} is in the $x$ range of
    \ccStyle{cv}, and \ccStyle{false} otherwise.}
    
    \ccMethod{Comparison_result curve_compare_at_x(const X_curve_2& cv1,
      const X_curve_2& cv2, const Point_2& pnt );}
    {compares the $y$-coordinate of $cv1$ and $cv2$ at the $x$-coordinate 
    of $pnt$. Returns \ccStyle{LARGER} if $cv1(x(q)) > cv2(x(q))$;
    \ccStyle{SMALLER} if $cv1(x(q)) < cv2(x(q))$; \ccStyle{EQUAL} otherwise.
    \ccPrecond{$cv1$ and $cv2$ are defined at $pnt$'s $x$-coordinate.}}

    \ccMethod{Comparison_result curve_compare_at_x_left(const X_curve_2& cv1,
      const X_curve_2& cv2, const Point_2& pnt);}
    {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the
     left of the $x$-coordinate of $pnt$. 
    \ccPrecond{$cv1$ and $cv2$ are defined to the left of $pnt$'s
     $x$-coordinate.}}
    
    \ccMethod{Comparison_result curve_compare_at_x_right(const X_curve_2& cv1,
      const X_curve_2& cv2, const Point_2& pnt);}
    {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the right of
     the $x$-coordinate of $pnt$.
    \ccPrecond{$cv1$ and $cv2$ are defined to the left of $pnt$'s
     $x$-coordinate.}}
    
    \ccMethod{Curve_point_status curve_get_point_status(const X_curve_2& cv,
       const Point_2& pnt);} {returns a constant describing the
       relative position between $cv$ and $pnt$:
       \begin{itemize}
       \item[]\ccStyle{CURVE_NOT_IN_RANGE} - $pnt$ is not in the $x$-range of
       $cv$, 
%       \item[]\ccStyle{CURVE_VERTICAL} - $cv$ is a vertical segment,
       \item[]\ccStyle{UNDER_CURVE} - $pnt$ is below $cv$,
       \item[]\ccStyle{ABOVE_CURVE} - $pnt$ is above $cv$, and
       \item[]\ccStyle{ON_CURVE} - $pnt$ is on $cv$.
       \end{itemize}}
       
       \ccMethod{bool curve_is_between_cw(const X_curve_2& cv,
          const X_curve_2& first, const X_curve_2& second, const Point_2&
          pnt);} {given three curves that share an endpoint $pnt$,
          returns $true$ if $cv$ is between $first$ and $second$, when
          going in the clockwise direction around $pnt$ from $first$
          to $second$. }


       \ccMethod{bool curve_is_same(const X_curve_2 & cv1,
                                    const X_curve_2 & cv2);}
       {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} have the same graph.}

       \ccMethod{bool point_is_same(const Point_2 & p1,
                                    const Point_2 & p2);}
       {returns \ccc{true} if \ccc{p1} is the same as \ccc{p2}.}
	  
%construction function
%---------------------   

    \ccMethod{Point_2 curve_source(const X_curve_2& cv);}
             {returns the source of \ccc{cv}.}
    \ccMethod{Point_2 curve_target(const X_curve_2& cv);}
             {returns the target of \ccc{cv}.}

%additions needed for the default point location strategy

%      \smallskip {\noindent \bf \large Requirements for
%         \ccStyle{Info_face}, \ccStyle{Info_edge}, \ccStyle{Info_vertex}}
      
%      All info types should have a constructor and a copy
%      constructor.

\ccHasModels
  \ccc{Pm_segment_traits_2<Kernel>}

  The \ccc{PlanarMapWithIntersectionsTraits_2} and
  \ccc{ArrangementTraits_2} concepts are refinements of the
  \ccc{PlanarMapTraits_2} concept, in other words, a model of the
  formers is a model of the latter.  The meaning of that is that all
  supplied (or user written ) arrangement traits classes can be used
  ass the \ccc{Traits} template parameter for
  \ccc{Planar_map_2<Dcel,Traits>}.  See the list of the arrangement
  traits classes as part of the \ccc{Arrangement_2 Reference Pages}.
  
\end{ccRefConcept} % Pm_traits

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+















