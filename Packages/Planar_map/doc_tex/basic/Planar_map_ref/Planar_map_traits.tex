% +------------------------------------------------------------------------+
% | Reference manual page: Planar_map_traits.tex (Planar_map)
% +------------------------------------------------------------------------+
% | 
% | Package: pm (Planar_map_2)
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+

\begin{ccRefConcept}{PlanarMapTraits_2}
\label{PM_sec:req:interface} 
 
%\label{I1_S}} 
   
   A model for the \ccRefName\ concept must provide the following types and
   operations. It defines the geometric types and primitive operations used
   in the planar map data structure \ccc{Planar_map_2<Dcel,Traits>}.

\ccCreationVariable{pm_traits}


\ccDefinition
    A class \ccClassTemplateName\ that satisfies the requirements of an
    interface class for a planar map class must provide the following types
    and operations. 

\ccTypes

    The geometric types defined below must have a default constructor,
    copy constructor, assignment operator and \ccStyle{operator==}.
    
    \ccNestedType{Point_2}{A type that holds the position of a vertex in
    the plane.}
    
    \ccNestedType{X_monotone_curve_2}{A type that holds an $x$-monotone curve in the
    plane.}

\ccHeading{Categories}
    
    \ccNestedType{Has_left_category}{A boolean category that indicates
     whether the method
     \ccc{curves_compare_y_at_x_left()} is required or
     alternatively the methods
     \ccc{point_reflect_in_x_and_y()} and
     \ccc{curve_reflect_in_x_and_y()} are required. It must be either
     \ccc{Tag_true} or \ccc{Tag_false}.}

\ccHeading{Enumerations}

    \ccEnum{enum Comparison_result {SMALLER, EQUAL, LARGER};}
    {a constant describing the relative position between objects.}
    
\ccCreation
    
% Only a default constructor is required. Note that further constructors
% can be provided.

    \ccConstructor{Traits();}
    {A default constructor.}

    \ccOperations
%    \ccSetTwoOfThreeColumns{4cm}{4cm}

%predicates
%----------
    \ccMethod{Comparison_result compare_x(const Point_2& p0,
                                          const Point_2& p1);}
    {compares the \ccStyle{x}-coordinates of $p0$ and $p1$.  Returns
    \ccStyle{LARGER} if $x(p0) > x(p1)$; \ccStyle{SMALLER} if $x(p0) < x(p1)$;
    \ccStyle{EQUAL} otherwise.}
    
    \ccMethod{Comparison_result compare_xy(const Point_2& p0,
                                           const Point_2& p1);}
    {compares lexigoraphically the two points $p0$ and $p1$ by their
    \ccStyle{x}-coordinates, then by their \ccStyle{y}-coordinates.
    Returns \ccStyle{LARGER} if $x(p1) > x(p2)$, or if
                        $x(p1) = x(p2)$ and $y(p1) > y(p2)$; 
    \ccStyle{SMALLER} if $x(p1) < x(p2)$, or if $x(p1) = x(p2)$ and
                      $y(p1) < y(p2)$;
    \ccStyle{EQUAL} otherwise.}

    \ccMethod{bool curve_is_vertical(const X_monotone_curve_2& cv);} 
   {returns \ccStyle{true} if \ccStyle{cv} is a vertical segment, 
    \ccStyle{false} otherwise.}
        
    \ccMethod{bool point_in_x_range( const X_monotone_curve_2& cv,
       const Point_2& pnt );}
    {returns \ccStyle{true} if \ccStyle{pnt} is in the $x$ range of
    \ccStyle{cv}, \ccStyle{false} otherwise.}
    
    \ccMethod{Comparison_result curves_compare_y_at_x(const X_monotone_curve_2& cv1,
      const X_monotone_curve_2& cv2, const Point_2& pnt );}
    {compares the $y$-coordinate of $cv1$ and $cv2$ at the $x$-coordinate 
    of $pnt$. Returns \ccStyle{LARGER} if $cv1(x(q)) > cv2(x(q))$;
    \ccStyle{SMALLER} if $cv1(x(q)) < cv2(x(q))$; \ccStyle{EQUAL} otherwise.
    \ccPrecond{$cv1$ and $cv2$ are defined at $pnt$'s $x$-coordinate.}}

    \ccMethod{Comparison_result curves_compare_y_at_x_left(const X_monotone_curve_2& cv1,
      const X_monotone_curve_2& cv2, const Point_2& pnt);}
    {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the
     left of the $x$-coordinate of $pnt$.
     \ccPrecond{$cv1$ and $cv2$ meet at $pnt$ $x$-coordinate.}
     \ccPrecond{$cv1$ and $cv2$ are defined to the left of $pnt$'s
     $x$-coordinate.}}
    
    \ccMethod{Comparison_result curves_compare_y_at_x_right(const X_monotone_curve_2& cv1,
      const X_monotone_curve_2& cv2, const Point_2& pnt);}
    {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the right of
     the $x$-coordinate of $pnt$.
     \ccPrecond{$cv1$ and $cv2$ meet at $pnt$ $x$-coordinate.}
     \ccPrecond{$cv1$ and $cv2$ are defined to the left of $pnt$'s
     $x$-coordinate.}}
    
    \ccMethod{Curve_point_status curve_compare_y_at_x(const Point_2& pnt,
    const X_monotone_curve_2& cv);}
    {compares the y-coordinates of $pnt$ and the vertical projection of $pnt$
      on $cv$. Returns \ccStyle{LARGER} if y(p) > $cv(x(p))$; \ccStyle{SMALLER}
      if y(p) < $cv(x(p))$; \ccStyle{EQUAL} otherwise (p is on the curve).
    \ccPrecond{$cv$ is defined at $pnt$'s $x$-coordinate.}}

    \ccMethod{bool curve_equal(const X_monotone_curve_2 & cv1,
    const X_monotone_curve_2 & cv2);}
    {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} have the same graph, 
      \ccc{false} otherwise.}

    \ccMethod{bool point_equal(const Point_2 & p1,
                                 const Point_2 & p2);}
    {returns \ccc{true} if \ccc{p1} is the same as \ccc{p2}, \ccc{false}
      otherwise.}
	  
%construction function
%---------------------   

    \ccMethod{Point_2 curve_source(const X_monotone_curve_2& cv);}
             {returns the source of \ccc{cv}.}
    \ccMethod{Point_2 curve_target(const X_monotone_curve_2& cv);}
             {returns the target of \ccc{cv}.}

%additions needed for the default point location strategy

%      \smallskip {\noindent \bf \large Requirements for
%         \ccStyle{Info_face}, \ccStyle{Info_edge}, \ccStyle{Info_vertex}}
      
%      All info types should have a constructor and a copy
%      constructor.

\ccHasModels
  \ccc{Pm_segment_traits_2<Kernel>}

  The \ccc{PlanarMapWithIntersectionsTraits_2} and
  \ccc{ArrangementTraits_2} concepts are refinements of the
  \ccc{PlanarMapTraits_2} concept, in other words, a model of the
  formers is a model of the latter.  The meaning of that is that all
  supplied (or user written ) arrangement traits classes can be used
  ass the \ccc{Traits} template parameter for
  \ccc{Planar_map_2<Dcel,Traits>}.  See the list of the arrangement
  traits classes as part of the \ccc{Arrangement_2 Reference Pages}.
  
\end{ccRefConcept} % Pm_traits

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+















