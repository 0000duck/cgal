% +------------------------------------------------------------------------+
% | Reference manual page: Polyhedron_items.tex
% +------------------------------------------------------------------------+
% | 17.03.1999   Lutz Kettner
% | Package: Polyhedron
% | 
\RCSdef{\RCSPolyhedronitemsRev}{$Revision$}
\RCSdefDate{\RCSPolyhedronitemsDate}{$Date$}
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{Polyhedron_items}

\ccDefinition

The \ccRefName\ concept extends the \ccc{HalfedgeDS_Items} concept on
page~\pageref{pageHalfedgeDSitemsRef}. In addition to the requirements
stated there, a model for this concept must fulfill the following
requirements for the local
\ccc{Polyhedron_items::Vertex_wrapper<Refs,Traits>::Vertex} type and
\ccc{Polyhedron_items::Face_wrapper<Refs,Traits>::Face} type
in order to support the optional point for vertices and the optional
surface normal or plane equation for facets. Note that the items class
uses face instead of facet. Only the polyhedral surface renames faces
to facets.

\begin{ccClass}{Vertex}
\ccCreationVariable{v}

\ccHeading{%
  Types in \ccc{Polyhedron_items::Vertex_wrapper<Refs,Traits>::Vertex}}

Type for (optionally) associated geometry in vertices. If points
are not supported the respective type is \ccc{void*}.

\ccNestedType{Point}{point type stored in vertices.}

\ccNestedType{Supports_vertex_point}{either \ccc{CGAL::Tag_true}
    or \ccc{CGAL::Tag_false}.}

\ccTagFullDeclarations
\ccHeading{Operations required if \ccc{Supports_vertex_point} $\equiv$ 
           \ccc{CGAL::Tag_true}}

\ccMethod{Point&       point();}{}
\ccGlue
\ccMethod{const Point& point() const;}{point.}

\ccTagDefaults
\end{ccClass}

\begin{ccClass}{Face}
\ccCreationVariable{f}

\ccHeading{Types in \ccc{Polyhedron_items::Face_wrapper<Refs,Traits>::Face}}

Types for (optionally) associated geometry in faces. If they
are not supported the respective types are \ccc{void*}.

\ccNestedType{Normal}{surface normal vector stored in faces.}
\ccGlue
\ccNestedType{Plane}{plane equation stored in faces.}

\ccNestedType{Supports_face_plane}{either \ccc{CGAL::Tag_true}
    or \ccc{CGAL::Tag_false}.}
\ccGlue
\ccNestedType{Supports_face_normal}{\~{}}

\ccTagFullDeclarations
\ccHeading{Operations required if \ccc{Supports_face_plane} $\equiv$ 
           \ccc{CGAL::Tag_true}}
         
Note, this implies \ccc{Supports_face_normal} $\equiv$ \ccc{CGAL::Tag_true}, but
the return type of the \ccc{normal()} member function will not be by reference.

\ccMethod{Plane&       plane();}{}
\ccGlue
\ccMethod{const Plane& plane() const;}{plane equation.}
\ccGlue
\ccMethod{Normal normal() const;}{normal vector.}

\ccHeading{Operations required if \ccc{Supports_face_normal} $\equiv$ 
           \ccc{CGAL::Tag_true}}

\ccMethod{Normal&       normal();}{}
\ccGlue
\ccMethod{const Normal& normal() const;}{normal vector.}

\ccTagDefaults

\end{ccClass}

\ccHasModels

\ccc{CGAL::Polyhedron_items_3},
\ccc{CGAL::HalfedgeDS_vertex_base},
\ccc{CGAL::HalfedgeDS_face_base}.

\ccSeeAlso

\ccc{CGAL::Polyhedron_3},
\ccc{HalfedgeDS_Items},
\ccc{CGAL::HalfedgeDS_items},
\ccc{CGAL::HalfedgeDS_halfedge_base}.

\ccExample

We define our own items class based on the available
\ccc{CGAL::HalfedgeDS_face_base} base class for faces. We derive the
\ccc{Vertex_wrapper} and the \ccc{Halfedge_wrapper} without further
modifications from the \ccc{CGAL::HalfedgeDS_items} class and replace
the \ccc{Face_wrapper} definition with our new definition. The result
is a model for the \ccc{Polyhedron_items} concept similar to the 
available \ccc{CGAL::Polyhedron_items_3} class. See also there for another
illustrative example. 

\begin{ccExampleCode}
#include <CGAL/HalfedgeDS_bases.h>

struct My_items : public CGAL::HalfedgeDS_items {
    template < class Refs, class Traits>
    struct Face_wrapper {
        typedef CGAL::HalfedgeDS_face_base< Refs, CGAL::Tag_true, Traits> Face;
    };
};
\end{ccExampleCode}

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

