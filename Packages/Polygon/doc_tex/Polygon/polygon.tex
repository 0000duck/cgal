
\cleardoublepage
\chapter{Polygon}\label{Polygon}

\begin{ccClassTemplate}{Polygon_2<Traits,Container>}
\ccSection{2D Polygon}

\ccDefinition

The class \ccClassName\ represents a simple polygon in the two-dimensional
Euclidean plane $\E_2$. A polygon is called {\em simple} if there is no pair
of nonconsecutive edges sharing a point (see \cite{ps-cgi-85}).

An object \ccStyle{p} of the data type \ccClassName\ is defined by the sequence
of its vertices. A simple polygon \ccStyle{p} is oriented, i.e., its boundary has
clockwise or counterclockwise orientation. The side to the left of the boundary
is called the positive side and the side to the right of the boundary is called
the negative side.  As any Jordan curve, the boundary of a polygon divides the
plane into two open regions, a bounded one and an unbounded one.

An object \ccStyle{p} of \ccClassName\ is a dynamic data
structure, i.e. vertices can be added and removed. These operations may
destroy the simplicity of the polygon, which is a precondition to most
predicates of polygons.

The data type \ccClassName\ is parameterized with two template parameters: 
a traits class \ccStyle{Traits} and a container class \ccStyle{Container}. 
The parameter \ccStyle{Traits} defines the types and predicates
that are used in the polygon class and the polygon algorithms.
For example \ccStyle{Traits::Point_2} denotes the type of the vertices
of the polygon. 
A default polygon traits class \ccStyle{Polygon_traits_2<R>} is provided 
(see Section~\ref{sec:poly_default}), where \ccStyle{R} is a representation 
class.
The parameter \ccStyle{Container} specifies the type of container that is 
used to store the sequence of vertices of the polygon, e.g.\ a list, a vector, 
a tree, etc.
The type \ccStyle{Container} should fulfill the requirements of a sequence 
container given in \cite{ms-strg-96}. 
The value type of the container should be the same as the point type of the 
traits class.

%{\em Note}: Currently, a polygon declaration looks like
%\ccStyle{Polygon_2<Traits, list<Traits::Point_2> >}.
%When nested templates become available this might be simplified to
%\ccStyle{Polygon_2<Traits, list>}.

\subsubsection*{Assertions}
The polygon code uses infix \ccc{POLYGON} in the assertions,
for example defining the compiler flag
\ccc{CGAL_POLYGON_NO_PRECONDITIONS} switches precondition
checking off, cf.~Section~2 of the Reference Manual Part 0, General 
Introduction.

The following types denote iterators that allow to traverse the vertices and
edges of a polygon. 
Since it is questionable whether a polygon should be viewed as a circular or 
as a linear data structure both circulators and iterators are defined.
The circulators and iterators with `const' in their name are non-mutable, the 
others are mutable.

\ccExample

The following code fragment creates a polygon and checks if it is convex.

\ccIncludeVerbatim{Polygon/Polygon.C}

\end{ccClassTemplate}

\section{Algorithms on sequences of 2D points \label{sec:poly_algo}}

A number of algorithms on sequences of 2D points are supplied as global functions.
In all algorithms the points in the range \ccStyle{[first,last)} are interpreted
as the vertices of a polygon. The vertices in this range should have value type
\ccStyle{Traits::Point_2}. Most functions take a traits class as their last argument.

For the implementation of \ccc{oriented_side_2} 
a {\em crossing test} algorithm is used with complexity
$O(n)$, see \cite{h-pps-94}.
The implementation of \ccc{is_convex_2} checks if the polygon is locally convex
and if there is only one local minimum and one local maximum with respect to
the lexicographical ordering determined by
\ccc{Traits::lexicographically_xy_smaller}.
The complexity of the algorithm is $O(n)$, where $n$ is the number of points
in the range \ccStyle{[first,last)}.
The simplicity test \ccc{is_simple_2} of a polygon is a line-segment 
intersection test. For the implementation a plane sweep algorithm is used, see also 
\cite{ps-cgi-85}, p.276.
The complexity of the algorithm is $O(n \log n)$ (worst case), where $n$ is 
the number of points in the range \ccStyle{[first,last)}.

