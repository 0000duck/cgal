% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Section: Smallest Enclosing Sphere
% -----------------------------------------------------------------------------
% file  : doc_tex/basic/Optimisation/Optimisation_ref/Min_sphere_d.tex
% author: Bernd Gärtner (gaertner@inf.ethz.ch)
% -----------------------------------------------------------------------------
% $Revision$
% $Date$
% $CGAL_Package: Min_sphere_d WIP $
% =============================================================================

\begin{ccRefClass}{Min_sphere_of_spheres_d<Traits>}
\ccIndexSubitem[t]{sphere}{smallest enclosing sphere of spheres}
\ccIndexSubitem[t]{smallest enclosing}{sphere of spheres}
\ccIndexSubitem[t]{bounding volumes}{smallest enclosing sphere of spheres}
\ccIndexSubitemSeeAlso[t]{circle}{smallest enclosing sphere of spheres}

% -----------------------------------------------------------------------------
\ccDefinition

An object of the class \ccRefName\ is the unique sphere of smallest
volume enclosing a finite (multi)set of spheres in $d$-dimensional
Euclidean space $\E_d$. For a set $S$ of spheres we denote by $ms(S)$
the smallest sphere that contains all spheres of $S$; we call $ms(S)$
the \emph{minsphere} of $S$. $ms(S)$ can be degenerate, i.e.,
$ms(S)=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$, if
$S=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$ and $ms(S)=\{s\}$, if
$S=\{s\}$.  Any sphere in $S$ may be degenerate, too, i.e., any sphere
from $S$ may be a point.

An inclusion-minimal subset $R$ of $S$ with $ms(R)=ms(S)$ is called a
\emph{support set} for $ms(S)$; the spheres in $R$ are the
\emph{support spheres}.  A support set has size at most $d+1$, and all
its spheres lie on the boundary of $ms(S)$. (A sphere $s'$ is said to
\emph{lie on the boundary} of a sphere $s$, if $s'$ is contained in $s$
and if their boundaries intersect.)  In general, the support set is
not unique.

The algorithm computes the center and the radius of $ms(S)$, and finds
a support set $R$ (which remains fixed until the next insert or clear
operation).  We also provide a specialization of the algorithm for the
case when the center coordinates and radii of the input balls are
floating-point numbers.  This specialized algorithm uses
floating-point arithmetic only, is very fast and especially tuned for
stability and robustness.  Still, it's output may be incorrect in some
(rare) cases.
%
% We provide two versions of the algorithm, one computing
% the exact minsphere (using exact arithmetic) and one which finds the
% minsphere using floating-point arithmetic.  While the output of the
% former algorithm is always correct, the latter algorithm may produce
% incorrect results due to rounding errors.

In general, the radius and the Euclidean center coordinates of $ms(S)$
need not be rational.  Consequently, the algorithm computing the exact
minsphere will have to deal with algebraic numbers.  Fortunately, both
the radius and the coordinates of the minsphere are (in the worst case)
numbers of the form $a_i+b_i\sqrt{t}$, where $a_i,b_i,t\in \Q$ and
where $t\ge 0$ is the same for all coordinates and the radius.  Thus,
the exact minsphere can be described by the number~$t$, which is called
the ball's \emph{discriminant}, and by $d+1$ pairs $(a_i,b_i)\in\Q^2$
(one for the radius and $d$ for the center coordinates).

\ccInclude{CGAL/Min_sphere_of_spheres_d.h}

\ccRequirements
\ccIndexRequirements

The class \ccRefName\ expects a model of the concept
\ccc{MinSphereOfSpheresTraits} as its template argument.  We provide
the model \ccc{Min_sphere_of_spheres_d_traits_d} in order to make it
easy to work with $d$-dimensional spheres of type
\ccc{CGAL::Weighted_point<Pt,Wt>}.
% the models \ccc{MinSphereOfSpheres_d_traits_2},
% \ccc{MinSphereOfSpheres_d_traits_3} and
% \ccc{MinSphereOfSpheres_d_traits_d} for two-, three-, and
% $d$-dimensional spheres respectively.

\ccTypes
\ccIndexClassTypes

% kf.
%\ccSetTwoColumns{Min_sphere_d<Traits>:: Support_point_iterator}{}

\ccNestedType{Sphere}{typedefs to \ccc{Traits::Sphere}.}

\ccNestedType{FT}{typedefs to \ccc{Traits::FT}.}

\ccNestedType{Result}{is the type of the radius and of the center
coordinates of the computed minsphere: When \ccc{FT} is an inexact
number type (like \ccc{double}, for instance), then \ccc{Result} is
simply \ccc{FT}.  However, when \ccc{FT} is an exact number type, then
\ccc{Result} typedefs to a subclass of class \ccc{std::pair<FT,FT>}.}

\ccNestedType{Algorithm}{is either \ccc{CGAL::LP_algorithm} or
\ccc{CGAL::Farthest_first_heuristic}.  As is described in the
documentation of concept \ccc{MinSphereOfSpheresTraits}, the type
\ccc{Algorithm} reflects the method which is used to compute the
minsphere.  (Normally, \ccc{Algorithm} coincides with
\ccc{Traits::Algorithm}.  However, if the method
\ccc{Traits::Algorithm} should not be supported anymore in a future
release, then \ccc{Algorithm} will have another type.)}

\ccNestedType{Support_sphere_iterator}{non-mutable model of the STL
concept \ccc{BidirectionalIterator} with value type \ccc{Sphere}. Used
to access the support spheres defining the smallest enclosing sphere.}

\ccNestedType{Center_coordinate_iterator}{non-mutable model of the STL
concept \ccc{BidirectionalIterator} with value type \ccc{Result}. Used
to access the center coordinates of the minsphere.}

\ccCreation
\ccIndexClassCreation
\ccCreationVariable{minsphere}

\ccConstructor{ Min_sphere_of_spheres_d(const Traits& traits = Traits());}%
%
{creates a variable of type \ccRefName\ and initializes it to
$ms(\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}})$.  If the traits
parameter is not supplied, the class \ccc{Traits} must provide a
default constructor.}

\ccUnchecked
\ccConstructor{ template < typename InputIterator >
                Min_sphere_of_spheres_d( InputIterator  first,
                                   InputIterator  last,
                                   const Traits&  traits = Traits());}
%
{creates a variable \ccVar\ of type \ccRefName.  It is initialized to
$ms(S)$ with $S$ being the set of spheres in the range
[\ccc{first},\ccc{last}).
%
\ccRequire The value type of \ccc{first} and \ccc{last} is
\ccc{Sphere}. If the traits parameter is not supplied, the class
\ccc{Traits} must provide a default constructor.
%
\ccPrecond All spheres have the same dimension.}

\ccAccessFunctions
\begin{ccIndexMemberFunctions}
\ccIndexMemberFunctionGroup{access}

%\ccIndexSubitem[t]{support set}{\ccFont Min_sphere_of_spheres_d}
%\ccMemberFunction{ int  number_of_spheres( ) const;}{
%returns the number of spheres of \ccVar, i.e.\ $|S|$.}
%
%\ccMemberFunction{ int  number_of_support_spheres( ) const;}{
%returns the number of support spheres of \ccVar, i.e.\ $|R|$.}
%
%\ccMemberFunction{ Point_iterator  points_begin() const;}{
%returns an iterator referring to the first point of \ccVar.}
%%
%\ccMemberFunction{ Point_iterator  points_end() const;}{
%returns the corresponding past-the-end iterator.}
%

\ccMemberFunction{ Support_sphere_iterator  support_spheres_begin() const;}{
returns an iterator referring to the first support sphere of \ccVar.}
%
\ccMemberFunction{ Support_sphere_iterator  support_spheres_end() const;}{
returns the corresponding past-the-end iterator.}

\ccMemberFunction{ int ambient_dimension() const;}{ returns the
ambient dimension of the spheres in $S$, i.e.\ the number $d$. If
\ccVar\ is empty, the ambient dimension is $-1$.}

\ccMemberFunction{ int dimension() const;}{ returns the dimension of
the minsphere, i.e.\ the number $d-1$. If \ccVar\ is empty,  $-1$ is returned.}

\ccMemberFunction{ const FT& discriminant( ) const;}{ returns the
discriminant of \ccVar.  This number is only useful if \ccc{FT} is an
exact number type.  In this case, the center coordinates and the
radius of the minsphere are numbers of the form $a+b\sqrt{t}$, where
$t$ is the discriminant of the minsphere.  \ccPrecond \ccVar\ is not
empty.}

\ccMemberFunction{Result radius( ) const;}{ returns the radius of
\ccVar.  If \ccc{FT} is an exact number type then the radius of the
minsphere is the real number $a+b\sqrt{t}$ where $t$ is the minsphere's
discriminant, $a$ is the first and $b$ the second component of the
pair returned by \ccc{radius()}.  \ccPrecond \ccVar\ is not empty.}

\ccMemberFunction{Center_coordinate_iterator center_begin( ) const;}{
returns a const-iterator to the first center coordinate of \ccVar.
The iterator returns objects of type \ccc{Result}.  If \ccc{FT} is
an exact number type, then a center coordinate consists of a pair
$(a,b)$ describing the real number $a+b\sqrt{t}$, where $t$ is the
minsphere's discriminant.  \ccPrecond \ccVar\ is not empty.}

\ccMemberFunction{Center_coordinate_iterator center_end( ) const;}{
Returns the corresponding past-the-end iterator.}

% -----------------------------------------------------------------------------
\ccPredicates
\ccIndexMemberFunctionGroup{predicates}

%By definition, an empty \ccRefName\ has no boundary and no
%bounded side, i.e.\ its unbounded side equals the whole space $\E_d$.

%\ccMemberFunction{ Bounded_side
%                   bounded_side( const Sphere& p) const;}{
%        returns \ccc{CGAL::ON_BOUNDED_SIDE}, \ccc{CGAL::ON_BOUNDARY}, or
%        \ccc{CGAL::ON_UNBOUNDED_SIDE} iff \ccc{p} lies properly inside,
%        on the boundary, or properly outside of \ccVar, resp.
%        \ccPrecond if \ccVar\ is not empty, the dimension of $p$
%        equals \ccc{ambient_dimension()}.}
%
%\ccMemberFunction{ bool  has_on_bounded_side( const Sphere& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies properly inside \ccVar.
%        \ccPrecond if \ccVar\ is not empty, the dimension of $p$
%        equals \ccc{ambient_dimension()}.}
%
%\ccMemberFunction{ bool  has_on_boundary( const Sphere& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies on the boundary
%        of \ccVar.
%        \ccPrecond if \ccVar\ is not empty, the dimension of $p$
%        equals \ccc{ambient_dimension()}.}
%
%\ccMemberFunction{ bool  has_on_unbounded_side( const Sphere& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies properly outside of \ccVar.
%        \ccPrecond if \ccVar\ is not empty, the dimension of $p$
%        equals \ccc{ambient_dimension()}.}

\ccMemberFunction{ bool  is_empty( ) const;}{
        returns \ccc{true}, iff \ccVar\ is empty.}

%\ccIndexSubitem[t]{degeneracies}{\ccFont Min_sphere_d}
%\ccMemberFunction{ bool  is_degenerate( ) const;}{
%        returns \ccc{true}, iff \ccVar\ is degenerate, i.e.\ if
%        \ccVar\ is empty or equal to a single point, equivalently if
%        the number of support points is less than 2.}

% -----------------------------------------------------------------------------
\ccModifiers
\ccIndexMemberFunctionGroup{modifiers}

\ccMemberFunction{ void clear ();}{
        resets \ccVar\ to $ms(\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}})$.}

\ccUnchecked
\ccMemberFunction{ template < class InputIterator >
                   void set( InputIterator first,
                             InputIterator last );}{
        sets \ccVar\ to the $ms(S)$, where $S$ is the set of spheres
        in the range [\ccc{first},\ccc{last}).
        \ccRequire The value type of \ccc{first} and \ccc{last} is
        \ccc{Sphere}.
        \ccPrecond All spheres have the same dimension.}

\ccMemberFunction{ void  insert( const Sphere& s );}{
        inserts the sphere \ccc{s}
        into \ccVar\ and recomputes the smallest enclosing sphere.
        \ccPrecond If
        \ccVar\ is not empty, the dimension of \ccc{s} must be equal to
        \ccc{ambient_dimension()}.}

\ccMemberFunction{ template < class InputIterator >
                   void  insert( InputIterator  first,
                                 InputIterator  last );}{
        inserts the spheres in the range [\ccc{first},\ccc{last})
        into \ccVar\ and recomputes the smallest enclosing sphere.
        \ccRequire  The value type of \ccc{first} and \ccc{last} is
      \ccc{Sphere}.
        \ccPrecond All spheres have the same dimension. If
        \ccVar\ is not empty, this dimension must be equal to
        \ccc{ambient_dimension()}.}


% -----------------------------------------------------------------------------
\ccHeading{Validity Check}
\ccIndexMemberFunctionGroup{validity check}
\ccIndexSubitem[t]{validity check}{\ccFont Min_sphere_d}
An object \ccVar\ is valid, iff
\begin{itemize}
\item \ccVar\ contains all spheres of its defining set $S$,
\item \ccVar\ is the smallest sphere containing its support set $R$, and
\item $R$ is minimal, i.e., no support sphere is redundant.
\end{itemize}

\emph{Note:} The validation check must only be performed under exact
arithmetic (i.e., when \ccc{FT} is an exact number type).

\ccMemberFunction{ bool is_valid( bool verbose = false,
                                  int  level   = 0    ) const;}{
returns \ccc{true}, iff \ccVar\ is valid. If \ccc{verbose}
is \ccc{true}, some messages concerning the performed checks
are written to the standard error stream. The second parameter
\ccc{level} is not used, we provide it only for consistency
with interfaces of other classes.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}
\ccIndexMemberFunctionGroup{miscellaneous}

\def\ccTagRmConstRefPair{\ccFalse}
\ccMemberFunction{ const Traits&  traits( ) const;}{
        returns a const reference to the traits class object.}
        \def\ccTagRmConstRefPair{\ccTrue}

 \end{ccIndexMemberFunctions}

% -----------------------------------------------------------------------------
%\ccHeading{I/O}
%\begin{ccIndexGlobalFunctions}
%
%\ccIndexGlobalFunctionGroup{output}
%\ccFunction{ std::ostream& operator << ( std::ostream& os,
%                                    const Min_sphere_d<Traits>&
%                                        min_sphere);}{
%        writes \ccVar\ to output stream \ccc{os}.
%        \ccRequire The output operator is defined for \ccc{Point}.}
%
%\ccIndexGlobalFunctionGroup{input}
%
%\ccFunction{ std::istream& operator >> ( std::istream& is,
%                                    Min_sphere_d<Traits> min_sphere&);}{
%        reads \ccVar\ from input stream \ccc{is}.
%          \ccRequire The input operator is defined for \ccc{Point}.}
%
%\end{ccIndexGlobalFunctions}

% -----------------------------------------------------------------------------
%\ccSeeAlso
%
%    \ccRefIdfierPage{CGAL::Optimisation_d_traits_2<K,ET,FT>}\\
%    \ccRefIdfierPage{CGAL::Optimisation_d_traits_3<K,ET,FT>}\\
%    \ccRefIdfierPage{CGAL::Optimisation_d_traits_d<K,ET,FT>}\\
%    \ccRefConceptPage{OptimisationDTraits}\\
%    \ccRefIdfierPage{CGAL::Min_circle_2<Traits>}\\
%    \ccRefIdfierPage{CGAL::Min_annulus_d<Traits>}

% -----------------------------------------------------------------------------
\ccImplementation
\ccIndexImplementation
\ccIndexSubitem[t]{incremental algorithm}{\ccFont Min_sphere_of_spheres_d}
%\ccIndexSubitem[t]{farthest-first heuristic}{\ccFont Min_sphere_of_spheres_d}

We implement two algorithms, the LP-algorithm~\cite{msw-sblp-92} and a
heuristic.  As described in the documentation of concept
\ccc{MinSphereOfSpheresTraits}, each has its advantages and
disadvantages: The LP-algorithm has (for fixed dimension~$d$) linear
maximal expected running time (in the number of operations on the
number type \ccc{FT}), while the heuristic comes without any
complexity guarantee.  On the other hand, the LP-algorithm is, for
inexact number types \ccc{FT}, much worse at handling degeneracies and
should therefore not be used for approximate computation.  (For exact
number types \ccc{FT}, both methods handle all kinds of degeneracies.)

Currently, we require \ccc{Traits::FT} to be either an exact number
type or \ccc{double}; other inexact number types are not supported at
this time.  Also, the current implementation only handles spheres with
Cartesian coordinates; homogenous representation is not supported yet.

\ccExample
\ccIncludeVerbatim{Optimisation_ref/min_sphere_of_spheres_d_example.C}

\end{ccRefClass}

% ===== EOF ===================================================================

