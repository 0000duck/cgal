% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Section: Smallest Enclosing Sphere
% =============================================================================

\begin{ccRefClass}{Min_sphere_of_spheres_d<Traits>}
\ccIndexSubitem[t]{sphere}{smallest enclosing sphere of spheres}
\ccIndexSubitem[t]{smallest enclosing}{sphere of spheres}
\ccIndexSubitem[t]{bounding volumes}{smallest enclosing sphere of spheres}
\ccIndexSubitemSeeAlso[t]{circle}{smallest enclosing sphere of spheres}

% -----------------------------------------------------------------------------
\ccDefinition

An object of the class \ccRefName\ is a data structure that computes
the unique sphere of smallest volume enclosing a finite set of spheres
in $d$-dimensional Euclidean space $\E_d$.  For a set $S$ of spheres
we denote by $ms(S)$ the smallest sphere that contains all spheres of
$S$; we call $ms(S)$ the \emph{minsphere} of $S$. $ms(S)$ can be
degenerate, i.e., $ms(S)=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$,
if $S=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$ and $ms(S)=\{s\}$,
if $S=\{s\}$.  Any sphere in $S$ may be degenerate, too, i.e., any
sphere from $S$ may be a point.  Also, $S$ may contain several
copies of the same sphere.

An inclusion-minimal subset $R$ of $S$ with $ms(R)=ms(S)$ is called a
\emph{support set} for $ms(S)$; the spheres in $R$ are the
\emph{support spheres}.  A support set has size at most $d+1$, and all
its spheres lie on the boundary of $ms(S)$. (A sphere $s'$ is said to
\emph{lie on the boundary} of a sphere $s$, if $s'$ is contained in $s$
and if their boundaries intersect.)  In general, the support set is
not unique.

The algorithm computes the center and the radius of $ms(S)$, and finds
a support set $R$ (which remains fixed until the next insert or clear
operation).  We also provide a specialization of the algorithm for the
case when the center coordinates and radii of the input spheres are
floating-point numbers.  This specialized algorithm uses
floating-point arithmetic only, is very fast and especially tuned for
stability and robustness.  Still, it's output may be incorrect in some
(rare) cases; termination is guaranteed.

When default constructed, an instance of type
\ccc{Min_sphere_of_spheres_d<Traits>} represents the set
$S=\emptyset$, together with its minsphere $ms(S)=\emptyset$.  You can
add spheres to the set $S$ by calling \ccc{insert()}.  Once you have
``checked in'' all your spheres, you call \ccc{update()} to actually
compute the minsphere.  The instance is called \emph{up-to-date} iff
the minsphere of the inserted spheres $S$ has been computed (e.g.\ if
\ccc{update()} has been called after an \ccc{insert()}).

In general, the radius and the Euclidean center coordinates of $ms(S)$
need not be rational.  Consequently, the algorithm computing the exact
minsphere will have to deal with algebraic numbers.  Fortunately, both
the radius and the coordinates of the minsphere are (in the worst
case) numbers of the form $a_i+b_i\sqrt{t}$, where $a_i,b_i,t\in \Q$
and where $t\ge 0$ is the same for all coordinates and the radius.
Thus, the exact minsphere can be described by the number~$t$, which is
called the sphere's \emph{discriminant}, and by $d+1$ pairs
$(a_i,b_i)\in\Q^2$ (one for the radius and $d$ for the center
coordinates).

\ccInclude{CGAL/Min_sphere_of_spheres_d.h}

\ccRequirements
\ccIndexRequirements

The class \ccRefName\ expects a model of the concept
\ccc{MinSphereOfSpheresTraits} as its template argument.

% We provide the model \ccc{Min_sphere_of_spheres_d_traits_d} in
% order to facilitate working with $d$-dimensional spheres of type
% \ccc{CGAL::Weighted_point<Pt,Wt>}, where \ccc{Pt} is \ccc{Point_d}.
% the models \ccc{MinSphereOfSpheres_d_traits_2},
% \ccc{MinSphereOfSpheres_d_traits_3} and
% \ccc{MinSphereOfSpheres_d_traits_d} for two-, three-, and
% $d$-dimensional spheres respectively.

\ccTypes \ccIndexClassTypes

\ccNestedType{Sphere}{is a typedef to \ccc{Traits::Sphere}.}

\ccNestedType{FT}{is a typedef to \ccc{Traits::FT}.}

\ccNestedType{Result}{is the type of the radius and of the center
  coordinates of the computed minsphere: When \ccc{FT} is an inexact
  number type (\ccc{double}, for instance), then \ccc{Result} is
  simply \ccc{FT}.  However, when \ccc{FT} is an exact number type,
  then \ccc{Result} is a typedef to to a derived class of class
  \ccc{std::pair<FT,FT>}.}

\ccNestedType{Algorithm}{is either \ccc{CGAL::LP_algorithm} or
\ccc{CGAL::Farthest_first_heuristic}.  As is described in the
documentation of concept \ccc{MinSphereOfSpheresTraits}, the type
\ccc{Algorithm} reflects the method which is used to compute the
minsphere.  (Normally, \ccc{Algorithm} coincides with
\ccc{Traits::Algorithm}.  However, if the method
\ccc{Traits::Algorithm} should not be supported anymore in a future
release, then \ccc{Algorithm} will have another type.)}

\ccNestedType{Support_iterator}{non-mutable model of the STL
concept \ccc{BidirectionalIterator} with value type \ccc{Sphere}. Used
to access the support spheres defining the smallest enclosing sphere.}

\ccNestedType{Coordinate_iterator}{non-mutable model of the STL
concept \ccc{BidirectionalIterator} with value type \ccc{Result}. Used
to access the center coordinates of the minsphere.}

\ccCreation
\ccIndexClassCreation
\ccCreationVariable{minsphere}

\ccConstructor{ Min_sphere_of_spheres_d(const Traits& traits = Traits());}%
{creates a variable of type \ccRefName\ and initializes it to
  $ms(\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}})$.  If the traits
  parameter is not supplied, the class \ccc{Traits} must provide a
  default constructor.
  \ccPostcond \ccVar\ is up-to-date.}

\ccUnchecked
\ccConstructor{ template < typename InputIterator >
                Min_sphere_of_spheres_d( InputIterator  first,
                                   InputIterator  last,
                                   const Traits&  traits = Traits());}
%
{creates a variable \ccVar\ of type \ccRefName\ and inserts (cf.\
\ccc{insert()}) the spheres from the range [\ccc{first},\ccc{last}).
Notice that you have to call
\ccc{update()} in order to compute $ms(S)$; \ccVar\ is not up-to-date
after this call.
%
\ccRequire The value type of \ccc{first} and \ccc{last} is
\ccc{Sphere}. If the traits parameter is not supplied, the class
\ccc{Traits} must provide a default constructor.  Futhermore, the
spheres in the given range must not change during the lifetime of
variable \ccVar.  (The algorithm uses pointers to the inserted spheres
internally in order to save space and time, and consequently, the
referenced spheres must not change.)}

\ccAccessFunctions
\begin{ccIndexMemberFunctions}
\ccIndexMemberFunctionGroup{access}

\ccMemberFunction{ Support_iterator  support_begin() const;}{
returns an iterator referring to the first support sphere of \ccVar.
\ccPrecond \ccVar\ is up-to-date.}
%
\ccMemberFunction{ Support_iterator  support_end() const;}{
returns the corresponding past-the-end iterator.
\ccPrecond \ccVar\ is up-to-date.}


\ccMemberFunction{ const FT& discriminant( ) const;}{ returns the
discriminant of \ccVar.  This number is only useful if \ccc{FT} is an
exact number type.  In this case, the center coordinates and the
radius of the minsphere are numbers of the form $a+b\sqrt{t}$, where
$t$ is the discriminant of the minsphere.  \ccPrecond \ccVar\ is 
 up-to-date and not empty.}


\ccMemberFunction{Result radius( ) const;}{ returns the radius of
  \ccVar.  If \ccc{FT} is an exact number type then the radius of the
  minsphere is the real number $a+b\sqrt{t}$ where $t$ is the
  minsphere's discriminant, $a$ is the first and $b$ the second
  component of the pair returned by \ccc{radius()}.  \ccPrecond
  \ccVar\ is up-to-date and not empty.}

\ccMemberFunction{Coordinate_iterator center_begin( ) const;}{ returns
  a const-iterator to the first center coordinate of \ccVar.  The
  iterator returns objects of type \ccc{Result}.  If \ccc{FT} is an
  exact number type, then a center coordinate consists of a pair
  $(a,b)$ describing the real number $a+b\sqrt{t}$, where $t$ is the
  minsphere's discriminant.  \ccPrecond \ccVar\ is up-to-date and not
  empty.}

% -----------------------------------------------------------------------------
\ccPredicates
\ccIndexMemberFunctionGroup{predicates}

\ccMemberFunction{ bool is_empty( ) const;}{ returns \ccc{true}, iff
  \ccVar\ is empty, i.e.\ iff $ms(S)=\emptyset$.  \ccPrecond \ccVar\ 
  is up-to-date.}

%\ccIndexSubitem[t]{degeneracies}{\ccFont Min_sphere_d}
%\ccMemberFunction{ bool  is_degenerate( ) const;}{
%        returns \ccc{true}, iff \ccVar\ is degenerate, i.e.\ if
%        \ccVar\ is empty or equal to a single point, equivalently if
%        the number of support points is less than 2.}

% -----------------------------------------------------------------------------
\ccModifiers
\ccIndexMemberFunctionGroup{modifiers}

\ccMemberFunction{ void clear ();}{
        resets \ccVar\ to $ms(\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}})$, with $S:= \emptyset$.
\ccPostcond \ccVar\ is up-to-date.}

\ccUnchecked \ccMemberFunction{ template < class InputIterator > void
  set( InputIterator first, InputIterator last );}{ sets \ccVar\ to
  the $ms(S)$, where $S$ is the set of spheres in the range
  [\ccc{first},\ccc{last}) and calls \ccc{update()} internally.
  \ccRequire The value type of \ccc{first} and \ccc{last} is
  \ccc{Sphere}.  Futhermore, the spheres in the given range must not
  change during the lifetime of variable \ccVar.  (The algorithm uses
  pointers to the inserted spheres internally in order to save space and
  time, and consequently, the referenced spheres must not change.)
\ccPostcond \ccVar\ is up-to-date.  }

\ccMemberFunction{ void insert( const Sphere& s );}{ inserts the
  sphere \ccc{s} into the set $S$ of instance \ccVar.  Notice that
  \ccVar\ is not up-to-date after this call, so you will have to call
  \ccc{update()} to actually compute $ms(S)$.  \ccPrecond The sphere
  $s$ must not change during the lifetime of variable \ccVar.  (The
  algorithm uses pointers to the inserted spheres internally in order to
  save space and time, and consequently, the referenced spheres must
  not change.)}


\ccMemberFunction{ template < class InputIterator > void insert(
  InputIterator first, InputIterator last );}{ inserts the spheres in
  the range [\ccc{first},\ccc{last}) into the set $S$ of instance
  \ccVar.  Notice that \ccVar\ is not up-to-date after this call, so
  you will have to call \ccc{update()} to actually compute $ms(S)$.
  \ccRequire The value type of \ccc{first} and \ccc{last} is
  \ccc{Sphere}.  Futhermore, the spheres in the given range must not
  change during the lifetime of variable \ccVar.  (The algorithm uses
  pointers to the inserted spheres internally in order to save space and
  time, and consequently, the referenced spheres must not change.)}


% -----------------------------------------------------------------------------
\ccHeading{Validity Check}
\ccIndexMemberFunctionGroup{validity check}
\ccIndexSubitem[t]{validity check}{\ccFont Min_sphere_d}
An object \ccVar\ is valid, iff
\begin{itemize}
\item \ccVar\ contains all spheres of its defining set $S$,
\item \ccVar\ is the smallest sphere containing its support set $R$, and
\item $R$ is minimal, i.e., no support sphere is redundant.
\end{itemize}

%\ccMemberFunction{ bool is_valid( bool verbose = false,
%                                  int  level   = 0    ) const;}{
\ccMemberFunction{ bool is_valid() const;}{
returns \ccc{true}, iff \ccVar\ is valid.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}
\ccIndexMemberFunctionGroup{miscellaneous}

\def\ccTagRmConstRefPair{\ccFalse}
\ccMemberFunction{ const Traits&  traits( ) const;}{
        returns a const reference to the traits class object.}
        \def\ccTagRmConstRefPair{\ccTrue}

 \end{ccIndexMemberFunctions}

% -----------------------------------------------------------------------------
%\ccHeading{I/O}
%\begin{ccIndexGlobalFunctions}
%
%\ccIndexGlobalFunctionGroup{output}
%\ccFunction{ std::ostream& operator << ( std::ostream& os,
%                                    const Min_sphere_d<Traits>&
%                                        min_sphere);}{
%        writes \ccVar\ to output stream \ccc{os}.
%        \ccRequire The output operator is defined for \ccc{Point}.}
%
%\ccIndexGlobalFunctionGroup{input}
%
%\ccFunction{ std::istream& operator >> ( std::istream& is,
%                                    Min_sphere_d<Traits> min_sphere&);}{
%        reads \ccVar\ from input stream \ccc{is}.
%          \ccRequire The input operator is defined for \ccc{Point}.}
%
%\end{ccIndexGlobalFunctions}

% -----------------------------------------------------------------------------
%\ccSeeAlso
%
%    \ccRefIdfierPage{CGAL::Optimisation_d_traits_2<K,ET,FT>}\\
%    \ccRefIdfierPage{CGAL::Optimisation_d_traits_3<K,ET,FT>}\\
%    \ccRefIdfierPage{CGAL::Optimisation_d_traits_d<K,ET,FT>}\\
%    \ccRefConceptPage{OptimisationDTraits}\\
%    \ccRefIdfierPage{CGAL::Min_circle_2<Traits>}\\
%    \ccRefIdfierPage{CGAL::Min_annulus_d<Traits>}

% -----------------------------------------------------------------------------
\ccImplementation
\ccIndexImplementation
\ccIndexSubitem[t]{incremental algorithm}{\ccFont Min_sphere_of_spheres_d}
%\ccIndexSubitem[t]{farthest-first heuristic}{\ccFont Min_sphere_of_spheres_d}

We implement two algorithms, the LP-algorithm and a
heuristic~\cite{msw-sblp-92}.  As described in the documentation of
concept \ccc{MinSphereOfSpheresTraits}, each has its advantages and
disadvantages: Our implementation of the LP-algorithm has maximal
expected running time $O(2^d n)$, while the heuristic comes without
any complexity guarantee.  In particular, the LP-algorithm runs in
linear time for fixed dimension~$d$. (These running times hold for the
arithmetic model, so they count the number of operations on
the number type \ccc{FT}.)

On the other hand, the LP-algorithm is, for inexact number types
\ccc{FT}, much worse at handling degeneracies and should therefore not
be used in such a case.  (For exact number types
\ccc{FT}, both methods handle all kinds of degeneracies.)

Currently, we require \ccc{Traits::FT} to be either an exact number
type or \ccc{double} or \ccc{float}; other inexact number types are
not supported at this time.  Also, the current implementation only
handles spheres with Cartesian coordinates; homogenous representation
is not supported yet.

\ccExample
\ccIncludeVerbatim{../../examples/Min_sphere_of_spheres_d/%
min_sphere_of_spheres_d_example_d.C}

\end{ccRefClass}

% ===== EOF ===================================================================

