% // ============================================================================
%//
%// Copyright (c) 1999 The CGAL Consortium
%//
%// This software and related documentation is part of an INTERNAL release
%// of the Computational Geometry Algorithms Library (CGAL). It is not
%// intended for general use.
%//
%// ----------------------------------------------------------------------------
%//
%// release       :
%// release_date  :
%//
%// file          : /doc_tex/basic/Apollonius_graph_2/Apollonius_2.tex
%// revision      : $Revision$
%//
%// author(s)     : Menelaos Karavelas <mkaravel@cse.nd.edu>
%//
%// coordinator   : INRIA Sophia Antipolis (Mariette Yvinec <Mariette.Yvinec@sophia.inria.fr>)
%//
%//============================================================================

\chapter{2D Apollonius graph}
\label{chapter-apollonius2}

%\vspace*{1cm}

\begin{figure}[htb]
\begin{ccTexOnly}
\begin{center}
\includegraphics[width=0.4\textwidth]%
{Apollonius_graph_2/apollonius_diagram.eps}
\hfil
\includegraphics[width=0.4\textwidth]%
{Apollonius_graph_2/apollonius_graph.eps} 
\end{center}
\end{ccTexOnly}
\caption{The Apollonius diagram (left) and its dual the Apollonius
  graph (right).}
\label{fig:apollonius}
\begin{ccHtmlOnly}
<center>
<img border=0 src="./apollonius_diagram.gif" align=center
alt="The Apollonius diagram">
<img border=0 src="./apollonius_graph.gif" align=center
alt="The Apollonius graph (dual of the Apollonius diagram)">
</center>
\end{ccHtmlOnly}
\end{figure}

The 2D Apollonius graph class of \cgal\ is designed to compute the
dual of the {\em Apollonius diagram} or, as it is also known, the
{\em Additively weighted Voronoi diagram}. The algorithm that has been
implemented is dynamic, which means that we can perform insertions and
deletions on line. The corresponding \cgal\ class is called
\ccc{Apollonius_graph_2<ApolloniusGraphTraits_2,StoreHidden,ApolloniusGraphDataStructure_2>}
and will be discussed in
more detail below. The interested reader may want to refer to the
paper by Karavelas and Yvinec \cite{ky-dawvd-02} for the general idea
as well as the details of the algorithm implemented.


Before describing the details of the implementation we make a brief
introduction to the theory of Apollonius diagrams.
The Apollonius diagram is defined over a set of weighted points
$P_i=(c_i,w_i)$, $i=1,\ldots,n$, where $c_i$ is the point and $w_i$
the weight of $P_i$. It is a subdivision of the plane into connected
regions, called {\em cells}, associated with the weighted points (see
Fig. \ref{fig:apollonius}(left)). The cell of a 
weighted point $P_i$ is the locus of points on the plane that are
closer to $P_i$ than any other weighted point $P_j$, $j\ne i$.
The distance $\delta(x, P_i)$ of a point $x$ in the plane to a
circle $P_i$ is defined as: 
\[      \delta(x,P_i)=\|x-c_i\|-w_i,\]
where $\|\cdot\|$ denotes the Euclidean norm.
It can easily be seen that it is a generalization of the Voronoi
diagram for points, which can actually be obtained if all the weights
$w_i$ are equal. If all weights $w_i$ are non-negative, the Apollonius
diagram can be viewed as the Voronoi diagram of the set of circles
$\{P_1,\ldots, P_n\}$, where $c_i$ is the center of the circle $P_i$
and $w_i$ its radius. Unlike the case of points, however, it is
possible that a weighted point $P_i$ might have an empty cell. This
can also happen in the case of the power diagram, whose dual is the
regular triangulation \ref{}. If this is the
case we call the weighted point {\em hidden} (these are the black
circles in Fig. \ref{fig:apollonius}). A weighted point which is not
hidden will be referred to as {\em visible}.
From now on we will assume for simplicity that all weights are
positive and we will refer to the weighted points as circles.


The Apollonius diagram is a planar graph, and so is its dual, the
Apollonius graph. There are many ways to embed it on the plane and one
such way is shown in Fig. \ref{fig:apollonius}(right).
The Apollonius graph is uniquely defined once we have
the Apollonius diagram. If the circles are in {\em general position}
(see precise definition below), then the Apollonius graph is a graph
with triangular faces away from 
the convex hull of the set of circles (by triangular we mean that
every face has exactly three edges). Near the convex hull we may
have some spikes (i.e., vertices of degree 1). To unify our approach
and handling of the Apollonius graph we add to the set of (finite)
circles a fictitious circle at infinity, which we call the
{\em point at infinity}. We can then connect all vertices of the outer
face of the Apollonius graph to the point at infinity which gives us
a graph with the property that all its faces are now
triangular. However, the Apollonius graph is not a triangulation for
two main reasons: we cannot always embed it on the plane with straight
line segments that yield a triangulation and moreover we may have two
faces of the graph that have two edges in common, which is not allowed
in a triangulation. Both of these particularities appear when we
consider the Apollonius graph of the set of circles in
Fig. \ref{fig:apollonius}(right).


We would like to finish our brief introduction to the theory of
Apollonius graphs by discussing the concept of general position. We say
that a set of circles is in general position if no two triples of
circles have the same tritangent circle. This statement is rather
technical and it is best understood in the context of points. The
equivalent statement for points is that we have no two triples of
points that define the same circumcircle, or equivalently that no
four circles are co-circular. The statement about general position made
above is a direct generalization of the (much simpler to understand)
statement about points. On the contrary, when we have circles in
degenerate position, the Apollonius graph has faces with more than
three edges on their boundary. We can get a triangulated version of
the graph by simply {\em triangulating} the corresponding face in an
arbitrary way. In fact the algorithm that has been implemented in
\cgal\ has the property that it always returns a valid
{\em triangulated} version of the Apollonius graph. By valid we mean
that it contains the actual Apollonius graph (i.e., the actual dual of
the Apollonius diagram) and whenever there are faces with more than
three faces then they are triangulated. The way that they are
triangulated depends on the order of insertion and deletion of the
circles in the diagram.



One final point has to be made about hidden circles. First of all we
would like to be more precise about our definition of hidden circles:
we say that a circle is hidden if its cell has empty interior. This
definition allows us to guarantee that all visible circles have
cells that are two-dimensional regions.
Geometrically the fact that a circle is hidden means that it is
contained in the closure of the disk of another circle (see again
Fig. \ref{fig:apollonius}). Hidden circles pose an additional
difficulty to our algorithm and software design. Since we allow
circles to be inserted and deleted at wish, it is possible that a
circle that was hidden at some point, may become visible at another
point; for example this can happen if we delete the circle that
hides it. For this purpose we store hidden circles and have them
reappear when they become visible. We will discuss this issue in
detail below. For the time being it suffices to say that the user has
the ability to control this behavior. More specifically it is possible
to discard the circles that become hidden. This choice is totally
natural when for example we expect to do only insertions, since in
this case a circle that becomes hidden will never reappear. On the
other hand if deletions are expected as well, then we lose the ability
to have the hidden circles reappear.



\section{Software Design}
\label{sec:apollonius2-design}

The 2D Apollonius graph class
\ccc{Apollonius_graph_2<ApolloniusGraphEuclideanTraits_2,StoreHidden,ApolloniusGraphDataStructure_2>}
follows the design of the triangulation package of \cgal. It is
parametrized by three arguments:
\begin{itemize}
\item the {\bf geometric traits} class. The user can specify the
  type of geometric objects to be used such as weighted points, points
  etc. It also provides the geometric predicates for the computation
  of the Apollonius graph, as well as some basic constructions that
  can be used, for example, to visualize the Apollonius graph or the
  Apollonius diagram.
\item a {\bf boolean value} that indicates if the hidden weighted
  points are to be stored or not. Its value should be \ccc{true} if the
  user wants to keep track of the weighted points or \ccc{false}
  otherwise. It is suggested that the value of this template parameter
  is set to \ccc{false}, if only insertions are to be used. By default
  its value is set to \ccc{true}.
\item the {\bf Apollonius graph data structure}. This is essentially
  the same as the triangulation data structure (discussed in Chapter
  \ref{Chapter_2D_Triangulation_Data_structure}), augmented with some
  additional operations that are specific to Apollonius graphs. In
  fact it is a refinement of the
  \ccc{TriangulationDataStructure_2}. The class
  \ccc{Apollonius_graph_data_structure_2<Vb,Fb>} is a model of
  the concept \ccc{ApolloniusGraphDataStructure_2}. A default value
  for the corresponding template parameter is provided, so the user
  does not need to specify it.
\end{itemize}



\section{The Geometric Traits}
\label{sec:apollonius2-traits}

The predicates required for the computation of the Apollonius graph
are rather complicated. It is not the purpose of this document to
discuss them in detail. The interested reader may refer to the papers
by Karavelas and Emiris for the details
\cite{ke-ppawv-02,ke-rctac-03}. However, we would like to give a brief
overview of what they 
compute. There are several predicates needed by this algorithm. We
will discuss the most important/complicated ones. It turns out that
it is much easier to describe them in terms of the Apollonius diagram,
rather than the Apollonius graph. Whenever it is applicable we will also
describe their meaning in terms of the Apollonius graph.


The first two geometric predicates are called
\ccc{Is_hidden_2} and \ccc{Oriented_side_of_bisector_2}. The first one
involves two circles, say $P_1$ and $P_2$. It determines if $P_1$ is
hidden with respect to $P_2$; more precisely it checks whether the
circle $P_1$ is contained in the closure of the disk defined by the
circle $P_2$. As its name indicates, it determines if a circle is
hidden or not. The second predicate involves two circles $P_1$ and
$P_2$ and a point $q$. It answers the question whether $q$ is closer
to $P_1$ or $P_2$. Its name stems from the fact that answering the
afore-mentioned question is equivalent to determining the oriented
side of the bisector of $P_1$ and $P_2$ that contains the query point
$q$. This predicate is used by the algorithm for closest neighbor
queries for points.


The next geometric predicate is called \ccc{Vertex_conflict_2} and it
involves four circles $P_1$, $P_2$, $P_3$, and $P_4$ (see
Fig. \ref{fig:ag2vertexconflict}). The first three (red circles in
Fig. \ref{fig:ag2vertexconflict}) define a tritangent circle (yellow
circle in Fig. \ref{fig:ag2vertexconflict}). What we want to determine is
the sign of the distance of the green circle from the yellow
circle. The distance between two circles $K_1=(c_1,r_1)$ and
$K_2=(c_2, r_2)$ is defined as the distance of their centers minus
their radii:
\[   \delta(K_1, K_2) = \|c_1-c_2\|-r_1-r_2. \]
This predicate determines if a vertex in the Apollonius diagram
(the center of the yellow circle) is destroyed when a new circle is
inserted in the diagram (the green circle). In the Apollonius graph
it tells us if a triangular face of the diagram is to be destroyed or
not.

\begin{figure}[!htb]
\begin{ccTexOnly}
\begin{center}
\includegraphics[width=0.4\textwidth]%
{Apollonius_graph_2/apollonius-vertex_conflict-false.eps}
\hfil
\includegraphics[width=0.4\textwidth]%
{Apollonius_graph_2/apollonius-vertex_conflict-true.eps} 
\end{center}
\end{ccTexOnly}
\caption{The \ccc{Vertex_conflict_2} predicate. The red circles define
  the tritangent yellow circle. We want to determine if the sign of
  the distance of the green circle from the yellow one. The blue curve
  is the bisector of the top-most and bottom-most red circles.
  Left: the predicate returns \ccc{NEGATIVE}. Right: the predicate
  returns \ccc{POSITIVE}.}
\label{fig:ag2vertexconflict}
\begin{ccHtmlOnly}
<center>
<img border=0 src="./apollonius-vertex_conflict-false.gif" align=center
alt="The Vertex_conflict_2 predicate returns false">
<img border=0 src="./apollonius-vertex_conflict-true.gif" align=center
alt="The Vertex_conflict_2 predicate returns true">
</center>
\end{ccHtmlOnly}
\end{figure}

What we essentially want to compute when we construct incrementally a
Voronoi diagram, is whether the object to be inserted destroys an edge
of the Voronoi diagram or not. In the case of points this is really
easy and it amounts to the well known {\em incircle} test. In the case
of circles the situation is more complicated. We can have six possible
outcomes as to what portion of an edge of the Apollonius diagram the
new circle destroys (see Fig. \ref{fig:ag2edgeconflict}). The first
two can be answered directly by the \ccc{Vertex_conflict_2} predicate
evaluated for the two endpoints of the Apollonius diagram edge. This
is due to the fact that the value of the \ccc{Vertex_conflict_2}
predicate is different for the two endpoints. If the two values are
the same then we need an additional test which determines if the interior
of the Apollonius diagram edge is destroyed by the new circle. This is
what the \ccc{Finite_edge_interior_conflict_2} and
\ccc{Infinite_edge_interior_concflict_2} predicates do. In essense, it
is the same predicate (same idea) applied to two different types of
edges in the Apollonius diagram: a finite or an infinite edge. An edge
is infinite if its dual edge in the Apollonius graph connects the
point at infinity with the vertex corresponding to a (finite) circle; 
otherwise it is a finite edge.

\begin{figure}[!t]
\begin{ccTexOnly}
\begin{center}
\includegraphics[width=0.35\textwidth]%
{Apollonius_graph_2/apollonius-left_vertex.eps}
\hfil
\includegraphics[width=0.35\textwidth]%
{Apollonius_graph_2/apollonius-right_vertex.eps}\\
\includegraphics[width=0.35\textwidth]%
{Apollonius_graph_2/apollonius-no_conflict.eps}
\hfil
\includegraphics[width=0.35\textwidth]%
{Apollonius_graph_2/apollonius-entire_edge.eps}\\
\includegraphics[width=0.35\textwidth]%
{Apollonius_graph_2/apollonius-interior.eps}
\hfil
\includegraphics[width=0.35\textwidth]%
{Apollonius_graph_2/apollonius-both_vertices.eps}\\
\end{center}
\end{ccTexOnly}
\caption{The \ccc{Finite_edge_interior_conflict_2} predicate. The red
  circles define two tritangent yellow circles, whose centers are
  the endpoints of the edge in the Apollonius diagram (dark blue curve
  segment). The light blue curve is the bisecting curve of the
  top-most and bottom-most red circles, and it is also the supporting
  curve of the dark blue edge. The green circle is the circle to be
  inserted. Top left: only a neighborhood around the left-most
  endpoint of the edge will be destroyed. Top right: only a
  neighborhood around the right-most endpoint of the edge will be
  destroyed. Middle left: the green circle does not destroy anything
  from the edge. Middle right: the entire edge will be
  destroyed. Bottom left: a neighborhood in the interior of the edge
  will be destroyed; the regions near the endpoints remain
  unaffected. Bottom right: The neighborhood around the two endpoints
  will be destroyed, but an interval in the interior of the edge will
  remain in the new diagram.}
\label{fig:ag2edgeconflict}
\begin{ccHtmlOnly}
<center>
<img border=0 src="./apollonius-left_vertex.gif" align=center alt="">
<img border=0 src="./apollonius-right_vertex.gif" align=center alt="">
<br>
<img border=0 src="./apollonius-no_conflict.gif" align=center alt="">
<img border=0 src="./apollonius-entire_edge.gif" align=center alt="">
<br>
<img border=0 src="./apollonius-interior.gif" align=center alt="">
<img border=0 src="./apollonius-both_vertices.gif" align=center alt="">
</center>
\end{ccHtmlOnly}
\end{figure}


The last predicate that we want to discuss is called
\ccc{Is_degenerate_edge_2}. It tells us whether an edge in the
Apollonius diagram is degenerate, that is if its two endpoints
coincide. In the Apollonius graph such an edge corresponds to one of
the additional edges that we use to triangulate non-triangular faces.



\section{The Apollonius graph hierarchy}
\label{sec:ag2hierarchy}

The \ccc{ApolloniusGraphHierarchy_2} concept is nothing but the
equivalent of the concept behind the \ccc{Triangulation_hierarchy_2}
class, applied to the
Apollonius graph. It consists of a series of Apollonius graphs
constructed in a manner analogous to the Delaunay hierarchy by
Devillers \cite{d-iirdt-98}. The class
\ccc{Apollonius_graph_hierarchy_2<ApolloniusGraphTraits_2,StoreHidden,ApolloniusGraphDataStructure_2>}
is a model of the \ccc{ApolloniusGraphHierarchy_2} concept and has
exactly the same interface and functionality as the
\ccc{Apollonius_graph_2<ApolloniusGraphTraits_2,StoreHidden,ApolloniusGraphDataStructure_2>}
class. Using the Apollonius graph hierarchy involves an additional
cost in space and time for maintaining the hierarchy. Our experiments
have shown that it usually pays off to use the hierarchy for inputs
consisting of more than 100,000 circles.


\section{Examples}
\label{sec:apollonius2-examples}

\subsection{First example}
\ccIncludeExampleCode{Apollonius_graph_2/example1.C}

\subsection{Second example}
\ccIncludeExampleCode{Apollonius_graph_2/example2.C}

\subsection{Third example}
\ccIncludeExampleCode{Apollonius_graph_2/example3.C}

\subsection{Fourth example}
\ccIncludeExampleCode{Apollonius_graph_2/example4.C}