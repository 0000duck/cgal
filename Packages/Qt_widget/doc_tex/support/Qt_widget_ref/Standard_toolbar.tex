% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 02.04.2003  Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget_standard_toolbar}

\ccDefinition

The standard toolbar includes the basic tools used for zooming and translating.

\ccInclude{CGAL/IO/Qt_widget_standard_toolbar.h}
\ccGlue

\ccInheritsFrom
\ccc{QToolBar}

\ccCreation
\ccCreationVariable{stoolbar}
\ccSetTwoColumns{Qt_widget_standard_toolbar}{}

\ccConstructor{Qt_widget_standard_toolbar(Qt_widget *w, QMainWindow
*mw = 0, const char* name = 0);}{This constructor creates a new
toolbar in your application, containing all the standard tools. The
first parameter is a pointer to a Qt\_widget object, the second is a
pointer to a QMainWindow object, that contains the toolbar. The last
parameter is the name of the toolbar. If you are using this
constructor, you should deallocate yourself the memory used for the
toolbar. Use the other one if you want \qt\ to do it for you.}

\ccConstructor{Qt_widget_standard_toolbar(Qt_widget *w, QMainWindow
*mw = 0, QWidget* parent, bool newline = true, const char* name =
0);}{ The same as the previous one except from \ccc{parent} parameter that
is used to tell \qt\ to destroy the memory after the parent is
destroied. If \ccc{newline} is true, the toolbar will be placed on a
new line.}

\ccMethod{const QToolBar* toolbar();}{Deprecated: (in CGAL-2.4 the
standard toolbar was not derived from \ccc{QToolBar}) Returns a pointer to
the \ccc{QToolBar} private member. To use the standard toolbar in your 
application, you need this function in order to get the pointer to the 
toolbar.}

\ccHeading{public slots:}
\ccMethod{void back();}{Goes back in the history list of the standard toolbar.}
\ccMethod{void forward();}{Goes forward in the history list of the
standard toolbar.}
\ccMethod{void clear_history();}{Clears the history list of the
standard toolbar.}

\ccExample
\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Point_2.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/IO/Qt_widget_Delaunay_triangulation_2.h>

#include <qapplication.h>
#include <qmainwindow.h>

#include <CGAL/IO/Qt_widget.h>
#include <CGAL/IO/Qt_widget_layer.h>
#include <CGAL/IO/Qt_widget_standard_toolbar.h>

typedef CGAL::Cartesian<double>		    Rep;
typedef CGAL::Point_2<Rep>		    Point;
typedef CGAL::Delaunay_triangulation_2<Rep> Delaunay;

Delaunay dt;

class My_layer : public CGAL::Qt_widget_layer{
  void draw(){
    *widget << CGAL::BLACK;
    *widget << dt;
  }
};

class My_widget : public CGAL::Qt_widget {
public:
  My_widget(QMainWindow* c) : CGAL::Qt_widget(c) {};
private:
  //this event is called only when the user presses the mouse
  void mousePressEvent(QMouseEvent *e)
  {
    Qt_widget::mousePressEvent(e);
    dt.insert(Point(x_real(e->x()), y_real(e->y())));
    redraw();
  }
};

class My_window : public QMainWindow{
public:
  My_window(int x, int y)
  {
    widget = new My_widget(this);
    setCentralWidget(widget);
    resize(x,y);
    widget->set_window(0, x, 0, y);
    
    //How to attach the standard toolbar
    stoolbar = new CGAL::Qt_widget_standard_toolbar(widget, this,
						    "Standard toolbar");
    widget->attach(&v);
  }
private:
  My_widget *widget;
  My_layer  v;
  CGAL::Qt_widget_standard_toolbar *stoolbar;
};

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_window W(400,400);
    app.setMainWidget( &W );
    W.show();
    W.setCaption("Using the Standard Toolbar");
    return app.exec();
}
\end{ccExampleCode}

This example is implemented in the fifth tutorial. You can 
look over the code to see how the code works.

\end{ccRefClass}

% +-----------------------------------------------------+
% EOF







