% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  qt_widget.tex
% +------------------------------------------------------------------------+
% | Using Qt_widget to visualize CGAL Objects
% | 
% |
% |
% | 12.12.2001	Radu Ursu
% | 
\RCSdef{\qtwidgetRev}{$Revision$}
\RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

\newcommand{\qt}{{\sc QT}}	%QT abbreviation

\gdef\lciIfHtmlClassLinks{\lcFalse}
\gdef\lciIfHtmlRefLinks{\lcFalse}
\gdef\lciIfHtmlLinks{\lcFalse}

\chapter{Qt\_widget}
\label{chapterQtwidget}

\ccChapterRelease{\qtwidgetRev. \ \qtwidgetDate}\\
\ccChapterAuthor{Radu Ursu}

\qt\ is a GUI development toolkit\footnote{http://www.trolltech.com} that 
allows to develop cross-platform applications. In this chapter we describe a 
widget that allows to visualize CGAL objects.

% +-----------------------------------------------------+
\section{Introduction to Qt\_widget}
\label{Qt_widget}

The QWidget class is the base class of all user interface objects. The widget
 is the atom of the user interface: It receives mouse, keyboard and other 
events from the window system, and paints a representation of itself on the 
screen. Every widget is rectangular, and they are sorted in a Z-order. A 
widget is clipped by its parent and by the widgets in front of it.

Qt\_widget is a class derived from QWidget in order to receive all the events
from the window system.

Qt\_widget use as a backbuffer for drawing a pixmap
defined inside the class, that is an object of type QPixmap. The QPixmap class
is an off-screen pixel-based paint device. One common use of the QPixmap class
is to enable smooth updating of widgets.
The QPainter class paints on paint devices. There is an object of type 
QPainter defined in Qt\_widget that uses as a paint device the QPixmap object.

Qt\_widget provides a scale system. You can use scales for your objects as 
well as you can draw the objects with one scale and look at the objects with 
different scales. Also there is a possibility to tell the widget that you
want that the visible area should be mapped to a certain interval, and the 
widget adjust the scales according to that.

The Qt\_widget provides output operators for all \cgal\ objects. There are 
operators defined for outputing : points, segments, rays, circles, triangles, 
polygons, and all type of triangulations. Also some operators are defined to 
set Qt\_widget's properties, like BackgroundColor, FillColor, LineWidth, 
PointSize.

For handling input we adopted the event driven design of Qt. Now there is a 
concept of tool, and also some tools are already implemented, for input points,
 segments, line, polygons, simple polygons. Also you can use this concept to 
define some specialised tools that let you edit your already defined \cgal\ 
objects.

On top of Qt\_widget it is defined a concept of View. With views you can send 
output on the screen, you can see your objects from different perspectives and 
even you can use your objects to see compute results.

\section{Qt\_widget\_tools}
\label{Qt_widget_tools}

A tool for Qt\_widget is a class that receives events from Qt\_widget and can 
provide some functionalities like input objects for Qt\_widget and modify 
already created objects. Also some basic operations can be provided like tools
for zoomIn, zoomOut, translate.

There is a base class for tools called Qt\_widget\_tool, all the tools should 
be derived from this base class.
\begin{ccExampleCode}
namespace CGAL {
class Qt_widget_zoomrect : public Qt_widget_tool
{
public:
	....
protected:
	....
private:
	....
}//endclass
}//endnamespace
\end{ccExampleCode}
In order to attach a tool to Qt\_widget all you have to do is to declare and 
define the tool and then use the attach method from Qt\_widget class. The 
Qt\_widget and the tool mechanism is designed to use only one tool at one moment of time. You can't use two tools at the same time. When a tool is attached, both the tool and the Qt\_widget will receive the events from the Window System.
\begin{ccExampleCode}
CGAL::Qt_widget_zoomrect	zoomrectbut;
CGAL::Qt_widget			*widget;

widget->attach(zoomrectbut);
\end{ccExampleCode}
The events are declared in the base class as virtual functions. Your tool class
has to overload this functions in order to receive the events from the main 
widget. Only the tool that is attached at the moment will receive the events
from the widget.
\begin{ccExampleCode}
namespace CGAL {
class Qt_widget_zoomrect : public Qt_widget_tool
{
.....
private:
  void mousePressEvent(QMouseEvent *e)
  {
    if(e->button() == CGAL_QT_WINDOW_ZOOMRECT_BUTTON)
    {
      if (!on_first)
      {
        first_x = e->x();
        first_y = e->y();
        on_first = TRUE;
      }
    }
  };
......
}//endclass
}//endnamespace
\end{ccExampleCode}

\section{Using Tools to create \cgal\ objects}
\label{create_cgal_objects}

In order to create \cgal\ objects, your tool has to call the public member 
function new\_object(CGAL::Object) from Qt\_widget. Qt\_widget will emit the 
signal new\_cgal\_object(CGAL::Object). To be more clear, all the objects 
created with tools, will be catched by Qt\_widget and send to user through the
 signal new\_cgal\_object(CGAL::Object). This way, the user should write only 
a connect like this:

connect(Qt\_Widget,SIGNAL(new\_cgal\_object(CGAL::Object)),this,SLOT(get\_new\_object(CGAL::Object)));

Also in the user class the code should look like this. This should be a 
template for you anytime you want to use Qt\_widget, you should follow the same
model:
\begin{ccExampleCode}
class MyWindow : public QMainWindow
{
  Q_OBJECT
public:
  MyWindow(int w, int h): win(this) {
    setCentralWidget(&win);
    resize(w, h);
    connect(&win, SIGNAL(new_cgal_object(CGAL::Object)), 
      this, SLOT(get_new_object(CGAL::Object)));
   ...
  }
  ...
private:
  CGAL::Qt_widget	  win;		

private slots:
  void get_new_object(CGAL::Object obj)
  {
    Point p;
    Segment s;
    Line l;
    Polygon_2 poly;
    if (CGAL::assign(p, obj)) {
       ...
    } else if(CGAL::assign(s,obj)) {
       ...      
    } else if(CGAL::assign(l, obj)) {
       ...
    } else if(CGAL::assign(poly, obj)) {
       ...
    }
    ...
  }
};

int
main(int argc, char **argv)
{
  QApplication app( argc, argv );
    app.setStyle( new QPlatinumStyle );
    QPalette p( QColor( 250, 215, 100 ) );
    app.setPalette( p, TRUE );
  MyWindow win(800,800); // physical window size
  app.setMainWidget(&win);
  win.setMouseTracking(TRUE);
  win.show();
  // because Qt send resizeEvent only on show.
  win.set_window(-1, 1, -1, 1);
  return app.exec();
}

\end{ccExampleCode}

The following is an example of a tool that create \cgal\ points when the user 
click the left mouse button over the widget. Combined with the previous 
example, you can get \cgal\ objects. For example in the previous example all 
you have to do is to declare the tool and to attach it, let's say in the 
constructor, or in other member function..
 
\begin{ccExampleCode}
namespace CGAL {

template <class R>
class Qt_widget_get_point : public Qt_widget_tool
{
  //  Q_OBJECT
public:
  typedef typename R::Point_2	Point;
  typedef typename R::FT	FT;
  
  Qt_widget_get_point(const QCursor c=QCursor(Qt::crossCursor)) :
    cursor(c) {};
  
private:
  void mousePressEvent(QMouseEvent *e)
  {
    if(e->button() == CGAL_QT_WIDGET_GET_POINT_BUTTON)
    {
      FT
        x=static_cast<FT>(widget->x_real(e->x())),
        y=static_cast<FT>(widget->y_real(e->y()));
      widget->new_object(make_object(Point(x, y)));
    }
  };
  void attaching()
  {
    oldcursor = widget->cursor();
    widget->setCursor(cursor);
  };
  
  void detaching()
  {
    widget->setCursor(oldcursor);
  };

  QCursor cursor;
};

} // namespace CGAL
\end{ccExampleCode}

\section{Qt\_widget\_views}
\label{Qt_widget_views}

A view for Qt\_widget is a class that is used to draw something on the screen. 
For example if you store a triangulation object in your class, you can use a 
view to draw the triangulation in blue, a view to draw the voronoy in red, a 
view to draw the triangulation in white, a view to draw the vertices of the 
triangulation in green, and so on. In principle you can draw everything with
views, the advantage is that you can attach and detach a view whenever you want
. That means that when a view is attached, that view is displayed, the order of
displaying views is the order that you attached them. Let's say for example 
that you have 4 views A, B, C, D, attached in the order \ccStyle{A B C D}. You 
will see them displayed as \ccStyle{A} being the first one and \ccStyle{D} 
being the last one displayed, \ccStyle{D} will be on top. If you detach the 
view \ccStyle{C}, for example, you will heve only 3 views that will be 
displayed in the following order: \ccStyle{A B D}.

To attach this view all you have to do is:
\begin{ccExampleCode}
#include <CGAL/IO/Qt_view_show_triangulation.h>
#include <CGAL/IO/Qt_Widget.h>

Delaunay t;
CGAL::Qt_widget  *widget;
CGAL::Qt_view_show_triangulation < Delaunay >  *showT;
showT   = new Qt_view_show_triangulation< Delaunay >(t);
*widget << showT;

\end{ccExampleCode}



% +-----------------------------------------------------+
% EOF







