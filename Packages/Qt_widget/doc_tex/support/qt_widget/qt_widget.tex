% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  qt_widget.tex
% +------------------------------------------------------------------------+
% | Using Qt_widget to visualize CGAL Objects
% | 
% |
% |
% | 12.12.2001  Radu Ursu
% | 
\RCSdef{\qtwidgetRev}{$Revision$}
\RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

\newcommand{\qt}{{\em Qt}}      %QT abbreviation

\gdef\lciIfHtmlClassLinks{\lcFalse}
\gdef\lciIfHtmlRefLinks{\lcFalse}
\gdef\lciIfHtmlLinks{\lcFalse}

\chapter{Qt\_widget}
\label{chapterQtwidget}

\ccChapterRelease{\qtwidgetRev. \ \qtwidgetDate}\\
\ccChapterAuthor{Radu Ursu}

\qt\ is a {\sc Gui} toolkit\footnote{http://www.trolltech.com} for
cross-platform application development. 

% +-----------------------------------------------------+
\section{Introduction}

In this chapter we describe a widget and some helper classes that
allow to interact with two dimensional \cgal\ objects in \qt\ based applications.

The most important class is the class \ccStyle{Qt_widget}. It provides
a drawing area and output stream operators for \cgal\ objects, as well
as zooming and panning functionality.

The \ccStyle{Qt_widget} allows to attach {\em views}, and
it are usually views that draw on the drawing area of the widget.
Views can be activated and deactivated, and what you see in the drawing area
is the overlay of all attached activated views.

The \ccStyle{Qt_widget} allows further to attach one {\em tool} at the time. 
Tools are used for entering input, and \cgal\ provides input tools for the
two-dimensional \cgal\ objects. The limitation to one tool at the time comes
from the fact that only one logical entitiy should get the focus.

Finally, we provide a {\em toolbar} for controlling the basic functionality
of the \ccStyle{Qt_widget}.

The following sections desribe the main class as well as the helper classes
in more detail and give examples that can be taken as starting points for
new applications.


\section{Qt\_widget}
\label{Qt_widget}

The class \ccStyle{Qt_widget} is derived from the \qt\ class \ccStyle{QWidget}%
\footnote{A widget is the atom of the user interface: It receives mouse, keyboard and other 
events from the window system, and paints a representation of itself on the 
screen. Every widget is rectangular, and they are sorted in a Z-order. A 
widget is clipped by its parent and by the widgets in front of it.} 
which is the base class of all \qt\ user interface objects. 


The \ccStyle{Qt_widget} provides output operators for all \cgal\ objects. There are 
operators defined for outputing : points, segments, rays, circles, triangles, 
polygons, and all type of triangulations. Also some operators are defined to 
set \ccStyle{Qt_widget}'s properties, like background and fill color, as well as line
width and point size.

As the following examples show, simple applications can be written
without the views and tools.

\subsection{Example: Hello Segment}

The first example draws a red segment on an orange background.

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/IO/Qt_Widget.h>

#include <qapplication.h>

typedef CGAL::Cartesian<int> Rep;
typedef CGAL::Point_2<Rep>   Point;
typedef CGAL::Segment_2<Rep> Segment;

int main( int argc, char **argv )
{
    QApplication app( argc, argv );

    CGAL::Qt_widget W;
    app.setMainWidget( &W );
    W.resize(600, 600);
    W.set_window(0, 600, 0, 600);
    W.show();
    W.lock();
    W << BackgroundColor(ORANGE) << RED;
    W << Segment(Point(100,100), Point(400, 400));
    W.unlock();

    return app.exec();
}
\end{ccExampleCode}

In this example as you see, you can use \ccStyle{Qt\_widget} like a stream for output \cgal\ objects.
 There are some limitations in this example. When you'll try to resize the window, or to 
move the window, you'll notice that what you have drawn will no longer be there. Like all
the others window applications the code for drawing must be in a redraw function, in order
to work when you'll make modifications on the window. In the next example you'll see what
you have to do to resolve this problem.


\subsection{Example: A Triangulation}

This example is slightly more involved. The user can enter points and the application
draws the Delaunay triangulation of the point set. 

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/IO/Qt_Widget.h>

#include <qapplication.h>

typedef CGAL::Cartesian<double>             Rep;
typedef CGAL::Point_2<Rep>                  Point;
typedef CGAL::Delaunay_triangulation_2<Rep> Delaunay;

Delaunay dt;
class My_Window : public CGAL::Qt_widget {
public:
  My_Window(int x, int y){ resize(x,y); };
private:
  void redraw()
  {
    Qt_widget::redraw();
    *this << dt;
  }  
  // mouse events get dispatched to this function
  void mousePressEvent(QMouseEvent *e)
  {
    Qt_widget::mousePressEvent(e);
    dt.insert(Point(x_real(e->x()), y_real(e->y())));
    redraw();
  }
};

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_Window W(600,600);
    app.setMainWidget( &W );
    W.set_window(0, 600, 0, 600);
    W.show();
    return app.exec();
}
\end{ccExampleCode}

As you noticed, the code used to output the triangulation is put in \ccStyle{redraw()} function.
This function is called by the \ccStyle{Qt\_widget} when you modify the window. It is a better to
add the line \ccStyle{Qt\_widget::redraw();} at the beginning, as you'll see later why.

\section{Views}
\label{Qt_widget_views}

In the examples from the previous section the code for drawing on the
widget was in the redraw() function. As soon as the applications are more 
involved it is better to delegate the drawing task to {\em views}. 
For example, if the application displays a Delaunay triangulation, the corresponding Voronoi diagram,
 and the nearest vertex to the mouse coordinates, it makes
sense to have three independent views. The great advantage of views is that you
 can decide what views you want to see at the runtime, and the other great 
advantage is that views can be reused.

A view can be attached to a \ccc{Qt_widget}. The widget calls the method \ccc{Qt_widget_view::draw()} of all attached views, in the order 
that they were attached. It is a very simple rule, the last view attached will be on top.

Also the views could be activated and deactivated. For example if you have several \ccStyle{views} attached and you
will deactivate a \ccStyle{view}, that \ccStyle{view} will not be drawn anymore on the screen. But when you activate 
the \ccStyle{view} once again, the view will be placed in the same spot that was before have been deactivated.

By default a \ccStyle{View} is active when you attach it.

\cgal\ provides some predefined view classes as well as a base class
so that you can more easily write new views.


\subsection{Example: Using A View for Output}

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Point_2.h>
#include <CGAL/Delaunay_triangulation_2.h>


#include <qapplication.h>
#include <CGAL/IO/Qt_widget.h>
#include <CGAL/IO/Qt_widget_view.h>

typedef CGAL::Cartesian<double>		    Rep;
typedef CGAL::Point_2<Rep>		    Point;
typedef CGAL::Delaunay_triangulation_2<Rep> Delaunay;

Delaunay dt;

class My_View : public CGAL::Qt_widget_view{
  void draw(CGAL::Qt_widget& win){
    win << dt;
  }
};

class My_Window : public CGAL::Qt_widget {
public:
  My_Window(int x, int y)
  {
    resize(x,y);
    attach(&v);
  };
private:
  //this event is called only when the user press mouse
  void mousePressEvent(QMouseEvent *e)
  {
    Qt_widget::mousePressEvent(e);
    dt.insert(Point(x_real(e->x()), y_real(e->y())));
    redraw();
  }
  My_View v;
};

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_Window W(600,600);
    app.setMainWidget( &W );
    W.set_window(0, 600, 0, 600);
    W.show();
    return app.exec();
}
\end{ccExampleCode}

As you see, this example seems very much with the precedent one, but
the code for drawing the triangulation is no longer in \ccStyle{redraw()}
 function, instead it is used in a \ccStyle{View}.

This example defines a class derived from \ccStyle{Qt\_widget\_view}. In the member
function \ccStyle{draw()} it is the code for drawing the triangulation. In 
My\_Window class you need an instance of My\_View and you'll have to attach it,
if you want to see what the view draw on the screen.

Try to remove the line \ccStyle{attach(&v);} from the constructor to see
what's happening. The application will no longer display anything. Try to
deactivate and activate the \ccStyle{View} to see what's happening.


\section{Tools}
\label{Qt_widget_tools}

A tool for \ccStyle{Qt_widget} is a class that receives events from
\ccStyle{Qt_widget} and can provide some functionality like input
objects for \ccStyle{Qt_widget} and modify already created
objects. Also some basic operations can be provided like zooming in
and out, or panning.

\cgal\ provides some predefined input tools as well as a convenience base class 
\ccStyle{Qt_widget_tool} for making it easier to develop new tools.

Only one tool at the time can be attached to a widget.

We first show how to use tools and then how they work.

\subsection{Example}

The example in the previous section, did not allow to add a point to the triangulation.
That is where {\em  tools} come in. We attach the predefined tool \ccc{Qt_widget_get_point}
to the widget, and connect the signal emitted by the widget to the function that 
handles the input.  When the user clicks with the left mouse button, the tool creates
a point and passes it to the widget. The widget then creates a signal that gets passed
to the connected slot \ccc{My_Window::get_new_object(CGAL::Object)}.

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/IO/Qt_Widget.h>

#include <qapplication.h>

typedef CGAL::Cartesian<double>             Rep;
typedef CGAL::Point_2<Rep>                  Point;
typedef CGAL::Delaunay_triangulation_2<Rep> Delaunay;

Delaunay dt;
class My_Window : public CGAL::Qt_widget {
public:
  My_Window(int x, int y){
    resize(x,y);
    attach(get_point);
    connect(this, SIGNAL(new_cgal_object(CGAL::Object)), 
            this, SLOT(get_new_object(CGAL::Object)));
  };
private:
  CGAL::Qt_widget_get_point<Rep> get_point;   
private slots:
  void get_new_object(CGAL::Object obj)
  {
    Point p;
    if (CGAL::assign(p, obj)) { 
      dt.insert(p);
    }
    redraw();
  }

}//endclass;

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_Window W(600,600);
    app.setMainWidget( &W );
    W.set_window(0, 600, 0, 600);
    W.show();
    return app.exec();
}
\end{ccExampleCode}

The \ccStyle{Qt_widget} forwards all event callbacks to the attached tool.


\subsection{How Tools Work}

The following is an example of a tool that creates \cgal\ points when the user 
clicks the left mouse button over the widget. 
 
\begin{ccExampleCode}
namespace CGAL {

template <class R>
class Qt_widget_get_point : public Qt_widget_tool
{
public:
  typedef typename R::Point_2   Point;
  typedef typename R::FT        FT;
  
  Qt_widget_get_point(const QCursor c=QCursor(Qt::crossCursor)) :
    cursor(c) {};
  
private:
  void mousePressEvent(QMouseEvent *e)
  {
    if(e->button() == CGAL_QT_WIDGET_GET_POINT_BUTTON)
    {
      FT
        x=static_cast<FT>(widget->x_real(e->x())),
        y=static_cast<FT>(widget->y_real(e->y()));
      widget->new_object(make_object(Point(x, y)));
    }
  };
  void attaching()
  {
    oldcursor = widget->cursor();
    widget->setCursor(cursor);
  };
  
  // This function will be called immediately before detaching
  // the tool. The tool is responsible for cleaing up.
  void detaching()
  {
    widget->setCursor(oldcursor);
  };

  QCursor cursor;
}//endclass;
}//namespace CGAL
\end{ccExampleCode}

The \ccc{Qt_widget} forwards mouse and keyboard events to the attached tool.
In the above example only the \ccc{mousePressEvent} member function is overloaded.

Tools that create new \cgal\ objects, must call the member 
function \ccStyle{Qt_widget::new_object(CGAL::Object)}. The \ccStyle{Qt_widget} 
then emits the signal \ccStyle{new_cgal_object(CGAL::Object)}. This signal can be 
catched by any other object with the following connect statement:

\begin{ccExampleCode}
connect(Qt_widget,SIGNAL(new_cgal_object(CGAL::Object)),
        anyOtherObject,SLOT(anyOtherFunction(CGAL::Object)));
\end{ccExampleCode}

In the example we connect it to \ccc{MyWindow::get_new_object(CGAL::Object)}.

\section{Standard Toolbar}
\label{Qt_widget_standard_toolbar}

The standard toolbar includes the basic tools used for zooming and translating.
It's very easy to use, we provide further down a typical model of how to use 
the standard toolbar in your application:

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Point_2.h>
#include <CGAL/Delaunay_triangulation_2.h>


#include <qapplication.h>
#include <qmainwindow.h>

#include <CGAL/IO/Qt_widget.h>
#include <CGAL/IO/Qt_widget_standard_toolbar.h>

class My_window : public QMainWindow{
public:
  My_window(int x, int y) : win(this)
  {
    setCentralWidget(&win);
    resize(x,y);
    win.show();
    win.set_window(0, x, 0, y);
    
    //How to attach the standard toolbar
    stoolbar = new CGAL::Standard_toolbar(&win, this);
    this->addToolBar(stoolbar->toolbar(), Top, FALSE);
  }
private:
  CGAL::Qt_widget win;
  CGAL::Standard_toolbar *stoolbar;
};

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_window W(600,600);
    app.setMainWidget( &W );
    W.show();
    W.setCaption("Using the Standard Toolbar");
    return app.exec();
}
\end{ccExampleCode}



% +-----------------------------------------------------+
% EOF







