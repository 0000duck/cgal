% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  qt_widget.tex
% +------------------------------------------------------------------------+
% | Using Qt_widget to visualize CGAL Objects
% | 
% |
% |
% | 12.12.2001	Radu Ursu
% | 
\RCSdef{\qtwidgetRev}{$Revision$}
\RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

\newcommand{\qt}{{\em Qt}}	%QT abbreviation

\gdef\lciIfHtmlClassLinks{\lcFalse}
\gdef\lciIfHtmlRefLinks{\lcFalse}
\gdef\lciIfHtmlLinks{\lcFalse}

\chapter{Qt\_widget}
\label{chapterQtwidget}

\ccChapterRelease{\qtwidgetRev. \ \qtwidgetDate}\\
\ccChapterAuthor{Radu Ursu}

\qt\ is a {\sc Gui} toolkit\footnote{http://www.trolltech.com} for
cross-platform application development. 

% +-----------------------------------------------------+
\section{Introduction}

In this chapter we describe a widget and some helper classes that
allow to interact with two dimensional \cgal\ objects in \qt\ based applications.

The most important class is the class \ccStyle{Qt_widget}. It provides
a drawing area and output stream operators for \cgal\ objects, as well
as zooming and panning functionality.

The \ccStyle{Qt_widget} allows to attach {\em views}, and
it are usually views that draw on the drawing area of the widget.
Views can be activated and deactivated, and what you see in the drawing area
is the overlay of all attached activated views.

The \ccStyle{Qt_widget} allows further to attach one {\em tool} at the time. 
Tools are used for entering input, and \cgal\ provides input tools for the
two-dimensional \cgal\ objects. The limitation to one tool at the time comes
from the fact that only one logical entitiy should get the focus.

Finally, we provide a {\em toolbar} for controlling the basic functionality
of the \ccStyle{Qt_widget}.

The following sections desribe the main class as well as the helper classes
in more detail and give examples that can be taken as starting points for
new applications.


\section{Qt\_widget}
\label{Qt_widget}

The class \ccStyle{Qt_widget} is a derived from the \qt\ class \ccStyle{QWidget}%
\footnote{A widget is the atom of the user interface: It receives mouse, keyboard and other 
events from the window system, and paints a representation of itself on the 
screen. Every widget is rectangular, and they are sorted in a Z-order. A 
widget is clipped by its parent and by the widgets in front of it.} 
which is the base class of all \qt\ user interface objects. 


The \ccStyle{Qt_widget} provides output operators for all \cgal\ objects. There are 
operators defined for outputing : points, segments, rays, circles, triangles, 
polygons, and all type of triangulations. Also some operators are defined to 
set \ccStyle{Qt_widget}'s properties, like background and fill color, as well as line
width and point size.

As the following examples show, simple applications can be written
without the views and tools.

\subsection{Example: Hello Segment}

The first example draws a red segment on an orange background.

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/IO/Qt_Widget.h>

#include <qapplication.h>

typedef CGAL::Cartesian<int> Rep;
typedef CGAL::Point_2<Rep>   Point;
typedef CGAL::Segment_2<Rep> Segment;

int main( int argc, char **argv )
{
    QApplication app( argc, argv );

    CGAL::Qt_widget W;
    app.setMainWidget( &W );
    W.resize(600, 600);
    W.set_window(0, 600, 0, 600);
    W.show();
    W.lock();
    W << BackgroundColor(ORANGE) << RED;
    W << Segment(Point(100,100), Point(400, 400));
    W.unlock();

    return app.exec();
}
\end{ccExampleCode}

\subsection{Example: A Triangulation}

This example is slightly more involved. The user can enter points and the application
draws the Delaunay triangulation of the point set. 

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/IO/Qt_Widget.h>

#include <qapplication.h>

typedef CGAL::Cartesian<double>		    Rep;
typedef CGAL::Point_2<Rep>		    Point;
typedef CGAL::Delaunay_triangulation_2<Rep> Delaunay;

Delaunay dt;
class My_Window : public CGAL::Qt_widget {
public:
  My_Window(int x, int y){ resize(x,y); };
private:
  
  // mouse events get dispatched to this function
  void mousePressEvent(QMouseEvent *e)
  {
    dt.insert(Point(x_real(e->x()), y_real(e->y())));
    clear();
    *this << dt;
  }
};

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_Window W(600,600);
    app.setMainWidget( &W );
    W.set_window(0, 600, 0, 600);
    W.show();
    return app.exec();
}
\end{ccExampleCode}



\section{Views}
\label{Qt_widget_views}

In the examples from the previous section the code for drawing on the
widget was in the main function, or in the function that handled the
mouse event.  As soon as the applications are more involved it is
better to delegate the drawing task to {\em views}. For example, if
the application displays a Delaunay triangulation, the corresponding
Voronoi diagram, and the circumcircles of the triangles, it makes
sense to have three independent views.

A view can be attached to a \ccc{Qt_widget}. It can be activated and
deactivated. The widget calls the method \ccc{Qt_view::draw()} of all
attached and activated views, in the order that they were attached.

\cgal\ provides some predefined view classes as well as a base class
so that you can more easily write new views.

{\bf af: Is it possible to connect a signal to a view to (de-)activate it?}

\subsection{Example: Delaunay, Voronoi, and Circumcircle}

{\bf af: to be done.}

\begin{ccExampleCode}
#include <CGAL/IO/Qt_triangulation_view.h>
#include <CGAL/IO/Qt_Widget.h>

Delaunay t;
CGAL::Qt_widget  *widget;
CGAL::Qt_triangulation_view < Delaunay >  *showT;
showT   = new Qt_triangulation_view< Delaunay >(t);

showT->activate();
widget->attach(showT);

\end{ccExampleCode}


\subsection{How Views Work}

In the previous example we have seen how the \ccc{Qt_triangulation_view<T>}
can be used. Here we show how its implementation looks like.

\begin{ccExampleCode}
...
\end{ccExampleCode}



\section{Tools}
\label{Qt_widget_tools}

A tool for \ccStyle{Qt_widget} is a class that receives events from
\ccStyle{Qt_widget} and can provide some functionality like input
objects for \ccStyle{Qt_widget} and modify already created
objects. Also some basic operations can be provided like zooming in
and out, or panning.

\cgal\ provides some predefined input tools as well as a convenience base class 
\ccStyle{Qt_widget_tool} for making it easier to develop new tools.

Only one tool at the time can be attached to a widget.
{\bf af: Well, for zooming and panning, I could imagine that I can control
that with +, -, and cursor movement keys, independently from object input functions.}

We first show how to use tools and then how they work.

\subsection{Example: Delaunay, Voronoi, and Circum Circle (contd.)}

The example in the previous section, did not allow to add a point to the triangulation.
That is where {\em  tools} come in. We attach the predefined tool \ccc{Qt_widget_get_point}
to the widget, and connect the signal emitted by the widget to the function that 
handles the input.  When the user clicks with the left mouse button, the tool creates
a point and passes it to the widget. The widget then creates a signal that gets passed
to the connected slot \ccc{My_Window::get_new_object(CGAL::Object)}.

{\bf af: Who tells the views that they should redraw now??} 

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/IO/Qt_Widget.h>

#include <qapplication.h>

typedef CGAL::Cartesian<double>		    Rep;
typedef CGAL::Point_2<Rep>		    Point;
typedef CGAL::Delaunay_triangulation_2<Rep> Delaunay;

Delaunay dt;
class My_Window : public CGAL::Qt_widget {
public:
  My_Window(int x, int y){
    resize(x,y);
    attach(new Qt_widget_get_point());
    connect(this, SIGNAL(new_cgal_object(CGAL::Object)), 
            this, SLOT(get_new_object(CGAL::Object)));
  };
   
private slots:
  void get_new_object(CGAL::Object obj)
  {
    Point p;
    if (CGAL::assign(p, obj)) { 
      dt.insert(p);
    }
    // af: I guess here we need a redraw(), don't we?
  }
};

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    My_Window W(600,600);
    app.setMainWidget( &W );
    W.set_window(0, 600, 0, 600);
    W.show();
    return app.exec();
}
\end{ccExampleCode}




The \ccStyle{Qt_widget} forwards all event callbacks to the attached tool.


\subsection{How Tools Work}

The following is an example of a tool that creates \cgal\ points when the user 
clicks the left mouse button over the widget. 
 
\begin{ccExampleCode}
namespace CGAL {

template <class R>
class Qt_widget_get_point : public Qt_widget_tool
{
  //  Q_OBJECT
public:
  typedef typename R::Point_2	Point;
  typedef typename R::FT	FT;
  
  Qt_widget_get_point(const QCursor c=QCursor(Qt::crossCursor)) :
    cursor(c) {};
  
private:
  void mousePressEvent(QMouseEvent *e)
  {
    if(e->button() == CGAL_QT_WIDGET_GET_POINT_BUTTON)
    {
      FT
        x=static_cast<FT>(widget->x_real(e->x())),
        y=static_cast<FT>(widget->y_real(e->y()));
      widget->new_object(make_object(Point(x, y)));
    }
  };
  void attaching()
  {
    oldcursor = widget->cursor();
    widget->setCursor(cursor);
  };
  
  // This function will be called immediately before detaching
  // the tool. The tool is responsible for cleaing up.
  void detaching()
  {
    widget->setCursor(oldcursor);
  };

  QCursor cursor;
};

} // namespace CGAL
\end{ccExampleCode}

The \ccc{Qt_widget} forwards mouse and keyboard events to the attached tool.
In the above example only the \ccc{mousePressEvent} member function is overloaded.

Tools that create new \cgal\ objects, must call the member 
function \ccStyle{Qt_widget::new_object(CGAL::Object)}. The \ccStyle{Qt_widget} 
then emits the signal \ccStyle{new_cgal_object(CGAL::Object)}. This signal can be 
catched by any other object with the following connect statement:

\begin{ccExampleCode}
connect(Qt_Widget,SIGNAL(new_cgal_object(CGAL::Object)),
        anyOtherObject,SLOT(anyOtherFunction(CGAL::Object)));
\end{ccExampleCode}

In the example we connect it to \ccc{MyWindow::get_new_object(CGAL::Object)}.

\section{Standard Toolbar}
\label{Qt_widget_standard_toolbar}

The standard toolbar includes the basic tools used for zooming and translating.
It's very easy to use, we provide further down a typical model of how to use 
the standard toolbar in your application:

\begin{ccExampleCode}
#include<CGAL/IO/Qt_Widget_standard_toolbar.h>

class MyWindow : public QMainWindow
{
  Q_OBJECT
public:
  MyWindow(int w, int h): win(this) {
    setCentralWidget(&win);
    resize(w, h);
    
    //the standard toolbar
    stoolbar = new CGAL::Standard_toolbar (&win, this);
    this->addToolBar(stoolbar->toolbar(), Top, FALSE);
   ....
  }
  ....
private:
  CGAL::Qt_widget	  win;
  CGAL::Standard_toolbar  *stoolbar;
  ....
};

int
main(int argc, char **argv)
{
  QApplication app( argc, argv );
    app.setStyle( new QPlatinumStyle );
    QPalette p( QColor( 250, 215, 100 ) );
    app.setPalette( p, TRUE );
  MyWindow win(800,800); // physical window size
  app.setMainWidget(&win);
  win.setMouseTracking(TRUE);
  win.show();
  // because Qt send resizeEvent only on show.
  win.set_window(-1, 1, -1, 1);
  return app.exec();
}
\end{ccExampleCode}



% +-----------------------------------------------------+
% EOF







