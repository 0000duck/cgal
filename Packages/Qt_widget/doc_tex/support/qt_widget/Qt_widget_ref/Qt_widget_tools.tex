% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 03.01.2001	Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+
% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget_tool}

\ccInclude{CGAL/IO/Qt_widget_tool.h}
\ccGlue

\ccDefinition
A tool for Qt\_widget is a class that receives events from Qt\_widget and can 
provide some functionalities like input objects for Qt\_widget and modify 
already created objects.

\ccCreation
\ccCreationVariable{tool}
\ccSetTwoColumns{Qt_widget_tool}{}

\ccConstructor{Qt_widget_tool();}{The default constructor.}
\ccOperations
\ccSetThreeColumns{const_iterator}{container.begin() const;}{}

\ccMethod{bool is_attached() const;}{Return true if this tool is currently 
attached to the Qt\_widget.}
\ccMethod{virtual void mousePressEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void mouseReleaseEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void wheelEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void mouseDoubleClickEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void mouseMoveEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void keyPressEvent(QKeyEvent *);}{}
\ccGlue
\ccMethod{virtual void keyReleaseEvent(QKeyEvent *);}{}
\ccGlue
\ccMethod{virtual void enterEvent(QEvent *);}{}
\ccGlue
\ccMethod{virtual void leaveEvent(QEvent *);}{This virtual functions should be
overloaded in the child tool classes and declared as private members. This 
functions are called by the Qt\_widget every time a event is received by the 
widget.}
\ccHeading{protected}
\ccMethod{virtual void attaching();}{}
\ccGlue
\ccMethod{virtual void detaching();}{You have to overload this functions to
provide your tool with initialization and destruction code.}
\ccHeading{signals}
\ccMethod{void redraw();}{Emited when a tool needs that Qt\_widget refresh the
screen. For example after a tool modified an object, the screen should reflect
the change.}
\ccHeading{public slots}
\ccMethod{virtual void widget_repainted();}{Called every time by Qt\_widget
when the widget have been repainted.}
\end{ccRefClass}
\ccExample
An example of a tool that is working as a magnifying glass.
\begin{ccExampleCode}
#ifndef CGAL_QT_WINDOW_ZOOM_H
#define CGAL_QT_WINDOW_ZOOM_H

#include <CGAL/IO/Qt_Widget.h>
#include <CGAL/IO/Qt_Widget_tool.h>
#include <qcolor.h>

namespace CGAL {

class Qt_widget_zoom : public Qt_widget_tool
{
  //  Q_OBJECT
private:
	int									    x2, y2;
	bool circle_already_drawn;
	bool old_mouse_tracking;

public:
  Qt_widget_zoom() : circle_already_drawn(false) {};

  void draw_circle(int x,int y)
  {
    const int
    d=100, // diameter
    r=50;  // radius (should be d/2 :-)

    RasterOp oldRasterOp = widget->rasterOp();	//save the initial raster mode
    widget->setRasterOp(XorROP);
    QColor oldColor=widget->color(); // save the initial color
    widget->setColor(Qt::green);
    widget->painter().drawEllipse(x-r, y-r, d, d);
    widget->setColor(oldColor);
    widget->setRasterOp(oldRasterOp);
    widget->do_paint();
  };

  void leaveEvent(QEvent*)
  {
    if(circle_already_drawn)
      draw_circle(x2,y2);
    circle_already_drawn=false;
  };

  void widget_repainted(){
    circle_already_drawn=false;
  };

  void mousePressEvent(QMouseEvent *e)
  {
    const double ratios=2.0;
    double
      x=widget->x_real(e->x()),
      y=widget->y_real(e->y());
		
    if(e->button() == Qt::LeftButton)
      widget->zoom_in(ratios, x, y);
    if(e->button() == Qt::RightButton)
      widget->zoom_out(ratios, x, y);
		
    widget->redraw();
    emit(redraw()); 
  };

  void mouseMoveEvent(QMouseEvent *e)
  {
    int
      x = e->x(),
      y = e->y();

    widget->lock();
    draw_circle(x,y); // draw the new circle
    if(circle_already_drawn) // erase the old one if needed
        draw_circle(x2,y2);
    widget->unlock();
		
    //save the last coordinates to redraw the screen
    x2 = x;
    y2 = y;
    circle_already_drawn=true;
  };

  void attaching()
  {
    old_mouse_tracking=widget->hasMouseTracking();
    widget->setMouseTracking(TRUE);
    oldcursor = widget->cursor();
    widget->setCursor(crossCursor);
    circle_already_drawn=false;
  };

  void detaching()
  {
    if(circle_already_drawn)
      draw_circle(x2,y2); // erase the circle if needed
    widget->setCursor(oldcursor);
    widget->setMouseTracking(old_mouse_tracking);
  };
};//end class 

} // namespace CGAL

#endif // CGAL_QT_WINDOW_ZOOM_H
\end{ccExampleCode}
% +-----------------------------------------------------+
% EOF








