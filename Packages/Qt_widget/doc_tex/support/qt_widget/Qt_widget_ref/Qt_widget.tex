% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 13.12.2001	Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget}

\ccDefinition

An object of type Qt\_widget is a two-dimensional window for graphical IO. It 
is a class that is designed to help \cgal\ users easily visualize \cgal\ 
objects and for advanced users to interact with them. This widget is designed 
only for 2D \cgal\ objects.


\ccInclude{CGAL/Qt_widget.h}
\ccGlue

\ccCreation
\ccCreationVariable{win}
\ccSetTwoColumns{Qt_widget}{}

\ccConstructor{Qt\_widget(QWidget *parent = 0, const char *name = 0);}{}

\ccOperations
\ccSetThreeColumns{const_iterator}{container.begin() const;}{}

%scales
%\ccHeading{Scales}
\ccMethod{void set_window(double x_min, double x_max, double y_min, double 
y_max);}{Map the widget coordinates to the interval defined by the rectangle 
with given coordinates. This method should be called before \ccc{show()} from 
\ccStyle{QWidget}.}
\ccMethod{void set_x_scale(double xscale);}{Set the current X scale.}
\ccMethod{void set_y_scale(double yscale);}{Set the current Y scale.}
\ccMethod{void zoom_in(double ratio);}{Multiply X and Y scales by \ccc{ratio}.}
\ccMethod{void zoom_out(double ratio);}{Multiply X and Y scales by \ccc{ratio}.}
\ccMethod{void move_center(double distx, double disty);}{Move the center of the
 widget with \ccc{distx} on the X axe and with \ccc{disty} on Y axe.}
\ccMethod{void set_center(double x, double y);}{Set the center of the widget to
 O(x, y)}

%\ccHeading{Painter}
%painter
\ccMethod{void clear();}{Clear the screen. The properties remain the same 
after calling this member function.}
\ccMethod{void lock();}{Locks the widget, keeping the widget away from being 
refreshed. If you lock the widget you should verify that you unlock it 
somewhere else. The number of \ccc{lock()} calls should be the same with the 
number of \ccc{unlock()} calls.}
%\ccMethod(void unlock();){Unlocks the widget, and call do\_paint().}
\ccMethod{void do_paint();}{Refresh the widget calling 
\ccc{paintEvent(QPaintEvent *e)} for the Qt\_widget.}

%properties
%\ccHeading{Properties}
\ccMethod{void setColor(Qcolor c);}{Set the current pen color of the widget to 
be c.}
\ccMethod{void setBackgroundColor(QColor c);}{Set the current background color 
to be c.}
\ccMethod{void setFillColor(QColor c);}{Set the current fill color of the 
widget to be c.}
\ccMethod{void setFilled(bool f);}{Set the status of the widget to true or false
 concerning filling the objects: polygons, circles, rectangles \ldots}
\ccMethod{void setLineWidth(unsigned int i);}{Set the current line width of the widget.}
\ccMethod{void setPointSize(unsigned int i);}{Set the current point size of the widget.}
\ccMethod{void setPointStyle(PointStyle s);}{Set the current point style of the
 widget to s. PointStyle is a enumeration declared in Qt\_widget.}
\ccMethod{void setRasterOp(RasterOp r);}{Set the current raster operation.}

%tools
%\ccHeading{Tools}
\ccMethod{void attach(Qt_widget_tool& tool);}{Attach a tool to the widget. Only
one tool can be attached at a moment of time.}
\ccMethod{bool has_tool() const;}{Returns true if it is a tool attached.}
\ccMethod{void detach_current_tool();}{Detach the current tool from the widget.}

%scenes
%\ccHeading{Scenes}
\ccMethod{void add_scene(Qt_scene* s);}{Add the scene s in the list of scenes.
The last added will be on top of the screen.}
\ccMethod{void remove_scene(Qt_scene* s);}{Remove the scene s from the list.}
\ccMethod{void redraw();}{Redraw the scenes situated in the list. Before 
redraw the scenes clears the screen. Also calls \ccc{widget\_repainted()} for 
current tool.}

%Cgal
\ccMethod{void new_object(CGAL::Object obj);}{This function should be called 
by the tools that create \cgal\ objects. This function emit the signal 
new\_cgal\_object(CGAL::Object). The user should catch this signal through a 
connect, like described further down.}

\ccAccessFunctions
%Properties
%\ccHeading{Properties}
\ccMethod{QColor color() const;}{Returns the current pen color. The color 
returned is a Qt class.}
\ccMethod{QColor backgroundColor() const;}{Returns the current widget background
color. The color returned is a Qt class.}
\ccMethod{QColor fillColor() const;}{Returns the current color used for filling 
the objects. The color returned is a Qt class.}
\ccMethod{PointStyle pointStyle();}{Returns the current point style. PointStyle
 is a enumeration declared in Qt\_widget.}
\ccMethod{uint pointSize();}{Returns the current point size.}
\ccMethod{uint lineWidth();}{Returns the current line width.}
\ccMethod{RasterOp rasterOp();}{Return the current raster operation.}

%Painter
%\ccHeading{Painter}
\ccMethod{QPixmap& get_pixmap();}{Returns the current pixmap.}
\ccMethod{QPainter& painter();}{Returns the current painter.}

%Coordinates
%\ccHeading{Coordinates}
\ccMethod{double x_min() const;}{Returns the left X coordinate  of the widget.}
\ccMethod{double y_min() const;}{Returns the lower Y coordinate  of the widget.}
\ccMethod{double x_max() const;}{Returns the right X coordinate of the widget.}
\ccMethod{double y_max() const;}{Returns the upper Y coordinate of the widget.}

%Signals
\ccHeading{Signals}
\ccMethod{void mousePressed(QMouseEvent *e);}{}
\ccMethod{void mouseReleased(QMouseEvent *e);}{}
\ccMethod{void mouseMoved(QMouseEvent *e);}{}
\ccMethod{void resized();}{}
\ccMethod{void new_cgal_object(CGAL::Object);}{Triggered when a new object 
from a tool is received. The user should catch this signal if it's working with
tools that provide \cgal\ objects as input.}

\input{Qt_widget_ref/Operators_for_output.tex}
\input{Qt_widget_ref/Manipulators.tex}

\end{ccRefClass}

\ccExample
We could imagine a typical scenario to use Qt\_widget, like the example shown 
bellow:
\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Bbox_2.h>
#include <CGAL/Polygon_2.h>

#include <qapplication.h>
#include <CGAL/IO/Qt_Widget.h>

typedef CGAL::Cartesian<int> Rep;
typedef CGAL::Point_2<Rep> Point;
typedef CGAL::Circle_2<Rep> Circle;
typedef CGAL::Segment_2<Rep> Segment;
typedef CGAL::Line_2<Rep> Line;
typedef CGAL::Ray_2<Rep> Ray;
typedef CGAL::Triangle_2<Rep> Triangle;
typedef CGAL::Iso_rectangle_2<Rep> Rectangle;
typedef CGAL::Bbox_2 BBox;
typedef std::list<Point> Container;
typedef CGAL::Polygon_2<Rep,Container> Polygon;

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    using namespace CGAL;
    CGAL::Qt_widget W;
    app.setMainWidget( &W );
    W.resize(600, 600);
    W.set_window(0, 600, 0, 600);
    W.show();
    //painting something on the screen
    W.lock();
    W << BackgroundColor(ORANGE) << RED <<
	  LineWidth(3) << PointSize(3) << PointStyle(DISC);
    W << Segment(Point(10,20),Point(300,400));
    W << LineWidth(5) << GREEN << FillColor(BLACK) <<
      Circle(Point(400,400),50*50);
    W << LineWidth(1) << noFill << Circle(Point(300,300),300*300);
    W << BLUE << LineWidth(2);
    W << Segment(Point(200,200),Point(400,400));
    W << Segment(Point(200,400),Point(400,200));
    W.setFilled(TRUE);
    W << RED << Triangle(Point(150,300),
				   Point(150,350),
				   Point(100,325));
    W << FillColor(RED) << Rectangle(Point(320,220),
					       Point(350,240));
    W << DEEPBLUE << BBox(100,80,260,140);
    Polygon p;
    p.push_back(Point(300,30));
    p.push_back(Point(400,30));
    p.push_back(Point(500,130));
    p.push_back(Point(400,180));
    p.push_back(Point(300,130));
    W << p;
    W << Ray(Point(200,400), Point(180,430))
      << Ray(Point(200,400), Point(180,370));
    
    W.unlock();

    return app.exec();
}
\end{ccExampleCode}

In the given example, that is found in demo/basic/first.C, it is created an 
object of type Qt\_widget and then it's used the operators for output and the
manipulators to show some of the widget's functionality.

% +-----------------------------------------------------+
% EOF







