% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 13.12.2001	Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget}

\ccDefinition

An object of type \ccc{Qt_widget} is a two-dimensional window for graphical IO. It 
is a class that is designed to help \cgal\ users easily visualize \cgal\ 
objects and for advanced users to interact with them. This widget is designed 
only for 2D \cgal\ objects.




\ccInclude{CGAL/Qt_widget.h}
\ccGlue

\ccTypes

The widget class also defines the following enum type to specify
which case occurs when locating a point in the triangulation. 

\ccEnum{enum PointStyle { PIXEL, CROSS, PLUS, CIRCLE, DISC, RECT, BOX };}{}

\ccCreation
\ccCreationVariable{win}
\ccSetTwoColumns{Qt_widget}{}

\ccConstructor{Qt_widget(QWidget *parent = 0, const char *name = 0);}{}

\ccOperations
\ccSetThreeColumns{const_iterator}{container.begin() const;}{}

%scales
\ccHeading{Scaling}

\ccStyle{Qt_widget} provides a scale system. You can use scales for your objects as 
well as you can draw the objects with one scale and look at the objects with 
different scales. Also there is a possibility to tell the widget that you
want that the visible area should be mapped to a certain interval, and the 
widget adjust the scales according to that.

\ccMethod{void set_window(double x_min, double x_max, double y_min, double 
y_max);}{Map the widget coordinates to the interval defined by the rectangle 
with given coordinates. This method should be called before \ccc{show()} from 
\ccStyle{QWidget}.}
\ccMethod{void set_x_scale(double xscale);}{Set the current X scale.}
\ccMethod{void set_y_scale(double yscale);}{Set the current Y scale.}
\ccMethod{void zoom_in(double ratio);}{Multiply X and Y scales by \ccc{ratio}.}
\ccMethod{void zoom_out(double ratio);}{Multiply X and Y scales by \ccc{ratio}.}
\ccMethod{void move_center(double distx, double disty);}{Move the center of the
 widget with \ccc{distx} on the X axis and with \ccc{disty} on the Y axis.}
\ccMethod{void set_center(double x, double y);}{Set the center of the widget to
 \ccStyle{(x, y)}.}

%\ccHeading{Painter}
%painter
\ccMethod{void clear();}{Clear the screen. The properties remain the same 
after calling this member function.}
\ccMethod{void lock();}{Locks the widget, keeping the widget away from being 
refreshed. If you lock the widget you should verify that you unlock it 
somewhere else. The number of \ccc{lock()} calls should be the same with the 
number of \ccc{unlock()} calls.}
\ccMethod{void unlock();}{Unlocks the widget, and call \ccc{do_paint()}}

\ccMethod{void do_paint();}{Refresh the widget calling 
\ccc{paintEvent(QPaintEvent *e)} for the \ccc{Qt_widget} only if the widget is 
unlocked. This mean that redraw() is called if and only if the widget is 
unlocked.}

%properties
%\ccHeading{Properties}
\ccMethod{void setColor(Qcolor c);}{Set the current pen color of the widget to 
be c.}
\ccMethod{void setBackgroundColor(QColor c);}{Set the current background color 
to be c.}
\ccMethod{void setFillColor(QColor c);}{Set the current fill color of the 
widget to be c.}
\ccMethod{void setFilled(bool f);}{Set the status of the widget to true or false
 concerning filling the objects: polygons, circles, rectangles \ldots}
\ccMethod{void setLineWidth(unsigned int i);}{Set the current line width of the widget.}
\ccMethod{void setPointSize(unsigned int i);}{Set the current point size of the widget.}
\ccMethod{void setPointStyle(PointStyle s);}{Set the current point style of the
 widget to s. PointStyle is a enumeration declared in \ccc{Qt_widget}.}
\ccMethod{void setRasterOp(RasterOp r);}{Set the current raster operation.}

%tools
\ccHeading{Tools}
\ccMethod{void attach(Qt_widget_tool& tool);}{Attaches a tool to the widget. If another
tool is already attached this ges detached first.}

\ccMethod{bool has_tool() const;}{Returns true if a tool is attached.}

\ccMethod{void detach_current_tool();}{Detaches the current tool from the widget.}

%VIEWS
\ccHeading{Views}
\ccMethod{void attach(Qt_widget_view* s);}{Add the view s in the list of 
views.The last added will be on top of the screen.}
\ccMethod{void detach(Qt_widget_view* s);}{Remove the view s from the list.}
\ccMethod{void redraw();}{If you derive from \ccc{Qt_widget} you have to 
overload this function and put your code for drawing here if you don't use 
\ccc{views}. Redraw the views situated in the list. Before 
redraw the views, clears the screen. Also calls \ccc{widget\_repainted()} for 
current tool.}

%Cgal
\ccMethod{void new_object(CGAL::Object obj);}{This function should be called 
by the tools that create \cgal\ objects. It then emits the signal 
\ccc{new_cgal_object(CGAL::Object)}. Other components may catch this signal through a 
\ccc{connect}.}

\ccAccessFunctions
%Properties
%\ccHeading{Properties}
\ccMethod{QColor color() const;}{Returns the current pen color. The color 
returned is a Qt class.}

\ccMethod{QColor backgroundColor() const;}{Returns the current widget background
color. The color returned is a Qt class.}

\ccMethod{QColor fillColor() const;}{Returns the current color used for filling 
the objects. The color returned is a Qt class.}

\ccMethod{PointStyle pointStyle();}{Returns the current point style. PointStyle
 is a enumeration declared in \ccc{Qt_widget}.}

\ccMethod{uint pointSize();}{Returns the current point size.}

\ccMethod{uint lineWidth();}{Returns the current line width.}

\ccMethod{RasterOp rasterOp();}{Return the current raster operation.}


%Coordinates
%\ccHeading{Coordinates}
\ccMethod{double x_min() const;}{Returns the left \ccc{x} coordinate  of the widget.}
\ccMethod{double y_min() const;}{Returns the lower\ccc{y} coordinate  of the widget.}
\ccMethod{double x_max() const;}{Returns the right\ccc{x} coordinate of the widget.}
\ccMethod{double y_max() const;}{Returns the upper\ccc{y} coordinate of the widget.}

\begin{ccAdvanced}
%Painter
\ccHeading{Painter and Pixmap}

In order that views can draw on the drawing area of a widget, they have to access
the underlying pixmap and painter.
 
\ccStyle{Qt_widget} use as a backbuffer for drawing a pixmap
defined inside the class, that is an object of type \ccc{QPixmap}. The \ccc{QPixmap} class
is an off-screen pixel-based paint device. One common use of the \ccc{QPixmap} class
is to enable smooth updating of widgets.
The QPainter class paints on paint devices. There is an object of type 
QPainter defined in \ccStyle{Qt_widget} that uses as a paint device the \ccc{QPixmap} object.

\ccMethod{QPixmap& get_pixmap();}{Returns the current pixmap.}

\ccMethod{QPainter& painter();}{Returns the current painter.}
\end{ccAdvanced}

%Signals
\ccHeading{Signals}
\ccMethod{void mousePressed(QMouseEvent *e);}{}
\ccMethod{void mouseReleased(QMouseEvent *e);}{}
\ccMethod{void mouseMoved(QMouseEvent *e);}{}
\ccMethod{void resized();}{}
\ccMethod{void new_cgal_object(CGAL::Object);}{Triggered when a new object 
from a tool is received. The user should catch this signal if it's working with
tools that provide \cgal\ objects as input.}

\input{Qt_widget_ref/Operators_for_output.tex}
\input{Qt_widget_ref/Manipulators.tex}



\ccExample

In the given example, that is found in demo/basic/first.C, it is created an 
object of type \ccc{Qt_widget} and then it's used the operators for output and the
manipulators to show some of the widget's functionality.

\begin{ccExampleCode}
#include <CGAL/Cartesian.h>
#include <CGAL/Bbox_2.h>
#include <CGAL/Polygon_2.h>

#include <qapplication.h>
#include <CGAL/IO/Qt_Widget.h>

typedef CGAL::Cartesian<int> Rep;
typedef CGAL::Point_2<Rep> Point;
typedef CGAL::Circle_2<Rep> Circle;
typedef CGAL::Segment_2<Rep> Segment;
typedef CGAL::Line_2<Rep> Line;
typedef CGAL::Ray_2<Rep> Ray;
typedef CGAL::Triangle_2<Rep> Triangle;
typedef CGAL::Iso_rectangle_2<Rep> Rectangle;
typedef CGAL::Bbox_2 BBox;
typedef std::list<Point> Container;
typedef CGAL::Polygon_2<Rep,Container> Polygon;

int main( int argc, char **argv )
{
    QApplication app( argc, argv );
    using namespace CGAL;
    CGAL::Qt_widget W;
    app.setMainWidget( &W );
    W.resize(600, 600);
    W.set_window(0, 600, 0, 600);
    W.show();
    //painting something on the screen
    W.lock();
    W << BackgroundColor(ORANGE) << RED <<
	  LineWidth(3) << PointSize(3) << PointStyle(DISC);
    W << Segment(Point(10,20),Point(300,400));
    W << LineWidth(5) << GREEN << FillColor(BLACK) <<
      Circle(Point(400,400),50*50);
    W << LineWidth(1) << noFill << Circle(Point(300,300),300*300);
    W << BLUE << LineWidth(2);
    W << Segment(Point(200,200),Point(400,400));
    W << Segment(Point(200,400),Point(400,200));
    W.setFilled(TRUE);
    W << RED << Triangle(Point(150,300),
				   Point(150,350),
				   Point(100,325));
    W << FillColor(RED) << Rectangle(Point(320,220),
					       Point(350,240));
    W << DEEPBLUE << BBox(100,80,260,140);
    Polygon p;
    p.push_back(Point(300,30));
    p.push_back(Point(400,30));
    p.push_back(Point(500,130));
    p.push_back(Point(400,180));
    p.push_back(Point(300,130));
    W << p;
    W << Ray(Point(200,400), Point(180,430))
      << Ray(Point(200,400), Point(180,370));
    
    W.unlock();

    return app.exec();
}
\end{ccExampleCode}


\end{ccRefClass}
% +-----------------------------------------------------+
% EOF







