% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 03.01.2001  Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+
% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget_tool}

\ccInclude{CGAL/IO/Qt_widget_tool.h}
\ccGlue

\ccDefinition
The class \ccRefName\ serves as base class for tools.

\ccCreation
\ccCreationVariable{tool}
\ccSetTwoColumns{Qt_widget_tool}{}

\ccConstructor{Qt_widget_tool();}{The default constructor.}
\ccOperations
\ccSetThreeColumns{const_iterator}{container.begin() const;}{}

\ccMethod{bool is_attached() const;}{Return true if this tool is currently 
attached to the Qt\_widget.}

\ccMethod{virtual void mousePressEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void mouseReleaseEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void wheelEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void mouseDoubleClickEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void mouseMoveEvent(QMouseEvent *);}{}
\ccGlue
\ccMethod{virtual void keyPressEvent(QKeyEvent *);}{}
\ccGlue
\ccMethod{virtual void keyReleaseEvent(QKeyEvent *);}{}
\ccGlue
\ccMethod{virtual void enterEvent(QEvent *);}{}
\ccGlue
\ccMethod{virtual void leaveEvent(QEvent *);}{These virtual functions should be
overloaded in the child tool classes and declared as private members. The 
functions are called by the \ccc{Qt_widget} every time it receives an event.}

\ccHeading{protected}
\ccMethod{virtual void attaching();}{}
\ccGlue
\ccMethod{virtual void detaching();}{You have to overload this functions to
provide your tool with initialization and destruction code.}

\ccHeading{Signals}
\ccMethod{void redraw();}{Emitted when a tool needs that \ccc{Qt_widget} refreshes the
screen. For example after a tool modified an object, the screen should reflect
the change.}

\ccHeading{Public Slots}

\ccMethod{virtual void widget_repainted();}{Called every time by \ccc{Qt_widget}
when the widget has been repainted.}


\ccExample

An example of a tool that is working as a magnifying glass.

\begin{ccExampleCode}
#include <CGAL/IO/Qt_Widget.h>
#include <CGAL/IO/Qt_Widget_tool.h>
#include <qcolor.h>

namespace CGAL {

class Qt_widget_zoom : public Qt_widget_tool
{
private:
        int  x2, y2;
        bool circle_already_drawn;
        bool old_mouse_tracking;

public:
  Qt_widget_zoom() : circle_already_drawn(false) {};

  void draw_circle(int x,int y)
  {
    const int
    d=100, // diameter
    r=50;  // radius (should be d/2 :-)

    RasterOp oldRasterOp = widget->rasterOp();  //save the initial raster mode
    widget->setRasterOp(XorROP);
    QColor oldColor=widget->color(); // save the initial color
    widget->setColor(Qt::green);
    widget->painter().drawEllipse(x-r, y-r, d, d);
    widget->setColor(oldColor);
    widget->setRasterOp(oldRasterOp);
    widget->do_paint();
  };

  void leaveEvent(QEvent*)
  {
    if(circle_already_drawn)
      draw_circle(x2,y2);
    circle_already_drawn=false;
  };

  void widget_repainted(){
    circle_already_drawn=false;
  };

  void mousePressEvent(QMouseEvent *e)
  {
    const double ratios=2.0;
    double
      x=widget->x_real(e->x()),
      y=widget->y_real(e->y());
                
    if(e->button() == Qt::LeftButton)
      widget->zoom_in(ratios, x, y);
    if(e->button() == Qt::RightButton)
      widget->zoom_out(ratios, x, y);
                
    widget->redraw();
    emit(redraw()); 
  };

  void mouseMoveEvent(QMouseEvent *e)
  {
    int
      x = e->x(),
      y = e->y();

    widget->lock();
    draw_circle(x,y); // draw the new circle
    if(circle_already_drawn) // erase the old one if needed
        draw_circle(x2,y2);
    widget->unlock();
                
    //save the last coordinates to redraw the screen
    x2 = x;
    y2 = y;
    circle_already_drawn=true;
  };

  void attaching()
  {
    old_mouse_tracking=widget->hasMouseTracking();
    widget->setMouseTracking(TRUE);
    oldcursor = widget->cursor();
    widget->setCursor(crossCursor);
    circle_already_drawn=false;
  };

  void detaching()
  {
    if(circle_already_drawn)
      draw_circle(x2,y2); // erase the circle if needed
    widget->setCursor(oldcursor);
    widget->setMouseTracking(old_mouse_tracking);
  };
};//end class 

} // namespace CGAL
\end{ccExampleCode}

\end{ccRefClass}
% +-----------------------------------------------------+
% EOF








