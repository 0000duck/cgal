% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 13.12.2001  Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget}

\ccDefinition

An object of type \ccc{Qt_widget} is a two-dimensional window for
graphical IO. It is a class that is designed to help \cgal\ users
to visualize easily \cgal\ objects and for advanced users to interact
with them. This widget is designed for 2D \cgal\ objects only.

\ccInclude{CGAL/Qt_widget.h}

\ccInheritsFrom
\ccc{QWidget}

\ccTypes

The widget class also defines the following enum type to specify
which kind of point representation do you want to use:

\ccEnum{enum PointStyle { PIXEL, CROSS, PLUS, CIRCLE, DISC, RECT, BOX };}{}

\ccCreation
\ccCreationVariable{win}
\ccSetTwoColumns{Qt_widget}{}

\ccConstructor{Qt_widget(QWidget *parent = 0, const char *name =
0);}{Constructs a widget which is a child of \ccc{parent}, with the name
\ccc{name}. The default geometry is xmin = -1, xmax = 1, ymin = -1,
ymax = 1. By default the X and Y scale factors are equal.}

%\ccOperations
\ccSetThreeColumns{const_iterator}{container.begin() const;}{}

%SCALES
%\ccHeading{Scaling}

\ccStyle{Qt_widget} provides scaling support. You can use a scaling factor for
your objects as well as you can draw the objects with one scale and
look at the objects with different scales. Also there is a possibility
to tell the widget that you want that the visible area should be
mapped to a certain interval, and the widget adjust the scaling factor 
according to that.

\ccMethod{void set_window(double x_min, double x_max, double y_min, double 
y_max, bool u = false);}{Map the widget coordinates to the interval
defined by the rectangle with given coordinates. This method should be
called after \ccc{resize()} from \ccStyle{QWidget}. If \ccc{u} is
\ccc{true} the X and Y scale factors will not be equal and the widget
will not keep the aspect ratio.}

\ccMethod{void set_x_scale(double xscale);}{Set the current X scaling factor.}

\ccMethod{void set_y_scale(double yscale);}{Set the current Y scaling factor.}

\ccMethod{void zoom(double ratio);}{Multiply X and Y scaling factor by \ccc{ratio}.}

\ccMethod{void add_to_history();}{This function adds the current
viewport and transformations to history. You can use the public slots
\ccc{back()} and \ccc{forth()} to walk into history.}

\ccMethod{void clear_history();}{Clears the history. This means that 
there are no elements in the history list. Call this method when you
want to reinitialize the history list.}

\ccHeading{public slots:}
\ccGlue
\ccMethod{bool back();}{}
\ccGlue
\ccMethod{bool forth();}{This slots permits to walk into history. Return \ccc{true} if succeded.}

\begin{ccAdvanced}
You should have the same scaling factor for X and Y if you want to
keep the aspect ratio of your objects.
\end{ccAdvanced}

\ccMethod{void move_center(double distx, double disty);}{Move the center of the
 widget with \ccc{distx} on the X axis and with \ccc{disty} on the Y axis.}

\ccMethod{void set_center(double x, double y);}{Set the center of the widget to
 \ccStyle{(x, y)}.}

%PAINTER
%\ccHeading{Painter}
\ccMethod{void clear();}{Clear the screen. The properties of the
widget remain the same after calling this member function. You can see 
a list of the properties that you can set at the properties
description.}

\ccMethod{void lock();}{Locks the widget, keeping the widget from being 
refreshed. If you lock the widget you should verify that you unlock it 
somewhere. The number of \ccc{lock()} calls should be the same with the 
number of \ccc{unlock()} calls. Lock and unlock calls can be nested.}

\ccMethod{void unlock();}{Unlocks the widget, and calls
\ccc{do_paint()}. The widget is only unlocked if the number of unlock
calls is equal to the number of lock calls.}

\ccMethod{void do_paint();}{Refresh the widget calling 
\ccc{paintEvent(QPaintEvent *e)} for the \ccc{Qt_widget} only if the widget is 
unlocked. This mean that redraw() is called if and only if the widget is 
unlocked.}

%PROPERTIES
\ccHeading{Properties}

You can set the properties of the functions through this functions as
well as with the help of manipulators described later. The function
naming convention has changed for this member functions, to \qt\ convention.

\ccMethod{void setColor(Qcolor c);}{Set the current pen color of the widget to 
be c.}

\ccMethod{void setBackgroundColor(QColor c);}{Set the current background color 
to be \ccc{c}.}

\ccMethod{void setFillColor(QColor c);}{Set the current fill color of the 
widget to be \ccc{c}.}

\ccMethod{void setFilled(bool f);}{Set the status of the widget to
true or false concerning filling the objects: polygons, circles,
rectangles \ldots}

\ccMethod{void setLineWidth(unsigned int i);}{Set the current line width of the widget.}

\ccMethod{void setPointSize(unsigned int i);}{Set the current point size of the widget.}

\ccMethod{void setPointStyle(PointStyle s);}{Set the current point style of the
 widget to s. PointStyle is a enumeration declared in \ccc{Qt_widget}.}

\ccMethod{void setRasterOp(RasterOp r);}{Set the current raster operation.}

%LAYERS
\ccHeading{Layers}

\ccMethod{void attach(Qt_widget_layer* s);}{Add the layer s in the list of 
layers.The last added will be on top of the screen. Also the events
are forwarded to layers in the order they have been attached.}

\ccMethod{void detach(Qt_widget_layer* s);}{Remove the layer s from the list. 
s it's a pointer to an existing layer.}

\ccHeading{public slots:}
\ccMethod{void redraw();}{If you derive from \ccc{Qt_widget} you have to 
overload this function and put your code for drawing here if you don't use 
\ccc{layers}. Redraw the layers situated in the list. Before 
redraw the layers, clears the screen. At the end is emitted the signal 
\ccc{custom_redraw()}.}

\ccMethod{void print_to_ps();}{Redraws all the attached and active
layers into a Postscript device. It could be a file or a printer. If
you use the signal \ccc{custom_redraw()}, the painting that you do
using this signal will be drawn on top.}

%Cgal
\ccHeading{New CGAL Objects}
\ccMethod{void new_object(CGAL::Object obj);}{This function should be called 
by the tools that create \cgal\ objects. It then emits the signal 
\ccc{new_cgal_object(CGAL::Object)}. Slots of other components can be
connected to this signal.}

\ccAccessFunctions
%PROPERTIES
%\ccHeading{Properties}

Note that we use also types from \qt\ here.

\ccMethod{QColor color() const;}{Returns the current pen color. The color 
returned is a Qt class.}

\ccMethod{QColor backgroundColor() const;}{Returns the current widget
background color. The color returned is a Qt class.}

\ccMethod{QColor fillColor() const;}{Returns the current color used
for filling the objects. The color returned is a Qt class.}

\ccMethod{PointStyle pointStyle();}{Returns the current point style. PointStyle
 is a enumeration declared in \ccc{Qt_widget}.}

\ccMethod{uint pointSize();}{Returns the current point size.}

\ccMethod{uint lineWidth();}{Returns the current line width.}

\ccMethod{RasterOp rasterOp();}{Return the current raster operation.}


%COORDINATES
%\ccHeading{Coordinates}
\ccMethod{double x_min() const;}{Returns the left \ccc{x} coordinate
of the widget.}
\ccMethod{double y_min() const;}{Returns the lower \ccc{y} coordinate
of the widget.}
\ccMethod{double x_max() const;}{Returns the right \ccc{x} coordinate
of the widget.}
\ccMethod{double y_max() const;}{Returns the upper \ccc{y} coordinate
of the widget.}
\begin{ccAdvanced}
The coordinates of the screen are maped to a certain interval that you 
can choose  with \ccc{set_window} member function. The scale of the
objects you can visualize is computed and maintained the same for both 
axes to keep the aspect ratio of the objects. You should use
\ccc{x_real} or \ccc{y_real} to get the real world coordinates,
represented as a double, for your screen coordinates. If you are using
\ccc{gmp} you can use this functions with \ccc{Gmpq} as second
parameter. You may need it when you work with rationals. The double
from the other function could be more complex and can make you loose
speed in computations. Computing with rational coordinates directly
could increase the speed, rather than computing with complex double
coordinates.

\ccFunction{template<class FT> void x_real(int x, FT&) const;}{Returns
the \ccc{x} real world coordinate of the \ccc{Qt_widget}.}
\ccFunction{template<class FT> void y_real(int y, FT& )
const;}{Returns the \ccc{y} real world coordinate of the \ccc{Qt_widget}.}
\end{ccAdvanced}

\begin{ccAdvanced}
%PAINTER
\ccHeading{Painter and Pixmap}

In order that layers can draw on the drawing area of a widget, they
have to access the underlying pixmap and painter.
 
\ccStyle{Qt_widget} use as a backbuffer for drawing a pixmap
defined inside the class, i.e. an object of type \ccc{QPixmap}. The
\ccc{QPixmap} class is an off-screen pixel-based paint device. One
common use of the \ccc{QPixmap} class is to enable smooth updating of widgets.
The QPainter class paints on paint devices. There is an object of type 
QPainter defined in \ccStyle{Qt_widget} that uses as a paint device
the \ccc{QPixmap} object.

\ccMethod{QPixmap& get_pixmap();}{Returns the current pixmap.}

\ccMethod{QPainter& get_painter();}{Returns the current painter.}

%\ccMethod{QWMatrix& get_matrix();}{Returns the current world matrix
%for the current painter. You can modify the matrix using the pointer
%to the painter.}
\end{ccAdvanced}

%Signals
\ccHeading{Signals}

\ccMethod{void s_mousePressEvent(QMouseEvent *e);}{}
\ccGlue
\ccMethod{void s_mouseReleaseEvent(QMouseEvent *e);}{}
\ccGlue
\ccMethod{void s_mouseMoveEvent(QMouseEvent *e);}{}
\ccGlue
\ccMethod{void s_paintEvent(QPaintEvent *e);}{}
\ccGlue
\ccMethod{void s_resizeEvent(QResizeEvent *e);}{}
\ccGlue
\ccMethod{void s_wheelEvent(QMouseEvent *e);}{}
\ccGlue
\ccMethod{void s_mouseDoubleClickEvent(QMouseEvent *e);}{}
\ccGlue
\ccMethod{void s_keyPressEvent(QKeyEvent *e);}{}
\ccGlue
\ccMethod{void s_keyReleaseEvent(QKeyEvent *e);}{}
\ccGlue
\ccMethod{void s_enterEvent(QEvent *e);}{}
\ccGlue
\ccMethod{void s_leaveEvent(QEvent *e);}{}
\ccGlue
\ccMethod{void s_event(QEvent *e);}{The \ccc{Qt\_widget} receives the
events through virtual functions. This is the mechanism that \qt\
offers for dispaching events. This signals are called every time an
event is dispatched to a virtual function. For example if
\ccc{Qt\_widget} receives \ccc{mousePressEvent(QMouseEvent *e)} emits
\ccc{s_mousePressEvent(e)}. This is very useful when you have only a
pointer to \ccc{Qt_widget}. It is enough to connect this slot to your
function to receive the event.}

\ccMethod{void new_cgal_object(CGAL::Object);}{Triggered when a new object 
from a tool is received. The user should catch this signal if it's working with
tools that provide \cgal\ objects as input.}
\ccMethod{void custom_redraw();}{Emitted in the redraw() function after 
the layers are drawn.}

\input{Qt_widget_ref/Operators_for_output.tex}
\input{Qt_widget_ref/Manipulators.tex}



\ccExample

In the given example, that is found in demo/basic/tutorial1/tutorial1.C, it is created an object of type \ccStyle{Qt_widget} and then it's used the operators for output and the manipulators to show some of the widget's functionality.

\ccIncludeExampleCode{Qt_widget/basic/tutorial1/tutorial1.C}

\end{ccRefClass}
% +-----------------------------------------------------+
% EOF







