% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  geowin.tex
% +------------------------------------------------------------------------+

%\input{cprog.sty}

\ccParDims

\chapter{GeoWin}
\label{chapterGeoWin}
%\ccChapterRelease{\timerRev. \ \timerDate}\\
%\ccChapterAuthor{Matthias B\"asken}


%---------------------------------------------
% Introduction
%---------------------------------------------
\section{Introduction}

A $GeoWin$ is an editor for sets of geometric objects (geo\_scenes). It provides an interface for the visualization 
of the result and progression of geometric algorithms using the window data type of \leda.
A geo\_scene maintains a container (a \stl\ or \leda\ list) with geometric objects.
There are different kinds of scenes available in $GeoWin$ (see the reference manual pages of the
$GeoWin$ class for the details).
The $GeoWin$ data type can be used for:

\begin{itemize}

\item the construction and display of geometric objects and data structures
\item the visualization of geometric algorithms
\item writing interactive demos for geometric algorithms
\item debugging geometric algorithms.

\end{itemize}

Let us first have a look at the interactive use of $GeoWin$. You should open a $GeoWin$ by starting
one of the demonstration programs. A window with menus File, Edit, Scenes, Window, Options,
Algorithms and Help will pop up with an empty display region and a status line showing 
the position of the mouse.
In the Help menu you will find, among others, these three menu buttons :

\begin{itemize}
\item {\em About}    - a simple about dialog
\item {\em News}     - tells you what's new in the current release
\item {\em Buttons}  - teaches you how to use the mouse buttons in $GeoWin$.
\end{itemize}

With the left mouse button you can input a geometric object or scroll the scene by holding the
button while moving the mouse. By using the middle mouse button you can select an object by
clicking on it or a group of objects by holding the button and moving the mouse (that draws a
box, and all objects intersecting this box will be selected). The right mouse button opens a
menu by clicking on an object. This menu contains the options setup (setup the properties of the
object), select (selection of the object), delete (delete the object), 
object (change the value of the object) and raise (raise the object). By clicking on
the background with the right mouse button you can access the setup dialog of the whole scene,
where you can setup some global parameters of the scene (for instance colors and line parameters).
Next we give a short description of the menus in $GeoWin$:
\\
\\
{\em File} menu:
Here you will find buttons for I/O operations. You can save, load and export (save without header) scenes,
and you can also output the contents of scenes in postscipt format and make screenshots.
In the File menu you will also find the Quit button.
\\
\\
{\em Edit} menu:
A menu, where you find buttons for generating, reading, marking, unmarking, copying, deleting, moving
and rotating objects.
\\
\\
{\em Scenes} menu:
A menu with buttons and submenus for opening, closing, clearing and activating (making a scene the current or
active scene) scenes. This menu also contains a panel for setting the visibility and other options of a scene.
There are also submenus for looking at the contents of the scene.
\\
\\
{\em Window} menu:
A menu with redraw and zoom (adjusting the window coordinates) operations. Here you can also find a button for
showing 3d output (that is only interesting for scenes supporting this output mode).
\\
\\
{\em Options} menu:
A menu with sub-panels for editing various parameters of $GeoWin$ and for setting the scene defaults.
\\
\\
{\em Algorithms} menu:
For some scenes (for instance \leda\ point scenes) you can access various built-in algorithms.
\\
\\
{\em Help} menu:
In this menu you will find online help for the user interface of $GeoWin$.
\\
\\
{\em Done} :
The Done-button (see the following description of the $GeoWin$ data type).

After discussing the menus of $GeoWin$ let us have a look at the various parameters and attributes controlling
the behavior of $GeoWin$.
Every scene defines default attributes for its geometric objects. In editable scenes you can change the
attributes for every single object.
First, let's have a look at the default attributes of the scene. Open a scene in $GeoWin$, and then click on the 
background (or use the options submenu in the Scenes menu) to open a panel, where you can set them. You will find the following
options:

\begin{itemize}

\item {\em highlight focus}: If this option is enabled, the object under the mousepointer will be highlighted.
                 (for highlighting $GeoWin$ will use the color of selected boundaries)
		 
\item {\em show/handle def. points?} Some scenes support the movement of a point that helps defining
                 an object (for instance a vertex of a polygon). Using this choice item you can change
		 the behavior of this feature. If you choose $Show$, all the 'defining points' will be
		 shown and movement of these points will be supported. If you choose $Hide$, the
		 'defining points' will not be shown and the movement of these points will not be
		 supported. If you choose $Highlight$, only the 'defining points' of the object under
		 the mousepointer will be shown and movement of these points will be supported.
		 Note again that not all scenes support handling of these 'defining points'.
		 
\item {\em Input objects}: If the scene supports additional input objects, this item will be shown.
                 You can choose one of the input objects or the default input mode (using the 
		 window input operator).
             
\item {\em interior color}: An object that has to be filled will be filled with this color.
             
\item {\em boundary color}: The default color of the boundary of a non selected object in this scene.
                 
\item {\em selected color}: The default color of the boundary of a selected object in this scene.

\item {\em point style}: The point style used in the scene.
                 
\item {\em active/non active line width}: The default line width in active and non active scenes. 
                            Used for painting the boundary of objects.
                
\item {\em line style}: The default line style used in the scene (for painting the boundary). Can be solid, dashed or dotted.
            
\item {\em Debug}: If the scene is a result scene, you can choose here, that before every update
                of this scene the contents of its input scene will be written to a file.
      
\end{itemize}

Using this panel you can set some default attributes for the whole scene. But in editable scenes it is also
possible to change attributes of a single object.
Open a scene and input some objects. Now click with the right mouse button on an object. A little menu appears.
Using the setup button in this menu you get a panel on the screen.
There you can set the following attributes:

\begin{itemize}

\item {\em color of interior}: This color is used to paint the interior of the object.

\item {\em color of boundary}: Boundary color of the object, if it is not selected 

\item {\em line width}: The line width that is used to paint the boundary of the object.

\item {\em line style}: The line style that is used to paint the boundary of the object. 

\item {\em object label}: An attribute defining the label of an object 

\end{itemize}

{\bf Global parameters}

A $GeoWin$ has the window parameters background color, background pixmap (pm texture) and the grid parameters
(grid style, grid dist and show grid).
There are also some additional parameters, that can be set in the panels of the {\em Options} menu.

\begin{itemize}

\item {\em Grid Settings}: Here you can control whether or not a grid should be shown in the
              background of the drawing area of your $GeoWin$ and change grid parameters like grid dist
	      and style.

\item {\em bg texture/bg color}: These parameters control color and texture of the background of 
              your $GeoWin$.

\item {\em Show position}: This parameter controls whether the mouse coordinates should be shown in the status line.
                 
\item {\em Time Outs for Double Click and Dragging, Capture width}: Influences the behavior of the mouse input. 

\item {\em Rational kernel options}: If you are using rational \leda\ types in your $GeoWin$, these options
               are helpful. They let you set the precision (type: int) that is used when converting floating
               point types to rational \leda\ types and let you switch on (1) and off (0) the floating point filter
               used by many functions working with rational \leda\ types. 

\item {\em Measure Time}:  If this flag is true, $GeoWin$ outputs the used time after running a geometric algorithm. 
       
\item {\em 3d Output parameters}: They are only important for scenes supporting 3d output. 

\item {\em Eliminate}: This flag controls whether hidden lines should be eliminated or not. 

\item {\em Solid}: This flag controls whether the 3d output should be painted solid.

\item {\em Speed}: A Parameter that defines the speed of the animation when the three-dimensional output is painted.

\item {\em Scaling parameters}:
Here you can set the {\em x} and {\em y} coordinates of the window display area.

\end{itemize}
After this short discussion of the user interface of $GeoWin$ we'll have a look at a few example programs.

\section{Examples using the $GeoWin$ data type}

In this section two examples will show you how to use $GeoWin$ for writing interactive 
demos for geometric algorithms. You will find these (and a lot other) demo programs in the
$demo/GeoWin$ directory of your \cgal\ installation. Note that you must have \leda\ installed
to use $GeoWin$.

In the following examples a few typedefs from $geowin\_support.h$ are used.
They are all in the form

\begin{cprog}
typedef CGAL::Cartesian<double>  REP;
typedef CGAL::Point_2< REP >     CGALPoint;
typedef std::list<CGALPoint>     CGALPointlist;

typedef CGAL::Circle_2< REP >    CGALCircle;
typedef std::list<CGALCircle>    CGALCirclelist;

typedef CGAL::Line_2< REP >      CGALLine;
typedef std::list<CGALLine>      CGALLinelist;

...

\end{cprog}

\subsection{Simple demo demonstrating the minimum enclosing circle algorithm}

The following demonstration program first registers lists with \cgal\ 2D Points, because such a container
will be used in the editable scene created shortly afterwards.
Then a $GeoWin$ and two geo\_scenes are created.
The first created scene is an editable scene storing \cgal\ 2D Points in a list. The second created scene
is a result scene. The input for this scene is the contents of scene $my\_scene$. For computing the contents
of the result scene result the update object $min\_circ$ is used. $GeoWin$ calls this the update function 
of the update object every time the input scene $my\_scene$ changes to update the result scene.
The update function gets the current contents of the input scene (a list of \cgal\ 2D Points) and
computes the minimum enclosing circle.
After creating the 2 scenes the visibility flag of the result scene is set and the interactive mode
of $GeoWin$ is started.

\ccExample{CGALcircle.C}
\begin{cprog}
#include <CGAL/Cartesian.h>
#include <CGAL/Min_circle_2.h>
#include <CGAL/Min_circle_2_traits_2.h>
#include <CGAL/geowin_support.h>

typedef  CGAL::Cartesian<double>         R;
typedef  CGAL::Point_2<R>                Point;
typedef  CGAL::Min_circle_2_traits_2<R>  Traits;
typedef  CGAL::Min_circle_2<Traits>      Min_circle;
typedef  Min_circle::Circle              OptCircle;

class geo_circ : public geowin_update<std::list<CGALPoint>,std::list<CGALCircle> >
{
public:
 void update(const std::list<CGALPoint>& L, std::list<CGALCircle>& Cl)
 {
   Cl.clear();
   if (L.size() < 2) return;

   Min_circle  mc1( L.begin(), L.end());
   OptCircle ci= mc1.circle();

   Point ctp=ci.center();
   CGALCircle conv(ctp,ci.squared_radius());
   Cl.push_back(conv); 
 }
};

int main()
{
  geowin_init_default_type((CGALPointlist*)0, leda_string("CGALPointList"));

  CGALPointlist L;
  GeoWin GW("CGAL - Optimisation demo");

  geo_scene my_scene= GW.new_scene(L);  
  GW.set_point_style(my_scene, leda_disc_point);
  
  geo_circ min_circ;
  geo_scene result  = GW.new_scene(min_circ ,my_scene , 
                                   leda_string("Minimum circle"));
  GW.set_color(result,leda_blue);
  GW.set_line_width(result, 3);
  GW.set_visible(result,true);

  GW.edit(my_scene);
  return 0;
}
\end{cprog}

\subsection{A Delaunay triangulation demo using redraw and update objects}

The second example is a bit more complex. It uses three user editable input scenes:\\
$my\_scene$ contains points that are the input for an algorithm computing the
Delaunay triangulation.
$line\_scene$ contains lines; these are used for finding triangles of the Delaunay
triangulation intersected by these lines.
$pointloc\_scene$ contains points; these are used for locating triangles of the Delaunay
triangulation.
After the creation of the three edit scenes three result scenes are created. The result scene
$sc1$ and $res3$ use classes derived from $geowin\_redraw$ and $geowin\_update$ for
updating and redrawing.
After creating the result scenes we tell $GeoWin$ using the $add\_dependence$ method,
that two result scenes should be updated not only when their input scenes change.

\ccExample{CGALdtfl.C}

\begin{cprog}
#include <CGAL/basic.h>
#include <CGAL/Cartesian.h>
#include <CGAL/squared_distance_2.h>   
#include <CGAL/Point_2.h>
#include <CGAL/predicates_on_points_2.h>
#include <CGAL/Triangulation_euclidean_traits_2.h>
#include <CGAL/Triangulation_2.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/geowin_support.h>

typedef double coord_type;
typedef CGAL::Cartesian<coord_type>  Rep;
typedef CGAL::Point_2<Rep>  Point;
typedef CGAL::Segment_2<Rep>  Segment;

typedef CGAL::Triangulation_euclidean_traits_2<Rep> Gt;
typedef CGAL::Triangulation_vertex_base_2<Gt> Vb;
typedef CGAL::Triangulation_face_base_2<Gt>  Fb;
typedef CGAL::Triangulation_default_data_structure_2<Gt,Vb,Fb> Tds;
typedef CGAL::Triangulation_2<Gt,Tds>  Triang_2;
typedef CGAL::Delaunay_triangulation_2<Gt,Tds> Delaunay_triang_2;

typedef Delaunay_triang_2::Face::Face_handle Face_handle;
typedef Delaunay_triang_2::Line_face_circulator Line_face_circulator;

typedef Triang_2::Face  Face;
typedef Triang_2::Vertex Vertex;
typedef Triang_2::Edge Edge;
typedef Triang_2::Vertex_handle Vertex_handle;
typedef Triang_2::Edge_iterator  Edge_iterator;


class geo_delau : public geowin_update<std::list<CGALPoint>,std::list<CGALSegment> >
{
public:
 void update(const std::list<CGALPoint>& L, std::list<CGALSegment>& Sl)
 {
  Delaunay_triang_2 dt;    
  Sl.clear();      
  dt.insert(L.begin(),L.end());

  Edge_iterator eit = dt.edges_begin();
  Edge_iterator beyond = dt.edges_end();   
  Edge eact;

  while (eit != beyond) {
       eact = *eit;         
       Sl.push_back(dt.segment(eact));               
       ++eit;  
  }       
 }
};

class geo_triangles : public geowin_redraw, 
    public geowin_update<std::list<CGALPoint>, std::list<CGALPoint> >
{
public:

  CGALTrianglelist LT;
  geo_scene lines;

  virtual ~geo_triangles() {}

  virtual void draw(leda_window& W, leda_color c1, leda_color c2,
                    double x1,double y1,double x2,double y2)
  {  
    std::list<CGALTriangle>::const_iterator it   = LT.begin(), stop = LT.end();
    leda_color old = W.set_fill_color(leda_green);
    while( it != stop )
    {
       W << convert_to_leda(*it);
       it++;
    }
    W.set_fill_color(old);
  }

  virtual void update(const std::list<CGALPoint>& L, std::list<CGALPoint>&)
  { 
    Delaunay_triang_2 dt;    
    dt.insert(L.begin(),L.end());
    LT.clear();

    if (dt.dimension() != 2) return;

    GeoWin* gw = get_geowin(lines);

    CGALLinelist LST;
    gw->get_objects(lines,LST);

    std::list<CGALLine>::const_iterator it;
    CGALLine lakt;
    CGALPoint p1,p2; 

    for(it=LST.begin(); it != LST.end(); ++it) { 
       lakt= *it;
       p1=lakt.point(1); p2=lakt.point(2);
       Face_handle f = dt.locate(p1);
      
       Line_face_circulator lfc=dt.line_walk(p1,p2,f), done(lfc);
 
       if (lfc== (CGAL_NULL_TYPE) NULL) continue;

       do {
	  if(! dt.is_infinite( lfc  )){ LT.push_back(dt.triangle(lfc)); }
       }  
       while (++lfc != done); 
      
    }   
  }
};

class geo_triangles2 : public geowin_redraw, 
       public geowin_update<std::list<CGALPoint>, std::list<CGALPoint> >
{
public:

  CGALTrianglelist LT;
  geo_scene locate_points;

  virtual ~geo_triangles2() {}

  virtual void draw(leda_window& W, leda_color c1, leda_color c2,
                    double x1,double y1,double x2,double y2)
  {  
    std::list<CGALTriangle>::const_iterator it   = LT.begin(), stop = LT.end();
    leda_color old = W.set_fill_color(leda_blue);
    while( it != stop )
    {
       W << convert_to_leda(*it);
       it++;
    }
    W.set_fill_color(old);
  }

  virtual void update(const std::list<CGALPoint>& L, std::list<CGALPoint>&)
  { 
    Delaunay_triang_2 dt;    
    dt.insert(L.begin(),L.end());

    LT.clear();

    if (dt.dimension() != 2) return;

    GeoWin* gw = get_geowin(locate_points);   

    CGALPointlist LST;
    gw->get_objects(locate_points,LST);

    std::list<CGALPoint>::const_iterator it;
    CGALPoint lakt;

    for(it=LST.begin(); it != LST.end(); ++it) { 
       lakt= *it;
       Face_handle f = dt.locate(lakt);
       if (f != NULL && !dt.is_infinite(f)) LT.push_back(dt.triangle(f));
    }   
  }
};


int main()
{
  geowin_init_default_type((CGALPointlist*)0, leda_string("CGALPointList"));
  geowin_init_default_type((CGALLinelist*)0, leda_string("CGALLineList"));

  CGALPointlist L, LOC;
  CGALLinelist  CGLL;

  GeoWin GW("CGAL - Triangulation demo");
  geo_scene my_scene= GW.new_scene(L); 
  geo_scene line_scene= GW.new_scene(CGLL);
  GW.set_color(line_scene, leda_grey2);

  geo_scene pointloc_scene= GW.new_scene(LOC);
  GW.set_color(pointloc_scene, leda_blue);

  geo_triangles TRS;
  geo_scene sc1 = GW.new_scene( TRS, TRS, my_scene, "Triangles"); 
  GW.set_color(sc1, leda_blue);
  GW.set_visible(sc1,true);
  TRS.lines = line_scene;
 
  geo_delau delaunay_triang;
  geo_scene res2 = GW.new_scene(delaunay_triang, my_scene, 
                                leda_string("Delaunay Triangulation"));
  GW.set_color(res2, leda_red);

  geo_triangles2 TPT;
  geo_scene res3 = GW.new_scene( TPT, TPT, my_scene, "Triangles2"); 
  GW.set_color(res3, leda_red);
  TPT.locate_points = pointloc_scene;
  
  GW.add_dependence(line_scene,sc1);
  GW.add_dependence(pointloc_scene,res3);
  GW.set_all_visible(true);

  GW.edit(my_scene);
  return 0;  
}
\end{cprog}

\section{Implementation}
The implementation uses \leda\ 4.0, so you must have this or a higher version
of \leda\ installed to use
$GeoWin$. The $GeoWin$ library coming with \leda\ is compiled without namespace support.
However it is easy to add namespace support.
You have to recompile the $GeoWin$ library (the sources coming with \cgal\ or with \leda)
and the programs using $GeoWin$ with the option
-DGEOWIN\_USE\_NAMESPACE. This will compile the library with $GeoWin$ in the \cgal\ namespace.

% +----------------------------------------------------------+
%---------------------------------------------
% GeoWin data type
%---------------------------------------------

\ccDefGlobalScope{}
\begin{ccRefClass}{GeoWin}

\ccInclude{CGAL/geowin_support.h}


\ccDefinition
\ccCreationVariable{gw}

    An instance of data type \ccRefName\ is an editor 
    for sets of geometric objects. It can be used for the visualization of result
    and progression of geometric algorithms.
    
    \ccRefName\ manages the geometric objects in so called scenes.
    A scene contains a container storing geometric objects (the contents of the
    scene) and provides all operations that \ccRefName\ needs to edit it. 
    Every scene maintains a set of parameters:
    
    \begin{itemize}
    \item $name$ is the name of the scene 
          (type $leda\_string$)
    \item $color$ is the color for drawing the boundaries of the objects
          (type $leda\_color$)
    \item $color2$ (or $selection\_color$) is the color for drawing the selected boundaries of the objects
          (type $leda\_color$)
    \item $fill\_color$ is the color for drawing the interior of the objects
          (type $leda\_color$)
    \item $line\_width$ is the line width used for drawing the objects
          (type $int$)
    \item $active\_line\_width$ is the line width used for drawing the objects if the
          scene is active (type $int$)
    \item $line\_style$ is the line style used for drawing the objects
          (type $leda\_line\_style$)
    \item $visible$ is $true$ if the scene is visible in his $GeoWin$, $false$ otherwise
          (type $bool$)
    \item $active$ is $true$ if the scene has input focus (is currently edited) in
          his $GeoWin$, $false$ otherwise (type $bool$)
    \end{itemize}
    
    There are three kinds of scenes:
    \begin{enumerate}
    
    \item {\em Basic scene}
    
    The basic scene  type $GeoBaseScene<T>$ works on  every 
    container type  that provides an interface as the list of the \stl\ library. 
    More precisely, $T$ has to support the following type definitions and operations:
    \begin{itemize}
    \item $value\_type$ - the type of the values the container holds
    \item $iterator$ 
    \item operations $begin()$ and $end()$ returning an iterator that can be used
          for begining (ending) the traversal of the container
    \item $void \ push\_back(const \ T\&)$ for inserting an element at the end of the container
    \item $iterator \ insert(iterator, const \ T\&)$ for inserting an element
    \item $void \ erase(iterator \ it)$ for erasing an element at position $it$
    \item operation $bool \ empty()$ returning $true$ if the container is empty, $false$
          otherwise    
    \end{itemize}
    
    That means, that \leda\ lists can be used as well as containers.

    \item {\em Edit scene}
    
    A scene of type $GeoEditScene<T>$ is a user editable scene.
    \ccRefName\ is an editor for this kind of containers.
    
    \item {\em Result scene}
    
    A scene of type $GeoResultScene<I,R>$ is not independently 
    editable. Instead its contents (a container of type $R$) is computed by a user
    defined update
    function or update object with an update function. The update function computes
    the contents of the result scene every time when another scene (the input scene for
    the result scene) changes. The update function
    
      $void (*f\_update)(const \ I\& \ input, R\& \ result)$
      
    gets the contents of this input scene (a container $input$ of type $I$) and computes
    the contents $result$ of the result scene.
    We say that the result scene depends on its input scene.
    
    \end{enumerate}

Both Edit and Result scenes are derived from Basic scenes.
The geometric objects stored in the containers of the scenes have to support input and
output operators for IO-streams and the \leda\ window and the output operator to the \leda
class $ps\_file$ for Postscript output.    
Please note that the type $geo\_scene$ is the scene item type used in $GeoWin$.
It is a pointer to the base class of all scene types.
    
 
\ccCreation

\ccConstructor{GeoWin(const char* label = "GEOWIN");}
{creates a $GeoWin$ \ccVar\ with  frame label $label$.}

\ccConstructor{GeoWin(int w, int h,const char* label = "GEOWIN");} 
{creates a $GeoWin$ \ccVar.  \ccVar\ is constructed with 
frame label $label$ and physical size $w\times h$. }

\ccOperations


\medskip
{\bf a) Main Operations} 

The $new\_scene$ and $get\_objects$ operations use member templates. If your 
compiler does not support member templates, you should use 
the function templates $geowin\_new\_scene$ and $geowin\_get\_objects$ with
\ccVar\ as an additional first parameter.
All $new\_scene$ operations can get an optional additional last parameter.
This parameter is a pointer to a function that will be used to compute the
three-dimensional output of the scene.
The type of such a function pointer $f$ is \\
\\
\ccc{void (*f)(const T&, leda_d3_window&, GRAPH<leda_d3_point,int>&))},\\
\\
where $T$ is the type of the container used in the scene.
The function gets a reference to the container of it's scene, a reference to the
output \ccc{leda_d3_window} and to the parametrized graph describing the three-dimensional
output. The function usually adds new nodes and edges to this graph. Note that
every edge in the graph must have a reversal edge ( and the reversal information
has to be set).
    
The following $new\_scene$ operation can be used to create edit scenes.
The $CONTAINER$ has to be a $list<T>$ (where T is the type of your geometric
objects) and must be registered in $GeoWin$ (see Registration of types).

\ccMethod{template<class CONTAINER> geo_scene new_scene(CONTAINER& c);} 
{creates a new edit scene for $c$. $c$ will be edited by \ccVar\ . }

\medskip
The following $new\_scene$ operations can be used to create result scenes.
Result scenes use the contents of another scene (the input scene) 
as the input for a function (the update function). 
This function computes the contents of the result scene. The update function 
is called every time when the contents of the input scene changes.
Instead of using an update function you can use an update object that encapsulates
an update function.
The type of this update object has to be $geowin\_update<I,R>$ 
($I$ - type of the container in the input scene,
$R$ - type of the container in the result scene) or a class derived from it.
A derived class should overwrite the virtual update function

     $void \ update(const \ I\& \ in,R\& \ out)$ 
     
of the base class to provide a user defined update function. 
The class $geowin\_update<I,R>$ has 3 constructors getting function pointers
as arguments:
    \begin{itemize}    
     \item \ccc{geowin\_update(void \ (*f)(const \ I\& in, R\&  \ res)}
     
     \item \ccc{geowin\_update(void \ (*f)(const \ I\& in, R::value\_type\& \ obj)}
     
     \item \ccc{geowin\_update(R::value\_type \ (*f)(const \ I\& \ in)}
    \end{itemize}
    
If you provide such a function in the constructor, this function will
be called in the update function of the update object.
The first is the normal update function that gets the contents $in$ of the input 
scene and computes the contents $res$ of the output scene. 
In the second variant the contents of the result scene will first be cleared, then the
update function will be called and $obj$ will be inserted in the result scene.
In the third variant the contents of the result scene will be cleared, and then
the object returned by the update function will be inserted in the result scene.

The class \ccc{geowin_update} has also the following virtual functions:
\begin{itemize}    
     \item \ccc{bool insert(const InpObject& new)}
 
     \item \ccc{bool del(const InpObject& new)}
 
     \item \ccc{bool change(const InpObject& old_obj, const InpObject& new_obj)}
\end{itemize}
where $new$ is a new inserted or deleted object and $old\_obj$ and $new\_obj$ are 
objects before and after a change.
$InpObject$ is the value type of the container of the input scene.
With these functions it is possible to support incremental algorithms. The functions will
be called, when in the input scene new objects are added ($insert$), deleted ($del$) or 
changed while performing a move or rotate operation ($change$).
In the base class these functions return $false$. That means, that the standard update function
of the update object should be used, and usually the whole output will be recomputed using
the whole input. 
But in derived classes it is possible to overwrite
these functions and provide user-defined update operations for these three incremental
operations. Then the function has to return $true$.
That means, that the standard update function of the update object should not be used.    
 
It is also possible to provide user defined redraw for a scene.
For this purpose we use redraw objects derived from the class $geowin\_redraw$ .
The derived class has to overwrite the virtual redraw function

     $void \ draw(leda\_window\& \ W,leda\_color \ c1,leda\_color \ c2,double \ x1,double \ y1,double \ x2,double \ y2)$
     
of the base class to provide a user defined redraw function. The first three parameters
of this function are the redraw window and the first and second drawing color ($color$ 
and $color2$) of the scene. \\
In update and redraw functions and objects the following static member functions 
of the \ccc{GeoWin} class can be used:
\begin{itemize}
    \item \ccc{GeoWin*    GeoWin::get_call_geowin()}
    
    \item \ccc{geo_scene  GeoWin::get_call_scene()}
    
    \item \ccc{geo_scene  GeoWin::get_call_input_scene()}
\end{itemize}   
The first function returns a pointer to the \ccc{GeoWin} of the calling scene,
the second returns the calling scene and the third (only usable in update functions/
objects) returns the input scene of the calling scene.

If you want user defined postscript output, the derived class has to overwrite the
virtual function

     $bool \ write\_postscript(ps\_file\& \ PS,leda\_color \ c1,leda\_color \ c2)$
     
of the base class. The first parameter of this function is the output Postscript file 
(see Manual/contrib in your \leda\ distribution for a documentation of the ps\_file class),
the other parameters are the first and second drawing color ($color$ and $color2$) of
the scene. The function has to return false, if the contents of the scene should be
drawn to the Postscript output file too, true otherwise.

In the following member-templates    
$I$ and $R$ have to be a $list<T>$, where $T$ is the type of your geometric
objects. ($list$ can be a \stl\ or \leda\ list, see Registration of types.)
$I$ is the type of the contents of the input scene, $R$ the type of the contents
of the created result scene.

\ccMethod{template<class I, class R> 
geo_scene new_scene(F f_update, geo_scene sc, leda_string str);}
{where $F$ is the type 
$void \ (*)(const \ I\&, R\&)$,
creates a new result scene with name $str$.
The input scene for this new result scene will be $sc$.
The update function will be $f\_update$ . 
Note that this member-template does not compile on Visual C++. 
You have to use one of the other member templates for creating 
result scenes on this platform.
}
	     
\ccMethod{template<class I,class R>
geo_scene new_scene(geowin_update<I,R>& up, geo_scene sc_input, leda_string str);}
{creates a new result scene with name $str$.
The input scene for this new result scene will be $sc\_input$.
The update object will be $up$. }

\ccMethod{template<class I,class R>
geo_scene new_scene(geowin_update<I,R>& up, geowin_redraw& rd, geo_scene sc_input, leda_string str);}
{creates a new result scene with name $str$.
The input scene for this new result scene will be $sc\_input$.    
The update object will be $up$.  
The redraw object will be $rd$. }

\ccMethod{template<class I,class R>
void set_update(geo_scene res, geowin_update<I,R>& up);}
{makes $up$ the update object of $res$.}
  
\ccMethod{template<class S,class R>
void set_update(geo_scene res, void (*f_update)(const S&, R&));}
{makes $f\_update$ the update function of $res$.}

\ccMethod{template<class CONTAINER> bool get_objects(geo_scene sc,CONTAINER& c);}
{If the contents of scene $sc$ matches type $CONTAINER$, 
then the contents of scene $sc$ is copied to $c$.}

\ccMethod{template <class T> void get_selected_objects(GeoEditScene<T>* sc, T& cnt);}
{returns the selected objects of editable scene $sc$ in the container $cnt$.} 
 
\ccMethod{void edit();}
{starts the interactive mode of \ccVar\ . The operation returns if either the $Done$ or
$Quit$ button was pressed. }

\ccMethod{bool edit(geo_scene sc);}
{edits scene $sc$. Returns $false$ when the Quit Button was pressed,
$true$ otherwise. \ccPrecond $sc$ must be an edit scene. }

\medskip
{\bf b) Window Operations}

\ccMethod{void close();}
{closes \ccVar\ .}

\ccMethod{double get_xmin();}
{returns the minimum x-coordinate of the drawing area.}
  
\ccMethod{double get_ymin();}
{returns the minimum y-coordinate of the drawing area.}
  
\ccMethod{double get_xmax();}
{returns the maximum x-coordinate of the drawing area.}
    
\ccMethod{double get_ymax();} 
{returns the maximum y-coordinate of the drawing area.} 

\ccMethod{void display(int x,int y);}
{opens \ccVar\ at $(x,y)$. }

\ccMethod{leda_window& get_window();}
{returns a reference to the drawing window.}
  
\ccMethod{void init(double xmin, double xmax, double ymin);}
{same as $leda\_window$::init($xmin$, $xmax$, $ymin$).}
  
\ccMethod{void init(double x1, double x2, double y1, double y2, int r);}
{initializes the window so that the rectangle with lower 
left corner $(x1-r,y1-r)$ and upper right corner $(x2+r,y2+r)$
is visible at whole. The window must be open.}

\ccMethod{void redraw();}
{redraws the contents of \ccVar\ (all visible scenes).}

\ccMethod{int set_cursor(int cursor_id = -1); }
{sets the mouse cursor to $cursor\_id$. }


\clearpage
%\medskip
{\bf c) Scene Operations} 

\ccMethod{geo_scene get_scene_with_name(leda_string nm);}
{returns the scene named $nm$ or $NULL$ if there is no scene
named $nm$.}

\ccMethod{void activate(geo_scene sc);}
{makes scene $sc$ the active scene of \ccVar. }

\ccMethod{geo_scene get_active_scene();}
{returns the active scene of \ccVar. }

\ccMethod {bool is_active(geo_scene sc); }
{returns true if $sc$ is an active scene in a \ccRefName. }

\medskip
The following $get$ and $set$ operations can be used for retrieving and
changing scene parameters. All $set$ operations return the previous 
value. 
    
\ccMethod{leda_string get_name(geo_scene sc);}
{returns the name of scene $sc$. } 

\ccMethod{leda_string set_name(geo_scene sc, leda_string nm);}
{gives scene $sc$ the name $nm$. If there is already
a scene with name $nm$, another name is constructed
based on $nm$ and is given to $sc$. The operation
will return the given name.
}
  
\ccMethod{leda_color get_color(geo_scene sc);}
{returns the boundary drawing color of scene $sc$. }

\ccMethod{leda_color set_color(geo_scene sc, leda_color c);}
{sets the boundary drawing color of scene $sc$ to $c$. }

\ccMethod{leda_color get_selection_color(geo_scene sc);}
{returns the second drawing color (used for selected
boundaries) of scene $sc$. }

\ccMethod{leda_color set_selection_color(geo_scene sc, leda_color c);}
{sets the second drawing color of scene $sc$ (used for selected 
boundaries) to $c$. }

\ccMethod{leda_color get_fill_color(geo_scene sc);}
{returns the fill color of $sc$.}

\ccMethod{leda_color set_fill_color(geo_scene sc,leda_color c);}
{sets the fill color of $sc$ to $c$. Use color $leda\_invisible$ for
disable filling.}

\ccMethod{leda_color get_text_color(geo_scene sc);}
{returns the text color of $sc$.}

\ccMethod{leda_color set_text_color(geo_scene sc,leda_color c);}
{sets the text color of $sc$ to $c$. The text color is used for labels.}

\ccMethod{int get_line_width(geo_scene sc);}
{returns the line width of $sc$. }

\ccMethod{int get_active_line_width(geo_scene sc);}
{returns the active line width of $sc$. }

\ccMethod{int set_line_width(geo_scene sc,int w);}
{sets the line width for scene $sc$ to $w$.}
 
\ccMethod{int set_active_line_width(geo_scene sc,int w);}
{sets the active line width for scene $sc$ to $w$.}

\ccMethod{leda_line_style get_line_style(geo_scene sc);} 
{returns the line style of $sc$ .}
  
\ccMethod{leda_line_style set_line_style(geo_scene sc, leda_line_style l);} 
{sets the line style of scene $sc$ to $l$.}

\ccMethod{bool get_visible(geo_scene sc);}
{returns the visible flag of scene $sc$. }
  
\ccMethod{bool set_visible(geo_scene sc, bool v);}
{sets the visible flag of scene $sc$ to $v$. }

\ccMethod{void set_all_visible(bool v);}
{sets the visible flag of all scenes that are currently in \ccVar\ to $v$.}
  
\ccMethod{leda_point_style get_point_style(geo_scene sc);}
{returns the point style of $sc$.}
  
\ccMethod{leda_point_style set_point_style(geo_scene sc, leda_point_style p);}
{sets the point style of $sc$ to $p$.}

\begin{ccAdvanced}

\medskip
{The following operations can be used to set/get 
individual attributes of objects in scenes.
All set operations return the previous value.
The first parameter is the scene, where the object belongs to.
The second parameter is a generic pointer to the object.
\ccPrecond the object belongs to the scene (is in the container
of the scene).
Note that the following operations are member templates. 
}

\ccMethod{template<class T> leda_color get_obj_color(GeoBaseScene<T>* sc, void* adr);}
{returns the boundary color of the object at $(*adr)$.}

\ccMethod{template<class T> leda_color set_obj_color(GeoBaseScene<T>* sc, void* adr, leda_color c);}
{sets the boundary color of the object at $(*adr)$ to $c$.}  

\ccMethod{template<class T> leda_color get_obj_fill_color(GeoBaseScene<T>* sc, void* adr);}
{returns the interior color of the object at $(*adr)$.}

\ccMethod{template<class T> leda_color set_obj_fill_color(GeoBaseScene<T>* sc, void* adr, leda_color c);}
{sets the interior color of the object at $(*adr)$ to $c$.}   

\clearpage
\ccMethod{template<class T> int get_obj_line_width(GeoBaseScene<T>* sc, void* adr);}
{returns the line width of the object at $(*adr)$.} 

\ccMethod{template<class T> int set_obj_line_width(GeoBaseScene<T>* sc, void* adr, int w);}
{sets the line width of the object at $(*adr)$ to $w$.}

\medskip
{The following operations can be used as well to set/get individual attributes of objects in scenes.
But these operations search for an object $o$ in the (container of the) scene $(*sc)$ with $o==obj$. If such an object was found,
$true$ is returned, otherwise $false$. Then the object attribute will be assigned to the last parameter ($get$
operations) or will be set ($set$ operations) for the object.}

\ccMethod{template<class T> bool get_obj_color(GeoBaseScene<T>* sc, const T::value_type& obj, leda_color& c);}
{}

\ccMethod{template<class T> bool set_obj_color(GeoBaseScene<T>* sc, const T::value_type& obj, leda_color c);}
{}

\ccMethod{template<class T> bool get_obj_fill_color(GeoBaseScene<T>* sc, const T::value_type& obj, leda_color& c);}
{}
  
\ccMethod{template<class T> bool set_obj_fill_color(GeoBaseScene<T>* sc, const T::value_type& obj, leda_color c);}
{}

\ccMethod{template<class T> bool get_obj_line_style(GeoBaseScene<T>* sc, const T::value_type& obj, leda_line_style& l);}
{}

\ccMethod{template<class T> bool set_obj_line_style(GeoBaseScene<T>* sc, const T::value_type& obj, leda_line_style l);}
{}

\ccMethod{template<class T> bool get_obj_line_width(GeoBaseScene<T>* sc, const T::value_type& obj, int& l);}
{}
  
\ccMethod{template<class T> bool set_obj_line_width(GeoBaseScene<T>* sc, const T::value_type& obj, int l);}     
{}

\ccMethod{template<class T> void reset_obj_attributes(GeoBaseScene<T>* sc);}
{deletes all individual attributes of objects in scene $(*sc)$.}
  
\end{ccAdvanced}

\clearpage
%\medskip
{\bf d) Input and Output Operations}  

\ccMethod{void read(geo_scene sc,istream& is);}
{reads the contents of $sc$ from input stream $is$. The contents of
$sc$ is cleared before. }

\ccMethod{void write(geo_scene sc,ostream& os); }
{writes the contents of $sc$ to output stream $os$. }

\ccMethod{void write_active_scene(ostream& os);}
{writes the contents of the active scene of \ccVar
to output stream $os$ . }

\medskip
{\bf e) View Operations}

\ccMethod{void zoom_up();}
{The visible range is reduced to the half. }

\ccMethod{void zoom_down();}
{The visible range is doubled. }

\ccMethod{void fill_window();}
{changes window coordinate system, so that the objects of the 
currently active scene fill the window. }

\begin{ccAdvanced}
\ccMethod{leda_string get_bg_pixmap();}
{returns the name of the current background pixmap.}
  	    
\ccMethod{leda_string set_bg_pixmap(leda_string pix_name);} 	  
{changes the window background pixmap to pixmap with name $pix\_name$.
For the names of supported pixmaps see /pixmaps in your \leda\ include
directory.
The function returns the name of the previous background pixmap.}
\end{ccAdvanced}


\ccMethod{leda_color get_bg_color();}
{returns the current background color.}
  	    
\ccMethod{leda_color set_bg_color(leda_color c);} 
{sets the current background color to $c$ and returns its previous value.}	 

\ccMethod{bool get_show_grid();}
{returns true, if the grid will be shown, false otherwise.}
  
\ccMethod{bool set_show_grid(bool sh);}
{sets the show grid flag to $sh$ and returns the previous value.}
  
\ccMethod{double get_grid_dist();}
{returns the grid distance parameter.}
  
\ccMethod{double set_grid_dist(double g);}
{sets the grid distance parameter to $g$ and returns the previous value.}
  
\ccMethod{bool get_show_position();}
{returns true, if the mouse position will be shown, false otherwise.}
  
\ccMethod{bool set_show_position(bool sp);}
{sets the show mouse position flag to $sp$ and returns the previous value.} 

\begin{ccAdvanced}
\medskip
{\bf f) Event Handling} 

\ccVar\ provides operations for changing its default handling
of events. 
As in the \leda\ class $GraphWin$ the user can define what 
action should follow a mouse or key event. Constants are defined as in the
\leda\ class $GraphWin$ : 
   \begin{itemize}
   \item  A\_LEFT  (left mouse-button)
   \item  A\_MIDDLE (middle mouse-button)
   \item  A\_RIGHT (right mouse-button)
   \item  A\_SHIFT (shift-key)
   \item  A\_CTRL (control-key)
   \item  A\_ALT (alt-key)
   \item  A\_DOUBLE (double click)
   \item  A\_DRAG (button not released)
   \item  A\_IMMEDIATE (do it immediatly without dragging or double click 
   check)
   \item  A\_OBJECT (editable object at mouse position).
   \end{itemize}
and can be combined with OR ( \vline\ ).
  

\ccMethod{void set_action(long mask, geo_action f=0);}
{Set action on condition $mask$ to $f$. $geo\_action$ is a
function of type $void (*)(GeoWin\&, const \ leda\_point\&)$ . 
For $f$ == $0$ the corresponding action is deleted. 
$mask$ is a combination of some event constants (see the default values for examples).
}
  
\ccMethod{geo_action get_action(long mask);}
{Get action defined for condition $mask$.  }
  
\ccMethod{void reset_actions();}
{Set all actions to their default values. }

    \medskip
    Default values are defined as follows :
    \begin{itemize}
    \item A\_LEFT   or   A\_LEFT \vline\ A\_OBJECT \newline
    read a new object at mouse position.
    \item A\_LEFT \vline\ A\_DRAG    \newline       scrolling the window.
    \item A\_LEFT \vline\ A\_DRAG \vline\ A\_OBJECT \newline move the object.
    \item A\_LEFT \vline\ A\_CTRL 
    \newline pin current scene at mouse position or delete the pin point if 
    it is currently there. 
    \item A\_MIDDLE \vline\  A\_OBJECT \newline
    toggle the selection state of the object at mouse position.
    \item A\_MIDDLE \vline\ A\_DRAG  
    \newline  toggle the selection state of the objects in the dragging area.
    \item A\_RIGHT \vline\  A\_IMMEDIATE \newline
    set the options of the currently active scene.
    \item A\_RIGHT \vline\  A\_IMMEDIATE \vline\  A\_OBJECT \newline
    opens a menu for the object at mouse position.
    \end{itemize}

\ccMethod{void clear_actions();}
{clears all actions. }

{ \medskip
 {\bf Scene events}
     
The following event handling functions can be set for
edit scenes:
\begin{itemize}
\item Pre add handler
\item Post add handler
\item Pre delete handler
\item Post delete handler
\item Start and End change handler
\item Pre and Post move handler
\item Pre and post rotate handler
\end{itemize}
     
The add handlers will be called when a user tries to add an object
to an edit scene in $GeoWin$, the delete handlers will be called when
the user tries to delete an object and the change handlers will be
called when the user tries to change an object (for instance by moving 
or rotating it).
The templated set operations for setting handlers use member templates. 
If your compiler does not support member templates, you should use instead
the templated functions $geowin\_set\_HANDLER$, where $HANDLER$ is one the
following handlers. 
All handling functions get as the first parameter a reference to the 
$GeoWin$, where the scene belongs to.         
}

\ccMethod{template<class T,class F> bool set_pre_add_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called before an object is added to $(*sc)$.
$handler$ must have type $bool\ (*handler)(GeoWin\&, const\ T::value\_type \&)$.
$handler$ gets a reference to the added object. If $handler$ returns false, 
the object will not be added to the scene.}
  
\ccMethod{template<class T,class F> bool set_post_add_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called after an object is added to $(*sc)$. 
$handler$ must have type $void\ (*handler)(GeoWin\&, const\ T::value\_type \&)$.
$handler$ gets a reference to the added object.
}

\ccMethod{template<class T,class F> bool set_pre_del_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called before an object is  deleted from $(*sc)$.
$handler$ must have type $bool\ (*handler)(GeoWin\&, const\ T::value\_type \&)$.
$handler$ gets a reference to the added object. If $handler$ returns true, the object
will be deleted, if $handler$ returns false, the object will not be deleted.}
  
\ccMethod{template<class T,class F> bool set_post_del_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called after an object is deleted from $(*sc)$.
$handler$ must have type $void\ (*handler)(GeoWin\&, const\ T::value\_type \&)$.
}

\ccMethod{template<class T,class F> bool set_start_change_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called when a geometric object from $(*sc)$ starts changing 
(for instance when you move it or rotate it).
$handler$ must have type $bool\ (*handler)(GeoWin\&, const\ T::value\_type \&)$.
The handler function gets a reference to the object.
}

\clearpage
\ccMethod{template<class T,class F> bool set_pre_move_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called before every move operation.
$handler$ must have type $bool\ (*handler)(GeoWin\&, const\ T::value\_type \&, double\ x, double\ y)$. 
The handler gets as the second parameter a reference to the object, as the third parameter
and fourth parameter the move vector.
If the handler returns true, the change operation will be executed, if the handler
returns false, it will not be executed. 
}
  
\ccMethod{template<class T,class F> bool set_post_move_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called after every move operation.
$handler$ must have type $void\ (*handler)(GeoWin\&, const\ T::value\_type \&, double\ x, double\ y)$. 
The handler gets as the second parameter a reference to the object, as the third parameter
and fourth parameter the move vector.  
}
 
\ccMethod{template<class T,class F> bool set_pre_rotate_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called before every rotate operation.
$handler$ must have type $bool\ (*handler)(GeoWin\&, const\ T::value\_type \&, double\ x, double\ y, double\ a)$.
The handler gets as the second parameter a reference to the object, as the 3., 4. and 5. parameter
the rotation parameters. 
If the handler returns true, the rotate operation will be executed, if the handler returns false,
it will not be executed. 
}
  
\ccMethod{template<class T,class F> bool set_post_rotate_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called after every rotate operation.
$handler$ must have type $void\ (*handler)(GeoWin\&, const\ T::value\_type \&, double\ x, double\ y, double\ a)$. 
}
 
\ccMethod{template<class T,class F> bool set_end_change_handler(GeoEditScene<T>* sc, F handler);}
{sets the handler that is called when a geometric object from $(*sc)$ ends changing. 
$handler$ gets the object as the second parameter.
$handler$ must have type $void\ (*handler)(GeoWin\&, const\ T::value\_type \&)$.}

\end{ccAdvanced}

{
\medskip
{\bf Generator functions:}
The following operation can be used to set a generator function for an edit scene.
A generator function is used for generating objects of a scene. You can access these
generators in the $Edit$-menu. Some scenes have default generators (for instance
point scenes), but it is always possible to set your own generator functions for
edit scenes. \\
The operation uses member templates. 
If your compiler does not support member templates, you should use instead
the templated function $geowin\_set\_generate\_fcn$ instead. 
}
     
\ccMethod{template<class T> bool set_generate_fcn(GeoEditScene<T>* sc, F f);}
{ (where $F$ is the type
$void \ (*)(GeoWin\& \ gw,T\& \ L)$ ),
sets the generator function for edit scene $(*sc)$. 
The function $f$ gets the $GeoWin$ where $(*sc)$ belongs to and
a reference to the container $L$ of $(*sc)$. The function
should write the generated objects to $L$.
}

\medskip
{\bf Input objects:}
The default user input is handled by the window input operator.
But there is another possibility for a more flexible input provided by $GeoWin$ -
input objects.
The following operations can be used to set input objects for an editable scene.
The operation uses member templates. 
If your compiler does not support member templates, you should use instead
the templated functions prefixed with  $geowin$.
A \ccc{GeoInputObject<GeoObj>} has the following virtual functions:
\begin{itemize}     
        \item \ccc{void operator()(GeoWin& gw, leda_list<GeoObj>& L);} \\
     This virtual function is called for the input of objects. The new objects have to be
     returned in $L$.
    
        \item \ccc{void options(GeoWin& gw);} \\  
     This function is called for setting options for the input object.
\end{itemize}
     
\ccMethod{template<class T>
bool set_input_object(GeoEditScene<T>* sc, const GeoInputObject<T::value_type>& obj, leda_string name);}
{sets the input object $obj$ for edit scene $(*sc)$. 
The (member) function for the input of the objects gets the $GeoWin$ where $(*sc)$ belongs to and
a reference to a \leda\ list $L$. The function must write the new objects to $L$. The name $name$ will
be associated with the input object (this name will be shown in the user interface).}

  
\ccMethod{template<class T>
bool add_input_object(GeoEditScene<T>* sc, const GeoInputObject<T::value_type>& obj, leda_string name);}
{adds the input object $obj$ to the list of available input objects of edit scene $(*sc)$ without making 
$obj$ the current input object. The user switch to this input object in the user interface. The name $name$ will
be associated with the input object (this name will be shown in the user interface).}

\clearpage  
\ccMethod{template<class T>
void set_draw_object_fcn(GeoBaseScene<T>* sc, leda_window& (*fcn)(leda_window&, const T::value_type &, int w));}
{sets a function $fcn$ for scene $(*sc)$ that will be called for drawing the objects of scene $(*sc)$. 
If no such function is set (the default), the output operator is used.}


\ccMethod{void set_quit_handler(F f);}
{
(where $F$ is the type 
$bool \ (*)(const \ GeoWin\& \ gw)$ ),
sets a handler function $f$ that is called when the user 
clicks the quit menu button. $f$ should return true for allowing quiting, false otherwise. }
  
\ccMethod{void set_done_handler(F f);}
{
(where $F$ is the type 
$bool \ (*)(const \ GeoWin\& \ gw)$ ),
sets a handler function $f$ that is called when the user clicks the
done menu button. $f$ should return true for allowing quiting, false otherwise. }

\medskip
{\bf g) Further Operations} 

\ccMethod{leda_list<geo_scene> get_scenes();}
{returns the scenes of \ccVar\ .}
  
\ccMethod{leda_list<geo_scene> get_visible_scenes();}
{returns the visible scenes of \ccVar\ .}

\ccMethod{void add_dependence(geo_scene sc1, geo_scene sc2); }
{makes scene $sc2$ dependent from $sc1$. That means that $sc2$
will be updated when the contents of $sc1$ changes. }

\ccMethod{void del_dependence(geo_scene sc1, geo_scene sc2); }
{deletes the dependence of scene $sc2$ from $sc1$. }

\ccMethod{void set_frame_label(const char* label);}
{makes $label$ the frame label of \ccVar. }
	
\ccMethod{double version();}
{returns the $GeoWin$ version number.}
  	   
\ccMethod{void message(leda_string msg);}
{displays message $msg$ on top of the drawing area.
If $msg$ is the empty string, a previously written message is deleted.}

\ccMethod{void msg_open(leda_string msg);}
{displays message $msg$ in the message window of \ccVar.
If the message window is not open, it will be opened.}
  
\ccMethod{void msg_close();} 
{closes the message window.}
 
\ccMethod{void msg_clear(); } 
{clears the message window.}

\begin{ccAdvanced}

\ccMethod{void set_d3_fcn(geo_scene sc, void (*f)(geo_scene gs, leda_d3_window& W, GRAPH<leda_d3_point,int>& H));}
{sets a function for computing 3d output. The parameters of the function are
the $geo\_scene$ for that it will be set and a function pointer. The function $f$ will get the scene
for that it was set, a reference to a \leda\ $d3\_window$ that will be the output window and a 
parametrized \leda\ GRAPH that will be used for visualization.}

\ccMethod{D3_FCN  get_d3_fcn(geo_scene sc);}
{returns the function for computing 3d output that is set for scene $sc$.
The returned function pointer has the type \ccc{void (*)(geo_scene, d3_window&, GRAPH<d3_point,int>&)}.}

\end{ccAdvanced}

\medskip
\ccVar\ can be pined at a point in the plane. As standard behavior it is
defined that moves of geometric objects will be rotations around the
pin point. 

\ccMethod{bool get_pin_point( leda_point& p );}
{returns the pin point in $p$ if it is set.}

\ccMethod{void set_pin_point( leda_point  p );}
{sets the pin point to $p$.}

\ccMethod{void del_pin_point();}
{deletes the pin point.}

\ccMethod{void add_help_text(leda_string name);}
{adds the help text contained in $name.hlp$ with label $name$
to the help menu of the main window. The file $name.hlp$ must
exist either in the current working directory or in
$\$LEDAROOT/incl/Help$. Note that this operation must be called
before $gw.display()$. }

\medskip
The templated $add\_user\_call$ operation uses member templates. If your 
compiler does not support member templates, you should use
the templated function $geowin\_add\_user\_call$ with
\ccVar\ as an additional first parameter.

\ccMethod{template<class F> void add_user_call(leda_string label, F f);}
{adds a menu item $label$ to the "User" menu of \ccVar . \\
The user defined function \\
$geo\_call(GeoWin\& \ gw, F \ f, leda\_string \ label)$
is called whenever this menu button was pressed. This menu 
definition has to be finished before \ccVar\ is opened. }

\end{ccRefClass}

\subsection{Non-Member Functions}

\ccFunction{GeoWin* get_geowin(geo_scene sc);}
{
  returns a pointer to the $GeoWin$ of scene $sc$.
}

\subsection{Registration of types}

The following two function templates can be used to register types for usage
in edit scenes of $GeoWin$. Note that you have to perform this registration before the creation
of the first $GeoWin$.
To use $GeoWin$ with your
own types, the container class storing the geometric objects and your geometric
objects must meet some requirements:
\begin{enumerate}
\item The container must provide the functionality of the \stl\ list (especially 
$CONTAINER\_TYPE::iterator$ and $CONTAINER\_TYPE::value\_type$).
You can use \leda\ lists too.
\item You have to provide a generator function
\begin{verbatim}
void geowin_generate_objects(GeoWin& gw,CONTAINER_TYPE& L);
\end{verbatim}
This generator function can be used to generate input and return it in L.
\item If you don't want to use \leda\ lists, you should provide an info function
\begin{verbatim}
leda_string geowin_info_fcn(const CONTAINER_TYPE& L);
\end{verbatim}
This info function should return a string desribing the container.
\end{enumerate}
For the geometric objects the following requirements must be fulfilled:
\begin{enumerate}
\item default and copy constructor
\begin{verbatim}
TYPE();
TYPE(const TYPE&);
\end{verbatim}
\item operators for writing to an ostream and reading from an istream
\begin{verbatim}
std::ostream& operator<<(std::ostream&, const TYPE&);
std::istream operator>>(std::istream&, TYPE&);
\end{verbatim}
\item operators for writing to/ reading from a \leda\ window
\begin{verbatim}
leda_window& operator<<(leda_window&, const TYPE&);
leda_window& operator>>(leda_window&, TYPE&);
\end{verbatim}
\item an operator for writing to a ps\_file for postscript output
\begin{verbatim}
ps_file& operator<<(ps_file&, const TYPE&);
\end{verbatim}
\item a function for translating the object by a vector (dx,dy):
\begin{verbatim}
void geowin_Translate(TYPE& obj, double dx, double dy);
\end{verbatim}
\item a function for rotating the object  about point(dx,dy) by angle a:
\begin{verbatim}
void geowin_Rotate(TYPE& obj,double dx,double dy,double a);
\end{verbatim}
\item a function for calculating the bounding box of the object:
\begin{verbatim}
void geowin_BoundingBox(const TYPE& obj, double& x1, 
         double& x2, double& y1, double& y2);
\end{verbatim}
The function has to return the minimum and maximum x and y coordinates of the object $obj$.
\item a function for deciding whether the object intersects a box:
\begin{verbatim}
bool geowin_IntersectsBox(const TYPE& obj, double x1,
        double y1, double x2, double y2,bool f)
\end{verbatim}
This function gets the object obj, the coordinates of the box $x1,y1,x2,y2$ and a parameter $f$
(true, if the object is filled, false otherwise). The function should return true if
the object intersects the box $(x1, y1, x2, y2)$, false otherwise.

To register an additional type (that means a container class) for usage in 
edit scenes of $GeoWin$, you
have to call one of the two following functions:
\begin{verbatim}
template<class T> void geowin_init_default_type( T* t, string str);
template<class T> void geowin_init_basic_type(T* t,string str);
\end{verbatim}
str is a name desribing the container and its storage; it must be unique and is used for instance
for saving objects.
The first function will register the container class, build a scene prototype and set functions.
The second function will do the same, but it will not set an info-, translate-, rotate- and generate
function. That means that you have to provide in this case only the remaning functions and operators.
Register your additional types before creating a $GeoWin$.

\end{enumerate}


\ccFunction{void geowin_init_default_type( T* t, leda_string str);}
{ registers a type (container including geometric objects) for usage
  in scenes of $GeoWin$
  and links a scene typename $str$ with the real type. The container can be a \leda\ list 
  or an \stl\ list. Some functions and operators are required (see above).
}

\ccFunction{void geowin_init_basic_type(T* t,leda_string str);}
{ registers a type (container including geometric objects) for usage
  in scenes of $GeoWin$
  and links a scene typename $str$ with the real type. The container can be a \leda
  list or an \stl\ list. Some functions and operators are required (see above).
}

For the \cgal\ kernel types (using \stl\ lists as containers)  
2D Point, Line, Ray, Segment, Triangle, Iso Rectangle, Circle,
for the non kernel type Polygon and for the \cgal\ 3d kernel types Point,
Segment, Line, Ray, Triangle and Tetrahedron the required functions and operators
are already provided in $geowin\_support.h$ .
Note that when you use the $GeoWin$ library in the \cgal\ namespace (see Implementation), the
functions have to be in the \cgal\ namespace too.

\begin{ccClassTemplate}{geo_scene_traits<CONTAINER>}

\ccDefinition

It is also possible to encapsulate pointers to the required functions in a traits class.

\ccFunction{template<class CONTAINER> void geowin_init_default_type(geo_scene_traits<CONTAINER> tr);}
{ registers a type (container including geometric objects) for usage
  in scenes of $GeoWin$
  and links a scene typename with the real type. The container can be a \leda\ list 
  or an \stl\ list. Some functions and operators are required (see above).
}

The function pointers and the scene typename gets $tr$ in the constructor:
 
\ccCreation

\ccConstructor{geo_scene_traits<CONTAINER>(
                 leda_string (*info_fcn)(const CONTAINER\&), 
                 bool (*intersbox_fcn)(const VT\&, double, double, double, double, bool), 
                 void (*bbox_fcn)(const VT\&, double\&, double\&, double\&, double\&), 
                 void (*translate_fcn)(VT&, double, double), 
		 void (*rotate_fcn)(VT&, double, double, double), 
                 void (*generate_fcn)(VT&, CONTAINER&),
                 leda_string scene_type_name);}
{creates an object encapsulating the required function pointers and the scene typename
for registering scenes ($VT$ is CONTAINER::value\_type).}

\end{ccClassTemplate}

% +--------------------------------------------------------+
% restore default column and paragraph layout
\ccParDims

% EOF
