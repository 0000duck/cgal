% -*- latex -*-
% =============================================================================
% The CGAL Reference Manual
% Chapter: Geometric Optimisation
% Content: reference pages of package `Min_ellipse_2'
% -----------------------------------------------------------------------------
% file   : doc_tex/basic/Optimisation/Optimisation_ref/Approximate_min_ellipsoid_d.tex
% package: Approximate_min_ellipsoid_d
% author : Kaspar Fischer <fischerk@inf.ethz.ch>
% -----------------------------------------------------------------------------
% $Revision$
% $Date$
% =============================================================================

\newcommand{\vol}{\ensuremath{\mathop{{\textsc{vol}}}\nolimits}}
\newcommand{\mel}{\ensuremath{\mathop{{\textsc{mel}}}\nolimits}}
%\newcommand{\vol}{\ensuremath{\mathop{\rm vol}\nolimits}}
%\newcommand{\mel}{\ensuremath{\mathop{\rm mel}\nolimits}}

\begin{ccRefClass}{Approximate_min_ellipsoid_d<Traits>}

\ccIndexSubitem[t]{ellipse}{approximate smallest enclosing}
\ccIndexSubitem[t]{bounding volumes}{approximate smallest enclosing ellipsoid}

\ccSaveThreeColumns

% -----------------------------------------------------------------------------
\ccDefinition

An object of class \ccRefName\ is an approximation to the
ellipsoid of smallest volume enclosing a finite multiset of points
in $d$-dimensional Euclidean space~$\E^d$, $d\ge 2$.

An \emph{ellipsoid} in $\E^d$ is a Cartesian pointset of the form $\{
x\in\E^d \mid x^T E x + x^T e + \eta\leq 0 \}$, where $E$ is some
positive definite matrix from the set $\R^{d\times d}$, $e$ is some
real $d$-vector, and $\eta\in\R$.  A pointset $P\subseteq \E^d$ is
called \emph{full-dimensional} if its affine hull has dimension $d$.
For a finite, full-dimensional pointset $P$ we denote by $\mel(P)$ the
smallest ellipsoid that contains all points of $P$; this ellipsoid
exists and is unique.

%% i.e.~$me(P)=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$ if
%% $P=\mbox{\ccTexHtml{$\;\emptyset$}{&Oslash;}}$, $me(P)=\{p\}$ if
%% $P=\{p\}$, and $me(P) = \{ \mbox{\ccTexHtml{$(1-\lambda)p + \lambda q
%% \mid 0 \leq \lambda \leq 1$}{(1-l)p + l q | 0 <= l <= 1}} \}$ if
%% $P=\{p,q\}$.

For a given finite and full-dimensional pointset $P\subset \E^d$ and a
real number $\epsilon\ge 0$, we say that an ellipsoid ${\cal
E}\subset\E^d$ is a \emph{$(1+\epsilon)$-appoximation} to $\mel(P)$ if
$P\subset {\cal E}$ and $\vol({\cal E}) \leq (1+\epsilon)
\vol(\mel(P))$.  In other words, a $(1+\epsilon)$-approximation to
$\mel(P)$ is an enclosing ellipsoid whose volume is by at most a
factor of $1+\epsilon$ larger than the volume of the smallest
enclosing ellipsoid of $P$.

Given this notation, an object of class \ccRefName\ represents a
$(1+\epsilon)$-approximation to $\mel(P)$ for a given finite and
full-dimensional multiset of points $P\subset\E^d$ and a real constant
$\epsilon>0$.\footnote{A \emph{multiset} is a set where elements may
have multiplicity greater than~$1$.} When you construct the object,
you specify an iterator over the points $P$ and the number $\epsilon$,
which defines the \emph{desired approximation ratio} $1+\epsilon$.
The underlying algorithm will then try to compute a
$(1+\epsilon)$-approximation to $\mel(P)$, and one of the following
two cases takes place.
\begin{itemize}
\item The algorithm determines that $P$ is not full-dimensional (see
  \ccc{is_full_dimensional()} below).

  \emph{Important note:} due to rounding errors, the algorithm cannot
  in all cases decide correctly whether $P$ is full-dimensional or
  not.  If \ccc{is_full_dimensional()} returns \ccc{false}, the points
  lie in such a ``thin'' subspace of $\E^d$ that the algorithm is
  incapable of computing an approximation to $\mel(P)$.  More
  precisely, if \ccc{is_full_dimensional()} returns \ccc{false}, there
  exist two parallel hyperplanes in $\E^d$ with the points $P$ in
  between so that the distance $\delta$ between the hyperplanes is
  very small, possible zero. (If $\delta=0$ then $P$ is not
  full-dimensional.)

  If $P$ is not full-dimensional, you might want to use linear algebra
  techniques to determine an affine subspace $S$ of $\E^d$ that
  contains the points $P$ as a (w.r.t.\ $S$) full-dimensional
  pointset; once you have isolated $S$, you can invoke the algorithm
  again to compute an approximation to (the lower-dimensional)
  $\mel(P)$ in $S$.  Since \ccc{is_full_dimensional()} might (due to
  rounding errors, see above) return \ccc{false} even though $P$ is
  full-dimensional, the lower-dimensional subspace $S$ containing $P$
  need not exist.  Therefore, it might be more adivsable to fit a
  hyperplane $H$ through the pointset $P$, project $P$ onto this
  affine subspace $H$, and compute an approximation to the
  minimum-volume enclosing ellipsoid of the projected points within
  $H$; the fitting can be done for instance using the
  \ccc{linear_least_squares_fitting()} function from the \cgal package
  \ccc{Principal_component_analysis}.
\item The algorithm determines that $P$ is full-dimensional.  In this
  case, it provides an approximation ${\cal E}$ to $\mel(P)$, but
  depending on the input problem (i.e., on the pair $(P,\epsilon)$),
  it may not have achieved the desired approximation ratio but merely
  some \emph{worse} approximation ratio $1+\epsilon'>1+\epsilon$.  You
  can query the achieved approximation ratio $1+\epsilon'$ by calling
  \ccc{achieved_epsilon()}, which returns $\epsilon'$. The ellipsoid
  ${\cal E}$ itself can be queried via the methods
  \ccc{defining_matrix()}, \ccc{defining_vector()}, and
  \ccc{defining_scalar()}.
\end{itemize}

The ellipsoid ${\cal E}$ computed by the algorithm satisfies the inclusions
\begin{equation}
  \label{eq:approximate_min_ellipsoid_incl}
\frac{1}{(1+\epsilon')d} {\cal E} \subseteq \mathop{\rm
conv}\nolimits(P) \subseteq {\cal E}
\end{equation}
where $f {\cal E}$ denotes the ellipsoid ${\cal E}$ scaled by the
factor $f\in\R_+$ with respect to its center, and where $\mathop{\rm
conv}\nolimits(A)$ denotes the \emph{convex hull} of a pointset
$A\subset \E^d$.

The underlying algorithm can cope with all kinds of inputs (multisets
$P$, $\epsilon\in[0,\infty)$) and terminates in all cases.  There
is, however, no guarantee that any desired approximation ratio
is actually achieved; the performance of the algorithm in this respect
highly depends on the input pointset.  Values of at least $0.01$ for
$\epsilon$ are usually handled without problems.

Internally, the algorithm represents the input points' Cartesian
coordinates as \ccc{double}'s.  For this conversion to work, the input
point coordinates must be convertible to \ccc{double}.  Also, in order
to compute the achieved epsilon $\epsilon'$ from above, the algorithm
requires a number type \ccc{ET} that provides \emph{exact} arithmetic.
(Both these aspects are discussed in the documentation of model
\ccc{ApproximateMinEllipsoid_d_Traits_d}.)

\ccInclude{CGAL/Approximate_min_ellipsoid_d.h}

% -----------------------------------------------------------------------------
\ccRequirements
\ccIndexRequirements

The template parameter \ccc{Traits} is a model for
\ccc{ApproximateMinEllipsoid_d_Traits_d}.

We provide the model
\ccc{CGAL::Approximate_min_ellipsoid_d_traits_d<K>} using the
$d$-dimensional \cgal~kernel; the models
\ccc{CGAL::Approximate_min_ellipsoid_d_traits_2<K>} and
\ccc{CGAL::Approximate_min_ellipsoid_d_traits_3<K>} are for use with
the $2$- and $3$-dimensional \cgal~kernel, respectively.

% -----------------------------------------------------------------------------
\ccTypes
\ccIndexClassTypes

\ccSetTwoColumns{\ccRefName}{}

\ccNestedType{FT}{Typedef to \ccc{Traits::FT} (which is always a
typedef to \ccc{double}).}
\ccNestedType{ET}{Typedef to \ccc{Traits::ET} (which is an exact number type used for exact computation like for example in \ccc{achieved_epsilon()}).}
\ccNestedType{Point}{Typedef to
\ccc{Traits::Point}.}  \ccNestedType{Cartesian_const_iterator}{Typedef
to \ccc{Traits::Cartesian_const_iterator}.}

\ccPropagateThreeToTwoColumns

% -----------------------------------------------------------------------------
\ccCreation
\ccIndexClassCreation
\ccCreationVariable{ame}

An object of type \ccRefName\ can be created from an arbitrary point
set $P$ and some nonnegative \ccc{double} value \ccc{eps}.

\ccConstructor{ template < class Iterator >
                Approximate_min_ellipsoid_d(double eps,
		               Iterator  first,
                               Iterator  last,
                               const Traits&  traits    = Traits()   );}{
        initializes \ccVar\ to a $(1+\epsilon)$-approximation of
        $\mel(P)$ with $P$ being the set of points in the range
        [\ccc{first},\ccc{last}).  The number $\epsilon$ in this will
        be at most \ccc{eps}, if possible.  However, due to the
        limited precision in the algorithm's underlying arithmetic, it
        can happen that the computed approximation ellipsoid has a
        worse approximation ratio (and $\epsilon$ can thus be larger
        than \ccc{eps} in general).  In any case, the number
        $\epsilon$ (and with this, the achived approximation
        $1+\epsilon$) can be queried by calling the routine
        \ccc{achieved_epsilon()} discussed below.  \ccRequire
        \ccc{Iterator} must be a model for concept \ccc{InputIterator}
        with value type \ccc{Point}. \ccPrecond The dimension $d$ of
        the input points must be at least $2$.}

% -----------------------------------------------------------------------------
\ccAccessFunctions
\begin{ccIndexMemberFunctions}
\ccIndexMemberFunctionGroup{access}

The following methods can be used to query the achieved approximation
ratio $1+\epsilon'$ and the computed ellipsoid ${\cal E} = \{ x\in\E^d
\mid x^T E x + x^T e + \eta\leq 0 \}$.  The methods
\ccc{defining_matrix()}, \ccc{defining_vector()}, and
\ccc{defining_scalar()} do not return $E$, $e$, and $\eta$ directly
but yield multiples of these quantities that are exactly representable
using the \ccc{double} type.  (The parameters $E$, $e$, and $\eta$ of
the computed approximation ellipsoid ${\cal E}$ might not be exactly
representable as \ccc{double} numbers.)

\ccMemberFunction{unsigned int  number_of_points( ) const;}{
        returns the number of points of \ccVar, i.e., $|P|$.}

\ccMemberFunction{double achieved_epsilon() const;}{ returns a number
  $\epsilon'$ such that the computed approximation is (under exact
  arithmetic) guaranteed to be a $(1+\epsilon')$-approximation to
  $\mel(P)$.
\ccPrecond \ccc{\ccVar.is_full_dimensional()} is \ccc{true}.
\ccPostcond $\epsilon>0$.}

%\ccGlueBegin
%\ccMemberFunction{ Point_iterator  points_begin() const;}{
%        returns an iterator referring to the first point of \ccVar.}
%%
%\ccMemberFunction{ Point_iterator  points_end() const;}{
%        returns the corresponding past-the-end iterator.}
%\ccGlueEnd

\ccGlueBegin
\ccMemberFunction{double defining_matrix(int i,int j) const;}{
        gives access  to the $(i,j)$th entry of the matrix $E$ in the
	representation $\{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0
	\}$ of the computed approximation ellipsoid ${\cal E}$.  The number returned by
	this routine is $(1+\epsilon')(d+1)\,E_{ij}$, where $\epsilon'$ is
	the number returned by \ccc{achieved_epsilon()}.
	\ccPrecond $0\leq i,j\leq d$, where $d$ is the dimension
        of the points $P$, and \ccc{\ccVar.is_full_dimensional()} is \ccc{true}.}

\ccMemberFunction{double defining_vector(int i) const;}{
        gives access to the $i$th entry of the vector $e$ in the
	representation $\{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0
	\}$ of the computed approximation ellipsoid ${\cal E}$.  The number returned by
	this routine is $(1+\epsilon')(d+1)\,e_{i}$, where $\epsilon'$ is
	the number returned by \ccc{achieved_epsilon()}.
	\ccPrecond $0\leq i\leq d$, where $d$ is the dimension
        of the points $P$, and \ccc{\ccVar.is_full_dimensional()} is \ccc{true}.}
\ccMemberFunction{double defining_scalar() const;}{
        gives access to the scalar $\eta$ from the 
	representation $\{ x\in\E^d \mid x^T E x + x^T e + \eta\leq 0
	\}$ of the computed approximation ellipsoid ${\cal E}$.   The number returned by
	this routine is $(1+\epsilon')(d+1)\,\eta+1$, where $\epsilon'$ is
	the number returned by \ccc{achieved_epsilon()}.
	\ccPrecond \ccc{\ccVar.is_full_dimensional()} is \ccc{true}.}

\ccMemberFunction{ const Traits&  traits( ) const;}{
        returns a const reference to the traits class object.}
\ccGlueEnd


% -----------------------------------------------------------------------------
\ccPredicates
\ccIndexMemberFunctionGroup{predicates}

\ccMemberFunction{bool is_full_dimensional( ) const;}{ returns whether
        $P$ is full-dimensional or not, i.e., returns \ccc{true} if
        and only if $P$ is full-dimensional.  \\ \emph{Note:} due to
        the limited precision in the algorithm's underlying
        arithmetic, the result of this method is not always
        correct. Rather, a return value of \ccc{false} means that the
        points $P$ are contained in a ``very thin'' linear subspace of
        $\E^d$, and as a consequence, the algorithm cannot compute an
        approximation. More precisely, a return value of \ccc{false}
        means that the points $P$ are contained between two parallel
        hyperplanes in $\E^d$ that are very close to each other
        (possibly at distance zero) --- so close, that the algorithm
        could not compute an approximation ellipsoid.}

% -----------------------------------------------------------------------------
\ccHeading{Validity Check}
\ccIndexMemberFunctionGroup{validity check}
\lcTex{\ccIndexSubitem[t]{validity check}{\ccFont Min_ellipse_2}}

An object \ccVar\ is valid iff
\begin{itemize}
  \item \ccVar\ contains all points of its defining set $P$,
  \item \ccVar\ is a $(1+\epsilon)$-approximation to the smallest
    ellipsoid $\mel(P)$ of $P$,
  \item The ellipsoid represented by \ccVar\ fulfills the
  inclusion~(\ref{eq:approximate_min_ellipsoid_incl}).
\end{itemize}

\ccMemberFunction{ bool is_valid( bool verbose = false) const;}{
      returns \ccc{true} iff \ccVar\ is valid according to the above
      definition. If \ccc{verbose} is \ccc{true}, some messages
      concerning the performed checks are written to the standard error
      stream.}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}
\ccIndexMemberFunctionGroup{miscellaneous}

\def\ccTagRmConstRefPair{\ccFalse}

\ccMemberFunction{ void write_eps(const std::string& name) const;}{
        Writes the points $P$ and the computed approximation to
        $\mel(P)$ as an EPS-file under pathname \ccc{name}. \ccPrecond
        The dimension of points $P$ must be $2$.  \\ \emph{Note:} this
        routine is provided as a debugging routine; future version of
        \cgal\ might not provide it anymore.
	\ccPrecond \ccc{\ccVar.is_full_dimensional()} is \ccc{true}.}

\def\ccTagRmConstRefPair{\ccTrue}

\end{ccIndexMemberFunctions}

% -----------------------------------------------------------------------------
\ccSeeAlso

\ccRefIdfierPage{CGAL::Min_ellipse_2<Traits>}\\[1ex]

% -----------------------------------------------------------------------------
\ccImplementation
\ccIndexImplementation

We implement Khachyian's algorithm for rounding
polytopes~\cite{cgal:k-rprnm-96}.  Internally, we use
\ccc{double}-arithmetic and (initially a single)
Cholesky-decomposition.  The algorithm's running time is ${\cal
O}(nd^2(\epsilon^{-1}+\ln d + \ln\ln(n)))$, where $n=|P|$ and
$1+\epsilon$ is the desired approximation ratio.

%% @article{cgal:k-rprnm-96,
%%   Author = {L. Khachiyan},
%%   Date-Modified = {2005-02-01 14:18:59 +0100},
%%   Internal-No = {32},
%%   Journal = {Mathematics of Operations Research},
%%   Number = {2},
%%   Pages = {307--320},
%%   Title = {Rounding of polytopes in the real number model of computation},
%%   Volume = {21},
%%   Year = {1996}}

% -----------------------------------------------------------------------------
\ccExample
\ccIndexSubitem[C]{Min_ellipse_2}{example}

To illustrate the usage of \ccRefName\ we give two examples in 2D. The
first program generates a random set $P\subset\E^2$ and outputs the
points and a $1.01$-approximation of $\mel(P)$ as an EPS-file, which
you can view using {\tt gv}, for instance.  (In both examples you can
change the variables \ccc{n} and \ccc{d} to experiment with the code.)

\ccIncludeExampleCode{../examples/Approximate_min_ellipsoid_d/example.C}

The second program outputs the approximation in a format suitable
for display in Maplesoft's Maple.

\ccIncludeExampleCode{../examples/Approximate_min_ellipsoid_d/maple_example.C}

% -----------------------------------------------------------------------------

\ccRestoreThreeColumns

\end{ccRefClass}

% ===== EOF ===================================================================
