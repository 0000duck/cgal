%% =============================================================================
%% The CGAL Reference Manual
%% Chapter: STL Extensions - The Reference Part
%% -----------------------------------------------------------------------------
%% file  : doc_tex/support/STL_Extension/STL_Extension_ref/stl_extension.tex
%% author: Michael Hoffmann, Lutz Kettner 
%% -----------------------------------------------------------------------------
%% $CGAL_Chapter: STL_Extension $
%% $Revision$
%% $Date$
%% =============================================================================

%% +=========================================================================+

%% +---------------------------------------------+
\begin{ccRefFunction}{predecessor}
  \label{sectionPredecessor}
  \label{sectionGenericFunctions}

  \ccDefinition The function \ccRefName\ returns the previous iterator,
  i.e. the result of \ccc{operator--} on a bidirectional iterator.
  
  \ccInclude{CGAL/algorithm.h}
  
  \ccThree{BidirectionalIterator}{predecessor}{}
  \ccFunction{template <class BidirectionalIterator>
              BidirectionalIterator predecessor(BidirectionalIterator it);}
    {returns \ccc{--it}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::successor}
\end{ccRefFunction}

%% +---------------------------------------------+
\begin{ccRefFunction}{successor}
  \label{sectionSuccessor}

  \ccDefinition The function \ccRefName\ returns the next iterator, i.e.
  the result of \ccc{operator++} on a forward iterator.
  
  \ccInclude{CGAL/algorithm.h}
  
  \ccThree{ForwardIterator}{successor}{}
  \ccFunction{template <class ForwardIterator>
              ForwardIterator successor(ForwardIterator it);}
    {returns \ccc{++it}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::predecessor}
\end{ccRefFunction}

%% +---------------------------------------------+
\begin{ccRefFunction}{copy_n}
  \label{sectionCopyN}

  \ccDefinition The function \ccRefName\ copies $n$ items from an
  input iterator to an output iterator which is useful for possibly
  infinite
  sequences of random geometric objects.\footnote{%
    The \stl\ release June 13, 1997, from SGI contains an equivalent
    function, but it is not part of the ISO standard.}
  
  \ccInclude{CGAL/algorithm.h}
  
  \ccThree{OutputIterator}{copy_n}{}
  \ccFunction{template <class InputIterator, class Size, class
    OutputIterator> OutputIterator copy_n(InputIterator first, Size n,
    OutputIterator result);}{copies the first $n$ items from
    \ccc{first} to \ccc{result}. Returns the value of \ccc{result}
    after inserting the $n$ items.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Counting_iterator<Iterator, Value>}
\end{ccRefFunction}

%% +---------------------------------------------+
\begin{ccRefFunction}{min_max_element}
  \label{sectionMinmaxelement}
  
  \ccDefinition The function \ccRefName\ computes the minimal and the
  maximal element of a range. It is modeled after the STL functions
  \ccc{min_element} and \ccc{max_element}. The advantage of
  \ccc{min_max_element} compared to calling both STL functions is that
  one only iterates once over the sequence. This is more efficient
  especially for large and/or complex sequences.

  \ccInclude{CGAL/algorithm.h}
  
  \ccFunction{template < class ForwardIterator > std::pair<
    ForwardIterator, ForwardIterator > min_max_element(ForwardIterator
    first, ForwardIterator last);}{returns a pair of iterators where
    the first component refers to the minimal and the second component
    refers to the maximal element in the range [\ccc{first},
    \ccc{last}). The ordering is defined by \ccc{operator<} on the
    value type of \ccc{ForwardIterator}.}
  
  \ccFunction{template < class ForwardIterator, class CompareMin,
    class CompareMax > std::pair< ForwardIterator, ForwardIterator >
    min_max_element(ForwardIterator first, ForwardIterator last,
    CompareMin comp_min, CompareMax comp_max);}{returns a pair of
    iterators where the first component refers to the minimal and the
    second component refers to the maximal element in the range
    [\ccc{first}, \ccc{last}). \ccRequire
    \ccc{CompareMin} and \ccc{CompareMax} are adaptable binary
    function objects:
    \ccc{VT}~$\times$~\ccc{VT}~$\rightarrow$~\ccc{bool} where \ccc{VT}
    is the value type of \ccc{ForwardIterator}.}
  
  \ccExample The following example program computes the minimal and
  maximal element of the sequence $(3,\,6,\,5)$. Hence the output is
  \ccc{min = 3, max = 6}.
  
  \ccIncludeVerbatim{STL_Extension_ref/min_max_element_example_noheader.C}

\end{ccRefFunction}

%% Michael: I commented these, as I think they should be replaced by combining 
%% Filter_iterator with std::min/max_element().
%%
%% %% +---------------------------------------------+
%% \begin{ccRefFunction}{min_element_if}
%%   \label{sectionMinElementIf}
  
%%   \ccDefinition The function \ccRefName\ computes the minimum among
%%   the elements of a range which satisfy a certain predicate. It is
%%   modeled after the STL function \ccc{min_element}.

%%   \ccInclude{CGAL/algorithm.h}
  
%%   \ccFunction{template < class ForwardIterator, class Predicate >
%%     ForwardIterator min_element_if(ForwardIterator first,
%%     ForwardIterator last, Predicate pred);}{returns an iterator
%%     referring to the minimal element among those satifying the
%%     predicate \ccc{pred} in the range [\ccc{first}, \ccc{last}). The
%%     ordering is defined by the \ccc{operator<} on \ccc{VT} where
%%     \ccc{VT} is the value type of \ccc{ForwardIterator}.
%%     \ccRequire \ccc{pred} is an unary function
%%     object: \ccc{VT}~$\rightarrow$~\ccc{bool}.}
  
%%   \ccFunction{template < class ForwardIterator, class Compare, class
%%     Predicate > ForwardIterator min_element_if(ForwardIterator first,
%%     ForwardIterator last, Compare comp, Predicate pred);} {return an
%%     iterator referring to the minimal element among those satifying
%%     the predicate \ccc{pred} in the range [\ccc{first}, \ccc{last}).
%%     The ordering is defined by \ccc{comp}.
%%     \ccRequire \ccc{comp} is a binary function
%%     object: \ccc{VT}~$\times$~\ccc{VT}~$\rightarrow$~\ccc{bool} where
%%     \ccc{VT} is the value type of \ccc{ForwardIterator}. \ccc{pred} is
%%     an unary function object: \ccc{VT}~$\rightarrow$~\ccc{bool}.}
  
%%   \ccSeeAlso
%%   \ccRefIdfierPage{CGAL::max_element_if}\\
%%   \ccRefIdfierPage{CGAL::min_max_element}

%%   \ccExample The following example program computes the minimal odd
%%   element of the sequence $(3,\,5,\,2)$. Hence the output is
%%   \ccc{min_odd = 3}.
  
%%   \ccIncludeVerbatim{STL_Extension_ref/min_element_if_example_noheader.C}

%% \end{ccRefFunction}

%% %% +---------------------------------------------+
%% \begin{ccRefFunction}{max_element_if}
  
%%   \ccDefinition The function \ccRefName\ computes the maximum among
%%   the elements of a range which satisfy a certain predicate. It is
%%   modeled after the STL function \ccc{max_element}.

%%   \ccInclude{CGAL/algorithm.h}
  
%%   \ccFunction{template < class ForwardIterator, class Predicate >
%%     ForwardIterator max_element_if(ForwardIterator first,
%%     ForwardIterator last, Predicate pred);}{returns an iterator
%%     referring to the maximal element among those satifying the
%%     predicate \ccc{pred} in the range [\ccc{first}, \ccc{last}). The
%%     ordering is defined by the \ccc{operator<} on \ccc{VT} where
%%     \ccc{VT} is the value type of \ccc{ForwardIterator}.
%%     \ccRequire \ccc{pred} is an unary function
%%     object: \ccc{VT}~$\rightarrow$~\ccc{bool}.}
  
%%   \ccFunction{template < class ForwardIterator, class Compare, class
%%     Predicate > ForwardIterator max_element_if(ForwardIterator first,
%%     ForwardIterator last, Compare comp, Predicate pred);} {return an
%%     iterator referring to the maximal element among those satifying
%%     the predicate \ccc{pred} in the range [\ccc{first}, \ccc{last}).
%%     The ordering is defined by \ccc{comp}.
%%     \ccRequire \ccc{comp} is a binary function
%%     object: \ccc{VT}~$\times$~\ccc{VT}~$\rightarrow$~\ccc{bool} where
%%     \ccc{VT} is the value type of \ccc{ForwardIterator}. \ccc{pred} is
%%     an unary function object: \ccc{VT}~$\rightarrow$~\ccc{bool}.}

%%   \ccSeeAlso
%%   \ccRefIdfierPage{CGAL::min_element_if}\\
%%   \ccRefIdfierPage{CGAL::min_max_element}

%% \end{ccRefFunction}

%% +=========================================================================+

\begin{ccRefClass}{Emptyset_iterator}
  \label{sectionEmptysetIterator}

  \ccCreationVariable{i}
  
  \ccDefinition The class \ccClassName\ defines an
  \ccc{OutputIterator} that ignores everything written to it. One can
  think of it as being connected to \texttt{/dev/null}.

  \ccInclude{CGAL/iterator.h}

  \ccIsModel
  \ccc{OutputIterator}
  
  \ccCreation

  \ccTwo{Emptyset_iterator()}{}
  
  \ccConstructor{Emptyset_iterator();}{default constructor.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Oneset_iterator}

\end{ccRefClass}

\begin{ccRefClass}{Oneset_iterator<T>}
  \label{sectionOnesetIterator}

  \ccCreationVariable{i}
  
  \ccDefinition The class \ccClassTemplateName\ defines an
  \ccc{OutputIterator} that always refers to one specific object of
  type \ccc{T}.
  
  \ccInclude{CGAL/iterator.h}

  \ccIsModel
  \ccc{OutputIterator}
  
  \ccCreation

  \ccTwo{Oneset_iterator(T& t);}{}
  
  \ccTagFullDeclarations\ccConstructor{Oneset_iterator(T& t);}{creates
    an iterator referring to \ccc{t}.}\ccTagDefaults
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Emptyset_iterator}

\end{ccRefClass}

%% +--------------------------------------------------------+
\begin{ccRefClass}{Counting_iterator<Iterator, Value>}
  \label{sectionCountingIterator}

  \ccCreationVariable{i}
  
  \ccDefinition The iterator adaptor \ccClassTemplateName\ adds a
  counter to the internal iterator of type \ccc{Iterator} and defines
  equality of two instances in terms of this counter. It can be used
  to create finite sequences of possibly infinite sequences of values
  from input iterators.

  \ccInclude{CGAL/iterator.h}

  \ccIsModel
  \ccc{InputIterator}
  
  \ccRequirements \ccc{Iterator} is a model for
  \ccc{InputIterator}.

  \ccCreation

  \ccTwo{Identity<Value>MMMMMM}{}
  
  \ccConstructor{Counting_iterator( std::size_t n = 0);}{initializes
    the internal counter to $n$ and \ccVar\ has a singular value.}
  
  \ccConstructor{Counting_iterator( Iterator j, std::size_t n = 0);}{
    initializes the internal counter to $n$ and \ccVar\ to $j$.}

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::copy_n}

\end{ccRefClass}

%% +--------------------------------------------------------+
\begin{ccRefClass}{Insert_iterator<Container>}
  \label{sectionInsertIterator}

  \ccCreationVariable{i}
  
  \ccDefinition The output iterator \ccClassTemplateName\ is similar
  to \ccc{std::insert_iterator}, but differs in that it calls the
  \ccc{insert()} function of the container without the iterator
  additional argument.

  \ccInclude{CGAL/iterator.h}

  \ccIsModel
  \ccc{OutputIterator}
  
  \ccRequirements \ccc{Container} provides a member function
  \ccc{insert(const Container::const_reference&)}.

  \ccCreation

  \ccTwo{Identity<Value>MMMMMM}{}
  
  \ccConstructor{Insert_iterator( Container &c );}{initializes
    the internal container reference to $c$.}

  There is also a global function similar to \ccc{std::inserter}:

  \ccFunction{template < class Container >
              Insert_iterator<Container>
              inserter(Container &x);}
  { Constructs \ccc{Insert_iterator<Container>(x)}. }
  
\end{ccRefClass}

%% +--------------------------------------------------------+
\begin{ccRefClass}{N_step_adaptor<I,int N>}
  \ccCreationVariable{i}
  
  \ccDefinition The adaptor \ccRefName\ changes the step width of the
  iterator or circulator class \ccStyle{I} to $N$. It is itself an
  iterator or circulator respectively. The behavior is undefined if
  the adaptor is used on a range [$i,j$) where $j-i$ is not a multiple
  of $n$.
  
  \ccInclude{CGAL/iterator.h}
  
  \ccCreation
  \ccTwo{N_step_adaptor<I,int N> i( I j);;M}{}
  
  \ccConstructor{N_step_adaptor(const I& j);}{down cast.}
  
\end{ccRefClass}

\begin{ccRefClass}{Filter_iterator<Iterator, Predicate>}
  \label{sectionFilterIterator}

  \ccCreationVariable{i}
  
  \ccDefinition The iterator adaptor \ccClassTemplateName\ acts as a
  filter on a given range. Whenever the iterator is in-- or
  decremented, it ignores all iterators for which the given
  \ccc{Predicate} is true. The iterator category is the same as for
  \ccc{Iterator}.

  \ccInclude{CGAL/iterator.h}
  
  \ccRequirements
  \begin{itemize}
  \item \ccc{Iterator} is a model for \ccc{ForwardIterator}.
  \item \ccc{Predicate} is a functor: \ccc{Iterator} $\rightarrow$
    \ccc{bool}.
  \end{itemize}

  \ccCreation

  %%\ccTwo{Identity<Value>MMMMMM}{}
  
  \ccConstructor{Filter_iterator();}{}
  
  \ccConstructor{Filter_iterator(Iterator e, Predicate p, Iterator c = e);}
   {creates an iterator which filters values according to \ccc{p}.
    Initializes by taking the first valid iterator (according to \ccc{p}),
    starting at \ccc{c}, and stopping at \ccc{e} if none is found.}

\end{ccRefClass}

%% +---------------------------------------------+

\begin{ccRefClass}{Join_input_iterator_1<Iterator, Creator>}
  \label{sectionJoinInputIterator}
  
  \ccDefinition The class \ccRefName\ joins an input iterator and a
  creator function object. The result is again an input iterator which
  reads an object from the stream and applies the creator function
  object to that object whenever it advances.

  \ccInclude{CGAL/iterator.h}
  
  \ccIsModel \ccc{InputIterator}

  \ccTypes
  \ccNestedType{value_type}{typedef to \ccc{Creator::result_type}.}
  
  \ccCreation\ccCreationVariable{join}
  
  \ccConstructor{Join_input_iterator_1( Iterator i);} {the join of a
    single iterator $i$. Applies \ccc{Creator} to each item read from
    $i$.}

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Creator_1<Arg, Result>}
\end{ccRefClass}


%%  +--------------------------------------------------------+
\begin{ccRefClass}{Inverse_index<IC>}
  
  \ccDefinition The class \ccClassTemplateName\ constructs an inverse
  index for a given range [$i,j$) of two iterators or circulators of
  type \ccc{IC}.  The first element $I$ in the range [$i,j$) has the
  index 0.  Consecutive elements are numbered incrementally. The
  inverse index provides a query for a given iterator or circulator
  $k$ to retrieve its index number. {\em Precondition:}\/ The iterator
  or circulator must be either of the random access category or the
  dereference operator must return stable and distinguishable
  addresses for the values, e.g.~proxies or non-modifiable iterator
  with opaque values will not work.

  \ccInclude{CGAL/iterator.h}

  \ccCreation\ccCreationVariable{inverse}
  
  \ccTwo{Inverse_index< IC,> inverse( IC i, IC j);;}{}
  \ccConstructor{Inverse_index();}{invalid index.}
  
  \ccGlue\ccConstructor{Inverse_index( const IC& i);}{empty inverse
    index initialized to start at $i$.}
  
  \ccGlue\ccConstructor{Inverse_index( const IC& i, const IC& j);}
  {inverse index initialized with range [$i,j$).}

  \ccOperations
  \ccThree{std::size_t}{inverse.find( const T* p);}{}
  
  \ccMethod{std::size_t operator[]( const IC& k);}{returns inverse
    index of $k$. \ccPrecond $k$ has been stored in the inverse
    index.}
  
  \ccMethod{void push_back( const IC& k);}{adds $k$ at the end of the
    indices.}

  \ccImplementation
  
  For random access iterators or circulators, it is done in constant
  time by subtracting $i$. For other iterator categories, an \stl\ 
  \ccc{map} is used, which results in a $\log j-i$ query time. The
  comparisons are done using the operator \ccc{operator<} on pointers.

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Random_access_adaptor<IC>}\\
  \ccRefIdfierPage{CGAL::Random_access_value_adaptor<IC,T>}

\end{ccRefClass}

%% +--------------------------------------------------------+
\begin{ccRefClass}{Random_access_adaptor<IC>}
  
  \ccDefinition The class \ccClassTemplateName\ provides a random
  access for data structures. Either the data structure supports
  random access iterators or circulators where this class maps
  function calls to the iterator or circulator, or a \stl\ 
  \ccc{std::vector} is used to provide the random access. The iterator
  or circulator of the data structure are of type \ccc{IC}.

  \ccInclude{CGAL/iterator.h}

  \ccTypes

  \ccNestedType{size_type}{size type of the \stl\ \ccc{std::vector}.}

  \ccCreation\ccCreationVariable{random_access}

  \ccTwo{Random_access_adaptor< IC> random_access;}{}
  \ccConstructor{Random_access_adaptor();}{invalid index.}
  
  \ccConstructor{Random_access_adaptor( const IC& i);} {empty random
    access index initialized to start at $i$.}
  
  \ccConstructor{Random_access_adaptor( const IC& i, const IC& j);}
  {random access index initialized to the range [$i,j$).}
  
  \ccThree{Dist}{random_access.push_back( IC k);}{} \ccMethod{void
    reserve( size_type r);}{reserve $r$ entries, if a
    \ccc{std::vector} is used internally.}
  
  \ccOperations
  
  \ccMethod{IC operator[]( size_type n);}{returns iterator or
    circulator to the $n$-th item.  \ccPrecond $n <$ number of items
    in \ccVar.}
  
  \ccMethod{void push_back( const IC& k);}{adds $k$ at the end of the
    indices.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Inverse_index<IC>}\\
  \ccRefIdfierPage{CGAL::Random_access_value_adaptor<IC,T>}

\end{ccRefClass}


%% +--------------------------------------------------------+
\begin{ccRefClass}{Random_access_value_adaptor<IC,T>}
  
  \ccDefinition The class \ccClassTemplateName\ provides a random
  access for data structures. It is derived from
  \ccc{Random_access_adaptor<IC>}. Instead of returning iterators from
  the \ccc{operator[]} methods, it returns the dereferenced value of
  the iterator.  The iterator or circulator of the data structure are
  of type \ccc{IC}. Their value type is $T$.

  \ccInclude{CGAL/iterator.h}

  \ccOperations
  
  Creation and operations see \ccc{Random_access_adaptor<IC>}, with
  the exception of:
  
  \ccCreationVariable{random_access}

  \ccThree{Dist}{random_access.push_back( IC k);}{}
  
  \ccMethod{T& operator[]( size_type n);}{returns a reference to the
    $n$-th item.  \ccPrecond $n <$ number of items in \ccVar.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Inverse_index<IC>}\\
  \ccRefIdfierPage{CGAL::Random_access_adaptor<IC>}

\end{ccRefClass}

%% +=========================================================================+

%% +-----------------------------------------------------------------+

\begin{ccRefFunction}{swap_1}
  \ccDefinition The function \ccRefName\ is used to swap the arguments
  of a functor. The result is a functor $f'$ that calls the original
  functor $f$ with the first two arguments exchanged, that is
  $f'(x,y,\ldots)= f(y,x,\ldots)$.
  
  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < class F > typename Swap<F,1>::Type
    swap_1(const F& f);}{returns a functor equivalent to \ccc{f}, but
    where the first two arguments are exchanged.
    \ccRequire F is a model for
    \ccc{AdaptableFunctor} with arity $2 \le ar \le 5$.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Swap<F,i>}\\
  \ccRefIdfierPage{CGAL::swap_2}\\
  \ccRefIdfierPage{CGAL::swap_3}\\
  \ccRefIdfierPage{CGAL::swap_4}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{swap_2}
  \ccDefinition The function \ccRefName\ is used to swap the arguments
  of a functor. The result is a functor $f'$ that calls the original
  functor $f$ with the second and third argument exchanged, that is
  $f'(x,y,z,\ldots)= f(x,z,y,\ldots)$.
  
  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < class F > typename Swap<F,2>::Type
    swap_2(const F& f);}{returns a functor equivalent to \ccc{f}, but
    where the second and third argument are exchanged.
    \ccRequire F is a model for
    \ccc{AdaptableFunctor} with arity $3 \le ar \le 5$.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Swap<F,i>}\\
  \ccRefIdfierPage{CGAL::swap_1}\\
  \ccRefIdfierPage{CGAL::swap_3}\\
  \ccRefIdfierPage{CGAL::swap_4}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{swap_3}
  \ccDefinition The function \ccRefName\ is used to swap the arguments
  of a functor. The result is a functor $f'$ that calls the original
  functor $f$ with the third and fourth argument exchanged, that is
  $f'(w,x,y,z,\ldots)= f(w,x,z,y,\ldots)$.
  
  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < class F > typename Swap<F,3>::Type
    swap_3(const F& f);}{returns a functor equivalent to \ccc{f}, but
    where the third and fourth argument are exchanged.
    \ccRequire F is a model for
    \ccc{AdaptableFunctor} with arity $4 \le ar \le 5$.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Swap<F,i>}\\
  \ccRefIdfierPage{CGAL::swap_1}\\
  \ccRefIdfierPage{CGAL::swap_2}\\
  \ccRefIdfierPage{CGAL::swap_4}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{swap_4}
  \ccDefinition The function \ccRefName\ is used to swap the arguments
  of a functor. The result is a functor $f'$ that calls the original
  functor $f$ with the fourth and fifth argument exchanged, that is
  $f'(v,w,x,y,z)= f(v,w,x,z,y)$.
  
  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < class F > typename Swap<F,4>::Type
    swap_4(const F& f);}{returns a functor equivalent to \ccc{f}, but
    where the fourth and fifth argument are exchanged.
    \ccRequire F is a model for
    \ccc{AdaptableFunctor} with arity $5$.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Swap<F,i>}\\
  \ccRefIdfierPage{CGAL::swap_1}\\
  \ccRefIdfierPage{CGAL::swap_2}\\
  \ccRefIdfierPage{CGAL::swap_3}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{bind_1}
  \ccDefinition The function \ccRefName\ is used to bind the first
  argument of a functor to some specific value. The result is a
  functor that takes one argument less and calls the original functor
  where the first argument is set to the bound value.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{typename Bind< F, A, 1 >::Type}{bind_1}{}
  
  \ccFunction{template < class F, class A > typename Bind< F, A, 1
    >::Type bind_1(const F& f, const A& a);}{returns a functor
    equivalent to \ccc{f}, but where the first argument is bound
    (fixed) to \ccc{a}.  \ccRequire F is a model for
    \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Bind<F,A,i>}\\
  \ccRefIdfierPage{CGAL::bind_2}\\
  \ccRefIdfierPage{CGAL::bind_3}\\
  \ccRefIdfierPage{CGAL::bind_4}\\
  \ccRefIdfierPage{CGAL::bind_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{bind_2}
  \ccDefinition The function \ccRefName\ is used to bind the second
  argument of a functor to some specific value. The result is a
  functor that takes one argument less and calls the original functor
  where the second argument is set to the bound value.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{typename Bind< F, A, 1 >::Type}{bind_1}{}
  
  \ccFunction{template < class F, class A > typename Bind< F, A, 2
    >::Type bind_2(const F& f, const A& a);}{returns a functor
    equivalent to \ccc{f}, but where the second argument is bound
    (fixed) to \ccc{a}.  \ccRequire F is a model for
    \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Bind<F,A,i>}\\
  \ccRefIdfierPage{CGAL::bind_1}\\
  \ccRefIdfierPage{CGAL::bind_3}\\
  \ccRefIdfierPage{CGAL::bind_4}\\
  \ccRefIdfierPage{CGAL::bind_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{bind_3}
  \ccDefinition The function \ccRefName\ is used to bind the third
  argument of a functor to some specific value. The result is a
  functor that takes one argument less and calls the original functor
  where the third argument is set to the bound value.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{typename Bind< F, A, 1 >::Type}{bind_1}{}
  
  \ccFunction{template < class F, class A > typename Bind< F, A, 3
    >::Type bind_3(const F& f, const A& a);}{returns a functor
    equivalent to \ccc{f}, but where the third argument is bound
    (fixed) to \ccc{a}.  \ccRequire F is a model for
    \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Bind<F,A,i>}\\
  \ccRefIdfierPage{CGAL::bind_1}\\
  \ccRefIdfierPage{CGAL::bind_2}\\
  \ccRefIdfierPage{CGAL::bind_4}\\
  \ccRefIdfierPage{CGAL::bind_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{bind_4}
  \ccDefinition The function \ccRefName\ is used to bind the fourth
  argument of a functor to some specific value. The result is a
  functor that takes one argument less and calls the original functor
  where the fourth argument is set to the bound value.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{typename Bind< F, A, 1 >::Type}{bind_1}{}
  
  \ccFunction{template < class F, class A > typename Bind< F, A, 4
    >::Type bind_4(const F& f, const A& a);}{returns a functor
    equivalent to \ccc{f}, but where the fourth argument is bound
    (fixed) to \ccc{a}.  \ccRequire F is a model for
    \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Bind<F,A,i>}\\
  \ccRefIdfierPage{CGAL::bind_1}\\
  \ccRefIdfierPage{CGAL::bind_2}\\
  \ccRefIdfierPage{CGAL::bind_3}\\
  \ccRefIdfierPage{CGAL::bind_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{bind_5}
  \ccDefinition The function \ccRefName\ is used to bind the fifth
  argument of a functor to some specific value. The result is a
  functor that takes one argument less and calls the original functor
  where the fifth argument is set to the bound value.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{typename Bind< F, A, 1 >::Type}{bind_1}{}
  
  \ccFunction{template < class F, class A > typename Bind< F, A, 5
    >::Type bind_5(const F& f, const A& a);}{returns a functor
    equivalent to \ccc{f}, but where the fifth argument is bound
    (fixed) to \ccc{a}.  \ccRequire F is a model for
    \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Bind<F,A,i>}\\
  \ccRefIdfierPage{CGAL::bind_1}\\
  \ccRefIdfierPage{CGAL::bind_2}\\
  \ccRefIdfierPage{CGAL::bind_3}\\
  \ccRefIdfierPage{CGAL::bind_4}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{compare_to_less}
  \ccDefinition The function \ccRefName\ is used to change a functor
  returning a \ccc{Comparison_result} to one which returns a bool.
  The returned functor will return \ccc{true} iff the original one
  returns \ccc{SMALLER}.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccThree{typename Compare_to_less< F >::Type}{compare_to_less}{}
  
  \ccFunction{template < class F > Compare_to_less< F >
     compare_to_less(const F& f);}{returns a functor
    equivalent to \ccc{f}, but which returns a bool instead of a
    \ccc{Comparison_result}.  \ccRequire F is a model for
    \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Compare_to_less<F>}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{compose}
  \ccDefinition The function \ccRefName\ is used to
  \ccHtmlNoLinksFrom{compose} functors $f_0,\,\ldots,\,f_n$ into each
  other, thereby creating a new functor $f$. The first argument $f_0$
  always denotes the base functor, for which the remaining functors
  $f_1,\,\ldots,\,f_n$ provide the arguments. If we denote the arity
  of a functor $f$ by $ar(f)$, then $ar(f) = \sum_{i=1}^n ar(f_i)$,
  i.e., the arguments of $f$ are distributed among
  $f_1,\,\ldots,\,f_n$ according to their respective arity. Between
  one and three functors can be \ccHtmlNoLinksFrom{composed} into the
  base functor, giving raise to a functor of arity at most five.
  
  As an example, consider a binary functor $f_0$ and two functors
  $f_1$ and $f_2$, with arity three and two, respectively. Composing
  $f_1$ and $f_2$ into $f_0$ yields a new functor
  $$
  f\::\:(x_0,\,x_1,\,x_2,\,x_3,\,x_4) \mapsto
  f_0\left(f_1(x_0,\,x_1,\,x_2),\,f_2(x_3,\,x_4)\right)
  $$
  with arity five. 

  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < class F0, class F1 > typename Compose< F0, F1
    >::Type compose(const F0& f0, const F1& f1);}{returns the functor
    \ccc{f0}(\ccc{f1}($\cdot$)) with the same arity as \ccc{f1}.
    \ccRequire \ccc{f0} is unary function
    (arity~1). \ccc{f0} and \ccc{f1} are models for
    \ccc{AdaptableFunctor}.}
  
  \ccFunction{template < class F0, class F1, class F2 > typename
    Compose< F0, F1, F2 >::Type compose(const F0& f0, const F1& f1,
    const F2& f2);}{returns the functor
    \ccc{f0}(\ccc{f1}($\cdot$),$\,$\ccc{f2}($\cdot$)) with arity equal
    to $ar(\ccc{f1})+ar(\ccc{f2})$. \ccRequire
    \ccc{f0} is binary function (arity~2). \ccc{f0}, \ccc{f1}, and
    \ccc{f2} are models for \ccc{AdaptableFunctor}.}
  
  \ccFunction{template < class F0, class F1, class F2, class F3 >
    typename Compose< F0, F1, F2, F3 >::Type compose(const F0& f0,
    const F1& f1, const F2& f2, const F3& f3);}{returns the functor
    \ccc{f0}(\ccc{f1}($\cdot$),$\,$\ccc{f2}($\cdot$),$\,$\ccc{f3}($\cdot$))
    with arity equal to $ar(\ccc{f1})+ar(\ccc{f2})+ar(\ccc{f3})$.
    \ccRequire \ccc{f0} is ternary function
    (arity~3). \ccc{f0}, \ccc{f1}, \ccc{f2}, and \ccc{f3} are models
    for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Compose<F0,F1,F2,F3>}\\
  \ccRefIdfierPage{CGAL::compose_shared}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{compose_shared}
  \ccDefinition The function \ccRefName\ is used to
  \ccHtmlNoLinksFrom{compose} functors $f_0,\,\ldots,\,f_n$ into each
  other, thereby creating a new functor $f$. The first argument $f_0$
  always denotes the base functor, for which the remaining functors
  $f_1,\,\ldots,\,f_n$ provide the arguments. Contrary to the function
  \ccc{compose}, the arguments of $f$ are not split among
  $f_1,\,\ldots,\,f_n$, but instead shared by all the
  functors. Therefore, all the functors $f_1,\,\ldots,\,f_n$ must have
  the same arity, which is also the arity of the composed functor
  $f$. Two or three functors can be composed into the base functor,
  giving raise to a functor of arity at most five.
  
  As an example, consider a binary functor $f_0$ and two binary
  functors $f_1$ and $f_2$. Composing $f_1$ and $f_2$ into $f_0$
  yields a new binary functor
  $$
  f\::\: (x_0,\,x_1) \mapsto
  f_0\left(f_1(x_0,\,x_1),\,f_2(x_0,\,x_1)\right)\;.
  $$
  
  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < class F0, class F1, class F2 > typename
    Compose_shared< F0, F1, F2 >::Type compose_shared(const F0& f0,
    const F1& f1, const F2& f2);}{returns the functor
    \ccc{f0}(\ccc{f1}($\cdot$),$\,$\ccc{f2}($\cdot$)) with the same
    arity as $f1$ (and $f2$). \ccRequire \ccc{f0}
    is \ccc{AdaptableFunctor} of arity~2. \ccc{f1} and \ccc{f2} are
    \ccc{AdaptableFunctor}s having the same arity.}
  
  \ccFunction{template < class F0, class F1, class F2, class F3 >
    typename Compose_shared< F0, F1, F2, F3 >::Type
    compose_shared(const F0& f0, const F1& f1, const F2& f2, const F3&
    f3);}{returns the functor
    \ccc{f0}(\ccc{f1}($\cdot$),$\,$\ccc{f2}($\cdot$),$\,$\ccc{f3}($\cdot$))
    with the same arity as $f1$ (and $f2$, $f3$).
    \ccRequire \ccc{f0} is \ccc{AdaptableFunctor}
    of arity~3. \ccc{f1}, \ccc{f2}, and \ccc{f3} are
    \ccc{AdaptableFunctor}s having the same arity.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Compose_shared<F0,F1,F2,F3>}\\
  \ccRefIdfierPage{CGAL::compose}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{negate}
  \ccDefinition The function \ccRefName\ is a functor adaptor. For a
  given functor $f$, it creates a new functor $f'$ which is the
  negation of $f$. That is, $f' = !f$.

  \ccInclude{CGAL/functional.h}
  
  \ccFunction{template < typename F > typename Compose<
    std::logical_not<typename F::result_type>, F >::Type negate(const
    F& f);}{returns the functor \ccc{!f} with the same arity as
    \ccc{f}. \ccRequire \ccc{f} is a model for \ccc{AdaptableFunctor}.
    Unary negation is defined for \ccc{F::result_type}. }
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Compose<F0,F1,F2,F3>}\\
  \ccRefIdfierPage{CGAL::compose}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefClass}{Swap<F,i>}
  \ccDefinition The class \ccRefName\ is used to specify the type of a
  functor where the arguments \ccc{i} and \ccc{i+1} have been swapped.
  The class is used in conjunction with the \ccc{swap} functions.

  \ccInclude{CGAL/functional.h}

  \ccTypes
  \ccNestedType{Type}{the functor type.}
  
  \ccHeading{Notes} This class encapsulates differences in
  implementation across various platforms. But in any case, \ccc{Type}
  refers to a model of \ccc{AdaptableFunctor}.

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::swap_1}\\
  \ccRefIdfierPage{CGAL::swap_2}\\
  \ccRefIdfierPage{CGAL::swap_3}\\
  \ccRefIdfierPage{CGAL::swap_4}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefClass}

\begin{ccRefClass}{Bind<F,A,i>}
  \ccDefinition The class \ccRefName\ is used to specify the type of a
  bound functor of type \ccc{F}, i.e., where the \ccc{i}-th argument is
  bound to some object of type \ccc{A}. The class is used in
  conjunction with the \ccc{bind} functions.

  \ccInclude{CGAL/functional.h}

  \ccTypes
  \ccNestedType{Type}{the bound type.}
  
  \ccHeading{Notes} This class encapsulates the differences in
  implementation of the binders across various platforms. But in any
  case, \ccc{Type} refers to a model of \ccc{AdaptableFunctor}.

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::bind_1}\\
  \ccRefIdfierPage{CGAL::bind_2}\\
  \ccRefIdfierPage{CGAL::bind_3}\\
  \ccRefIdfierPage{CGAL::bind_4}\\
  \ccRefIdfierPage{CGAL::bind_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefClass}

\begin{ccRefClass}{Compose<F0,F1,F2,F3>}
  \ccDefinition The class \ccRefName\ is used to specify the type of a
  composed functor, i.e., the functor that results from composing
  functors of type \ccc{F1}, \ccc{F2}, and \ccc{F3}, into a functor of
  type \ccc{F0}. The arguments \ccc{F2} and \ccc{F3} are optional,
  such that between two and four functors can participate in the
  composition. The class is used in conjunction with the \ccc{compose}
  function; see there for an explanation on how exactly the functors
  are combined.

  \ccInclude{CGAL/functional.h}
  
  \ccTypes
  \ccNestedType{Type}{type of the composed functor.}
  
  \ccHeading{Notes} This class encapsulates the differences in
  implementation of the composers across various platforms. But in any
  case, \ccc{Type} refers to a model of \ccc{AdaptableFunctor}.

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::compose}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefClass}

\begin{ccRefClass}{Compare_to_less<F>}
  \ccDefinition The class \ccRefName\ is used to convert a functor which
  returns a \ccc{Comparison_result} to a predicate (returning bool) : it
  will return true iff the return value of \ccc{F} is \ccc{SMALLER}.
  The class is used in conjunction with the \ccc{compare_to_less}
  function; see there for an explanation on how exactly the functors
  are combined.

  \ccInclude{CGAL/function_objects.h}
  
  \ccTypes
  \ccNestedType{Type}{type of the composed functor.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::compare_to_less}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefClass}

\begin{ccRefClass}{Compose_shared<F0,F1,F2,F3>}
  \ccDefinition The class \ccRefName\ is used to specify the type of a
  composed functor, i.e., the functor that results from composing
  functors of type \ccc{F1}, \ccc{F2}, and \ccc{F3}, into a functor of
  type \ccc{F0}. The arguments \ccc{F2} and \ccc{F3} are optional,
  such that between two and four functors can participate in the
  composition. The class is used in conjunction with the
  \ccc{compose_shared} function; see there for an explanation on how
  exactly the functors are combined.

  \ccInclude{CGAL/functional.h}
  
  \ccTypes
  \ccNestedType{Type}{type of the composed functor.}
  
  \ccHeading{Notes} This class encapsulates the differences in
  implementation of the composers across various platforms. But in any
  case, \ccc{Type} refers to a model of \ccc{AdaptableFunctor}.

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::compose_shared}\\
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefClass}

\begin{ccRefFunctionObjectConcept}{AdaptableFunctor}
  
  \ccDefinition The concept \ccRefName\ defines an adaptable functor,
  i.e., a functor that can be used with function object adaptors such
  as binders and composers.

  \ccTypes 
  
  \ccTwo{Arity}{} \ccNestedType{result_type}{return type of the
    functor.}  \ccNestedType{Arity}{defines the arity of the functor,
    i.e., the number of arguments it takes. The class has to be a
    specialization of \ccc{CGAL::Arity_tag<int>}, where the template
    parameter corresponds to the arity of the functor, e.g.
    \ccc{CGAL::Arity_tag<2>} for binary functors.}
  
  \ccOperations
  
  \ccTagFullDeclarations\ccCreationVariable{f}
  \ccMethod{type0 operator()(type1 a1, type2 a2, ..., typen an)
    const;}{(as many arguments as defined by \ccc{Arity})\\returns
    \ccc{f(a1,...an)}.}  \ccTagDefaults
    
  \ccHeading{Notes} Alternatively, the type \ccc{Arity} can be defined
  in a specialization of \ccc{CGAL::Arity_traits<>} for the functor.
  This is useful where existing classes cannot be changed easily, e.g.
  the functors from the standard library.
  
  \ccHasModels All functors from the standard library, and all
  functors from the lower dimensional CGAL kernels. For all kernel
  functors, their arity is listed in the documentation. Some (few) of
  them are overloaded with operators of different arities; in this
  case one of these arities has been chosen as default arity. If you
  want to adapt the functor to a different arity, use the functor
  adaptor \ccc{CGAL::Set_arity<F,a>}.
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Arity_tag<int>}\\
  \ccRefIdfierPage{CGAL::Arity_traits<F>}\\
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\
  \ccRefIdfierPage{CGAL::set_arity_5}

\end{ccRefFunctionObjectConcept}

\begin{ccRefClass}{Arity_tag<int>}
  
  \ccDefinition The class \ccRefName\ is used to define the arity of a
  functor, i.e., the number of arguments it takes. It is used as a
  compile time tag only, that is objects of this type are never
  created anywhere.

  \ccInclude{CGAL/functional_base.h}

  \ccSeeAlso
  \ccRefConceptPage{AdaptableFunctor}

\end{ccRefClass}

\begin{ccRefClass}{Arity_traits<F>}
  
  \ccDefinition The class \ccRefName\ is used to define the arity of a
  functor class \ccc{F}, i.e., the number of arguments it takes. It is
  used as a compile time tag only, that is objects of this type are
  never created anywhere. Specializations of \ccRefName\ can be
  defined, where existing functors cannot be changed easily to contain
  their \ccc{Arity} type.

  \ccInclude{CGAL/functional_base.h}

  \ccNestedType{Arity}{\ccc{F::Arity}}

  \ccSeeAlso
  \ccRefConceptPage{AdaptableFunctor}\\
  \ccRefIdfierPage{CGAL::Arity_tag<int>}

\end{ccRefClass}

\begin{ccRefClass}{Set_arity<F,a>}
  \ccDefinition The class \ccRefName\ is used to specify the type of a
  functor of type \ccc{F} whose arity has been set explicitly to
  \ccc{a}. The class is used in conjunction with the \ccc{set_arity}
  functions.

  \ccInclude{CGAL/functional.h}
  
  \ccTypes
  \ccNestedType{Type}{the functor type.}
  
  \ccHeading{Notes} This class encapsulates the differences in
  implementation across various platforms. But in any case, \ccc{Type}
  refers to a model of \ccc{AdaptableFunctor} with arity \ccc{a}.

  \ccSeeAlso
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\
  \ccRefIdfierPage{CGAL::set_arity_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefClass}

\begin{ccRefFunction}{set_arity_0}
  \ccDefinition The function \ccRefName\ is used to set the arity of a
  functor to zero. The result is a functor that takes no arguments and
  calls the original functor with no arguments.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{Set_arity< F, 0 >::Type}{set_arity_0}{}
  
  \ccFunction{template < class F > Set_arity< F, 0 >::Type
    set_arity_0(const F& f);}{returns a functor equivalent to \ccc{f},
    but which has arity zero.
    \ccRequire F is a model for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\
  \ccRefIdfierPage{CGAL::set_arity_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{set_arity_1}
  \ccDefinition The function \ccRefName\ is used to set the arity of a
  functor to one. The result is a functor that takes one argument and
  calls the original functor with this argument.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{Set_arity< F, 1 >::Type}{set_arity_1}{}
  
  \ccFunction{template < class F > Set_arity< F, 1 >::Type
    set_arity_1(const F& f);}{returns a functor equivalent to \ccc{f},
    but which has arity one.
    \ccRequire F is a model for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\
  \ccRefIdfierPage{CGAL::set_arity_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{set_arity_2}
  \ccDefinition The function \ccRefName\ is used to set the arity of a
  functor to two. The result is a functor that takes two arguments and
  calls the original functor with these arguments.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{Set_arity< F, 2 >::Type}{set_arity_2}{}
  
  \ccFunction{template < class F > Set_arity< F, 2 >::Type
    set_arity_2(const F& f);}{returns a functor equivalent to \ccc{f},
    but which has arity two.
    \ccRequire F is a model for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\
  \ccRefIdfierPage{CGAL::set_arity_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{set_arity_3}
  \ccDefinition The function \ccRefName\ is used to set the arity of a
  functor to three. The result is a functor that takes three arguments
  and calls the original functor with these arguments.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{Set_arity< F, 3 >::Type}{set_arity_3}{}
  
  \ccFunction{template < class F > Set_arity< F, 3 >::Type
    set_arity_3(const F& f);}{returns a functor equivalent to \ccc{f},
    but which has arity three.
    \ccRequire F is a model for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\
  \ccRefIdfierPage{CGAL::set_arity_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{set_arity_4}
  \ccDefinition The function \ccRefName\ is used to set the arity of a
  functor to four. The result is a functor that takes four arguments
  and calls the original functor with these arguments.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{Set_arity< F, 4 >::Type}{set_arity_4}{}
  
  \ccFunction{template < class F > Set_arity< F, 4 >::Type
    set_arity_4(const F& f);}{returns a functor equivalent to \ccc{f},
    but which has arity four.
    \ccRequire F is a model for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_5}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

\begin{ccRefFunction}{set_arity_5}
  \ccDefinition The function \ccRefName\ is used to set the arity of a
  functor to five. The result is a functor that takes five arguments
  and calls the original functor with these arguments.
  
  \ccInclude{CGAL/functional.h}
  
  \ccThree{Set_arity< F, 5 >::Type}{set_arity_5}{}
  
  \ccFunction{template < class F > Set_arity< F, 5 >::Type
    set_arity_5(const F& f);}{returns a functor equivalent to \ccc{f},
    but which has arity five.
    \ccRequire F is a model for \ccc{AdaptableFunctor}.}
  
  \ccSeeAlso
  \ccRefIdfierPage{CGAL::Set_arity<F,a>}\\
  \ccRefIdfierPage{CGAL::set_arity_0}\\
  \ccRefIdfierPage{CGAL::set_arity_1}\\
  \ccRefIdfierPage{CGAL::set_arity_2}\\
  \ccRefIdfierPage{CGAL::set_arity_3}\\
  \ccRefIdfierPage{CGAL::set_arity_4}\\ 
  \ccRefConceptPage{AdaptableFunctor}
  
\end{ccRefFunction}

%% +=========================================================================+

\begin{ccRefFunctionObjectConcept}{Projection_object}
  \label{sectionProjectionFunctionObjects}
  
  \ccDefinition The concept \ccRefName\ is modeled after the STL
  concept \ccc{UnaryFunction}, but takes also care of (const)
  references.
  
  \ccTagFullDeclarations
  \ccNestedType{argument_type}{argument type.}
  \ccNestedType{result_type}{result type.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Projection_object();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  \ccMethod{result_type& operator()(argument_type &) const;}{}
  \ccGlue
  \ccMethod{const result_type& operator()(const argument_type &) const;}{}
  \ccTagDefaults

  \ccHasModels
  \ccRefIdfierPage{CGAL::Identity<Value>}\\
  \ccRefIdfierPage{CGAL::Dereference<Value>}\\
  \ccRefIdfierPage{CGAL::Get_address<Value>}\\
  \ccRefIdfierPage{CGAL::Cast_function_object<Arg, Result>}\\
  \ccRefIdfierPage{CGAL::Project_vertex<Node>}\\
  \ccRefIdfierPage{CGAL::Project_facet<Node>}\\
  \ccRefIdfierPage{CGAL::Project_point<Node>}\\
  \ccRefIdfierPage{CGAL::Project_normal<Node>}\\
  \ccRefIdfierPage{CGAL::Project_plane<Node>}\\
  \ccRefIdfierPage{CGAL::Project_next<Node>}\\
  \ccRefIdfierPage{CGAL::Project_prev<Node>}\\
  \ccRefIdfierPage{CGAL::Project_next_opposite<Node>}\\
  \ccRefIdfierPage{CGAL::Project_opposite_prev<Node>}
  
\end{ccRefFunctionObjectConcept}

\begin{ccRefFunctionObjectClass}{Identity<Value>}
  \ccDefinition The class \ccRefName\ represents the identity function
  on \ccc{Value}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Value}.}
  \ccNestedType{result_type}{typedef to \ccc{Value}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Identity();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& x) const;}{returns
    \ccc{x}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    x) const;}{returns \ccc{x}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

%% \begin{ccRefFunctionObjectClass}{Compose<Fct1, Fct2>}
%%   \ccDefinition The class \ccRefName\ composes two projections:
%%   $\ccc{Fct1} \circ \ccc{Fct2} \circ x \equiv \ccc{Fct1()(
%%     Fct2()(x))}$.
  
%%   \ccInclude{CGAL/function_objects.h}
  
%%   \ccHeading{Requirements} \ccc{Fct1} and \ccc{Fct2} are both models
%%   for \ccc{Projection_object}.

%%   \ccIsModel
%%   \ccRefConceptPage{Projection_object}

%%   \ccTagFullDeclarations
%%   \ccNestedType{argument_type}{typedef to \ccc{Fct2::argument_type}.}
%%   \ccNestedType{result_type}{typedef to \ccc{Fct1::result_type}.}
%%   \ccCreationVariable{o}
%%   \ccCreation
%%   \ccConstructor{Compose();}{default constructor.}
%%   \ccOperations
%%   \ccThree{const result_type&;;}{A}{}
  
%%   \ccMethod{result_type& operator()(argument_type& x) const;}{returns
%%     \ccc{Fct1()(Fct2()(x))}.}
  
%%   \ccGlue\ccMethod{const result_type& operator()(const argument_type&
%%     x) const;}{returns \ccc{Fct1()(Fct2()(x))}.} \ccTagDefaults

%% \end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Dereference<Value>}
  \ccDefinition The class \ccRefName\ dereferences a pointer
  (\ccc{operator*}).
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Value*}.}
  \ccNestedType{result_type}{typedef to \ccc{Value}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Dereference();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& x) const;}{returns
    \ccc{*x}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    x) const;}{returns \ccc{*x}.} \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Get_address<Value>}
  \ccDefinition The class \ccRefName\ gets the address of an lvalue
  (\ccc{operator&}).
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Value}.}
  \ccNestedType{result_type}{typedef to \ccc{Value*}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Get_address();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& x) const;}{returns
    \ccc{&x}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    x) const;}{returns \ccc{&x}.} \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Cast_function_object<Arg, Result>}
  \ccDefinition The class \ccRefName\ applies a C-style type cast to
  its argument.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Arg}.}
  \ccNestedType{result_type}{typedef to \ccc{Result}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Cast_function_object();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& x) const;}{returns
    \ccc{(Result)x}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    x) const;}{returns \ccc{(Result)x}.} \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_vertex<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{vertex()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node}.}
  \ccNestedType{result_type}{typedef to \ccc{Node::Vertex}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_vertex();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n.vertex()}.}
  
  \ccGlue \ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n.vertex()}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_facet<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{facet()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node}.}
  \ccNestedType{result_type}{typedef to \ccc{Node::Facet}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_facet();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n.facet()}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n.facet()}.} \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_point<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{point()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node}.}
  \ccNestedType{result_type}{typedef to \ccc{Node::Point}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_point();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n.point()}.}
  
  \ccGlue \ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n.point()}.} \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_normal<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{normal()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node}.}
  \ccNestedType{result_type}{typedef to \ccc{Node::Normal}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_normal();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n.normal()}.}
  
  \ccGlue \ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n.normal()}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_plane<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{plane()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node}.}
  \ccNestedType{result_type}{typedef to \ccc{Node::Plane}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_plane();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n.plane()}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n.plane()}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_next<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{next()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node*}.}
  \ccNestedType{result_type}{typedef to \ccc{Node*}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_next();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n->next()}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n->next()}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_prev<Node>}
  \ccDefinition The class \ccRefName\ calls the member function
  \ccc{prev()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node*}.}
  \ccNestedType{result_type}{typedef to \ccc{Node*}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_prev();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n->prev()}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n->prev()}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_next_opposite<Node>}
  \ccDefinition The class \ccRefName\ calls the member functions
  \ccc{next()->opposite()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node*}.}
  \ccNestedType{result_type}{typedef to \ccc{Node*}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_next_opposite();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n->next()->opposite()}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n->next()->opposite()}.}  \ccTagDefaults

\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Project_opposite_prev<Node>}
  \ccDefinition The class \ccRefName\ calls the member functions
  \ccc{opposite()->prev()} on an instance of type \ccc{Node}.
  
  \ccInclude{CGAL/function_objects.h}

  \ccIsModel
  \ccRefConceptPage{Projection_object}

  \ccTagFullDeclarations
  \ccNestedType{argument_type}{typedef to \ccc{Node*}.}
  \ccNestedType{result_type}{typedef to \ccc{Node*}.}
  \ccCreationVariable{o}
  \ccCreation
  \ccConstructor{Project_opposite_prev();}{default constructor.}
  \ccOperations
  \ccThree{const result_type&;;}{A}{}
  
  \ccMethod{result_type& operator()(argument_type& n) const;}{returns
    \ccc{n->opposite()->prev()}.}
  
  \ccGlue\ccMethod{const result_type& operator()(const argument_type&
    n) const;}{returns \ccc{n->opposite()->prev()}.}
  \ccTagDefaults

\end{ccRefFunctionObjectClass}

%% +--------------------------------------------------------+

\begin{ccRefFunctionObjectClass}{Creator_1<Arg, Result>}
  \label{sectionCreatorFunctionObjects}
  
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from one argument.
  
  \ccInclude{CGAL/function_objects.h}

  \ccHeading{Requirements} \ccc{Arg} is convertible to \ccc{Result}.
  
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of argument.}
  \ccNestedType{result_type}{type of object to create.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a) const;}{returns
    \ccc{result_type(a)}.}

  \ccTagDefaults
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_2<Arg1, Arg2, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from two arguments.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a corresponding
  constructor.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument1_type}{type of first argument.}
  \ccNestedType{argument2_type}{type of second argument.}
  \ccNestedType{result_type}{type of object to create.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type1 a1, argument_type2
    a2) const;}{returns \ccc{result_type(a1, a2)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_3<Arg1, Arg2, Arg3, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from three arguments.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a corresponding
  constructor.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument1_type}{type of first argument.}
  \ccNestedType{argument2_type}{type of second argument.}
  \ccNestedType{argument3_type}{type of third argument.}
  \ccNestedType{result_type}{type of object to create.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type1 a1, argument_type2
    a2, argument_type3 a3) const;}{returns \ccc{result_type(a1, a2,
      a3)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_4<Arg1, Arg2, Arg3, Arg4, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from four arguments.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a corresponding
  constructor.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument1_type}{type of first argument.}
  \ccNestedType{argument2_type}{type of second argument.}
  \ccNestedType{argument3_type}{type of third argument.}
  \ccNestedType{argument4_type}{type of 4th argument.}
  \ccNestedType{result_type}{type of object to create.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type1 a1, argument_type2
    a2, argument_type3 a3, argument_type4 a4) const;}{returns
    \ccc{result_type(a1, a2, a3, a4)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_5<Arg1, Arg2, Arg3, Arg4, Arg5, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from five arguments.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a corresponding
  constructor.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument1_type}{type of first argument.}
  \ccNestedType{argument2_type}{type of second argument.}
  \ccNestedType{argument3_type}{type of third argument.}
  \ccNestedType{argument4_type}{type of 4th argument.}
  \ccNestedType{argument5_type}{type of 5th argument.}
  \ccNestedType{result_type}{type of object to create.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type1 a1, argument_type2
    a2, argument_type3 a3, argument_type4 a4, argument_type5 a5)
    const;}{returns \ccc{result_type(a1, a2, a3, a4, a5)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_2<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from two arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from two
  \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2)
    const;}{returns \ccc{result_type(a1, a2)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_3<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from three arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from
  three \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3) const;}{returns \ccc{result_type(a1, a2, a3)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_4<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from four arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from
  four \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3, argument_type a4) const;}{returns
    \ccc{result_type(a1, a2, a3, a4)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_5<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from five arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from
  five \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3, argument_type a4, argument_type a5)
    const;}{returns \ccc{result_type(a1, a2, a3, a4, a5)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_6<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from six arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from six
  \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3, argument_type a4, argument_type a5,
    argument_type a6) const;}{returns \ccc{result_type(a1, a2, a3, a4,
      a5, a6)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_7<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from seven arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from
  seven \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3, argument_type a4, argument_type a5,
    argument_type a6, argument_type a7) const;}{returns
    \ccc{result_type(a1, a2, a3, a4, a5, a6, a7)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_8<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from eight arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from
  eight \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3, argument_type a4, argument_type a5,
    argument_type a6, argument_type a7, argument_type a8)
    const;}{returns \ccc{result_type(a1, a2, a3, a4, a5, a6, a7,
      a8)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_9<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from nine arguments of the same type.
  
  \ccInclude{CGAL/function_objects.h}
  
  \ccRequirements \ccc{Result} defines a constructor from
  nine \ccc{Arg} arguments.
  
  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}
  
  \ccMethod{result_type operator()(argument_type a1, argument_type a2,
    argument_type a3, argument_type a4, argument_type a5,
    argument_type a6, argument_type a7, argument_type a8,
    argument_type a9) const;}{returns \ccc{result_type(a1, a2, a3, a4,
      a5, a6, a7, a8, a9)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}

\begin{ccRefFunctionObjectClass}{Creator_uniform_d<Arg, Result>}
  \ccDefinition The concept \ccRefName\ defines types and operations
  for creating objects from two arguments of the same type.

  \ccInclude{CGAL/function_objects.h}

  \ccRequirements \ccc{Result} defines a constructor from three arguments: 
  one \ccc{d} dimension and two \ccc{Arg} arguments.

  \def\ccLongParamLayout{\ccTrue}
  \ccTagFullDeclarations\ccCreationVariable{c}
  \ccNestedType{argument_type}{type of arguments; typedef to
    \ccc{Arg}.}
  \ccNestedType{result_type}{type of object to create; typedef to
    \ccc{Result}.}
  \ccThree{result_type;;}{operator()(argument_type a) const;;}{}

  \ccMethod{result_type operator()(argument_type a1, argument_type a2)
    const;}{returns \ccc{result_type(d, a1, a2)}.}

  \ccTagDefaults\def\ccLongParamLayout{\ccFalse}
\end{ccRefFunctionObjectClass}


%% +--------------------------------------------------------+

\begin{ccRefClass}{Triple<T1, T2, T3>}
  
  \ccDefinition The Triple class is an extension of \ccc{std::pair}.
  \ccRefName\ is a heterogeneous triple: it holds one object of type
  \ccc{T1}, one of type \ccc{T2}, and one of type \ccc{T3}.  A
  \ccRefName\ is much like a container, in that it "owns" its
  elements. It is not actually a model of container, though, because
  it does not support the standard methods (such as iterators) for
  accessing the elements of a container.

  \ccInclude{CGAL/utility.h}
  
  \ccRequirements \ccc{T1}, \ccc{T2} and \ccc{T3} must be assignable.
  Additional operations have additional requirements.

  %\ccSetThreeColumns{T*}{next_link ;}{}
  \ccThree{result_type;;}{operator()(argument a) ;;}{}

  \ccTypes
  \ccTypedef{typedef T1 first_type;}{}
  \ccGlue
  \ccTypedef{typedef T2 second_type;}{}
  \ccGlue
  \ccTypedef{typedef T3 third_type;}{}

  \ccHeading{Variables}
  \ccVariable{T1 first;}{first element}
  \ccGlue
  \ccVariable{T2 second;}{second element}
  \ccGlue
  \ccVariable{T3 third;}{third element}

  \ccCreation
  \ccCreationVariable{t}
  
  \ccConstructor{Triple();}{introduces a triple using the default
    constructor of the three elements.}
  
  \ccConstructor{Triple(T1 x, T2 y, T3 z);}{constructs a triple such
    that \ccc{first} is constructed from \ccc{x}, \ccc{second} is
    constructed from \ccc{y}, and \ccc{third} is constructed from
    \ccc{z}.}
  
  \ccConstructor{template <class U, class V, class W> Triple(U u, V v,
    W w);} {constructs a triple such that \ccc{first} is constructed
    from \ccc{u}, \ccc{second} is constructed from \ccc{v}, and
    \ccc{third} is constructed from \ccc{w}. \ccRequire Proper
    conversion operators exist from \ccc{U} to \ccc{T1}, \ccc{V} to
    \ccc{T2}, and \ccc{W} to \ccc{T3}.}

  \ccFunction{template <class T1, class T2, class T3> bool
    operator<(Triple<T1, T2, T3> x, Triple<T1, T2, T3> y);} {The
    comparison operator. It uses lexicographic comparison: the return
    value is true if the first element of \ccc{x} is less than the
    first element of \ccc{y}, and false if the first element of
    \ccc{y} is less than the first element of \ccc{x}. If neither of
    these is the case, then it returns true if the second element of
    \ccc{x} is less than the second element of \ccc{y}, and false if
    the second element of \ccc{y} is less than the second element of
    \ccc{x}.  If neither of these is the case, then it returns the
    result of comparing the third elements of \ccc{x} and \ccc{y}.
    This operator may only be used if \ccc{T1}, \ccc{T2} and \ccc{T3}
    define the comparison operator.}
  
  \ccFunction{template <class T1, class T2, class T3> bool
    operator==(Triple<T1, T2, T3> x, Triple<T1, T2, T3> y);} {The
    equality operator. The return value is true if and only the first
    elements of \ccc{x} and \ccc{y} are equal, the second elements of
    \ccc{x} and \ccc{y} are equal, and the third elements of \ccc{x}
    and \ccc{y} are equal.  This operator may only be used if
    \ccc{T1}, \ccc{T2} and \ccc{T3} define the equality operator.}
  
  \ccFunction{template <class T1, class T2, class T3> Triple<T1, T2,
    T3> make_triple(T1 x, T2 y, T3 z);} {Equivalent to
    \ccStyle{Triple<T1, T2, T3>(x, y, z)}.}

\end{ccRefClass}

%% +--------------------------------------------------------+

\begin{ccRefClass}{Quadruple<T1, T2, T3, T4>}
  
  \ccDefinition The Quadruple class is an extension of
  \ccc{std::pair}.  \ccRefName\ is a heterogeneous quadruple: it holds
  one object of type \ccc{T1}, one of type \ccc{T2}, one of type
  \ccc{T3}, and one of type \ccc{T4}.  A \ccRefName\ is much like a
  container, in that it ``owns'' its elements. It is not actually a
  model of container, though, because it does not support the standard
  methods (such as iterators) for accessing the elements of a
  container.

  \ccInclude{CGAL/utility.h}
  
  \ccRequirements \ccc{T1}, \ccc{T2}, \ccc{T3} and \ccc{T4} must be
  assignable. Additional operations have additional requirements.

  %\ccSetThreeColumns{T*}{next_link ;}{}
  \ccThree{result_type;;}{operator()(argument a) ;;}{}

  \ccTypes
  \ccTypedef{typedef T1 first_type;}{}
  \ccGlue
  \ccTypedef{typedef T2 second_type;}{}
  \ccGlue
  \ccTypedef{typedef T3 third_type;}{}
  \ccGlue
  \ccTypedef{typedef T4 fourth_type;}{}

  \ccHeading{Variables}
  \ccVariable{T1 first;}{first element}
  \ccGlue
  \ccVariable{T2 second;}{second element}
  \ccGlue
  \ccVariable{T3 third;}{third element}
  \ccGlue
  \ccVariable{T4 fourth;}{fourth element}

  \ccCreation
  \ccCreationVariable{t}
  
  \ccConstructor{Quadruple();} {introduces a quadruple using the
    default constructor of the four elements.}
  
  \ccConstructor{Quadruple(T1 x, T2 y, T3 z, T4 w);} {constructs a
    quadruple such that \ccc{first} is constructed from \ccc{x},
    \ccc{second} is constructed from \ccc{y}, \ccc{third} is
    constructed from \ccc{z}, and \ccc{fourth} is constructed from
    \ccc{w}.}
  
  \ccConstructor{template <class U, class V, class W, class X>
    Quadruple(U u, V v, W w, X x);} {constructs a quadruple such that
    \ccc{first} is constructed from \ccc{u}, \ccc{second} is
    constructed from \ccc{v}, \ccc{third} is constructed from \ccc{w},
    and \ccc{fourth} is constructed from \ccc{x}. \ccRequire Proper
    conversion operators exist from \ccc{U} to \ccc{T1}, \ccc{V} to
    \ccc{T2}, \ccc{W} to \ccc{T3}, and \ccc{X} to \ccc{T4}.  }
   
  \ccFunction{template <class T1, class T2, class T3, class T4> bool
    operator<(Quadruple<T1, T2, T3, T4> x, Quadruple<T1, T2, T3, T4>
    y);} {The comparison operator. It uses lexicographic comparison:
    the return value is true if the first element of \ccc{x} is less
    than the first element of \ccc{y}, and false if the first element
    of \ccc{y} is less than the first element of \ccc{x}. If neither
    of these is the case, then it returns true if the second element
    of \ccc{x} is less than the second element of \ccc{y}, and false
    if the second element of \ccc{y} is less than the second element
    of \ccc{x}. If neither of these is the case, then it returns true
    if the third element of \ccc{x} is less than the third element of
    \ccc{y}, and false if the third element of \ccc{y} is less than
    the third element of \ccc{x}.  If neither of these is the case,
    then it returns the result of comparing the fourth elements of
    \ccc{x} and \ccc{y}. This operator may only be used if \ccc{T1},
    \ccc{T2}, \ccc{T3}, and \ccc{T4} define the comparison operator.}
  
  \ccFunction{template <class T1, class T2, class T3, class T4> bool
    operator==(Quadruple<T1, T2, T3, T4> x, Quadruple<T1, T2, T3, T4>
    y);} {The equality operator. The return value is true if and only
    the first elements of \ccc{x} and \ccc{y} are equal, the second
    elements of \ccc{x} and \ccc{y} are equal, the third elements of
    \ccc{x} and \ccc{y} are equal, and the fourth elements of \ccc{x}
    and \ccc{y} are equal.  This operator may only be used if
    \ccc{T1}, \ccc{T2}, \ccc{T3}, and \ccc{T4} define the equality
    operator.}
  
  \ccFunction{template <class T1, class T2, class T3, class T4>
    Quadruple<T1, T2, T3, T4> make_quadruple(T1 x, T2 y, T3 z, T4 w);}
  {Equivalent to \ccStyle{Quadruple<T1, T2, T3, T4>(x, y, z, w)}.}

\end{ccRefClass}

%% +=========================================================================+

%% +--------------------------------------------------------+
\ccParDims

%% EOF


