#line 4157 "stl_extension.aw"

#line 20 "cgal_header.awi"
// ============================================================================
//
// Copyright (c) 1997, 1998, 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------------
//
// release       : $CGAL_Revision: $
// release_date  : $CGAL_Date: $
//
// file          : test_In_place_list.C
// chapter       : $CGAL_Chapter: STL Extensions for CGAL $
// package       : $CGAL_Package: STL_Extension $
// source        : stl_extension.fw
#line 37 "cgal_header.awi"
// revision      : $Revision$
// revision_date : $Date$
// author(s)     : Michael Hoffmann <hoffmann@inf.ethz.ch>
//                 Lutz Kettner <kettner@inf.ethz.ch>
//
// coordinator   : INRIA, Sophia Antipolis
//
// Stl_Extensions: In place list.
// ============================================================================

#line 4161 "stl_extension.aw"

#ifndef CGAL_BASIC_H
#include <CGAL/basic.h>
#endif // CGAL_BASIC_H
#ifndef CGAL_PROTECT_CSTDDEF
#include <cstddef>
#define CGAL_PROTECT_CSTDDEF
#endif
#ifndef CGAL_PROTECT_ITERATOR
#include <iterator>
#define CGAL_PROTECT_ITERATOR
#endif
#ifndef CGAL_PROTECT_LIST
#include <list>
#define CGAL_PROTECT_LIST
#endif
#ifndef CGAL_PROTECT_VECTOR
#include <vector>
#define CGAL_PROTECT_VECTOR
#endif
#ifndef CGAL_CIRCULATOR_H
#include <CGAL/circulator.h>  // Needed for iterator category assertions.
#endif // CGAL_CIRCULATOR_H
#ifndef CGAL_CIRCULATOR_IMPL_H
#include <CGAL/circulator_impl.h>  // Needed for test data structures.
#endif // CGAL_CIRCULATOR_IMPL_H
#ifndef CGAL_IN_PLACE_LIST_H
#include <CGAL/In_place_list.h>
#endif // CGAL_IN_PLACE_LIST_H

#line 24 "iterator_test.awi"
// Global data structures.
std::list<int>   L;
std::vector<int> V;
// int*          C_array;  // Gnu gcov produces a core here!

// Workaround
int* new_C_array() {
    int* p = new int[5];
    for ( int i = 1; i <= 5; i++) {
        p[i-1] = i;
    }
    return p;
}

// Build a simple 'n'-element circular structure using struct's.
struct Node {
    int   key;
    Node* next;
    Node* prev;
    Node() : key(0), next(this), prev( this) {}
    Node( int n) : key(n), next(this), prev( this) {}
    Node( Node* _nx, Node* _pv, int n)
        : key(n), next(_nx), prev( _pv) {}
};
Node* new_node( Node* _nx, Node* _pv, int n) {
    return new Node( _nx, _pv, n);
}
void append_node( Node* p, int n) {
    Node* q = new_node( p, p->prev, n);
    p->prev->next = q;
    p->prev = q;
}
Node* generate_nodes( int n) {
    CGAL_assertion( n > 0);
    Node* p = new Node(1);
    for ( int i = 2; i <= n; i++)
        append_node( p, i);
    return p;
}
void delete_nodes( Node* p) {
    Node* end = p;
    Node* q   = p;
    p = p->next;
    while ( p != end) {
        delete q;
        q = p;
        p = p->next;
    }
    delete q;
}

typedef CGAL::Forward_circulator_over_struct< Node>
    Struct_circulator;
typedef CGAL::Forward_const_circulator_over_struct< Node>
    Struct_const_circulator;
typedef CGAL::Bidirectional_circulator_over_struct< Node>
    Struct_bi_circulator;
typedef CGAL::Bidirectional_const_circulator_over_struct< Node>
    Struct_bi_const_circulator;

// Build a simple 'n'-element circular structure using struct's.
class CNode {
    CNode* _next;
    CNode* _prev;
  public:
    int   key;
    CNode*       next()       { return _next;}
    const CNode* next() const { return _next;}
    CNode*       prev()       { return _prev;}
    const CNode* prev() const { return _prev;}
    CNode() : _next(this), _prev( this), key(0) {}
    CNode( int n) : _next(this), _prev( this), key(n) {}
    CNode( CNode* _nx, CNode* _pv, int n)
        : _next(_nx), _prev( _pv), key(n) {}
    friend CNode* new_cnode( CNode* _nx, CNode* _pv, int n);
    friend void append_cnode( CNode* p, int n);
    friend void delete_cnodes( CNode* p);
};
CNode* new_cnode( CNode* _nx, CNode* _pv, int n) {
    return new CNode( _nx, _pv, n);
}
void append_cnode( CNode* p, int n) {
    CNode* q = new_cnode( p, p->_prev, n);
    p->_prev->_next = q;
    p->_prev = q;
}
CNode* generate_cnodes( int n) {
    CGAL_assertion( n > 0);
    CNode* p = new CNode(1);
    for ( int i = 2; i <= n; i++)
        append_cnode( p, i);
    return p;
}
void delete_cnodes( CNode* p) {
    CNode* end = p;
    CNode* q   = p;
    p = p->_next;
    while ( p != end) {
        delete q;
        q = p;
        p = p->_next;
    }
    delete q;
}

typedef CGAL::Forward_circulator_over_class< CNode>
    Class_circulator;
typedef CGAL::Forward_const_circulator_over_class< CNode>
    Class_const_circulator;
typedef CGAL::Bidirectional_circulator_over_class< CNode>
    Class_bi_circulator;
typedef CGAL::Bidirectional_const_circulator_over_class< CNode>
    Class_bi_const_circulator;


void init_global_data() {
    // C_array = new int[5];
    for ( int i = 1; i <= 5; i++) {
        L.push_back(i);
        V.push_back(i);
        // C_array[i-1] = i;
    }
}

void clean_global_data() {
    //delete[] C_array;
}

// Test value type and distance type.
int test_value_type( int*)                 { return 1;}
int test_value_type( Node*)                { return 1;}
int test_value_type( CNode*)               { return 1;}
int test_value_type( char*)                { return 2;}
int test_value_type( double*)              { return 3;}

int test_distance_type( std::ptrdiff_t*)   { return 1;}
int test_distance_type( char*)             { return 2;}
int test_distance_type( double*)           { return 3;}
#line 4192 "stl_extension.aw"

using namespace CGAL;

#line 994 "stl_extension.aw"
struct item : public In_place_list_base<item> {
  int key;
  item() {}
  item( int i) : key(i) {}
  item( const item& i)
  : In_place_list_base<item>(i), key(i.key) {}
  bool operator== (const item& i) const { return key == i.key;}
  bool operator!= (const item& i) const { return key != i.key;}
  bool operator== (int i) const         { return key == i;}
  bool operator!= (int i) const         { return key != i;}
  bool operator<  (const item& i) const { return key < i.key;}
};
int test_value_type( item*)           { return 1;}

void test_In_place_list() {
  {
    typedef In_place_list<item,false> List;
    typedef List::iterator            Iterator;
    typedef List::const_iterator      Const_iterator;
    typedef List::size_type           Size;
    List l1;
    CGAL_assertion( l1.empty());
    CGAL_assertion( l1.size() == 0);
    CGAL_assertion( l1.max_size() == Size(-1));
    CGAL_assertion( l1 == l1);
    CGAL_assertion( l1.begin() == l1.end());
    List l2(l1);
    CGAL_assertion( l1 == l2);
    CGAL_assertion( l2.begin() == l2.end());
    List l;
    l.push_back( *new item(1));
    l.push_back( *new item(2));
    l.push_back( *new item(3));
    l.push_back( *new item(4));
    l.push_back( *new item(5));
    l1 = l;
    CGAL_assertion( ! l1.empty());
    CGAL_assertion( l1.size() == 5);
    CGAL_assertion( l1 == l);
    CGAL_assertion( l1 != l2);
    Iterator begin = l.begin();
    Iterator end   = l.end();
    Assert_bidirectional_category(begin);
    Assert_bidirectional_category(end);
    #line 312 "iterator_test.awi"
    #line 235 "iterator_test.awi"
    #line 173 "iterator_test.awi"
    { // Open own scope to hide local variables.
        // Check generally correct parameter properties.
        CGAL::Assert_circulator_or_iterator(begin);
        CGAL::Assert_circulator_or_iterator(end);
        CGAL::Assert_is_at_least_forward_category(begin);
        CGAL::Assert_is_at_least_forward_category(end);
        CGAL_assertion(1==test_value_type(std::value_type(begin)));
        CGAL_assertion(1==test_value_type(std::value_type(end)));
        CGAL_assertion(1==test_distance_type(std::distance_type(begin)));
        CGAL_assertion(1==test_distance_type(std::distance_type(end)));
    
        // Default constructor.
        Iterator z = Iterator();
        CGAL::Assert_circulator_or_iterator(z);
        // Copy constructor.
        Iterator i = begin;
    
        // Check general support for circulators and iterators.
        CGAL_assertion( CGAL::is_empty_range( z, z));
        CGAL_assertion( ! CGAL::is_empty_range( i, end));
    
        int su = 0;
        int k  = 1;
        // Check general loop, pre-increment, dereference.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = ++i;
                CGAL_assertion(  i ==  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key);
                }
            } while (i != end);  // Inequality and equality checked.
        }
        CGAL_assertion( i == end);  // Equality checked.
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = begin;
        su = 0;
        k  = 1;
        // Loop with post increment.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = i++;
                CGAL_assertion(  i !=  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key + 1);
                }
            } while (i != end);
        }
        CGAL_assertion( i == end);
        CGAL_assertion( su == 15);
    }
    { // Open own scope to hide local variables.
        // Change three elements and check post-/pre-increment.
        Iterator i = begin;
        (*i++).key = 4;
        CGAL_assertion( 4 == (*begin).key);
        CGAL_assertion( 2 == (*i).key);
        (*i++).key = 3;
        CGAL_assertion( 3 == (*i).key);
        (*++i).key = 7;
        CGAL_assertion( 7 == (*i).key);
    
        // Check the setting and reset these elements
        // to their original values.
        i = begin;
        CGAL_assertion( 4 == (*i).key);
        (*i).key = 1;
        i++;
        CGAL_assertion( 3 == (*i).key);
        (*i++).key = 2;
        CGAL_assertion( 3 == (*i).key);
        i++;
        CGAL_assertion( 7 == (*i).key);
        (*i).key = 4;
    
        // Check the resetting.
        i = begin;
        int k = 1;
        do {
            CGAL_assertion( k == (*i).key);
            ++i;
            ++k;
        } while (i != end);
    }
    #line 272 "iterator_test.awi"
    #line 173 "iterator_test.awi"
    { // Open own scope to hide local variables.
        // Check generally correct parameter properties.
        CGAL::Assert_circulator_or_iterator(begin);
        CGAL::Assert_circulator_or_iterator(end);
        CGAL::Assert_is_at_least_forward_category(begin);
        CGAL::Assert_is_at_least_forward_category(end);
        CGAL_assertion(1==test_value_type(std::value_type(begin)));
        CGAL_assertion(1==test_value_type(std::value_type(end)));
        CGAL_assertion(1==test_distance_type(std::distance_type(begin)));
        CGAL_assertion(1==test_distance_type(std::distance_type(end)));
    
        // Default constructor.
        Iterator z = Iterator();
        CGAL::Assert_circulator_or_iterator(z);
        // Copy constructor.
        Iterator i = begin;
    
        // Check general support for circulators and iterators.
        CGAL_assertion( CGAL::is_empty_range( z, z));
        CGAL_assertion( ! CGAL::is_empty_range( i, end));
    
        int su = 0;
        int k  = 1;
        // Check general loop, pre-increment, dereference.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = ++i;
                CGAL_assertion(  i ==  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key);
                }
            } while (i != end);  // Inequality and equality checked.
        }
        CGAL_assertion( i == end);  // Equality checked.
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = begin;
        su = 0;
        k  = 1;
        // Loop with post increment.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = i++;
                CGAL_assertion(  i !=  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key + 1);
                }
            } while (i != end);
        }
        CGAL_assertion( i == end);
        CGAL_assertion( su == 15);
    }
    { // Open own scope to hide local variables.
        CGAL::Assert_is_at_least_bidirectional_category(begin);
        CGAL::Assert_is_at_least_bidirectional_category(end);
        // Loop backwards and pre-decrement.
        Iterator i = end;
        int su = 0;
        int k  = 5;
        do {
            Iterator j = --i;
            CGAL_assertion(  i ==  j);
            CGAL_assertion( (*i).key == (*j).key);
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != begin);
        CGAL_assertion( i == begin);
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = end;
        su = 0;
        k  = 5;
        // Loop with post-decrement.
        do {
            Iterator j = i--;
            CGAL_assertion(  i !=  j);
            if ( j != end) {
                CGAL_assertion( (*i).key == (*j).key - 1);
            }
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != begin);
        CGAL_assertion( i == begin);
        CGAL_assertion( su == 15);
    }
#line 1040 "stl_extension.aw"
    #line 484 "iterator_test.awi"
    #line 479 "iterator_test.awi"
    CGAL::Assert_iterator( begin);
    CGAL::Assert_iterator( end);
#line 1042 "stl_extension.aw"

    List l4 = l;
    const List& l3 = l4;
    Const_iterator c_begin = l3.begin();
    Const_iterator c_end   = l3.end();
    Assert_bidirectional_category(c_begin);
    Assert_bidirectional_category(c_end);
    #line 272 "iterator_test.awi"
    #line 173 "iterator_test.awi"
    { // Open own scope to hide local variables.
        // Check generally correct parameter properties.
        CGAL::Assert_circulator_or_iterator(c_begin);
        CGAL::Assert_circulator_or_iterator(c_end);
        CGAL::Assert_is_at_least_forward_category(c_begin);
        CGAL::Assert_is_at_least_forward_category(c_end);
        CGAL_assertion(1==test_value_type(std::value_type(c_begin)));
        CGAL_assertion(1==test_value_type(std::value_type(c_end)));
        CGAL_assertion(1==test_distance_type(std::distance_type(c_begin)));
        CGAL_assertion(1==test_distance_type(std::distance_type(c_end)));
    
        // Default constructor.
        Const_iterator z = Const_iterator();
        CGAL::Assert_circulator_or_iterator(z);
        // Copy constructor.
        Const_iterator i = c_begin;
    
        // Check general support for circulators and iterators.
        CGAL_assertion( CGAL::is_empty_range( z, z));
        CGAL_assertion( ! CGAL::is_empty_range( i, c_end));
    
        int su = 0;
        int k  = 1;
        // Check general loop, pre-increment, dereference.
        if (! CGAL::is_empty_range( i, c_end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Const_iterator j = ++i;
                CGAL_assertion(  i ==  j);
                if ( i != c_end) {
                    CGAL_assertion( (*i).key == (*j).key);
                }
            } while (i != c_end);  // Inequality and equality checked.
        }
        CGAL_assertion( i == c_end);  // Equality checked.
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = c_begin;
        su = 0;
        k  = 1;
        // Loop with post increment.
        if (! CGAL::is_empty_range( i, c_end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Const_iterator j = i++;
                CGAL_assertion(  i !=  j);
                if ( i != c_end) {
                    CGAL_assertion( (*i).key == (*j).key + 1);
                }
            } while (i != c_end);
        }
        CGAL_assertion( i == c_end);
        CGAL_assertion( su == 15);
    }
    { // Open own scope to hide local variables.
        CGAL::Assert_is_at_least_bidirectional_category(c_begin);
        CGAL::Assert_is_at_least_bidirectional_category(c_end);
        // Loop backwards and pre-decrement.
        Const_iterator i = c_end;
        int su = 0;
        int k  = 5;
        do {
            Const_iterator j = --i;
            CGAL_assertion(  i ==  j);
            CGAL_assertion( (*i).key == (*j).key);
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != c_begin);
        CGAL_assertion( i == c_begin);
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = c_end;
        su = 0;
        k  = 5;
        // Loop with post-decrement.
        do {
            Const_iterator j = i--;
            CGAL_assertion(  i !=  j);
            if ( j != c_end) {
                CGAL_assertion( (*i).key == (*j).key - 1);
            }
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != c_begin);
        CGAL_assertion( i == c_begin);
        CGAL_assertion( su == 15);
    }
#line 1051 "stl_extension.aw"
    #line 484 "iterator_test.awi"
    #line 479 "iterator_test.awi"
    CGAL::Assert_iterator( c_begin);
    CGAL::Assert_iterator( c_end);
#line 1053 "stl_extension.aw"

    l.destroy();
    l1.destroy();
    l2.destroy();
    l4.destroy();
  }{
    typedef In_place_list<item,true> List;
    typedef List::iterator       Iterator;
    typedef List::const_iterator Const_iterator;
    typedef List::size_type      Size;
    List l1;
    CGAL_assertion( l1.empty());
    CGAL_assertion( l1.size() == 0);
    CGAL_assertion( l1.max_size() == Size(-1));
    CGAL_assertion( l1 == l1);
    CGAL_assertion( l1.begin() == l1.end());
    List l2(l1);
    CGAL_assertion( l1 == l2);
    CGAL_assertion( l2.begin() == l2.end());
    List l;
    l.push_back( *new item(1));
    l.push_back( *new item(2));
    l.push_back( *new item(3));
    l.push_back( *new item(4));
    l.push_back( *new item(5));
    l1 = l;
    CGAL_assertion( ! l1.empty());
    CGAL_assertion( l1.size() == 5);
    CGAL_assertion( l1 == l);
    CGAL_assertion( l1 != l2);
    Iterator begin = l.begin();
    Iterator end   = l.end();
    Assert_bidirectional_category(begin);
    Assert_bidirectional_category(end);
    #line 312 "iterator_test.awi"
    #line 235 "iterator_test.awi"
    #line 173 "iterator_test.awi"
    { // Open own scope to hide local variables.
        // Check generally correct parameter properties.
        CGAL::Assert_circulator_or_iterator(begin);
        CGAL::Assert_circulator_or_iterator(end);
        CGAL::Assert_is_at_least_forward_category(begin);
        CGAL::Assert_is_at_least_forward_category(end);
        CGAL_assertion(1==test_value_type(std::value_type(begin)));
        CGAL_assertion(1==test_value_type(std::value_type(end)));
        CGAL_assertion(1==test_distance_type(std::distance_type(begin)));
        CGAL_assertion(1==test_distance_type(std::distance_type(end)));
    
        // Default constructor.
        Iterator z = Iterator();
        CGAL::Assert_circulator_or_iterator(z);
        // Copy constructor.
        Iterator i = begin;
    
        // Check general support for circulators and iterators.
        CGAL_assertion( CGAL::is_empty_range( z, z));
        CGAL_assertion( ! CGAL::is_empty_range( i, end));
    
        int su = 0;
        int k  = 1;
        // Check general loop, pre-increment, dereference.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = ++i;
                CGAL_assertion(  i ==  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key);
                }
            } while (i != end);  // Inequality and equality checked.
        }
        CGAL_assertion( i == end);  // Equality checked.
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = begin;
        su = 0;
        k  = 1;
        // Loop with post increment.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = i++;
                CGAL_assertion(  i !=  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key + 1);
                }
            } while (i != end);
        }
        CGAL_assertion( i == end);
        CGAL_assertion( su == 15);
    }
    { // Open own scope to hide local variables.
        // Change three elements and check post-/pre-increment.
        Iterator i = begin;
        (*i++).key = 4;
        CGAL_assertion( 4 == (*begin).key);
        CGAL_assertion( 2 == (*i).key);
        (*i++).key = 3;
        CGAL_assertion( 3 == (*i).key);
        (*++i).key = 7;
        CGAL_assertion( 7 == (*i).key);
    
        // Check the setting and reset these elements
        // to their original values.
        i = begin;
        CGAL_assertion( 4 == (*i).key);
        (*i).key = 1;
        i++;
        CGAL_assertion( 3 == (*i).key);
        (*i++).key = 2;
        CGAL_assertion( 3 == (*i).key);
        i++;
        CGAL_assertion( 7 == (*i).key);
        (*i).key = 4;
    
        // Check the resetting.
        i = begin;
        int k = 1;
        do {
            CGAL_assertion( k == (*i).key);
            ++i;
            ++k;
        } while (i != end);
    }
    #line 272 "iterator_test.awi"
    #line 173 "iterator_test.awi"
    { // Open own scope to hide local variables.
        // Check generally correct parameter properties.
        CGAL::Assert_circulator_or_iterator(begin);
        CGAL::Assert_circulator_or_iterator(end);
        CGAL::Assert_is_at_least_forward_category(begin);
        CGAL::Assert_is_at_least_forward_category(end);
        CGAL_assertion(1==test_value_type(std::value_type(begin)));
        CGAL_assertion(1==test_value_type(std::value_type(end)));
        CGAL_assertion(1==test_distance_type(std::distance_type(begin)));
        CGAL_assertion(1==test_distance_type(std::distance_type(end)));
    
        // Default constructor.
        Iterator z = Iterator();
        CGAL::Assert_circulator_or_iterator(z);
        // Copy constructor.
        Iterator i = begin;
    
        // Check general support for circulators and iterators.
        CGAL_assertion( CGAL::is_empty_range( z, z));
        CGAL_assertion( ! CGAL::is_empty_range( i, end));
    
        int su = 0;
        int k  = 1;
        // Check general loop, pre-increment, dereference.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = ++i;
                CGAL_assertion(  i ==  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key);
                }
            } while (i != end);  // Inequality and equality checked.
        }
        CGAL_assertion( i == end);  // Equality checked.
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = begin;
        su = 0;
        k  = 1;
        // Loop with post increment.
        if (! CGAL::is_empty_range( i, end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Iterator j = i++;
                CGAL_assertion(  i !=  j);
                if ( i != end) {
                    CGAL_assertion( (*i).key == (*j).key + 1);
                }
            } while (i != end);
        }
        CGAL_assertion( i == end);
        CGAL_assertion( su == 15);
    }
    { // Open own scope to hide local variables.
        CGAL::Assert_is_at_least_bidirectional_category(begin);
        CGAL::Assert_is_at_least_bidirectional_category(end);
        // Loop backwards and pre-decrement.
        Iterator i = end;
        int su = 0;
        int k  = 5;
        do {
            Iterator j = --i;
            CGAL_assertion(  i ==  j);
            CGAL_assertion( (*i).key == (*j).key);
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != begin);
        CGAL_assertion( i == begin);
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = end;
        su = 0;
        k  = 5;
        // Loop with post-decrement.
        do {
            Iterator j = i--;
            CGAL_assertion(  i !=  j);
            if ( j != end) {
                CGAL_assertion( (*i).key == (*j).key - 1);
            }
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != begin);
        CGAL_assertion( i == begin);
        CGAL_assertion( su == 15);
    }
#line 1089 "stl_extension.aw"
    #line 484 "iterator_test.awi"
    #line 479 "iterator_test.awi"
    CGAL::Assert_iterator( begin);
    CGAL::Assert_iterator( end);
#line 1091 "stl_extension.aw"

    const List l3( l);
    Const_iterator c_begin = l3.begin();
    Const_iterator c_end   = l3.end();
    Assert_bidirectional_category(c_begin);
    Assert_bidirectional_category(c_end);
    #line 272 "iterator_test.awi"
    #line 173 "iterator_test.awi"
    { // Open own scope to hide local variables.
        // Check generally correct parameter properties.
        CGAL::Assert_circulator_or_iterator(c_begin);
        CGAL::Assert_circulator_or_iterator(c_end);
        CGAL::Assert_is_at_least_forward_category(c_begin);
        CGAL::Assert_is_at_least_forward_category(c_end);
        CGAL_assertion(1==test_value_type(std::value_type(c_begin)));
        CGAL_assertion(1==test_value_type(std::value_type(c_end)));
        CGAL_assertion(1==test_distance_type(std::distance_type(c_begin)));
        CGAL_assertion(1==test_distance_type(std::distance_type(c_end)));
    
        // Default constructor.
        Const_iterator z = Const_iterator();
        CGAL::Assert_circulator_or_iterator(z);
        // Copy constructor.
        Const_iterator i = c_begin;
    
        // Check general support for circulators and iterators.
        CGAL_assertion( CGAL::is_empty_range( z, z));
        CGAL_assertion( ! CGAL::is_empty_range( i, c_end));
    
        int su = 0;
        int k  = 1;
        // Check general loop, pre-increment, dereference.
        if (! CGAL::is_empty_range( i, c_end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Const_iterator j = ++i;
                CGAL_assertion(  i ==  j);
                if ( i != c_end) {
                    CGAL_assertion( (*i).key == (*j).key);
                }
            } while (i != c_end);  // Inequality and equality checked.
        }
        CGAL_assertion( i == c_end);  // Equality checked.
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = c_begin;
        su = 0;
        k  = 1;
        // Loop with post increment.
        if (! CGAL::is_empty_range( i, c_end)) {   // superfluous
            do {
                CGAL_assertion( k == (*i).key);
                su += (*i).key;
                ++k;
                Const_iterator j = i++;
                CGAL_assertion(  i !=  j);
                if ( i != c_end) {
                    CGAL_assertion( (*i).key == (*j).key + 1);
                }
            } while (i != c_end);
        }
        CGAL_assertion( i == c_end);
        CGAL_assertion( su == 15);
    }
    { // Open own scope to hide local variables.
        CGAL::Assert_is_at_least_bidirectional_category(c_begin);
        CGAL::Assert_is_at_least_bidirectional_category(c_end);
        // Loop backwards and pre-decrement.
        Const_iterator i = c_end;
        int su = 0;
        int k  = 5;
        do {
            Const_iterator j = --i;
            CGAL_assertion(  i ==  j);
            CGAL_assertion( (*i).key == (*j).key);
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != c_begin);
        CGAL_assertion( i == c_begin);
        CGAL_assertion( su == 15);
    
        // Assignment.
        i = c_end;
        su = 0;
        k  = 5;
        // Loop with post-decrement.
        do {
            Const_iterator j = i--;
            CGAL_assertion(  i !=  j);
            if ( j != c_end) {
                CGAL_assertion( (*i).key == (*j).key - 1);
            }
            CGAL_assertion( k == (*i).key);
            su += (*i).key;
            --k;
        } while (i != c_begin);
        CGAL_assertion( i == c_begin);
        CGAL_assertion( su == 15);
    }
#line 1099 "stl_extension.aw"
    #line 484 "iterator_test.awi"
    #line 479 "iterator_test.awi"
    CGAL::Assert_iterator( c_begin);
    CGAL::Assert_iterator( c_end);
#line 1101 "stl_extension.aw"
  }{
    // in_list_prog.C
    typedef In_place_list<item,true> List;
    typedef List::iterator       Iterator;
    List  l;
    item* p = new item(1);
    l.push_back( *p);
    l.push_back( *new item(2));
    l.push_front( *new item(3));
    l.push_front( *new item(4));
    l.push_front( *new item(2));
    Iterator i = l.begin();
    ++i;
    l.insert(i,*new item(5));
    l.insert(p,*new item(5));
    int a[7] = {2,5,4,3,5,1,2};
    CGAL_assertion( std::equal( l.begin(), l.end(), a));
    l.sort();
    l.unique();
    int b[5] = {1,2,3,4,5};
    CGAL_assertion( l.size() == 5);
    CGAL_assertion( std::equal( l.begin(), l.end(), b));
  }
}
#line 4196 "stl_extension.aw"

int main() {
  init_global_data();
  test_In_place_list();
  clean_global_data();
  return 0;
}
// EOF //
