// ============================================================================
//
// Copyright (c) 1997-2001 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------------
//
// release       : $CGAL_Revision: CGAL-I $
// release_date  : $CGAL_Date$
//
// file          : test/Min_sphere_d_new/test_Min_sphere_d_d.C
// package       : $CGAL_Package: Min_sphere_d_new $
// chapter       : Geometric Optimisation
//
// source        : web/Min_sphere_d.aw
// revision      : $Revision$
// revision_date : $Date$
//
// author(s)     : Bernd Gärtner, Sven Schönherr <sven@inf.ethz.ch>
// coordinator   : ETH Zürich (Bernd Gärtner <gaertner@inf.ethz.ch>)
//
// implementation: test program for smallest enclosing sphere (dD traits class)
// ============================================================================

// includes
// --------
#include <CGAL/Cartesian_d.h>
#include <CGAL/Homogeneous_d.h>
#include <CGAL/Min_sphere_d_new.h>
#include <CGAL/Optimisation_d_traits_d.h>

#include <CGAL/Random.h>
#include <vector>

#include "test_Min_sphere_d.h"

#define  Min_sphere_d               OTHER_Min_sphere_d
#undef  CGAL_MIN_SPHERE_D_H
#undef  CGAL_CFG_NO_AUTOMATIC_TEMPLATE_INCLUSION
#define CGAL_CFG_NO_AUTOMATIC_TEMPLATE_INCLUSION
#include <CGAL/Min_sphere_d.h>
#undef  Min_sphere_d

// typedefs
// --------
// test variant 1 (needs LEDA)
#ifdef CGAL_USE_LEDA
# include <CGAL/leda_integer.h>
  typedef  CGAL::Cartesian_d<leda_integer>     K_1;
  typedef  CGAL::Optimisation_d_traits_d<K_1>  Traits_1;
# define TEST_VARIANT_1 \
    "Optimisation_d_traits_d< Cartesian_d<leda_integer> >"
#endif

// test variant 2 (needs GMP)
#ifdef CGAL_USE_GMP
# include <CGAL/_QP_solver/Double.h>
  typedef  CGAL::Cartesian_d< int >                               K_2;
  typedef  CGAL::Optimisation_d_traits_d<K_2,GMP::Double,double>  Traits_2;
# define TEST_VARIANT_2 \
    "Optimisation_d_traits_d< Cartesian_d<int>, GMP::Double, double >"
#endif


// comparing (needs LEDA)
#ifdef CGAL_USE_LEDA
  typedef  CGAL::Homogeneous_d<leda_integer>   K_3;
  typedef  CGAL::Optimisation_d_traits_d<K_3>  Traits_3;
  typedef  CGAL::Min_sphere_d<Traits_1>        Min_sphere_d;
  typedef  CGAL::Min_sphere_d<Traits_3>        O_Min_sphere_d;
#endif

// main
// ----
int
main( int argc, char* argv[])
{
    using namespace std;

    // command line arguments
    int verbose = -1;
    if ( argc > 1) verbose = atoi( argv[ 1]);
    CGAL::Verbose_ostream  verr ( verbose >= 0); verr  << "";
    CGAL::Verbose_ostream  verr0( verbose == 0); verr0 << "";
    CGAL::Verbose_ostream  verrX( verbose >  0); verrX << "";

    // code coverage
    // -------------
    #ifdef TEST_VARIANT_1
    
        verr << endl
             << "==================================="
             << "===================================" << endl
             << "Testing `Min_sphere_d' with traits class model" << endl
             << "==> " << TEST_VARIANT_1 << endl
             << "==================================="
             << "===================================" << endl
             << endl;
    
        // generate point set
        std::vector<K_1::Point_d>  points_1;
        points_1.reserve( 100);
        {
            int d = 5*1;
            std::vector<int>  coords( d);
            int  i, j;
            for ( i = 0; i < 100; ++i) {
                for ( j = 0; j < d; ++j)
                    coords[ j] = CGAL::default_random( 0x100000);
                points_1.push_back( K_1::Point_d( d, coords.begin(),
                                                       coords.end()));
            }
        }
    
        // call test function
        CGAL::test_Min_sphere_d( points_1.begin(), points_1.end(),
                                 Traits_1(), verbose);
    
    #endif

    #ifdef TEST_VARIANT_2
    
        verr << endl
             << "==================================="
             << "===================================" << endl
             << "Testing `Min_sphere_d' with traits class model" << endl
             << "==> " << TEST_VARIANT_2 << endl
             << "==================================="
             << "===================================" << endl
             << endl;
    
        // generate point set
        std::vector<K_2::Point_d>  points_2;
        points_2.reserve( 100);
        {
            int d = 5*2;
            std::vector<int>  coords( d);
            int  i, j;
            for ( i = 0; i < 100; ++i) {
                for ( j = 0; j < d; ++j)
                    coords[ j] = CGAL::default_random( 0x100000);
                points_2.push_back( K_2::Point_d( d, coords.begin(),
                                                       coords.end()));
            }
        }
    
        // call test function
        CGAL::test_Min_sphere_d( points_2.begin(), points_2.end(),
                                 Traits_2(), verbose);
    
    #endif

    // additional tests
    // ----------------
    #ifdef CGAL_USE_LEDA
    
        verr << endl
             << "==================================="
             << "===================================" << endl
             << "Comparing `Min_sphere_d' with `OTHER_Min_sphere_d'" << endl
             << "==================================="
             << "===================================" << endl
             << endl;
    
        // convert point set
        std::vector<K_3::Point_d>  points_3;
        points_3.reserve( points_1.size());
        {
            int          d = points_1[ 0].dimension();
            unsigned int i;
            for ( i = 0; i < points_1.size(); ++i) {
                points_3.push_back( 
		  K_3::Point_d( d, 
				points_1[ i].homogeneous_begin(),
				points_1[ i].homogeneous_end()));
            }
        }
    
        // compute smallest enclosing spheres
        Min_sphere_d  ms( points_1.begin(), points_1.end(),
                          Traits_1(), verbose);
        verrX << endl << ms << endl;
        assert( ms.is_valid( verbose > 0));
        
        O_Min_sphere_d  o_ms( points_3.begin(), points_3.end(), Traits_3());
        verrX << endl << o_ms << endl;
        assert( o_ms.is_valid( verbose > 0));
        verrX << endl;
    
        // check center and squared radius
        COVER( "center",
            O_Min_sphere_d::Point  o_ms_center = o_ms.center();
        
            verrX << "center (as point): " << ms.center()
                  << "  [NOTE: coordinates are truncated!]" << endl;
        
            int           d     = points_1[ 0].dimension();
            leda_integer  den   = ms.center_coordinates_begin()[ d];
            leda_integer  o_den = o_ms_center.homogeneous( d);
            for ( int j = 0; j < d; ++j) {
                assert( ms.center_coordinates_begin()[ j]*o_den
                        == o_ms_center.homogeneous( j)*den);
            }
            verrX << "centers are equal." << endl;
        );
        
        COVER( "squared radius",
            verrX << "squared radius: " << ms.squared_radius()
                  << "  [NOTE: value is truncated!]" << endl;
        
            assert( CGAL::Quotient<leda_integer>(
                        ms.squared_radius_numerator(),
                        ms.squared_radius_denominator())
                    == o_ms.squared_radius());
            verrX << "squared radii are equal." << endl;
        );
    
    #endif


    return 0;
}

// ===== EOF ==================================================================
