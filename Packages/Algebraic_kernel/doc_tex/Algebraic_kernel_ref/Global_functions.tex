%%%%%%%%%%%%%% predicates

\begin{ccRefFunction}{compare_x}

\ccFunction{template < class AlgebraicKernel_2_2>
	Comparison_result compare_x
	(const AlgebraicKernel_2_2::Root_for_circles_2_2 &r1,
	const AlgebraicKernel_2_2::Root_for_circles_2_2 &r2);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Compare_X}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernel_2_2::CompareX}

\end{ccRefFunction}

\begin{ccRefFunction}{compare_y}

\ccFunction{template < class AlgebraicKernel_2_2>
	Comparison_result compare_y
	(const AlgebraicKernel_2_2::Root_for_circles_2_2 &r1,
	const AlgebraicKernel_2_2::Root_for_circles_2_2 &r2);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Compare_Y}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernel_2_2::CompareY}

\end{ccRefFunction}

\begin{ccRefFunction}{compare_xy}

\ccFunction{template < class AlgebraicKernel_2_2>
	Comparison_result compare_xy
	(const AlgebraicKernel_2_2::Root_for_circles_2_2 &r1,
	const AlgebraicKernel_2_2::Root_for_circles_2_2 &r2);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Compare_XY}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernel_2_2::CompareXY}

\end{ccRefFunction}

\begin{ccRefFunction}{sign_at}

\ccFunction{template < class AlgebraicKernel_2_2, class OutputIterator >
	OutputIterator sign_at
	(const AlgebraicKernel_2_2::Polynomial_for_circles_2_2 &p,
	const AlgebraicKernel_2_2::Root_for_circles_2_2 &r);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Sign_at}.}

\ccSeeAlso

\ccRefConceptPage{AlgebraicKernel_2_2::SignAt}

\end{ccRefFunction}

%%%%%%%%%%%%%%%%%%%%%%%% constructions

\begin{ccRefFunction}{solve}

\ccDefinition

\ccFunction{template < class AlgebraicKernel_2_2, class OutputIterator >
	OutputIterator solve
	(const AlgebraicKernel_2_2::Polynomial_1_2 &p1,
	const AlgebraicKernel_2_2::Polynomial_1_2 &p2,
	OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Solve}.}

\ccFunction{template < class AlgebraicKernel_2_2, class OutputIterator >
	OutputIterator solve
	(const AlgebraicKernel_2_2::Polynomial_1_2 &p1,
	const AlgebraicKernel_2_2::Polynomial_for_circles_2_2 &p2,
	OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Solve}.}

\ccFunction{template < class AlgebraicKernel_2_2, class OutputIterator >
	OutputIterator solve
	(const AlgebraicKernel_2_2::Polynomial_for_circles_2_2 &p1,
	const AlgebraicKernel_2_2::Polynomial_for_circles_2_2 &p2,
	OutputIterator res);}
	{Calls the operator() of \ccc{AlgebraicKernel_2_2::Solve}.}
\ccSeeAlso

\ccRefConceptPage{AlgebraicKernel_2_2::Solve}

\end{ccRefFunction}

\begin{ccRefFunction}{make_root_of_2}

\ccFunction{template < class RT >
	Root_of_2<RT>
	make_root_of_2(RT a, RT b, RT c, int i);}
	{Returns the \ccc{i}th root of equation $aX^2+bX+c=0$. \ccc{RT} is supposed to be a \ccc{RingNumberType}, and \ccc{Root_of_2<RT>} is the type given by \ccc{Root_of_traits_2<RT>}.}

\ccFunction{template < class RT >
	Root_of_2<RT>
	make_root_of_2(FT a, FT b, FT c, int i);}
	{.}

\footnote{groumpf. \ccc{Root_of_taits} is templated by RT but we also need (do we?) make-root-of with FT. Relation between RT and FT...?}

\ccSeeAlso

\ccRefIdfierPage{CGAL::Root_of_2<RT>}\\
\ccRefIdfierPage{CGAL::Root_of_traits_2<RT>}

\end{ccRefFunction}

