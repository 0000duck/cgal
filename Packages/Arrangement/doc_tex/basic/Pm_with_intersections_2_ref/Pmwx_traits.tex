% +------------------------------------------------------------------------+
% | Reference manual page: Pmwx_2_traits.tex (Arrangement)
% +------------------------------------------------------------------------+
% |
% | Package: arr (Planar_map_with_intersections_2)
% |
% +------------------------------------------------------------------------+

\ccRefPageBegin

%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+
% +========================================================================+
%   Arrangement_2_traits
% +========================================================================+
\begin{ccRefConcept}{PlanarMapWithIntersectionsTraits_2}

\ccDefinition
A model of the \ccRefName\ concept aggregates the geometric types and
primitive operations used by the 
\ccc{Planar_map_with_intersections_2<Planar_map>} data structure.

Note that the concept \ccRefName\ refines the concept \ccc{PlanarMapTraits_2}
and inherits all its types and operations.

In addition to the requirements of the \ccc{PlanarMapTraits_2} concept, it must
provide the types and operations listed below.

\ccRefines
\ccc{PlanarMapTraits_2} \lcTex{(\ccRefPage{PlanarMapTraits_2})}.

\ccTypes

The geometric types defined below must have a default constructor,
copy constructor, and assignment operator.

\ccNestedType{Curve_2}{A type that holds a general curve in the plane.
  Its endpoints must be of type \ccc{Point_2}.
  Curves of type either \ccc{X_monotone_curve_2} or \ccc{Curve_2} can be
  inserted into a \ccc{Planar_map_with_intersections_2<Dcel,Traits>} object.}

\ccCreationVariable{pmwx_traits}

\ccCreation
    
\ccConstructor{Traits();}
{A default constructor.}

\ccOperations

The following methods that have a curve parameter of type
\ccc{X_monotone_curve_2} have the implicit precondition that requires the
curve to be $x$-monotone.

\ccMethod{bool curves_overlap(const X_monotone_curve_2& cv1,
                              const X_monotone_curve_2& cv2);}
         {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} overlap
          in a one-dimensional subcurve (i.e., non countable and non infinite
	  number of points), \ccc{false}. otherwise.}

%construction function
%---------------------   

\ccMethod{template<class OutputIterator>
          OutputIterator make_x_monotone(const Curve_2& cv,
                                         OutputIterator res);}
	 {cuts \ccc{cv} into $x$-monotone subcurves and stores them in a
	   sequence starting at \ccc{res}. The order in which they are stored
	   defines their order in the hierarchy tree. Returns past-the-end
	   iterator of the sequence.}

\ccMethod{void curve_split(const X_monotone_curve_2& cv,
                           X_monotone_curve_2& c1, X_monotone_curve_2& c2,
                           const Point_2& split_pt);}
         {splits $cv$ at \ccc{split_pt} into two curves, and assigns them to
           \ccc{c1} and \ccc{c2} respectively.
           \ccPrecond{\ccc{split_pt} is on \ccc{cv} but is not one of its
	     endpoint.}}

\ccMethod{bool nearest_intersection_to_right(const X_monotone_curve_2& c1,
                                             const X_monotone_curve_2& c2,
                                             const Point_2& pt,
                                             Point_2& p1, Point_2& p2);}
	 {finds the nearest intersection point (or points) of \ccc{c1} and
	   \ccc{c2} lexicographically to the right of \ccc{pt} not including
	   \ccc{pt} itself, (with one exception explained below).
	   If the intersection of \ccc{c1} and \ccc{c2} is an
	   \ccc{X_monotone_curve_2}, that is, they overlap at infinitely many
	   points, then if the right endpoint and the left endpoint of the
	   overlapping subcurve are strictly to the right of \ccc{pt}, they are
	   returned through the two point references \ccc{p1} and \ccc{p2}
	   respectively. If \ccc{pt} is between the overlapping-subcurve
	   endpoints, or \ccc{pt} is its left endpoint, \ccc{pt} and the right
	   endpoint of the subcurve are returned through \ccc{p1} and \ccc{p2}
	   respectively. If the intersection of the two curves is a point to the
	   right of \ccc{pt}, it is returned through \ccc{p1} and \ccc{p2}.
	   Returns \ccc{true} if \ccc{c1} and \ccc{c2} do intersect to the right
	   of \ccc{pt}, \ccc{false} otherwise.}

\ccMethod{bool nearest_intersection_to_left(const X_monotone_curve& c1,
                                            const X_monotone_curve& c2,
                                            const Point_2& pt,
                                            Point_2& p1, Point_2& p2);}
	 {finds the nearest intersection point (or points) of \ccc{c1} and
	   \ccc{c2} lexicographically to the left of \ccc{pt} not including
	   \ccc{pt} itself, (with one exception explained below).
	   If the intersection of \ccc{c1} and \ccc{c2} is an
	   \ccc{X_monotone_curve_2}, that is, they overlap at infinitely many
	   points, then if the left endpoint and the left endpoint of the
	   overlapping subcurve are strictly to the left of \ccc{pt}, they are
	   returned through the two point references \ccc{p1} and \ccc{p2}
	   respectively. If \ccc{pt} is between the overlapping-subcurve
	   endpoints, or \ccc{pt} is its left endpoint, \ccc{pt} and the left
	   endpoint of the subcurve are returned through \ccc{p1} and \ccc{p2}
	   respectively. If the intersection of the two curves is a point to the
	   left of \ccc{pt}, it is returned through \ccc{p1} and \ccc{p2}.
	   Returns \ccc{true} if \ccc{c1} and \ccc{c2} do intersect to the left
	   of \ccc{pt}, \ccc{false} otherwise. This constructor is not
	   required for the aggregate insertion of curves into the planar map.
	   Recall, that the aggregate insertion is based on a sweep-line
	   algorithm.}

\ccHasModels
%  The package does not supply specific implementations of the planar
%  map with intersections traits concept. However, since the
%  \ccc{Arrangement Traits} concept is a refinment of the \ccRefName\
%  concept, all of the models of the former are models of the latter.
The following classes are models of the 
\ccc{ArrangementTraits_2} concept that is a refinment of the \ccRefName\
concept. 

  \ccc{Arr_segment_traits_2<Kernel>}\\
  \ccc{Arr_segment_cached_traits_2<Kernel>}\\
  \ccc{Arr_leda_segment_traits_2<Kernel>}\\
  \ccc{Arr_polyline_traits<Kernel, Container>} \\
  \ccc{Arr_leda_polyline_traits<Kernel, Container>} \\
  \ccc{Arr_conic_traits_2<Kernel>}

\end{ccRefConcept}

\ccRefPageEnd
