%% ==============================================================
%% Specification: Minimum enclosing quadrilaterals
%% --------------------------------------------------------------
%% file  : spec_oops.awi
%% author: Michael Hoffmann
%% $Id$
%% ==============================================================

\clearpage
\section{Minimum Enclosing Quadrilaterals}
\label{secOOPS}
\cgalColumnLayout

This section describes several functions to compute the smallest
enclosing region $r$ of a planar convex polygon $P$ where $r$ is to be
chosen from a set $\mathcal{R}$ of candidate regions.

\ccHtmlNoClassToc
\begin{ccHtmlClassFile}{computing_minimum_enclosing_rectangle.html}
  {Function Declaration of \ccc{minimum_enclosing_rectangle_2}}
  \ccHtmlNoClassIndex\ccHtmlNoClassLinks
  %% class wrapper to keep the font at a uniform size:
  \begin{ccClass}{dummy}
    \ccHtmlNoIndex\subsection{Computing a Minimum Enclosing Rectangle}
  \label{secMinimumEnclosingRectangle}
  \end{ccClass}
  
  This section describes a function to compute a minimal enclosing
  rectangle (not necessarily axis-parallel) of a given convex point
  set. Note that this rectangle is not unique in general.

  \ccInclude{CGAL/minimum_enclosing_quadrilateral_2.h}

  \def\ccLongParamLayout{\ccTrue} 
  
  \ccGlobalFunction{
    template < class ForwardIterator, class OutputIterator, class Traits >
    OutputIterator
    minimum_enclosing_rectangle_2(
    ForwardIterator points_begin,
    ForwardIterator points_end,
    OutputIterator o,
    Traits& t = Default_traits);}
  
  computes a minimum enclosing rectangle of the point set described by
  [\ccc{points_begin}, \ccc{points_end}), writes its vertices
  (counterclockwise) to \ccc{o} and returns the past-the-end iterator
  of this sequence.\\
  If the input range is empty, \ccc{o} remains unchanged.\\
  If the input range consists of one element only,
  exactly this point is written to \ccc{o}.\\
  
  \ccHeading{Precondition}
  \begin{enumerate}
  \item If \ccc{Traits} is specified, it satisfies the requirements
    stated in section \ref{req_MinimumEnclosingQuadrilateralTraits}
    and the value type \ccc{VT} of \ccc{InputIterator} is
    \ccc{Traits::Point_2}. Otherwise \ccc{VT} is
    \ccc{CGAL::Point_2<R>} for some representation class \ccc{R}.
  \item \ccc{OutputIterator} accepts \ccc{VT} as value type.
  \item The points denoted by the range [\ccc{points_begin},
    \ccc{points_end}) form the boundary of a convex polygon $P$ in
    counterclockwise orientation.
  \end{enumerate}
  
  \ccImplementation We use a rotating caliper algorithm
  \cite{t-sgprc-83} with worst case running time linear in the number
  of input points.
  
  \ccExample The following code generates a random convex polygon
  \ccc{P} with 20 vertices and computes the minimum enclosing
  rectangle of \ccc{P}.

  \ccIncludeVerbatim{minimum_enclosing_rectangle_2_example_noheader.C}

\end{ccHtmlClassFile}
    
\ccHtmlNoClassToc
\begin{ccHtmlClassFile}{computing_minimum_enclosing_parallelogram.html}
  {Function Declaration of \ccc{minimum_enclosing_parallelogram_2}}
  \ccHtmlNoClassIndex\ccHtmlNoClassLinks
  %% class wrapper to keep the font at a uniform size:
  \begin{ccClass}{dummy}
    \ccHtmlNoIndex\subsection{Computing a Minimum Enclosing Parallelogram}
  \label{secMinimumEnclosingParallelogramm}
  \end{ccClass}
  
  This section describes a function to compute a minimal enclosing
  parallelogram (not necessarily axis-parallel) of a given convex
  point set. Note that this parallelogram is not unique in general.

  \ccInclude{CGAL/minimum_enclosing_quadrilateral_2.h}

  \def\ccLongParamLayout{\ccTrue} 
  
  \ccGlobalFunction{
    template < class ForwardIterator, class OutputIterator, class Traits >
    OutputIterator
    minimum_enclosing_parallelogram_2(
    ForwardIterator points_begin,
    ForwardIterator points_end,
    OutputIterator o,
    Traits& t = Default_traits);}
  
  computes a minimum enclosing parallelogram of the point set
  described by [\ccc{points_begin}, \ccc{points_end}), writes its
  vertices (counterclockwise) to \ccc{o} and returns the past-the-end
  iterator of this sequence.
  If the input range is empty, \ccc{o} remains unchanged.\\
  If the input range consists of one element only,
  exactly this point is written to \ccc{o}.\\
  
  \ccHeading{Precondition}
  \begin{enumerate}
  \item If \ccc{Traits} is specified, it satisfies the requirements
    stated in section \ref{req_MinimumEnclosingQuadrilateralTraits}
    and the value type \ccc{VT} of \ccc{InputIterator} is
    \ccc{Traits::Point_2}. Otherwise \ccc{VT} is
    \ccc{CGAL::Point_2<R>} for some representation class \ccc{R}.
  \item \ccc{OutputIterator} accepts \ccc{VT} as value type.
  \item The points denoted by the range [\ccc{points_begin},
    \ccc{points_end}) form the boundary of a convex polygon $P$ in
    counterclockwise orientation.
  \end{enumerate}
  
  \ccImplementation We use a rotating caliper algorithm
  \cite{stvwe-mepa-95,v-fmep-90} with worst case running time linear
  in the number of input points.
  
  \ccExample The following code generates a random convex polygon
  \ccc{P} with 20 vertices and computes the minimum enclosing
  parallelogram of \ccc{P}.

  \ccIncludeVerbatim{minimum_enclosing_parallelogram_2_example_noheader.C}

\end{ccHtmlClassFile}

\ccHtmlNoClassToc
\begin{ccHtmlClassFile}{computing_minimum_enclosing_strip.html}
  {Function Declaration of \ccc{minimum_enclosing_strip_2}}
  \ccHtmlNoClassIndex\ccHtmlNoClassLinks
  %% class wrapper to keep the font at a uniform size:
  \begin{ccClass}{dummy}
    \ccHtmlNoIndex\subsection{Computing a Minimum Enclosing Strip}
  \label{secMinimumEnclosingStrip}
  \end{ccClass}
  
  This section describes a function to compute a minimal enclosing
  strip (not necessarily axis-parallel) of a given convex point set.
  Note that this strip is not unique in general. A strip is the closed
  region bounded by two parallel lines in the plane.

  \ccInclude{CGAL/minimum_enclosing_quadrilateral_2.h}

  \def\ccLongParamLayout{\ccTrue} 
  
  \ccGlobalFunction{
    template < class ForwardIterator, class OutputIterator, class Traits >
    OutputIterator
    minimum_enclosing_strip_2(
    ForwardIterator points_begin,
    ForwardIterator points_end,
    OutputIterator o,
    Traits& t = Default_traits);}
  
  computes a minimum enclosing strip of the point set described by
  [\ccc{points_begin}, \ccc{points_end}), writes its vertices to
  \ccc{o} and returns the past-the-end iterator of this sequence.\\
  If the input range is empty or consists of one element only, \ccc{o}
  remains unchanged.
  
  \ccHeading{Precondition}
  \begin{enumerate}
  \item If \ccc{Traits} is specified, it satisfies the requirements
    stated in section \ref{req_MinimumEnclosingQuadrilateralTraits}
    and the value type \ccc{VT} of \ccc{InputIterator} is
    \ccc{Traits::Point_2}. Otherwise \ccc{VT} is
    \ccc{CGAL::Point_2<R>} for some representation class \ccc{R}.
  \item \ccc{OutputIterator} accepts \ccc{VT} as value type.
  \item The points denoted by the range [\ccc{points_begin},
    \ccc{points_end}) form the boundary of a convex polygon $P$ in
    counterclockwise orientation.
  \end{enumerate}
  
  \ccImplementation We use a rotating caliper algorithm
  \cite{t-sgprc-83} with worst case running time linear in the number
  of input points.
    
  \ccExample The following code generates a random convex polygon
  \ccc{P} with 20 vertices and computes the minimum enclosing
  strip of \ccc{P}.

  \ccIncludeVerbatim{minimum_enclosing_strip_2_example_noheader.C}

\end{ccHtmlClassFile}
    
\begin{ccAdvanced}
  \ccHtmlNoClassToc\ccHtmlNoClassIndex\begin{ccClass}{Minq_traits}
    \ccCreationVariable{t}\ccTagFullDeclarations
    
    \subsection{Requirements for Minimum Enclosing Quadrilateral Traits
      Classes}\label{req_MinimumEnclosingQuadrilateralTraits}
    
    \ccDefinition A class \ccClassName\ has to provide the following
    types and operations in order to qualify as a traits class for
    \ccc{minimum_enclosing_rectangle_2},
    \ccc{minimum_enclosing_parallelogram_2} and
    \ccc{minimum_enclosing_strip_2}.
    
    \ccTypes 
    
    \ccTwo{Minq_traits::Rotate_direction_by_multiple_of_pi_22}{}

    \ccNestedType{Point_2}{class used for representing the input
      points.}
    
    \ccNestedType{Direction_2}{class used for representing
      directions.}
    
    \ccNestedType{Line_2}{class used for representing lines.}
    
    \ccNestedType{Rectangle_2}{class used for representing (not
      necessarily axis-parallel) rectangles.}
    
    \ccNestedType{Parallelogram_2}{class used for representing (not
      necessarily axis-parallel) parallelograms.}
    
    \ccNestedType{Strip_2}{class used for representing strips, that is
      the range between (including) two parallel lines.}
    
    \ccNestedType{Equal_2}{AdaptableBinaryFunction class\\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$ \ccc{bool}.\\
      Returns true, iff the two points are equal.}
    
    \ccNestedType{Less_x_2}{AdaptableBinaryFunction class \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$ \ccc{bool}.\\
      \ccc{op(p,q)} returns true, iff the $x$-coordinate of \ccc{p} is
      smaller than the $x$-coordinate of \ccc{q}.}
    
    \ccNestedType{Less_y_2}{AdaptableBinaryFunction class \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$ \ccc{bool}.\\
      \ccc{op(p,q)} returns true, iff the $y$-coordinate of \ccc{p} is
      smaller than the $y$-coordinate of \ccc{q}.}
    
    \ccNestedType{Greater_x_2}{AdaptableBinaryFunction class
      \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$ \ccc{bool}.\\
      \ccc{op(p,q)} returns true, iff the $x$-coordinate of \ccc{p} is
      greater than the $x$-coordinate of \ccc{q}.}
    
    \ccNestedType{Greater_y_2}{AdaptableBinaryFunction class
      \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$ \ccc{bool}.\\
      \ccc{op(p,q)} returns true, iff the $y$-coordinate of \ccc{p} is
      greater than the $y$-coordinate of \ccc{q}.}
    
    \ccNestedType{Right_of_implicit_line_2}{Function class \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Point_2} $\times$ \ccc{Direction_2}
      $\rightarrow$ \ccc{bool}.\\ \ccc{op(p1,p2,d)} returns true, iff
      the \ccc{p1} is strictly to the right of the oriented line
      through \ccc{p2} with direction \ccc{d}.}
    
    \ccNestedType{Less_rotate_ccw_2}{AdaptableBinaryFunction class
      \\\ccc{op}: \ccc{Direction_2} $\times$ \ccc{Direction_2}
      $\rightarrow$ \ccc{bool}.\\ \ccc{op(d1,d2)} returns true, iff
      the slope of \ccc{d1} is less than the slope of \ccc{d2}.}
    
    \ccNestedType{Area_less_rectangle_2}{AdaptableBinaryFunction class
      \\\ccc{op}: \ccc{Rectangle_2} $\times$ \ccc{Rectangle_2}
      $\rightarrow$ \ccc{bool}.\\ \ccc{op(r1,r2)} returns true, iff
      the area of $r1$ is strictly less than the area of $r2$.}
    
    \ccNestedType{Area_less_parallelogram_2}{AdaptableBinaryFunction
      class \\\ccc{op}: \ccc{Parallelogram_2} $\times$
      \ccc{Parallelogram_2} $\rightarrow$ \ccc{bool}.\\ 
      \ccc{op(p1,p2)} returns true, iff the area of $p1$ is strictly
      less than the area of $p2$.}
    
    \ccNestedType{Width_less_strip_2}{AdaptableBinaryFunction class
      \\\ccc{op}: \ccc{Strip_2} $\times$ \ccc{Strip_2} $\rightarrow$
      \ccc{bool}.\\ \ccc{op(s1,s2)} returns true, iff the width of
      $s1$ is strictly less than the width of $s2$.}
    
    \ccNestedType{Rotate_direction_by_multiple_of_pi_2}{
      AdaptableBinaryFunction class \\\ccc{op}: \ccc{Direction_2}
      $\times$ \ccc{int} $\rightarrow$ \ccc{Direction_2}.\\ For a
      direction $d$ and $i,\, 0 \le i < 4$ \ccc{op(d,i)} returns the
      direction that results from clockwise rotating $d$ by $i \cdot
      \pi$.}
    
    \ccNestedType{Construct_direction_2}{AdaptableBinaryFunction class
      \\\ccc{op}: \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$
      \ccc{Direction_2}.\\ \ccc{op(p,q)} returns the direction of the
      vector from $p$ to $q$.}
    
    \ccNestedType{Construct_rectangle_2}{Function class \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Direction_2} $\times$ \ccc{Point_2}
      $\times$ \ccc{Point_2} $\times$ \ccc{Point_2} $\rightarrow$
      \ccc{Rectangle_2}.\\ If the points
      \ccc{p1},\,\ccc{p2},\,\ccc{p3},\,\ccc{p4} form the boundary of a
      convex polygon (oriented counterclockwise),
      \ccc{op(p1,d,p2,p3,p4)} returns the rectangle with one of the
      points on each side and one sides parallel to \ccc{d}.}
    
    \ccNestedType{Construct_parallelogram_2}{Function class
      \\\ccc{op}: \ccc{Point_2} $\times$ \ccc{Direction_2} $\times$
      \ccc{Point_2} $\times$ \ccc{Direction_2} $\times$ \ccc{Point_2}
      $\times$ \ccc{Point_2} $\rightarrow$ \ccc{Rectangle_2}.\\ If the
      points \ccc{p1},\,\ccc{p2},\,\ccc{p3},\,\ccc{p4} form the
      boundary of a convex polygon (oriented counterclockwise),
      \ccc{op(p1,d1,p2,d2,p3,p4)} returns the parallelogram with one
      of the points on each side and one side parallel to each of
      \ccc{d1} and \ccc{d2}.}
    
    \ccNestedType{Construct_strip_2}{Function class \\\ccc{op}:
      \ccc{Point_2} $\times$ \ccc{Direction_2} $\times$ \ccc{Point_2}
      $\rightarrow$ \ccc{Strip_2}.\\ \ccc{op(p1,d,p2)} returns the
      strip bounded by the lines through \ccc{p1} resp. \ccc{p2} with
      direction \ccc{d}.}
    
    \ccOperations
    
    \ccThree{OutputIterator}{OutputIterator}{}
    
    \ccMemberFunction{template < class OutputIterator > OutputIterator
      copy_rectangle_vertices_2(const Rectangle_2& r, OutputIterator
      o) const;}{copies the four vertices of \ccc{r} in
      counterclockwise order to \ccc{o}.}
    
    \ccMemberFunction{template < class OutputIterator > OutputIterator
      copy_parallelogram_vertices_2(const Parallelogram_2& p,
      OutputIterator o) const;}{copies the four vertices of \ccc{p} in
      counterclockwise order to \ccc{o}.}
    
    \ccMemberFunction{template < class OutputIterator > OutputIterator
      copy_strip_lines_2(const Strip_2& s, OutputIterator o)
      const;}{copies the two lines bounding \ccc{s} to \ccc{o}.}

    The following functions just return the corresponding function
    object.
    
    \ccThree{Rotate_direction_by_multiple_of_pi_2}{
      rotate_direction_by_multiple_of_pi_2_object();}{}
        
    \ccMemberFunction{Equal_2 equal_2_object();}{}
    \ccGlue\ccMemberFunction{Less_x_2 less_x_2_object();}{}
    \ccGlue\ccMemberFunction{Less_y_2 less_y_2_object();}{}
    \ccGlue\ccMemberFunction{Greater_x_2 greater_x_2_object();}{}
    \ccGlue\ccMemberFunction{Greater_y_2 greater_y_2_object();}{}
    
    \ccGlue\ccMemberFunction{Right_of_implicit_line_2
      right_of_implicit_line_2_object() const;}{}
    \ccGlue\ccMemberFunction{Less_rotate_ccw_2
      less_rotate_ccw_2_object();}{}
    \ccGlue\ccMemberFunction{Area_less_rectangle_2
      area_less_rectangle_2_object();}{}
    \ccGlue\ccMemberFunction{Area_less_parallelogram_2
      area_less_parallelogram_2_object();}{}
    \ccGlue\ccMemberFunction{Width_less_strip_2
      width_less_strip_2_object();}{}
    \ccGlue\ccMemberFunction{Construct_direction_2
      construct_direction_2_object();}{}
    \ccGlue\ccMemberFunction{Construct_rectangle_2
      construct_rectangle_2_object() const;}{}
    \ccGlue\ccMemberFunction{Construct_parallelogram_2
      construct_parallelogram_2_object() const;}{}
    \ccGlue\ccMemberFunction{Construct_strip_2
      construct_strip_2_object() const;}{}
    \ccGlue\ccMemberFunction{Rotate_direction_by_multiple_of_pi_2
      rotate_direction_by_multiple_of_pi_2_object();}{}
    
    \ccSeeAlso\ccInclude{CGAL/Minimum_enclosing_quadrilateral_traits_2.h}
    
    The class
    \ccc{Minimum_enclosing_quadrilateral_default_traits_2<R>}
    (templatized with a \cgal\ representation class) fulfills these
    requirements.
    
  \end{ccClass}
\end{ccAdvanced}

%% --------------------------------------------------------------
%% EOF spec_oops.awi
%% --------------------------------------------------------------
