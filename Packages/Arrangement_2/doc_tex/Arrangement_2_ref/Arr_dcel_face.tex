% +------------------------------------------------------------------------+
% | Reference manual page: Arr_dcel_face.tex
% +------------------------------------------------------------------------+
% | 
% | Package: Arrangement_2
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

\begin{ccRefConcept}{ArrangementDcelFace}

\ccDefinition

A face record in a \dcel\ data structure. A face may either be unbounded,
otherwise it has an incident halfedge along the chain defining its outer
boundary. A face may also contain holes and isolated vertices in its
interior.

\ccCreationVariable{f}

\ccTypes
%=======

\ccNestedType{Vertex}{the corresponding \dcel\ vertex type.}
\ccGlue
\ccNestedType{Halfedge}{the corresponding \dcel\ halfedge type.}

\ccNestedType{Holes_iterator}{a bidirectional iterator over the holes in 
inside the face. Its value-type is \ccStyle{Halfedge*}.}

\ccNestedType{Isolated_vertices_iterator}{a bidirectional iterator over the
isolated vertices in inside the face. Its value-type is \ccStyle{Vertex*}.}

The non-mutable iterators \ccc{Holes_const_iterator},
and \ccc{Isolated_vertices_const_iterator} are also defined.

\ccCreation
%==========

\ccConstructor{Arr_dcel_face();}
   {default constructor.}

\ccMethod{void assign (const Self& other);}
   {assigns \ccVar{} with the contents of the \ccc{other} face.}

\ccHtmlNoLinksFrom{   % to avoid linkage of Vertex, etc to HDS::Vertex

\ccAccessFunctions
%=================

All functions below also have \ccc{const} counterparts, returning non-mutable
pointers or iterators:

  \ccMethod{Halfedge* halfedge();}
    {returns an incident halfedge along the outer boundary of the face.
     If \ccVar{} is the unbounded face, the function returns \ccc{NULL}.}

  \ccMethod{size_t number_of_holes() const;}
    {returns the number of holes inside \ccVar{}.}
  \ccGlue
  \ccMethod{Holes_iterator holes_begin();}
    {returns a begin-iterator for the holes inside \ccVar{}.}
  \ccGlue
  \ccMethod{Holes_iterator holes_end();}
    {returns a past-the-end iterator for the holes inside \ccVar{}.}

  \ccMethod{size_t number_of_isolated_vertices() const;}
    {returns the number of isolated vertices inside \ccVar{}.}
  \ccGlue
  \ccMethod{Isolated_vertices_iterator isolated_vertices_begin();}
    {returns a begin-iterator for the isolated vertices inside \ccVar{}.}
  \ccGlue
  \ccMethod{Isolated_vertices_iterator isolated_vertices_end();}
    {returns a past-the-end iterator for the isolated vertices inside 
     \ccVar{}.}

\ccModifiers
%===========

  \ccMethod{void set_halfedge (Halfedge* e);}
    {sets the incident halfedge.}

  \ccMethod{void add_hole (Halfedge* e);}
    {adds \ccc{e} as a hole inside \ccVar{}.}

  \ccMethod{void erase_hole (Holes_iterator it);}
    {removes the hole that \ccc{it} points to from inside \ccVar{}.}
  
  \ccMethod{void add_isolated_vertex (Vertex* v);}
    {adds \ccc{v} as an isolated vertex inside \ccVar{}.}

  \ccMethod{void erase_isolated_vertex (Isolated_vertices_iterator it);}
    {removes the isolated vertex that \ccc{it} points to from inside \ccVar{}.}

} % ccHtmlNoLinksFrom

\ccSeeAlso

\ccc{ArrangementDcel}\lcTex{ 
     (\ccRefPage{ArrangementDcel})}\\
\ccc{ArrangementDcelVertex}\lcTex{
     (\ccRefPage{ArrangementDcelVertex})} \\
\ccc{ArrangementDcelHalfedge}\lcTex{
     (\ccRefPage{ArrangementDcelHalfedge})}

\end{ccRefConcept}  

\ccRefPageEnd
