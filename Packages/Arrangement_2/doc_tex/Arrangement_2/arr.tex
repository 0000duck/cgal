
\newcommand{\reals}{{\rm I\!\hspace{-0.025em} R}}
\newcommand{\C}{{\cal C}}
\newcommand{\A}{{\cal A}}
\newcommand{\eps}{{\varepsilon}}
\newcommand{\dcel}{{\sc Dcel}}


% ===============================================================
\section{Introduction}
\label{arr_sec:intro}
% ===================

Given a set $\C$ of planar curves, their {\em arrangement}
$\A(\C)$ is the subdivision they induce on the plane into
zero-dimensional, one-dimensional and two-dimensional cells,
called {\em vertices}, {\em edges} and {\em faces}, respectively.

As the curves in $\C$ can intersect and are not necessarily
$x$-monotone, we construct a collection $\C''$ in two steps. We
first decompose each curve in $\C$ into maximal $x$-monotone
curves (and possible isolated points), thus obtaining the
collection $\C'$. Then we decompose each curve in $\C'$ into
maximal connected pieces not intersecting any other curve (or
point) in $\C'$. This way we obtain the collection $\C''$ of
$x$-monotone subcurves that pairwise disjoint in their interiors.
This collection may also contain isolated points, if the curves of
$\C$ contain such points. The collection $\C''$ can be
conveniently embedded as a planar graph, whose vertices are
associated with curve endpoints or with isolated points and whose
edges are associated with subcurves. This graph can represented
using a {\em doubly-connected edge list} data-structure (\dcel\
for short), which consists of containers of vertices, edges and
faces and maintains the incidence relations among these objects.

The main idea behind the \dcel\ data-structure is to represent
each edge using a pair of directed {\em halfedges}, one going from
the (lexicographically) left endpoint of the curve to its right
endpoint, and the other --- known as its {\em twin} halfedge ---
going in the opposite direction. Halfedges are used to separate
faces and to connect vertices (with the exception of {\em isolated
vertices}, which are not connected).

If a vertex $v$ is the target of a halfedge $e$, we say that $v$
and $e$ are {\em incident} to each other. The halfedges incident
to a vertex $v$ form a circular list oriented in a clockwise order
around this vertex (we assume $v$ is not an isolated vertex, as
isolated vertices have no incident halfedges).

Each halfedge $e$ stores a pointer to its {\it incident face},
which is the face lying to its left. Moreover, every halfedge is
followed by another halfedge sharing the same incident face, such
that the target vertex of the halfedge is the same as the source
vertex of the next halfedge. The halfedges are therefore connected
in circular lists and form chains, such that all edges of a chain
are incident to the same face and wind along its boundary. We call
such chains a {\em connected component of the boundary} (or {\em
CCB} for short).

A bounded face has a unique CCB of halfedges winding is a
counterclockwise orientation along its boundary, that is defined
to be its {\em outer CCB}, while the unbounded face does not have
an outer boundary (as the arrangement module supports only bounded
curves, we always have exactly one unbounded face in the
arrangement). Any other connected component of the boundary of the
face is called a {\em hole} (or {\em inner CCB}), and can be
represented as a circular chain of halfedges winding in a
clockwise orientation around its outer boundary. Note that a hole
is not necessarily a single face --- it may have no area, or
alternatively it may consist of several connected faces.  Every
face can have several holes contained in its interior (or there
may be no holes). In addition, every face may contain isolated
vertices in its interior. See Figure~\ref{arr_fig:seg_dcel} for an
illustration of the various \dcel\ features.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/arr_segs.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of interior-disjoint line segment, which
consists of a single connected component inside the unbounded face
$\tilde{f}$, with some of the \dcel\ records that represent it.
The half-edge $e$ (and its twin $e'$) correspond to a line segment
that connects the vertices $v_1$ and $v_2$ and separates the face
$f_1$ from $f_2$. The predecessor $e_{\rm prev}$ and successor
$e_{\rm next}$ of $e$ are part of the chain that form the outer
boundary of the face $f_2$. The face $f_1$ has a more complicated
structure as it contains two holes in its interior: One hole
consists of two adjacent faces $f_3$ and $f_4$, while the other
hole is comprised of two edges. $f_1$ also contains two isolated
vertices $u_1$ and $u_2$ in its interior.}
\label{arr_fig:seg_dcel}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="arr_segs.gif"  border=0 alt="An arrangement of line segments">
%</center>
%\end{ccHtmlOnly}
\end{figure}

\section{The Main Arrangement Class}
\label{arr_sec:arr_class}
%===================================

The main guideline behind the design of the arrangement package is
the separation of the representation of the planar arrangement
from the various algorithms that operate on it. Another important
guideline is the separation between geometry an topology in the
arrangement representation.

The class \ccc{Arrangement_2<Traits,Dcel>} is a the main class in
the arrangement package. It is used to represent planar
arrangements and provides the interface needed to traverse them
and to maintain them. The arrangement is represented using the
\dcel\ class, which captures the {\em topological structure} of
the planar subdivision, and a geometric {\em traits} class that
defines the family of planar curves that form the arrangement and
supplies a range of geometric predicates (and constructions)
needed to construct and maintain the arrangement.

The separation between topology and geometry is defined by the two
template parameters of the \ccc{Arrangement_2} template:
\begin{itemize}
\item The \ccc{Traits} template-parameter should be instantiated with a
model of the \ccc{ArrangementBasicTraits} concept. The traits
class defines the types of $x$-monotone curves and two-dimensional
points --- \ccc{X_monotone_curve_2} and \ccc{Point_2},
respectively --- and supports basic geometric predicates on them.

In the first sections of this chapter we will always use
\ccc{Arr_segment_traits_2}, which enables the construction of
arrangements of line segments, as our traits class. However, the
arrangement package is shipped with several other traits classes
that can handle also poly-lines (continuous piecewise-linear
curves), conic arcs and arcs of rational functions. We will
exemplify the usage of these traits classes in
Section~\ref{arr_sec:traits}.

\item The \ccc{Dcel} template-parameter should be instantiated with a
class that is a model of the \ccc{ArranagementDcel} concept. The
value of this parameter is by default
\ccc{Arr_default_dcel<Traits>}, and it is recommended for most
users to stick to this default implementation of a \dcel\ class.
However, in some applications it is necessary to extend the \dcel\
features --- see Section~\ref{arr_sec:ex_dcel} for further
explanations and examples.
\end{itemize}

\subsection{Traversing the Arrangement}
\label{arr_ssec:traverse}
%--------------------------------------

The simplest and most fundamental arrangement operations are the
various traversal methods, that allow users to systematically go
over the relevant features of the arrangement at hand.

As mentioned before, the arrangement is represented as a \dcel,
and therefore stores three containers of vertices, halfedges and
faces. The \ccc{Arrangement_2} class therefore supplies iterators
for these containers. For example, the methods
\ccc{vertices_begin()} and \ccc{vertices_end()} return
\ccc{Arrangement_2::Vertex_iterator} objects that define the valid
range of arrangement vertices. The value type of this iterator is
\ccc{Arrangement_2::Vertex}. Moreover, the vertex-iterator type is
equivalent to \ccc{Arrangement_2::Vertex_handle}, which serves as
a pointer to a vertex. As we see next, all function related to
arrangement features accept handle types as input parameters and
return handle types as their output. Each of the three nested
classes support a \ccc{handle()} method that returns a handle to
the object at hand.

In addition to the iterators for arrangement vertices, halfedges
and faces, the arrangement class also support \ccc{edges_begin()}
and \ccc{edges_end()} that return
\ccc{Arrangement_2::Edge_iterator} objects for traversing the
arrangement edges. Note that the value type of this iterator is
\ccc{Arrangement_2::Halfedge}, representing one of the twin
halfedge that form the edge. In fact, as twin halfedges always are
always contiguous in the halfedge container, using this iterator
is equivalent to going over all halfedges and taking every second
halfedge.

All iterator, circulator and handle types also have non-mutable
(a.k.a. {\em const}) counterparts. For example, the arrangement
has a non-constant member function called \ccc{vertices_begin()}
that returns a \ccc{Vertex_iterator} object and another const
member function that returns a a \ccc{Vertex_const_iterator}
object. In fact, all methods listed in this section that return an
iterator, a circulator or a handle have non-mutable counterparts.
It should be noted that, for example, \ccc{Vertex_handle} can be
readily converted to a \ccc{Vertex_const_handle}, but not
vice-versa.

\subsubsection{Traversal Methods for an Arrangement Vertex}
\label{arr_sssec:tr_vertex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A vertex is always associated with a geometric entity, namely with
a \ccc{Point_2} object, which can be retrieved by calling the
\ccc{point()} method of the nested \ccc{Vertex} class.

The \ccc{is_isolated()} method is used to determine whether a
vertex is isolated or not. Recall that the incident halfedges
incident to a regular (non-isolated) vertex form a circular list
around this vertex. The \ccc{incident_halfedges()} method returns
a circulator of type
\ccc{Arrangement_2::Halfedge_around_vertex_circulator} that
enables the traversal of this circular list in a clockwise
direction. The value type of this circulator is \ccc{Halfedge}.

The following function prints all the neighbors of a given
arrangement vertex (assuming the \ccc{Point_2} type can be
exported to the standard output using the \ccc{<<} operator). For
simplicity, we assume that the arrangement type and its nested
type are properly defined (see next for more complete examples):
\begin{alltt}
void print_neighboring_vertices (Vertex_const_handle v)
\{
  if (v->is_isolated())
  \{
    std::cout << "The vertex (" << v->point() << ") is isolated" << std::endl;
    return;
  \}

  Halfedge_around_vertex_const_circulator  first, curr;
  Vertex_const_handle                      u;

  std::cout << "The neighbors of the vertex (" << v->point() << ") are:";
  first = curr = v->incident_halfedges();
  do
  \{
    // Note that the current halfedge is (u -> v):
    u = curr->source();
    std::cout << " (" << u->point() << ")";

    ++curr;
  \} while (curr != first);
  std::cout << std::endl;

  return;
\}
\end{alltt}

In case of an isolated vertex, it is possible to obtain the face
that contains this vertex. However, this is done via a method of
the \ccc{Arrangement_2} class, called \ccc{incident_face
(Vertex_handle v)}, and not using one of the methods of the nested
\ccc{Vertex} class.

\subsubsection{Traversal Methods for an Arrangement Halfedge}
\label{arr_sssec:tr_halfedge}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each pair of twin halfedge is associated with an
\ccc{X_monotone_curve_2} object, which can be retrieved by calling
the \ccc{curve()} method of the nested \ccc{Halfedge} class.

The \ccc{source()} and \ccc{target()} methods return handles to
the halfedge source and target vertices, respectively. One can
obtain a handle to the twin halfedge using the \ccc{twin()}
method. From the definition of halfedges, it follows that if
\ccc{he} is a halfedge handle, then:
\begin{itemize}
\item \ccc{he->curve()} is equivalent to \ccc{he->twin()->curve()}.
\item \ccc{he->source()} is equivalent to \ccc{he->twin()->target()}.
\item \ccc{he->target()} is equivalent to \ccc{he->twin()->source()}.
\end{itemize}

Every halfedge has an incident face that lies to its left, which
can be obtained by using the \ccc{face()} method. Recall that a
halfedge is always one link in a connected chains of halfedges
that share the same incident face, known as a {\em CCB}. The
\ccc{prev()} and \ccc{next()} methods return handles to the
previous and next halfedges in the CCB (note that \ccc{he->prev()}
is not necessarily equivalent to \ccc{he->twin()->next()}).

As the CCB is actually a circular list, it is natural to traverse
it using a circulator. The \ccc{ccb()} method returns a
\ccc{Arrangement_2::Ccb_halfedge_circulator} object for the
halfedges along the CCB.

The following function prints all $x$-monotone curves and points
along a CCB (assuming that the \ccc{Point_2} and the
\ccc{X_monotone_curve_2} types can be exported to the standard
output using the \ccc{<<} operator):
\begin{alltt}
void print_ccb (Ccb_halfedge_const_circulator circ)
\{
  Ccb_halfedge_const_circulator  curr = circ;
  Halfedge_const_handle          he;

  std::cout << "(" << curr->source()->point() << ")";
  do
  \{
    he = curr->handle();
    std::cout << "   [" << he->curve() << "]   "
              << "(" << he->target()->point() << ")";

    ++curr;
  \} while (curr != circ);
  std::cout << std::endl;

  return;
\}
\end{alltt}


\subsubsection{Traversal Methods for an Arrangement Face}
\label{arr_sssec:tr_face}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As the \ccc{Arrangement_2} class supports only finite curves, the
arrangement always has a single unbounded face, where all other
arrangement features form holes (or isolated vertices) inside this
face. (Note that an empty arrangement contains no other feature
{\em but} the unbounded face.) The function \ccc{unbounded_face()}
returns a handle to this face.

Given a \ccc{Face} object, we can use the \ccc{is_unbounded()}
method to determine whether it is unbounded. Bounded face have an
outer CCB, and the \ccc{outer_ccb()} method returns a circulator
for the halfedges along this CCB. Note that the halfedges along
this CCB wind in a counterclockwise orientation around the outer
boundary of the face.

A face can also contain disconnected components in its interior,
namely holes and isolated vertices:
\begin{itemize}
\item The \ccc{holes_begin()} and \ccc{holes_end()} methods return
\ccc{Arrangement_2::Holes_iterator} objects that define the range
of holes inside the face. The value type of this iterator is
\ccc{Ccb_halfedge_circulator}, defining the CCB that winds in a
clockwise orientation around a hole.

\item The \ccc{isolated_vertices_begin()} and
\ccc{isolated_vertices_end()} methods return
\ccc{Arrangement_2::Isolated_vertices_iterator} objects that
define the range of isolated vertices inside the face. The value
type of this iterator is \ccc{Vertex}.
\end{itemize}

The following function prints the outer and inner boundaries of a
given face, using the function \ccc{print_ccb()} that was
introduced in the previous subsection:
\begin{alltt}
void print_face (Face_const_handle f)
\{
  // Print the outer boundary.
  if (f->is_unbounded())
  \{
    std::cout << "Unbounded face. " << std::endl;
  \}
  else
  \{
    std::cout << "Outer boundary: ";
    print_ccb (f->outer_ccb());
  \}

  // Print the boundary of each of the holes.
  Holes_const_iterator              hole;
  int                               index = 1;

  for (hole = f->holes_begin(); hole != f->holes_end(); ++hole, ++index)
  \{
    std::cout << "    Hole #" << index << ": ";
    print_ccb (*hole);
  \}

  // Print the isolated vertices.
  Isolated_vertices_const_iterator  iv;

  for (iv = f->isolated_vertices_begin(), index = 1;
       iv != f->isolated_vertices_end(); ++iv, ++index)
  \{
    std::cout << "    Isolated vertex #" << index << ": "
              << "(" << iv->point() << ")" << std::endl;
  \}

  return;
\}
\end{alltt}

\subsubsection{Additional Example}
\label{arr_sssec:tr_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To conclude the review of the various traversal methods, we bring
the following function that prints the current setting of the
arrangement:\footnote{To simplify the code, we assume that the
\ccc{Arrangement_2} type is defined as a proper instantiation of
the \ccc{Arrangement_2<Traits,Dcel>} template and all its nested
types are also defined. In the file \ccc{arr_print.h} that can be
found under the examples folder this function (and the rest of the
functions listed in this section) are brought in a more general
setting, where the arrangement type serves as a template parameter
for these functions, so different instantiations of the
\ccc{Arrangement_2<Traits,Dcel>} template can be provided to the
same function templates.}
\begin{alltt}
void print_arrangement (const Arrangement_2& arr)
\{
  // Print the arrangement vertices.
  Vertex_const_iterator      vit;

  std::cout << arr.number_of_vertices() << " vertices:" << std::endl;
  for (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)
  \{
    std::cout << "(" << vit->point() << ")";
    if (vit->is_isolated())
      std::cout << " - Isolated." << std::endl;
    else
      std::cout << " - degree " << vit->degree() << std::endl;
  \}

  // Print the arrangement edges.
  Edge_const_iterator        eit;

  std::cout << arr.number_of_edges() << " edges:" << std::endl;
  for (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)
    std::cout << "[" << eit->curve() << "]" << std::endl;

  // Print the arrangement faces.
  Face_const_iterator        fit;

  std::cout << arr.number_of_faces() << " faces:" << std::endl;
  for (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)
    print_face (fit);

  return;
\}
\end{alltt}

\subsection{Modifying the Arrangement}
\label{arr_ssec:modify}
%-------------------------------------

\subsubsection{Inserting Non-Intersecting Curves}
\label{arr_sssec:mf_insert_cv}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Alongside with the traversal methods, the arrangement class also
supports several methods that modify the arrangement, the most
important ones being the specialized insertion functions of
$x$-monotone curves whose interior is disjoint from any other
curve in the existing arrangement and does not contain any vertex
of the arrangement. We will also assume that the location of the
curve in the arrangement is known.

The reason for these rather harsh restrictions on the nature of
the inserted curves is the decoupling of the topological
arrangement representation from the various algorithms that
operate on it. While the insertion of an $x$-monotone curve whose
interior is disjoint from all existing arrangement features is
quite straightforward (as we see next), inserting curves that
intersect with the arrangement is much more complicated and
requires the application of non-trivial algorithms. These insertion
operations are therefore implemented as global functions that
operate on the arrangement and the inserted curve(s) --- see
Section~\ref{arr_sec:gl_funs} for more details and ample examples.


\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
    \begin{tabular}{ccc}
        \input{Arrangement_2/insert_in_face.pstex_t} &
        \input{Arrangement_2/insert_from_vertex.pstex_t} &
        \input{Arrangement_2/insert_at_vertices.pstex_t} \\
    {\small (a)} & {\small (b)} & {\small (c)}\\
    \end{tabular}
\end{center}
\end{ccTexOnly}
\caption{The various specialized insertion
procedures. The inserted $x$-monotone curve is drawn with a light
dashed line, surrounded by two solid arrows that represent the
pair of twin half-edges added to the \dcel. Existing vertices are
shown as black dots while new vertices are shown as light dots.
Existing half-edges that are affected by the insertion operations
are drawn as dashed arrows. (a) Inserting a curve as a new hole
inside the face $f$. (b) Inserting a curve from an existing
vertex $u$ that corresponds to one of its endpoints. (c) Inserting
a whose endpoints are already represented by the vertices
$u_1$ and $u_2$. In our case, the new pair of half-edges close a
new face $f'$, where the hole $h_1$, which used to belong to $f$,
now becomes an enclave in this new face.}
\label{arr_fig:insert}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="insert_funcs.gif"  border=0 alt="The various specialized insertion procedures.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

It is not difficult to see that when we insert an $x$-monotone curve
into an existing arrangement, such that the interior of this curve is
disjoint from any arrangement feature, only the following three
scenarios are possible, depending on the status of the endpoints
of the inserted subcurve:
\begin{enumerate}

\item In case both curve endpoints do not correspond to any existing
arrangement vertex we use we have to create two new vertices
corresponding to the curve endpoints and connect them using a pair of
twin halfedges. This halfedge pair initiates a new hole inside the
face that contains the curve in its interior.

\item If exactly one endpoint corresponds to an existing arrangement
vertex (we distinguish between a vertex that corresponds to the left
endpoint of the inserted curve and a vertex corresponding to its right
endpoint), we have to create a new vertex that corresponds to the other
endpoint of the curve and to connect the two vertices by a pair of
twin halfedges that form an ``antenna'' emanating from the boundary
of an existing connected component (note that if the existing vertex
used to be isolated, this operation is actually equivalent to forming
a new hole inside the face that contains this vertex).

\item Otherwise, if both endpoints correspond to existing arrangement
vertices we connect these vertices using a pair of twin halfedges.
Let us assume the two vertices are not isolated (otherwise the
operation is equivalent to one of the two previous cases). The two
following cases may occur:
\begin{itemize}
\item Two disconnected components are merged into a single connected
component.

\item A new face is created --- actually, it is split from an existing
arrangement face. In this case we also have to examine the holes and
isolated vertices in the existing face and move the relevant ones
inside the new face.
\end{itemize}
\end{enumerate}

The \ccc{Arrangement_2} class offers insertion functions named
\ccc{insert_in_face_interior()}, \ccc{insert_from_left_vertex()},
\ccc{insert_from_right_vertex()} and \ccc{insert_at_vertices()} that
perform the special insertion procedures listed above. The first
function accepts an $x$-monotone curve and an arrangement face that
contains this curve in its interior, while the other function accept
an $x$-monotone and handles to the existing vertices that correspond
to the curve endpoints. Each of the four functions return a handle to
one of the twin halfedges that have been created, where:
\begin{itemize}
\item \ccc{insert_in_face_interior(cv, f)} returns a halfedge directed
from the vertex corresponding to the left endpoint of \ccc{cv} toward
the vertex corresponding to its right endpoint.

\item \ccc{insert_from_left_vertex(cv, v)} and
\ccc{insert_from_right_vertex(cv, v)} return a halfedge whose source
is the vertex $v$ that and whose target is the new vertex that has just
been created.

\item \ccc{insert_at_vertices(cv, v1, v2)} returns a halfedge directed
from $v_1$ to $v_2$.
\end{itemize}

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_1.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{The arrangement of the line segments $s_1, \ldots, s_5$
constructed in \ccc{example1.C}. The arrows mark the direction of
the halfedges returned from the various insertion functions.}
\label{arr_fig:ex_1}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_1.gif"  border=0 alt="The segment arrangement constructed in \ccc{example1.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program demonstrates the usage of the four insertion
functions. It creates an arrangement of five line segments, as
depicted in Figure~\ref{arr_fig:ex_1}. As the arrangement is very
simple, we use the simple Cartesian kernel of \cgal\ with integer
coordinates for the segment endpoints. We used the built-in
\ccc{Arr_segment_traits_2} class that enables the efficient
maintenance of arrangements of line segments
--- see more details on this traits class in Section~\ref{arr_sec:traits}:

\ccIncludeExampleCode{../examples/Arrangement_2/example1.C}

Note that the first line segment is inserted in the interior of the
unbounded face, while for the insertion of the rest of the line segments
are inserted using the vertices created by the insertion of previous
segments. The resulting arrangement consists of three faces, while the
two bounded faces form together a hole in the unbounded face.

\subsubsection{Manipulating Isolated Vertices}
\label{arr_sssec:mf_iso_verts}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Isolated points are in general simpler geomteric entities than curves
and indeed the member functions that manipulate them are easier to
understand.

The function \ccc{insert_isolated_vertex(p, f)} inserts an isolated point
$p$ located in the interior of a given face $f$ into the arrangement and
returns a handle to the arrangement vertex associated with $p$. Naturally,
the precondition that $p$ is really an isolated point, namely it does not
coincide with any existing arrangement vertex and does not lie on any
edge.

As we have already mentioned in Section~\ref{arr_ssec:traverse}, it is
possible to obtain the face surrounding an isolated vertex by calling
\ccc{incident_face(v)} (with the precondition that $v$ is an isolated
vertex --- other vertices may not necessarily have a unique incident face).

The function \ccc{remove_isolated_vertex(v)} receives a handle to an
isolated vertex and removes it from the arrangement.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_2.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments containing three isolated
vertices, as constructed in \ccc{example2.C}. The vertices $u_2$
and $u_3$ are eventually deleted from the arrangement.}
\label{arr_fig:ex_2}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_2.gif"  border=0 alt="The segment arrangement constructed in \ccc{example2.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program demonstrates the usage of the arrangement
member-functions for manipulating isolated vertices. It first
inserts three isolated vertices inside the unbounded face, then
inserts four line segments that form a rectangular hole inside
the unbounded face (see Figure~\ref{arr_fig:ex_2} for an
illustration). It finally goes over the vertices and removes
those isolated vertices that are still contained in the unbounded
face ($u_2$ and $u_3$ in this case):

\ccIncludeExampleCode{../examples/Arrangement_2/example2.C}

\subsubsection{Manipulating Halfedges}
\label{arr_sssec:mf_halfedges}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the previous subsection we showed how to introduce new isolated
vertices in the arrangement. But how do we create a vertex that
lies on an existing arrangement edge (more precisely, on an
$x$-monotone curve that is associated with an arrangement edge)?

It should be noted that such an operation involves the splitting
of a curve at a given point in its interior, while the traits
class used by \ccc{Arrangement_2} does not necessarily have the
ability to perform such a split operation. However, if users know
how to split an $x$-monotone curve into two as a given point $p$,
they can use the \ccc{split_edge(e, p, c1, c2)} function, were
$c_1$ and $c_2$ are the two subcurves resulting for splitting the
$x$-monotone curve associated with the halfedge $e$ at a point $p$
in its interior. The function splits the halfedge pair into two
pairs, both incident to a new vertex $v$ associated with $p$, and
returns a handle to a halfedge whose source equals $e$'s source
vertex and whose target is the new vertex $v$.

The reverse operation is also possible. Suppose that we have a
vertex $v$ of degree $2$, whose two incident halfedges, $e_1$ and
$e_2$, are associated with the curves $c_1$ and $c_2$. Suppose
further that we know how to merge these two curves into a single
continuous $x$-monotone curve $c$ --- then calling
\ccc{merge_edge(e1, e2, c)} will merge the two edges into a single
edge associated with the curve $c$, resulting the removal of the
vertex $v$ from the arrangement.

Finally, the function \ccc{remove_edge(e)} removes the edge $e$
from the arrangement. Note that this operation is the reverse of
\ccc{insert_at_vertices()}, so it may cause a connected component
two split into two, or two face to merge into one.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
    \begin{tabular}{ccc}
        \input{Arrangement_2/ex_3a.pstex_t} &
        \input{Arrangement_2/ex_3b.pstex_t} &
        \input{Arrangement_2/ex_3c.pstex_t} \\
    {\small (a)} & {\small (b)} & {\small (c)}\\
    \end{tabular}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments containing as constructed
in \ccc{example3.C}. Note that the edges $e_7$ and $e_8$ and the
vertices $w_1$ and $w_2$, introduced in step~(b) are eventually
removed in step~(c).} \label{arr_fig:ex_3}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_3.gif"  border=0 alt="The segment arrangement constructed in \ccc{example3.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the following example program we show how the edge-manipulation
functions can be used. Not that here we still stick to integer
coordinates, but as we work on a larger scale we use an unbounded
integer number-type (in this case, the \ccc{Gmpz} type taken from
the {\sc Gmp} library) instead of the built-in \ccc{int}
type.\footnote{As a rule of thumb, one can use a bounded integer
type containing for representing line segments whose coordinates
are bounded by $\lfloor\sqrt[3]{M}\rfloor$, where $M$ is the
maximal representable integer value.} We also use the standard
Cartesian kernel of \cgal\ as our kernel --- this is recommended
when the kernel is instantiated with a more complex number type:

\ccIncludeExampleCode{../examples/Arrangement_2/example3.C}

Note how we use the halfedge handles returned from
\ccc{split_edge()} and \ccc{merge_edge()}. Also note the insertion
of the isolated vertex $v_6$ inside the triangular face (the
incident face of $e_7$). This vertex is eventually connected to
other vertices, so it stops being isolated.

In this context, we should mention the two member functions
\ccc{modify_vertex(v, p)}, which sets $p$ to be the point
associated with the vertex $v$, and \ccc{modify_edge(e, c)}, which
sets $c$ to be the $x$-monotone curve associated with the halfedge
$e$. To avoid the invalidation of the geometric structure of the
arrangement, these functions have preconditions that $p$ is
geometrically equivalent to \ccc{v->point()} and $c$ is equivalent
to \ccc{e->curve()} (i.e., the two curves have the same graph),
respectively. It therefore seems that these two functions are of
little use. However, we should keep in mind that there may be
extraneous data (probably non-geometric) associated with the point
objects or with the curve objects, as defined by the traits class,
so we are thus able to modify this data. In addition, we may
replace a geometric object with an equivalent object that has a
more compact representation. See more details in
Section~\ref{arr_sec:traits}.

\section{Global Arrangement Functions}
\label{arr_sec:gl_funs}
%=====================================

\section{Traits Classes}
\label{arr_sec:traits}
%=======================

\section{Extending the \dcel}
\label{arr_sec:ex_dcel}
%============================

\section*{Design and Implementation History}
%===========================================

The code of this package is the result of a long development process.
Initially (and until version~3.1), the code was spread among several
packages, namely \ccc{Topological_map}, \ccc{Planar_map_2},
\ccc{Planar_map_with_intersections_2} and \ccc{Arrangement_2}, that were
developed by~: \newline
Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran,
Sariel Har-Peled, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Ron Wein,
Baruch Zukerman and Tali Zvi.

In version~3.2, as part of the ACS project, the packages have done through
a major re-design, resulting in an improved \ccc{Arrangement_2} package.
The code of the new package was restructured and developed by~: \newline
Efi Fogel, Idit Haran, Ron Wein and Baruch Zukerman.
