\newcommand{\reals}{{\rm I\!\hspace{-0.025em} R}}
\newcommand{\C}{{\cal C}}
\newcommand{\A}{{\cal A}}
\newcommand{\eps}{{\varepsilon}}
\newcommand{\dcel}{{\sc Dcel}}
\newcommand{\naive}{na\"{\i}ve}
\newcommand{\kdtree}{{\sc Kd}-tree}


% ===============================================================
\section{Introduction}
\label{arr_sec:intro}
% ===================

Given a set $\C$ of planar curves, their {\em arrangement}
$\A(\C)$ is the subdivision they induce on the plane into
zero-dimensional, one-dimensional and two-dimensional cells,
called {\em vertices}, {\em edges} and {\em faces}, respectively.

As the curves in $\C$ can intersect and are not necessarily
$x$-monotone, we construct a collection $\C''$ in two steps. We
first decompose each curve in $\C$ into maximal $x$-monotone
curves (and possible isolated points), thus obtaining the
collection $\C'$. Then we decompose each curve in $\C'$ into
maximal connected pieces not intersecting any other curve (or
point) in $\C'$. This way we obtain the collection $\C''$ of
$x$-monotone subcurves that pairwise disjoint in their interiors.
This collection may also contain isolated points, if the curves of
$\C$ contain such points. The collection $\C''$ can be
conveniently embedded as a planar graph, whose vertices are
associated with curve endpoints or with isolated points and whose
edges are associated with subcurves. This graph can represented
using a {\em doubly-connected edge list} data-structure (\dcel\
for short), which consists of containers of vertices, edges and
faces and maintains the incidence relations among these objects.

The main idea behind the \dcel\ data-structure is to represent
each edge using a pair of directed {\em halfedges}, one going from
the (lexicographically) left endpoint of the curve to its right
endpoint, and the other --- known as its {\em twin} halfedge ---
going in the opposite direction. Halfedges are used to separate
faces and to connect vertices (with the exception of {\em isolated
vertices}, which are not connected).

If a vertex $v$ is the target of a halfedge $e$, we say that $v$
and $e$ are {\em incident} to each other. The halfedges incident
to a vertex $v$ form a circular list oriented in a clockwise order
around this vertex (we assume $v$ is not an isolated vertex, as
isolated vertices have no incident halfedges).

Each halfedge $e$ stores a pointer to its {\it incident face},
which is the face lying to its left. Moreover, every halfedge is
followed by another halfedge sharing the same incident face, such
that the target vertex of the halfedge is the same as the source
vertex of the next halfedge. The halfedges are therefore connected
in circular lists and form chains, such that all edges of a chain
are incident to the same face and wind along its boundary. We call
such chains a {\em connected component of the boundary} (or {\em
CCB} for short).

A bounded face has a unique CCB of halfedges winding is a
counterclockwise orientation along its boundary, that is defined
to be its {\em outer CCB}, while the unbounded face does not have
an outer boundary (as the arrangement module supports only bounded
curves, we always have exactly one unbounded face in the
arrangement). Any other connected component of the boundary of the
face is called a {\em hole} (or {\em inner CCB}), and can be
represented as a circular chain of halfedges winding in a
clockwise orientation around its outer boundary. Note that a hole
is not necessarily a single face --- it may have no area, or
alternatively it may consist of several connected faces.  Every
face can have several holes contained in its interior (or there
may be no holes). In addition, every face may contain isolated
vertices in its interior. See Figure~\ref{arr_fig:seg_dcel} for an
illustration of the various \dcel\ features.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/arr_segs.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of interior-disjoint line segment, which
consists of a single connected component inside the unbounded face
$\tilde{f}$, with some of the \dcel\ records that represent it.
The half-edge $e$ (and its twin $e'$) correspond to a line segment
that connects the vertices $v_1$ and $v_2$ and separates the face
$f_1$ from $f_2$. The predecessor $e_{\rm prev}$ and successor
$e_{\rm next}$ of $e$ are part of the chain that form the outer
boundary of the face $f_2$. The face $f_1$ has a more complicated
structure as it contains two holes in its interior: One hole
consists of two adjacent faces $f_3$ and $f_4$, while the other
hole is comprised of two edges. $f_1$ also contains two isolated
vertices $u_1$ and $u_2$ in its interior.}
\label{arr_fig:seg_dcel}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="arr_segs.gif"  border=0 alt="An arrangement of line segments">
%</center>
%\end{ccHtmlOnly}
\end{figure}

\section{The Main Arrangement Class}
\label{arr_sec:arr_class}
%===================================

The main guideline behind the design of the arrangement package is
the separation of the representation of the planar arrangement
from the various algorithms that operate on it. Another important
guideline is the separation between geometry an topology in the
arrangement representation.

The class \ccc{Arrangement_2<Traits,Dcel>} is a the main class in
the arrangement package. It is used to represent planar
arrangements and provides the interface needed to traverse them
and to maintain them. The arrangement is represented using the
\dcel\ class, which captures the {\em topological structure} of
the planar subdivision, and a geometric {\em traits} class that
defines the family of planar curves that form the arrangement and
supplies a range of geometric predicates (and constructions)
needed to construct and maintain the arrangement.

The separation between topology and geometry is defined by the two
template parameters of the \ccc{Arrangement_2} template:
\begin{itemize}
\item The \ccc{Traits} template-parameter should be instantiated with a
model of the \ccc{ArrangementBasicTraits_2} concept. The traits
class defines the types of $x$-monotone curves and two-dimensional
points --- \ccc{X_monotone_curve_2} and \ccc{Point_2},
respectively --- and supports basic geometric predicates on them.

In the first sections of this chapter we will always use
\ccc{Arr_segment_traits_2}, which enables the construction of
arrangements of line segments, as our traits class. However, the
arrangement package is shipped with several other traits classes
that can handle also polylines (continuous piecewise-linear
curves), conic arcs and arcs of rational functions. We will
exemplify the usage of these traits classes in
Section~\ref{arr_sec:traits}.

\item The \ccc{Dcel} template-parameter should be instantiated with a
class that is a model of the \ccc{ArranagementDcel} concept. The
value of this parameter is by default
\ccc{Arr_default_dcel<Traits>}, and it is recommended for most
users to stick to this default implementation of a \dcel\ class.
However, in some applications it is necessary to extend the \dcel\
features --- see Section~\ref{arr_sec:ex_dcel} for further
explanations and examples.
\end{itemize}

\subsection{Traversing the Arrangement}
\label{arr_ssec:traverse}
%--------------------------------------

The simplest and most fundamental arrangement operations are the
various traversal methods, that allow users to systematically go
over the relevant features of the arrangement at hand.

As mentioned before, the arrangement is represented as a \dcel,
and therefore stores three containers of vertices, halfedges and
faces. The \ccc{Arrangement_2} class therefore supplies iterators
for these containers. For example, the methods
\ccc{vertices_begin()} and \ccc{vertices_end()} return
\ccc{Arrangement_2::Vertex_iterator} objects that define the valid
range of arrangement vertices. The value type of this iterator is
\ccc{Arrangement_2::Vertex}. Moreover, the vertex-iterator type is
equivalent to \ccc{Arrangement_2::Vertex_handle}, which serves as
a pointer to a vertex. As we see next, all function related to
arrangement features accept handle types as input parameters and
return handle types as their output. Each of the three nested
classes support a \ccc{handle()} method that returns a handle to
the object at hand.

In addition to the iterators for arrangement vertices, halfedges
and faces, the arrangement class also support \ccc{edges_begin()}
and \ccc{edges_end()} that return
\ccc{Arrangement_2::Edge_iterator} objects for traversing the
arrangement edges. Note that the value type of this iterator is
\ccc{Arrangement_2::Halfedge}, representing one of the twin
halfedge that form the edge. In fact, as twin halfedges always are
always contiguous in the halfedge container, using this iterator
is equivalent to going over all halfedges and taking every second
halfedge.

All iterator, circulator and handle types also have non-mutable
(a.k.a. {\em const}) counterparts. For example, the arrangement
has a non-constant member function called \ccc{vertices_begin()}
that returns a \ccc{Vertex_iterator} object and another const
member function that returns a a \ccc{Vertex_const_iterator}
object. In fact, all methods listed in this section that return an
iterator, a circulator or a handle have non-mutable counterparts.
It should be noted that, for example, \ccc{Vertex_handle} can be
readily converted to a \ccc{Vertex_const_handle}, but not
vice-versa.

\subsubsection{Traversal Methods for an Arrangement Vertex}
\label{arr_sssec:tr_vertex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A vertex is always associated with a geometric entity, namely with
a \ccc{Point_2} object, which can be retrieved by calling the
\ccc{point()} method of the nested \ccc{Vertex} class.

The \ccc{is_isolated()} method is used to determine whether a
vertex is isolated or not. Recall that the incident halfedges
incident to a regular (non-isolated) vertex form a circular list
around this vertex. The \ccc{incident_halfedges()} method returns
a circulator of type
\ccc{Arrangement_2::Halfedge_around_vertex_circulator} that
enables the traversal of this circular list in a clockwise
direction. The value type of this circulator is \ccc{Halfedge}.

The following function prints all the neighbors of a given
arrangement vertex (assuming the \ccc{Point_2} type can be
exported to the standard output using the \ccc{<<} operator). For
simplicity, we assume that the arrangement type and its nested
type are properly defined (see next for more complete examples):
\begin{alltt}
void print_neighboring_vertices (Vertex_const_handle v)
\{
  if (v->is_isolated())
  \{
    std::cout << "The vertex (" << v->point() << ") is isolated" << std::endl;
    return;
  \}

  Halfedge_around_vertex_const_circulator  first, curr;
  Vertex_const_handle                      u;

  std::cout << "The neighbors of the vertex (" << v->point() << ") are:";
  first = curr = v->incident_halfedges();
  do
  \{
    // Note that the current halfedge is (u -> v):
    u = curr->source();
    std::cout << " (" << u->point() << ")";

    ++curr;
  \} while (curr != first);
  std::cout << std::endl;

  return;
\}
\end{alltt}

In case of an isolated vertex, it is possible to obtain the face
that contains this vertex. However, this is done via a method of
the \ccc{Arrangement_2} class, called \ccc{incident_face
(Vertex_handle v)}, and not using one of the methods of the nested
\ccc{Vertex} class.

\subsubsection{Traversal Methods for an Arrangement Halfedge}
\label{arr_sssec:tr_halfedge}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each pair of twin halfedge is associated with an
\ccc{X_monotone_curve_2} object, which can be retrieved by calling
the \ccc{curve()} method of the nested \ccc{Halfedge} class.

The \ccc{source()} and \ccc{target()} methods return handles to
the halfedge source and target vertices, respectively. One can
obtain a handle to the twin halfedge using the \ccc{twin()}
method. From the definition of halfedges, it follows that if
\ccc{he} is a halfedge handle, then:
\begin{itemize}
\item \ccc{he->curve()} is equivalent to \ccc{he->twin()->curve()}.
\item \ccc{he->source()} is equivalent to \ccc{he->twin()->target()}.
\item \ccc{he->target()} is equivalent to \ccc{he->twin()->source()}.
\end{itemize}

Every halfedge has an incident face that lies to its left, which
can be obtained by using the \ccc{face()} method. Recall that a
halfedge is always one link in a connected chains of halfedges
that share the same incident face, known as a {\em CCB}. The
\ccc{prev()} and \ccc{next()} methods return handles to the
previous and next halfedges in the CCB (note that \ccc{he->prev()}
is not necessarily equivalent to \ccc{he->twin()->next()}).

As the CCB is actually a circular list, it is natural to traverse
it using a circulator. The \ccc{ccb()} method returns a
\ccc{Arrangement_2::Ccb_halfedge_circulator} object for the
halfedges along the CCB.

The following function prints all $x$-monotone curves and points
along a CCB (assuming that the \ccc{Point_2} and the
\ccc{X_monotone_curve_2} types can be exported to the standard
output using the \ccc{<<} operator):
\begin{alltt}
void print_ccb (Ccb_halfedge_const_circulator circ)
\{
  Ccb_halfedge_const_circulator  curr = circ;
  Halfedge_const_handle          he;

  std::cout << "(" << curr->source()->point() << ")";
  do
  \{
    he = curr->handle();
    std::cout << "   [" << he->curve() << "]   "
              << "(" << he->target()->point() << ")";

    ++curr;
  \} while (curr != circ);
  std::cout << std::endl;

  return;
\}
\end{alltt}


\subsubsection{Traversal Methods for an Arrangement Face}
\label{arr_sssec:tr_face}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As the \ccc{Arrangement_2} class supports only finite curves, the
arrangement always has a single unbounded face, where all other
arrangement features form holes (or isolated vertices) inside this
face. (Note that an empty arrangement contains no other feature
{\em but} the unbounded face.) The function \ccc{unbounded_face()}
returns a handle to this face.

Given a \ccc{Face} object, we can use the \ccc{is_unbounded()}
method to determine whether it is unbounded. Bounded face have an
outer CCB, and the \ccc{outer_ccb()} method returns a circulator
for the halfedges along this CCB. Note that the halfedges along
this CCB wind in a counterclockwise orientation around the outer
boundary of the face.

A face can also contain disconnected components in its interior,
namely holes and isolated vertices:
\begin{itemize}
\item The \ccc{holes_begin()} and \ccc{holes_end()} methods return
\ccc{Arrangement_2::Holes_iterator} objects that define the range
of holes inside the face. The value type of this iterator is
\ccc{Ccb_halfedge_circulator}, defining the CCB that winds in a
clockwise orientation around a hole.

\item The \ccc{isolated_vertices_begin()} and
\ccc{isolated_vertices_end()} methods return
\ccc{Arrangement_2::Isolated_vertices_iterator} objects that
define the range of isolated vertices inside the face. The value
type of this iterator is \ccc{Vertex}.
\end{itemize}

The following function prints the outer and inner boundaries of a
given face, using the function \ccc{print_ccb()} that was
introduced in the previous subsection:
\begin{alltt}
void print_face (Face_const_handle f)
\{
  // Print the outer boundary.
  if (f->is_unbounded())
  \{
    std::cout << "Unbounded face. " << std::endl;
  \}
  else
  \{
    std::cout << "Outer boundary: ";
    print_ccb (f->outer_ccb());
  \}

  // Print the boundary of each of the holes.
  Holes_const_iterator              hole;
  int                               index = 1;

  for (hole = f->holes_begin(); hole != f->holes_end(); ++hole, ++index)
  \{
    std::cout << "    Hole #" << index << ": ";
    print_ccb (*hole);
  \}

  // Print the isolated vertices.
  Isolated_vertices_const_iterator  iv;

  for (iv = f->isolated_vertices_begin(), index = 1;
       iv != f->isolated_vertices_end(); ++iv, ++index)
  \{
    std::cout << "    Isolated vertex #" << index << ": "
              << "(" << iv->point() << ")" << std::endl;
  \}

  return;
\}
\end{alltt}

\subsubsection{Additional Example}
\label{arr_sssec:tr_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To conclude the review of the various traversal methods, we bring
the following function that prints the current setting of the
arrangement:\footnote{To simplify the code, we assume that the
\ccc{Arrangement_2} type is defined as a proper instantiation of
the \ccc{Arrangement_2<Traits,Dcel>} template and all its nested
types are also defined. In the file \ccc{arr_print.h} that can be
found under the examples folder this function (and the rest of the
functions listed in this section) are brought in a more general
setting, where the arrangement type serves as a template parameter
for these functions, so different instantiations of the
\ccc{Arrangement_2<Traits,Dcel>} template can be provided to the
same function templates.}
\begin{alltt}
void print_arrangement (const Arrangement_2& arr)
\{
  // Print the arrangement vertices.
  Vertex_const_iterator      vit;

  std::cout << arr.number_of_vertices() << " vertices:" << std::endl;
  for (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)
  \{
    std::cout << "(" << vit->point() << ")";
    if (vit->is_isolated())
      std::cout << " - Isolated." << std::endl;
    else
      std::cout << " - degree " << vit->degree() << std::endl;
  \}

  // Print the arrangement edges.
  Edge_const_iterator        eit;

  std::cout << arr.number_of_edges() << " edges:" << std::endl;
  for (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)
    std::cout << "[" << eit->curve() << "]" << std::endl;

  // Print the arrangement faces.
  Face_const_iterator        fit;

  std::cout << arr.number_of_faces() << " faces:" << std::endl;
  for (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)
    print_face (fit);

  return;
\}
\end{alltt}

\subsection{Modifying the Arrangement}
\label{arr_ssec:modify}
%-------------------------------------

In this section we review the various member functions of the
\ccc{Arrangement_2} class that allows users to modify the
topological structure of the arrangement by introducing new
edges and vertices, modifying them and removing them.

Please note that the arrangement member-functions that insert new
curves into the arrangement, thus enabling the construction of
planar subdivision, are rather specialized, in the sense that the
user has to have a large amount of a-priori knowledge on the
location of the inserted curve. Indeed, for most purposes it is
more convenient to construct an arrangement using the global
insertion functions. Readers may therefore skip to
Section~\ref{arr_sec:gl_funcs} and go over it before reading this
section.

\subsubsection{Inserting Non-Intersecting Curves}
\label{arr_sssec:mf_insert_cv}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The most important functions that allow users to modify the
arrangement, and the most frequently used ones, are the
specialized insertion functions of $x$-monotone curves whose
interior is disjoint from any other curve in the existing
arrangement and does not contain any vertex of the arrangement.
We will also assume that the location of the curve in the
arrangement is known.

The reason for these rather harsh restrictions on the nature of
the inserted curves is the decoupling of the topological
arrangement representation from the various algorithms that
operate on it. While the insertion of an $x$-monotone curve whose
interior is disjoint from all existing arrangement features is
quite straightforward (as we see next), inserting curves that
intersect with the arrangement is much more complicated and
requires the application of non-trivial algorithms. These
insertion operations are therefore implemented as global functions
that operate on the arrangement and the inserted curve(s) --- see
Section~\ref{arr_sec:gl_funcs} for more details and ample
examples.


\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
    \begin{tabular}{ccc}
        \input{Arrangement_2/insert_in_face.pstex_t} &
        \input{Arrangement_2/insert_from_vertex.pstex_t} &
        \input{Arrangement_2/insert_at_vertices.pstex_t} \\
    {\small (a)} & {\small (b)} & {\small (c)}\\
    \end{tabular}
\end{center}
\end{ccTexOnly}
\caption{The various specialized insertion
procedures. The inserted $x$-monotone curve is drawn with a light
dashed line, surrounded by two solid arrows that represent the
pair of twin half-edges added to the \dcel. Existing vertices are
shown as black dots while new vertices are shown as light dots.
Existing half-edges that are affected by the insertion operations
are drawn as dashed arrows. (a) Inserting a curve as a new hole
inside the face $f$. (b) Inserting a curve from an existing
vertex $u$ that corresponds to one of its endpoints. (c) Inserting
a whose endpoints are already represented by the vertices
$u_1$ and $u_2$. In our case, the new pair of half-edges close a
new face $f'$, where the hole $h_1$, which used to belong to $f$,
now becomes an enclave in this new face.}
\label{arr_fig:insert}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="insert_funcs.gif"  border=0 alt="The various specialized insertion procedures.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

It is not difficult to see that when we insert an $x$-monotone curve
into an existing arrangement, such that the interior of this curve is
disjoint from any arrangement feature, only the following three
scenarios are possible, depending on the status of the endpoints
of the inserted subcurve:
\begin{enumerate}

\item In case both curve endpoints do not correspond to any existing
arrangement vertex we use we have to create two new vertices
corresponding to the curve endpoints and connect them using a pair of
twin halfedges. This halfedge pair initiates a new hole inside the
face that contains the curve in its interior.

\item If exactly one endpoint corresponds to an existing arrangement
vertex (we distinguish between a vertex that corresponds to the left
endpoint of the inserted curve and a vertex corresponding to its right
endpoint), we have to create a new vertex that corresponds to the other
endpoint of the curve and to connect the two vertices by a pair of
twin halfedges that form an ``antenna'' emanating from the boundary
of an existing connected component (note that if the existing vertex
used to be isolated, this operation is actually equivalent to forming
a new hole inside the face that contains this vertex).

\item Otherwise, if both endpoints correspond to existing arrangement
vertices we connect these vertices using a pair of twin halfedges.
Let us assume the two vertices are not isolated (otherwise the
operation is equivalent to one of the two previous cases). The two
following cases may occur:
\begin{itemize}
\item Two disconnected components are merged into a single connected
component.

\item A new face is created --- actually, it is split from an existing
arrangement face. In this case we also have to examine the holes and
isolated vertices in the existing face and move the relevant ones
inside the new face.
\end{itemize}
\end{enumerate}

The \ccc{Arrangement_2} class offers insertion functions named
\ccc{insert_in_face_interior()}, \ccc{insert_from_left_vertex()},
\ccc{insert_from_right_vertex()} and \ccc{insert_at_vertices()} that
perform the special insertion procedures listed above. The first
function accepts an $x$-monotone curve and an arrangement face that
contains this curve in its interior, while the other function accept
an $x$-monotone and handles to the existing vertices that correspond
to the curve endpoints. Each of the four functions return a handle to
one of the twin halfedges that have been created, where:
\begin{itemize}
\item \ccc{insert_in_face_interior(c, f)} returns a halfedge directed
from the vertex corresponding to the left endpoint of \ccc{cv} toward
the vertex corresponding to its right endpoint.

\item \ccc{insert_from_left_vertex(c, v)} and
\ccc{insert_from_right_vertex(cv, v)} return a halfedge whose source
is the vertex $v$ that and whose target is the new vertex that has just
been created.

\item \ccc{insert_at_vertices(c, v1, v2)} returns a halfedge directed
from $v_1$ to $v_2$.
\end{itemize}

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_1.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{The arrangement of the line segments $s_1, \ldots, s_5$
constructed in \ccc{example1.C}. The arrows mark the direction of
the halfedges returned from the various insertion functions.}
\label{arr_fig:ex_1}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_1.gif"  border=0 alt="The segment arrangement constructed in \ccc{example1.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program demonstrates the usage of the four insertion
functions. It creates an arrangement of five line segments, as
depicted in Figure~\ref{arr_fig:ex_1}. As the arrangement is very
simple, we use the simple Cartesian kernel of \cgal\ with integer
coordinates for the segment endpoints. We used the built-in
\ccc{Arr_segment_traits_2} class that enables the efficient
maintenance of arrangements of line segments
--- see more details on this traits class in Section~\ref{arr_sec:traits}:

\ccIncludeExampleCode{../examples/Arrangement_2/example1.C}

Note that the first line segment is inserted in the interior of the
unbounded face, while for the insertion of the rest of the line segments
are inserted using the vertices created by the insertion of previous
segments. The resulting arrangement consists of three faces, while the
two bounded faces form together a hole in the unbounded face.

\subsubsection{Manipulating Isolated Vertices}
\label{arr_sssec:mf_iso_verts}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Isolated points are in general simpler geometric entities than
curves and indeed the member functions that manipulate them are
easier to understand.

The function \ccc{insert_isolated_vertex(p, f)} inserts an isolated point
$p$ located in the interior of a given face $f$ into the arrangement and
returns a handle to the arrangement vertex associated with $p$. Naturally,
the precondition that $p$ is really an isolated point, namely it does not
coincide with any existing arrangement vertex and does not lie on any
edge.

As we have already mentioned in Section~\ref{arr_ssec:traverse}, it is
possible to obtain the face surrounding an isolated vertex by calling
\ccc{incident_face(v)} (with the precondition that $v$ is an isolated
vertex --- other vertices may not necessarily have a unique incident face).

The function \ccc{remove_isolated_vertex(v)} receives a handle to an
isolated vertex and removes it from the arrangement.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_2.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments containing three isolated
vertices, as constructed in \ccc{example2.C}. The vertices $u_2$
and $u_3$ are eventually deleted from the arrangement.}
\label{arr_fig:ex_2}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_2.gif"  border=0 alt="The segment arrangement constructed in \ccc{example2.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program demonstrates the usage of the arrangement
member-functions for manipulating isolated vertices. It first
inserts three isolated vertices inside the unbounded face, then
inserts four line segments that form a rectangular hole inside
the unbounded face (see Figure~\ref{arr_fig:ex_2} for an
illustration). It finally goes over the vertices and removes
those isolated vertices that are still contained in the unbounded
face ($u_2$ and $u_3$ in this case):

\ccIncludeExampleCode{../examples/Arrangement_2/example2.C}

\subsubsection{Manipulating Halfedges}
\label{arr_sssec:mf_halfedges}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the previous subsection we showed how to introduce new isolated
vertices in the arrangement. But how do we create a vertex that
lies on an existing arrangement edge (more precisely, on an
$x$-monotone curve that is associated with an arrangement edge)?

It should be noted that such an operation involves the splitting
of a curve at a given point in its interior, while the traits
class used by \ccc{Arrangement_2} does not necessarily have the
ability to perform such a split operation. However, if users know
how to split an $x$-monotone curve into two as a given point $p$,
they can use the \ccc{split_edge(e, p, c1, c2)} function, were
$c_1$ and $c_2$ are the two subcurves resulting for splitting the
$x$-monotone curve associated with the halfedge $e$ at a point $p$
in its interior. The function splits the halfedge pair into two
pairs, both incident to a new vertex $v$ associated with $p$, and
returns a handle to a halfedge whose source equals $e$'s source
vertex and whose target is the new vertex $v$.

The reverse operation is also possible. Suppose that we have a
vertex $v$ of degree $2$, whose two incident halfedges, $e_1$ and
$e_2$, are associated with the curves $c_1$ and $c_2$. Suppose
further that we know how to merge these two curves into a single
continuous $x$-monotone curve $c$ --- then calling
\ccc{merge_edge(e1, e2, c)} will merge the two edges into a single
edge associated with the curve $c$, resulting the removal of the
vertex $v$ from the arrangement.

Finally, the function \ccc{remove_edge(e)} removes the edge $e$
from the arrangement. Note that this operation is the reverse of
\ccc{insert_at_vertices()}, so it may cause a connected component
two split into two, or two face to merge into one.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
    \begin{tabular}{ccc}
        \input{Arrangement_2/ex_3a.pstex_t} &
        \input{Arrangement_2/ex_3b.pstex_t} &
        \input{Arrangement_2/ex_3c.pstex_t} \\
    {\small (a)} & {\small (b)} & {\small (c)}\\
    \end{tabular}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments containing as constructed
in \ccc{example3.C}. Note that the edges $e_7$ and $e_8$ and the
vertices $w_1$ and $w_2$, introduced in step~(b) are eventually
removed in step~(c).} \label{arr_fig:ex_3}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_3.gif"  border=0 alt="The segment arrangement constructed in \ccc{example3.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the following example program we show how the edge-manipulation
functions can be used. Not that here we still stick to integer
coordinates, but as we work on a larger scale we use an unbounded
integer number-type (in this case, the \ccc{Gmpz} type taken from
the {\sc Gmp} library) instead of the built-in \ccc{int}
type.\footnote{As a rule of thumb, one can use a bounded integer
type containing for representing line segments whose coordinates
are bounded by $\lfloor\sqrt[3]{M}\rfloor$, where $M$ is the
maximal representable integer value.} We also use the standard
Cartesian kernel of \cgal\ as our kernel --- this is recommended
when the kernel is instantiated with a more complex number type:

\ccIncludeExampleCode{../examples/Arrangement_2/example3.C}

Note how we use the halfedge handles returned from
\ccc{split_edge()} and \ccc{merge_edge()}. Also note the insertion
of the isolated vertex $v_6$ inside the triangular face (the
incident face of $e_7$). This vertex is eventually connected to
other vertices, so it stops being isolated.

In this context, we should mention the two member functions
\ccc{modify_vertex(v, p)}, which sets $p$ to be the point
associated with the vertex $v$, and \ccc{modify_edge(e, c)}, which
sets $c$ to be the $x$-monotone curve associated with the halfedge
$e$. To avoid the invalidation of the geometric structure of the
arrangement, these functions have preconditions that $p$ is
geometrically equivalent to \ccc{v->point()} and $c$ is equivalent
to \ccc{e->curve()} (i.e., the two curves have the same graph),
respectively. It therefore seems that these two functions are of
little use. However, we should keep in mind that there may be
extraneous data (probably non-geometric) associated with the point
objects or with the curve objects, as defined by the traits class,
so we are thus able to modify this data. In addition, we may
replace a geometric object with an equivalent object that has a
more compact representation. See more details in
Section~\ref{arr_sec:traits}.

\begin{ccAdvanced}
\subsubsection{Advanced Insertion Functions}
\label{arr_sssec:adv_insert}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Assume that the specialized insertion function
\ccc{insert_from_left_vertex(c,v)} is invoked for a curve $c$
whose right endpoint is already associated with a non-isolated
vertex $v$, namely it has already several edges incident to it. It
is necessary in this case to locate the right place for the
inserted curve $c$ around $v$. In fact, it is sufficient to locate
one of the halfedges \ccc{pred} directed toward $v$ such that $c$
is located between \ccc{pred} and \ccc{pred->next()} in a
clockwise direction around $v$, in order to perform the insertion
(see Figure~\ref{arr_fig:insert} for an illustration). This may
take $O(d)$ time where $d$ is the degree of the vertex, but if the
halfedge \ccc{pred} is known in advance, the insertion can be
carried out in constant time.

The \ccc{Arrangement_2} class provide the advanced versions of
\ccc{insert_from_left_vertex()} and
\ccc{insert_from_right_vertex()} that accept a halfedge \ccc{pred}
as specified above, instead of a vertex $v$. These functions are
more efficient as they carried out in constant time and without
performing any geometric operations, thus they should be used when
\ccc{pred} is known. In case that the vertex $v$ is isolated or
that the predecessor halfedge for the new inserted curve is not
known, the simpler versions of these insertion functions should be
used.

Similarly, there exist two overrides of the \ccc{insert_at_vertices()}
function: One that accept the two predecessor halfedges around the two
vertices $v_1$ and $v_2$ that correspond to the curve endpoints, and
one that accepts a handle for one vertex and a predecessor halfedge
around the second vertex.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_4.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments, as constructed in
\ccc{example4.C}. Note that $p_0$ is initially inserted as an
isolated point and later on connected to the other four vertices.}
\label{arr_fig:ex_4}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_4.gif"  border=0 alt="The segment arrangement constructed in \ccc{example4.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program shows how to construct the arrangement
depicted in Figure~\ref{arr_fig:ex_4} using the specialized
insertion functions that accept predecessor halfedges:

\ccIncludeExampleCode{../examples/Arrangement_2/example4.C}
\end{ccAdvanced}

\section{Issuing Queries on an Arrangement}
\label{arr_sec:queries}
%==========================================

One of the most important query types defined on arrangements is
the {\em point-location} query: Given a point, find the arrangement
cell that contains it. Typically, the result of a point-location
query is one of the arrangement faces, but in degenerate
situations the query point can be located on an edge or coincide
with a vertex.

Point-location queries are not only common in many applications,
they also play an important role in the global insertion functions
(see Section~\ref{arr_sec:gl_funcs}). It is therefore crucial to
have the ability of effectively answering such queries for any
arrangement instance.

\subsection{Point-Location Queries}
\label{arr_ssec:pl}
%----------------------------------

The arrangement package comes with several classes (more
precisely, class templates parameterized by an arrangement class)
that model the \ccc{ArrPointLocation} concept
--- namely, they all have a member functions called
\ccc{locate(a)} that accepts a query point $q$ and outputs a
\cgal\ \ccc{Object} that wraps a handle to the arrangement cell
containing the query point. This object can be assigned to either
a \ccc{Face_const_handle}, \ccc{Halfedge_const_handle} or a
\ccc{Vertex_const_handle}.

An instance of any point-location class is always attached to an
\ccc{Arrangement_2} instance. This attachment can be performed
when the point-location instance is constructed, or at a later
time, using the \ccc{init(arr)} method, where \ccc{arr} is the
attached \ccc{Arrangement_2} instance.

The following function template, which can be found in the example
file \ccc{point_location_utils.h} accepts a point-location object,
whose type can be any of the models to the \ccc{ArrPointLocation}
concept, and a point and prints out the result of the point-location
query for the given point. The point-location object \ccc{pl} is
assumed to be already associated with an arrangement:

\begin{alltt}
template <class PointLocation>
void point_location_query
        (const PointLocation& pl,
         const typename PointLocation::Arrangement_2::Point_2& q)
\{
  // Perform the point-location query.
  CGAL::Object    obj = pl.locate (q);

  // Print the result.
  typedef typename PointLocation::Arrangement_2  Arrangement_2;

  typename Arrangement_2::Vertex_const_handle    v;
  typename Arrangement_2::Halfedge_const_handle  e;
  typename Arrangement_2::Face_const_handle      f;

  if (CGAL::assign (f, obj))
  \{
    // q is located inside a face:
    if (f->is_unbounded())
      std::cout << "Inside the unbounded face." << std::endl;
    else
      std::cout << "Inside a bounded face." << std::endl;
  \}
  else if (CGAL::assign (e, obj))
  \{
    // q is located on an edge:
    std::cout << "On an edge: " << e->curve() << std::endl;
  \}
  else if (CGAL::assign (v, obj))
  \{
    // q is located on a vertex:
    if (v->is_isolated())
      std::cout << "On an isolated vertex: " << v->point() << std::endl;
    else
      std::cout << "On a vertex: " << v->point() << std::endl;
  \}
  else
  \{
    CGAL_assertion_msg (false, "Invalid object.");
  \}

  return;
\}
\end{alltt}

\subsubsection{Point-Location Strategies}
\label{arr_sssec:pl_strat}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each of the various point-location classes employs a different
algorithm or {\em strategy} for answering queries.
\begin{itemize}
\item \ccc{Arr_naive_point_location<Arrangement>} locate the query
point \naive ly, by exhaustively scanning all arrangement cells.

\item \ccc{Arr_walk_along_a_line_point_location<Arrangement>}
simulates a traversal along an imaginary vertical ray emanating
from the query point: It starts from the unbounded face of the
arrangement and moves downward toward the query point until
locating the arrangement cell containing it.

\item \ccc{Arr_landmarks_point_location<Arrangement,Generator>}
uses a set of ``landmark'' points whose location in the
arrangement is known. Given a query point, it uses a \kdtree\ to
find the nearest landmark and then traverses the straight line
segment connecting this landmark to the query point.

There are various strategies to select the landmark set in the
arrangement, where the strategy is determined by the
\ccc{Generator} template parameter. By default, the generator
class \ccc{Arr_landmarks_vertices_generator} is used and the
arrangement vertices are the selected landmarks, but other
landmark-generating strategies, such as sampling random points or
choosing points on a grid are also available --- see the reference
manual for more details.

\item \ccc{Arr_trapezoid_ric_point_location<Arrangement>} implements
Mulmuley's algorithm~\cite{m-fppa-90}. The arrangement faces are
decomposed into simpler cells of constant complexity known as {\em
pseudo-trapezoids} and a search-structure (a directed acyclic
graph) is constructed on top of these cells, allowing to locate
the pseudo-trapezoid (hence the arrangement cell) containing a
query point in expected logarithmic time.
\end{itemize}

The main advantage of the first two strategies is that they do not
require any extra data, so the respective classes just store a
pointer to an arrangement object and operate directly on it.
Attaching such point-location objects to an existing arrangement
has virtually no running-time cost at all, but the query time is
linear in the size of the arrangement (the performance of the
``walk'' strategy is much better in practice, but its worst-case
performance is linear). Using these strategies are therefore
recommended only when a relatively small number of point-location
queries are issued by the application.

On the other hand, the landmarks and the trapezoid RIC strategies
require auxiliary data structures on top of the arrangement, which
they need to construct once they are attached to arrangement
object and need to keep up-to-date as this arrangement changes.
The data structures needed by both strategies can be constructed
in $O(n \log n)$ time (where $n$ is the size of the arrangement),
but the construction needed by the landmark algorithm is in
practice one order of magnitude faster. In addition, although both
resulting data structures are asymptotically linear in size, the
\kdtree\ that the landmarks algorithm stores needs significantly
less memory. We note that Mulmuley's algorithm guarantees a
logarithmic query time, while the query time for the landmarks
strategy is only logarithmic on average --- and we may have
scenarios where the query time can be linear. In practice however,
both strategies are competitive.

The main drawback in the current implementation of the landmarks
strategy is that while the updating the auxiliary data structures
related to the trapezoidal decomposition is done very efficiently,
the \kdtree\ maintained by the landmarks algorithm needs to be
frequently rebuilt as the arrangement changes. In addition, using
the landmarks point-location class adds some extra requirement
from the traits class (that is, the traits class should be a model
of a refined concept \ccc{ArrangementLandmarkTraits_2} --- see
Section~\ref{arr_sec:traits} for the details). However, most
built-in traits classes that come with the \cgal\ public release
support these extra operations.

It is therefore recommended to use the
\ccc{Arr_landmarks_point_location} class when the application
frequently issues point-location queries on a rather static
arrangement that only seldom changes. If the arrangement is more
dynamic and is frequently going through changes, the
\ccc{Arr_trapezoid_ric_point_location} class should be the
selected point-location strategy.

\subsubsection{An Example}
\label{arr_sssec:pl_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_5.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{The arrangement of line segments, as constructed in
\ccc{example5.C}, \ccc{example6.C} and \ccc{example7.C}. The
arrangement vertices are drawn in light dots, while the query
points $q_1, \ldots, q_6$ are marked with crosses.}
\label{arr_fig:ex_5}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_5.gif"  border=0 alt="The segment arrangement constructed in \ccc{example5.C}, \ccc{example6.C} and \ccc{example7.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program constructs a simple arrangement of five line
segments that form a pentagonal face, with a single isolated vertex
in its interior, as depicted in Figure~\ref{arr_fig:ex_5} (the
details of the arrangement construction are omitted from the main
program, and can be found in \ccc{point_location_utils.h}). It then
employs the \naive\ and the landmark strategies to issue several
point-location queries on this arrangement:

\ccIncludeExampleCode{../examples/Arrangement_2/example5.C}

Note that the program uses the auxiliary \ccc{point_location_query()}
function template to nicely print the result of each query.

\subsection{Vertical Ray Shooting}
\label{arr_ssec:ray_shoot}
%---------------------------------

Another important query issued on arrangement is the vertical
ray-shooting query: Given a query point, which arrangement feature
do we encounter if we shoot a vertical ray emanating upward (or
downward) from this point? In the general case the ray hits an
edge, but it is possible that it hit a vertex, or that the
arrangement does not have any feature lying directly above (or
below) the query point.

The \ccc{Arr_naive_point_location}, the
\ccc{Arr_walk_along_a_line_point_location} and the
\ccc{Arr_trapezoid_ric_point_location} classes are also models of
the \ccc{ArrVerticalRayShoot} concept. That is, they all have
member functions called \ccc{ray_shoot_up(q)} and
\ccc{ray_shoot_down(q)} that accepts a query point $q$ and output
a \cgal\ \ccc{Object}. This can be assigned to either a
\ccc{Halfedge_const_handle} or to a \ccc{Vertex_const_handle}.
Alternatively, the returned value is an empty object if there is
no edge or vertex lying directly above (or below) $q$.

The following function template, also located in the example
file \ccc{point_location_utils.h} accepts a vertical ray-shooting
object, whose type can be any of the models to the
\ccc{ArrVerticalRayShoot} concept and prints out the result of
the upward vertical ray-shooting operations from a given query
point. The ray-shooting object \ccc{vrs} is assumed to be already
associated with an arrangement:

\begin{alltt}
template <class VerticalRayShoot>
void vertical_ray_shooting_query
    (const VerticalRayShoot& vrs,
     const typename VerticalRayShoot::Arrangement_2::Point_2& q)
\{
  // Perform the point-location query.
  CGAL::Object    obj = vrs.ray_shoot_up (q);

  // Print the result.
  typedef typename VerticalRayShoot::Arrangement_2  Arrangement_2;

  typename Arrangement_2::Vertex_const_handle    v;
  typename Arrangement_2::Halfedge_const_handle  e;

  if (CGAL::assign (e, obj))
  \{
    // We hit an edge:
    std::cout << "Hit an edge: " << e->curve() << std::endl;
  \}
  else if (CGAL::assign (v, obj))
  \{
    // We hit a vertex:
    if (v->is_isolated())
      std::cout << "Hit an isolated vertex: " << v->point() << std::endl;
    else
      std::cout << "Hit a vertex: " << v->point() << std::endl;
  \}
  else
  \{
    // We did not hit anything:
    CGAL_assertion_msg (obj.is_empty(), "Invalid object.");

    std::cout << "Hit nothing." << std::endl;
  \}

  return;
\}
\end{alltt}

The following program uses the auxiliary function listed above
to perform vertical ray-shooting queries on an arrangement. Note
that the arrangement and the query points are exactly the same
as in \ccc{example5.C} --- see Figure~\ref{arr_fig:ex_5}:

\ccIncludeExampleCode{../examples/Arrangement_2/example6.C}

The number type we use in this example is \cgal's built-in
\ccc{MP_Float} type which is a floating-point number with an
unbounded mantissa. It supports construction from an integer
or from a machine \ccc{float} or \ccc{double} and performs
additions, subtractions and multiplications in an exact number.

\subsection{Batched Point-Location}
\label{arr_ssec:batched_pl}
%----------------------------------

Suppose that at a given moment we have our application has to
issue a relatively large number $m$ of point-location queries on a
specific arrangement instance. It is possible of course to define
a point-location object and to issue separate queries on the
arrangement. However, as explained in Section~\ref{arr_ssec:pl},
choosing a simple point-location strategy (the \naive\ or the walk
strategy) means inefficient queries, while the more sophisticated
strategies need to construct auxiliary structures that incur extra
running times.

On the other hand, the arrangement package included a global
\ccc{locate()} function that accepts an arrangement a range of
query points as its input and sweeps through the arrangement to
locate the points simultaneously. The function outputs the query
results as pairs, where each pair is comprised of a query point
and a \cgal\ \ccc{Object} that represents the cell containing the
point (see also Section~\ref{arr_ssec:pl}). The output pairs are
sorted in increasing $xy$-lexicographical order.

The batched point-location operation can be performed in
$O\left((m+n)\log{(m+n)}\right)$ time, where $n$ is the size of
the arrangement. This means that when the number $m$ of
point-location queries is of the same order of magnitude as $n$,
this operation is more efficient than issuing separate queries.
Experimental results also backup the theoretical time bounds.
Moreover, the batched point-location operation does not have to
construct and maintain additional data structures.

In the following program issued a batched point-location query,
which is essentially equivalent to the six separate queries
performed in \ccc{example5.C} (see Section~\ref{arr_ssec:pl}):

\ccIncludeExampleCode{../examples/Arrangement_2/example7.C}

\section{Global Arrangement Functions}
\label{arr_sec:gl_funcs}
%=====================================

In Section~\ref{arr_sec:arr_class} we reviewed in detail the
\ccc{Arrangement_2} class that represents two-dimensional
subdivisions of bounded planar curves and mentioned that its
interface is minimal in the sense that the member functions hardly
perform any geometric algorithms and are mainly used for
maintaining the topological structure of the subdivision. In this
section we go over the global functions that operate of
arrangements, implementing operations that require non-trivial
geometric algorithms or loading some extra requirements on the
traits class.

\subsection{Incremental Insertion Functions}
\label{arr_ssec:inc_insert}
%-------------------------------------------

\subsubsection{Inserting Non-Intersecting Curves}
\label{arr_sssec:insert_non_x}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Section~\ref{arr_sec:arr_class} we explained how to construct
arrangements of $x$-monotone curves that are pairwise disjoint in
their interior, when the location of the segment endpoints in the
arrangement is known. We now relax this assumption and assume that
we wish to insert a $x$-monotone curve $c$ into an existing
arrangement such that it is disjoint from all existing arrangement
edges, but its location is unknown.

The global function \ccc{insert_non_intersecting(arr, pl, c)}
performs this exact operation: It insert the $x$-monotone curve
\ccc{c} into the arrangement \ccc{arr}. The second argument
\ccc{pl} is a point-location object attached to the arrangement,
which is used for performing the insertion: It locates both curve
endpoints in the arrangement, where each endpoint is expected to
either coincide with an existing vertex or lie inside a face.
Based on the query results, it is possible to invoke one of the
specializes insertion function (see
Section~\ref{arr_sec:arr_class}) and insert $c$ at its proper
position.\footnote{The \ccc{insert_non_intersecting()} function,
as all other functions reviewed in this section, is thus a
function template, parameterized by an arrangement class and a
point-location class (a model of the \ccc{ArrPointLocation}
concept).} The insertion operation thus requires hardly any
geometric operations on top on the ones needed to answer the
point-location queries. Moreover, it is sufficient that the
arrangement class is instantiated with a traits class that models
the \ccc{ArrangementBasicTraits_2} concept (or the
\ccc{ArrangementLandmarkTraits_2} concept, if the landmarks
point-location strategy is used), which does not have to support
the computation of intersection points between curves.

\subsubsection{Inserting $x$-Monotone Curves}
\label{arr_sssec:insert_x_mon}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The \ccc{insert_non_intersecting()} function is indeed very
efficient, but its preconditions on the input curves are still
rather restricting. Let us assume that the arrangement is
instantiated with a traits class that models the refined
\ccc{ArrangementXMonotoneTraits_2} concept and supports
intersection computations (see Section~\ref{arr_sec:traits} for
the exact details). Given an $x$-monotone curve, it is sufficient
to locate its left endpoint in the arrangement and to trace its
{\em zone}
--- namely the set of arrangement features it crosses --- until
reaching the right endpoint. Each time the new curve $c$ traverses
an existing vertex or an edge we have to split it into subcurves
(in the latter case, we have to split the curve associated with
the existing halfedge as well) and associated new edges with these
subcurves.

The global function \ccc{insert_x_monotone(arr, pl, c)} performs
this exact operation: It receives an $x$-monotone curve \ccc{c}
which may intersect the arrangement \ccc{arr} and inserts it into
the arrangement by computing its zone. The running-time cost is
proportional to the complexity of the curve's zone.

\subsubsection{Inserting General Curves}
\label{arr_sssec:insert_gen}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far all our examples were of arrangement of line segments,
where the \ccc{Arrangement_2} template was instantiated with the
\ccc{Arr_segment_traits_2} class. Line segments are always
$x$-monotone, so the fact that \ccc{insert_x_monotone()} accepts
an $x$-monotone curve does not seem to be a restriction, as all
line segments are $x$-monotone (we even consider vertical line
segments to be {\em weakly} $x$-monotone).

Suppose that we construct an arrangement of circles. A circle is
obviously not $x$-monotone, so we cannot use
\ccc{insert_x_monotone()} in this case.\footnote{Note that a key
operation when inserting an $x$-monotone curve is to locate its
left endpoint in the arrangement. A circle, however, does not have
any endpoints!} However, it is possible to subdivide each circle
into two $x$-monotone circular arcs (its upper half and its lower
half) and to insert each $x$-monotone arc separately.

The function \ccc{insert(arr, pl, c)} requires that the traits
class used by the arrangement \ccc{arr} is a model of the concept
\ccc{ArrangementTraits_2}, which refines the
\ccc{ArrangementXMonotoneTraits_2} concept: It has to define an
additional \ccc{Curve_2} type (which may differ from the
\ccc{X_monotone_curve_2} type and support its separation into
$x$-monotone curves (see the exact details in
Section~\ref{arr_sec:traits}). It performs the insertion of the
curve $c$, which need not be $x$-monotone, into the arrangement by
subdividing it into $x$-monotone subcurves and inserting each one
separately.

\subsubsection{Inserting Points}
\label{arr_sssec:insert_point}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While the arrangement class enables us to insert a point as an
isolated vertex in a given face. The global functions
\ccc{insert_vertex(arr, pl, p)} inserts a vertex to \ccc{arr} that
corresponds to the point \ccc{p}. It uses the point-location
object \ccc{pl} to locate the point in the arrangement and acts
according to the result:
\begin{itemize}
\item If \ccc{p} is located inside a face, it inserts it as an
isolated vertex inside this face.
\item If \ccc{p} lies on an edge, the edge is split to create a
vertex associated with \ccc{p}.
\item Otherwise, \ccc{p} coincides with an existing vertex and
we are done.
\end{itemize}
In all cases, the function returns a handle to the vertex
associated with \ccc{p}.

As the insertion operation may involve splitting curves, the
arrangement \ccc{arr} should be instantiated with a traits class
that models the \ccc{ArrangementXMonotoneTraits_2} concept.

\subsubsection{An Example}
\label{arr_sssec:insert_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_8.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of five intersecting line segments, as
constructed in \ccc{example8.C} and \ccc{example9.C}. The segment
endpoint are marked with dark dots and the arrangement vertices
that correspond to intersection points are marked by white dots.
The query point $q$ is marked with a cross and the face that
contains it is lightly shaded.}
\label{arr_fig:ex_8}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_8.gif"  border=0 alt="The segment arrangement constructed in \ccc{example8.C} and \ccc{example9.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program constructs an arrangement of intersecting
line segments. We know that $s_1$ and $s_2$ do not intersect, so
we use \ccc{insert_non_intersecting()} to insert them into the
empty arrangement. The rest of the segments are inserted using
\ccc{insert_x_monotone()} or \ccc{insert()}, which are equivalent
in case of line segments. The resulting arrangement consists of
$13$ vertices, $16$ edges and $5$ faces.

In the previous examples, all arrangement vertices corresponded to
segment endpoints. In this case we have additional vertices that
correspond to intersection points between two segments. The
coordinates of these intersection points are rational numbers if
the input coordinates are rational (or integer) --- we therefore
use the \ccc{Quotient<int>} number type to represent the
coordinates:

\ccIncludeExampleCode{../examples/Arrangement_2/example8.C}

\subsection{Aggregated Insertion Functions}
\label{arr_ssec:agg_insert}
%------------------------------------------

Let us assume we have to insert a set of $m$ input curves into an
arrangement. It is possible of course to do this incrementally,
inserting curves one by one as shown in the previous section.
However, the arrangement package provides three global functions
\ccc{insert_non_intersecting(arr, begin, end)},
\ccc{insert_x_monotone(arr, begin, end)} and \ccc{insert(arr,
begin, end)} that insert a range of curves, given by the input
iterators \ccc{[begin, end)} into an arrangement \ccc{arr}. The
different functions accept a set of pairwise interior-disjoint
$x$-monotone curves, a set of $x$-monotone curves that may
intersect one another, or a set of general (not necessarily
$x$-monotone) \ccc{Curve_2} objects --- exactly as their
incremental counterparts.

We make a distinction between two cases: (i) The given arrangement
\ccc{arr} is empty (has only an unbounded face), so we have to
construct it. (ii) We have to insert $m$ input curves to a
non-empty arrangement \ccc{arr}.

In the first case, we have to sweep over the input curves, compute
their intersection points and construct the \dcel\ that represents
their planar arrangement. This process can be performed in
$O\left((m + k)\log m\right)$ time, where $k$ is the total number
of intersection points. The running bound is asymptotically better
than the time needed for incremental insertion if the arrangement
is relatively sparse (when $k$ is bounded by $\frac{m^2}{\log
m}$), but in practice it is recommended to use this aggregated
construction process even for dense arrangements, since the
sweep-line algorithm needs less geometric operations compared to
the incremental insertion algorithms.

Another important advantage the aggregated insertion functions
have is that they require no point-location queries, thus no
point-location object needs to be attached to the arrangement. As
explained in Section~\ref{arr_ssec:pl}, there is a tradeoff
between construction time and query time in each of the
point-location strategy, which affects the running times of the
incremental insertion process. This tradeoff plays no role in case
of aggregated insertion.

The following example shows how to construct the arrangement of
line segments depicted in Figure~\ref{arr_fig:ex_8} and built
incrementally in the example in the previous section. We use the
\ccc{insert_x_monotone()} function as we are dealing with line
segments. Note that no point-location object is defined and
attached to the arrangement:

\ccIncludeExampleCode{../examples/Arrangement_2/example9.C}

In case we have to insert a set of $m$ curves into an existing
arrangement, we should consider the size of the arrangement $n$.
As a rule of thumb, if $m = o(\sqrt{n})$ it is usually more
efficient to insert the curves one by one. For larger input sets,
it is recommended to use the aggregated insertion procedures.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_10.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of eleven intersecting line segments, as
constructed in \ccc{example10.C}. The segments of ${\mathcal S}_1$
are drawn in solid lines and the segments of ${\mathcal S}_2$ are
drawn in dark dashed lines. Note that the segment $s$ (light
dashed line) overlaps one of the ${\mathcal S}_1$ segments.}
\label{arr_fig:ex_10}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_10.gif"  border=0 alt="The segment arrangement constructed in \ccc{example10.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In following example we aggregately construct an arrangement of a
set ${\mathcal S}_1$ containing 5 line segments, then insert a
single segment incrementally and add a set ${\mathcal S}_2$ with 5
more line segments in an aggregated fashion. Note that the line
segments of ${\mathcal S}_1$ are pairwise interior-disjoint, so we
use \ccc{insert_non_intersecting()}. ${\mathcal S}_2$ also contain
pairwise interior-disjoint segments, but as they intersect the
existing arrangement, we have to use \ccc{insert_x_monotone()} to
insert them. Also note that the single segment $s$ we insert
incrementally overlaps an existing arrangement edge:

\ccIncludeExampleCode{../examples/Arrangement_2/example10.C}

The number type used in the example above,
\ccc{Quotient<MP_Float>}, which is capable of exactly computing
the intersection points as long as the segment endpoints are given
as floating-point numbers.

\subsection{Removing Vertices and Edges}
\label{arr_ssec:gl_remove}
%---------------------------------------

The two following global functions handle the removal of vertices
and edges from an arrangement. The difference between them and the
member functions of the \ccc{Arrangement_2} template is that they
require that the traits class that instantiates the arrangement
instance is a model of the refined
\ccc{ArrangementXMonotoneTraits_2} concept, as they allow the
merger of two curves associated with adjacent edges to form a
single edge.

The function \ccc{remove_vertex(arr, v)} removes the vertex
\ccc{v} from the given arrangement \ccc{arr}, where \ccc{v} is
either an isolated vertex or if it is a {\em redundant} vertex
--- namely, it has exactly two incident edges associated with two curves
that can be merged to form a single $x$-monotone curve. If neither
of the two cases apply, the function returns an indication that it
has failed to remove the vertex.

The function \ccc{remove_vertex(arr, e)} removes the edge \ccc{e}
from the arrangement by simply calling \ccc{arr.remove_edge(e)}
(see Section~\ref{arr_ssec:modify}). In addition, if either of the
end vertices of \ccc{e} becomes redundant after the removal of the
edge, it is removed as well.

The following example demonstrates the usage of the global removal
functions. In creates an arrangement of four line segment forming
an H-shape with a double horizonal line. Then it removes the two
horizontal edges and clears all redundant vertices, such that the
final arrangement consists of just two edges associated with the
vertical line segments:

\ccIncludeExampleCode{../examples/Arrangement_2/example11.C}

\section{Traits Classes}
\label{arr_sec:traits}
%=======================

As mentioned in the introduction od this chapter, the traits class
encapsulates the definitions of the geometric entities and
implements the geometric predicates and constructions needed by
the \ccc{Arrangement_2} and by its peripheral algorithms. We have
also mentioned throughout the chapter that there are different
levels of requirements from the traits class, namely the traits
class can be a model of different concepts.

A model of the basic concept, \ccc{ArranagementBasicTraits_2},
needs to define the types \ccc{Point_2} and
\ccc{X_monotone_curve_2}, where objects of the first type are
associated with arrangement vertices and objects of the latter
type are associated with edges. In addition, it has to support the
following set of predicates:
\begin{itemize}
\item Compare the $x$-coordinates of two points $p$ and $q$.
\item Compare two points $p$ and $q$ lexicographically, by their
$x$-coordinates then by their $y$-coordinates.
\item Return the left endpoint (similarly, the right endpoint) of
an $x$-monotone curve $c$.
\item Given an $x$-monotone curve $c$ and a point $p$ that lies in its
$x$-range, determine whether $p$ lies below, above or on $c$.
\item Given two $x$-monotone curves $c_1$ and $c_2$ that share a
common left endpoint (similarly, right endpoint) $p$, determine
whether $c_1$ lies above or under $c_2$ immediately to the right
(to the left) of $p$, or whether the two curves coincide there.
\item Check two curves for equality (two curves are equal if their
graph is the same).
\end{itemize}
This basic set of predicates is sufficient for constructing
arrangements of $x$-monotone curves and points that are pairwise
disjoint in their interiors and for performing point-location
queries and vertical ray-shooting queries.

The landmarks point-location strategy (see
Section~\ref{arr_ssec:pl}) needs its associated arrangement to be
instantiated with a model of the refined
\ccc{ArranagementLandmarkTraits_2}. A model of this concept must
define an approximated number type (typically \ccc{double}) and
support the additional operations:
\begin{itemize}
\item Given a point \ccc{p}, approximate the coordinates of
\ccc{p} using the approximated number type.
\item Given two points \ccc{p_1} and \ccc{p_2}, construct an
$x$-monotone curve connecting \ccc{p_1} and \ccc{p_2}.
\end{itemize}

If the traits class models the \ccc{ArranagementXMonotoneTraits_2}
concept, which refines the \ccc{ArranagementBasicTraits_2}
concept, it has to support the following functions:
\begin{itemize}
\item Compute all intersection points and overlapping sections of
two given $x$-monotone curves. If possible, compute also the
multiplicity of each intersection point.\footnote{If the two
curves intersect at a point $p$ but have different tangents, $p$
is of multiplicity 1. If the tangents are also equal but the their
curvatures are not the same, $p$ is of multiplicity 2, etc.}
Knowing the multiplicity of an intersection point is not required,
but it can speed up the arrangement construction.
\item Split an $x$-monotone curve $c$ to two subcurves at a point
$p$ lying in its interior.
\item Given two $x$-monotone curve $c_1$ and $c_2$ that share a
common endpoint, determine whether $c_1$ and $c_2$ are {\em
mergeable} --- that is, whether they can be merged to form a
single continuous $x$-monotone curve.
\item Merge two mergeable $x$-monotone curve $c_1$ and $c_2$.
\end{itemize}
Using a model of the \ccc{ArranagementXMonotoneTraits_2}, it is
possible to construct arrangements of sets of $x$-monotone curves
(and points) in general settings.

The refined concept \ccc{ArranagementTraits_2} refines the
\ccc{ArranagementXMonotoneTraits_2} concept by adding the notion
of a general, not necessarily $x$-monotone (and not necessarily
connected) curve. A model of this concept must define the
\ccc{Curve_2} type and support the separation of an curve into a
set of continuous $x$-monotone curves and isolated points. For
example, the curve $C:\ (x^2 + y^2)(x^2 + y^2 - 1) = 0$ is the
unit circle (the loci of all points for which $x^2 + y^2  = 1$)
with the origin $(0,0)$ as a singular point in its interior. $C$
should therefore be separated into two circular arcs (the upper
part and the lower part of the unit circle) and a single isolated
point.

Note that the refined model \ccc{ArranagementTraits_2} is required
only when using the global \ccc{insert()} functions (see
Section~\ref{arr_sec:gl_funcs}), which accept a \ccc{Curve_2}
object (in the incremental version) or a range of \ccc{Curve_2}
objects (in the aggregated version).

In the rest of this section we will review the traits classes
included in the public distribution of \cgal, that handle line
segments, polylines and conic arcs. The last subsection overviews
the meta-traits classes distributed with \cgal.

\section{Traits Classes for Line Segments}
\label{arr_ssec:tr_segs}
%-----------------------------------------

The \ccc{Arr_segment_traits_2<Kernel>} class has been used
throughout this chapter. It is parameterized by a geometric kernel
and uses the \ccc{Kernel::Point_2} type as it point type. However,
it is important to note that the \ccc{X_monotone_curve_2} type
(and the \ccc{Curve_2} type) is {\em not} identical to the
\ccc{Kernel::Segment_2} type. The reason is that a kernel segment
is typically represented by its two endpoints, and these may have
a complicated representation if the segment has been intersected
several times (in comparison with the representation of its
original endpoints), and this fact may significantly slow down the
application. The \ccc{Arr_segment_traits_2} therefore represents a
segment using its supporting line and two endpoints, such that
most computations are performed on the supporting line, which
never changes as the segment is split. It also caches some
additional information with the segment to speed up the various
predicates.

However, it is important to note that an \ccc{X_monotone_curve_2}
instance can be constructed from two endpoints or from a kernel
segment. Moreover, an \ccc{X_monotone_curve_2} can also be casted
or assigned to a \ccc{Kernel::Segment_2} object. The two types are
thus fully convertible to one another.

\cgal also offers a simpler alternative segment-traits class. The
traits class \ccc{Arr_non_caching_segment_basic_traits<Kernel>} is
a model of the \ccc{ArrangementBasicTraits_2} concept. It uses
\ccc{Kernel::Point_2} as its point type and
\ccc{Kernel::Segment_2} as its $x$-monotone curve type. As this
traits class does not support intersecting and splitting segments,
the kernel representation is efficient enough. It is still less
efficient than \ccc{Arr_segment_traits_2} for constructing
arrangements of pairwise disjoint line segments, but using this
traits class may be preferable as it reduces the memory
consumption a bit, since no extra data is stored with the line
segments.

\section{The Polyline Traits Class}
\label{arr_ssec:tr_polylines}
%-----------------------------------

The \ccc{Arr_polyline_traits_2<Segment_traits>} class can be used
to maintain arrangements of polylines (a.k.a. poly-segments),
which are continuous piecewise linear curves. A polyline can be
created from any range of points, where the $i$th and $(i+1)$st
points in the range represent the endpoints of the $i$th segment
of the polyline. The polyline traits class is templated with a
segment-traits traits class that supports the basic operations on
segments.

Polylines are the simplest form of a curve that is not necessarily
$x$-monotone. They can be used to approximate more complicated
curves in a convenient manner, as the algebra needed to handle
them is elementary --- rational arithmetic is sufficient to
construct an arrangement of polylines is an exact and robust
manner. Note, however, that a single polyline can be split to an
unbounded number of $x$-monotone polylines, and that the number of
intersection points (or overlapping sections) between two
polylines is also unbounded.

The polyline-traits class is a model of the
\ccc{ArrangementTraits_2} concept and of the
\ccc{ArrangementLandmarkTraits_2} concept. Its \ccc{Curve_2} and
\ccc{X_monotone_curve_2} types are identical.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_12.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of three polylines, as constructed in
\ccc{example12.C}. Dark dots mark vertices associated with
polyline endpoints while white dots mark vertices that correspond
to intersection points. Note that $\pi_2$ is split into three
$x$-monotone polylines and that $\pi_1$ and $\pi_3$ have two
overlapping sections.}
\label{arr_fig:ex_12}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_12.gif"  border=0 alt="The polyline arrangement constructed in \ccc{example12.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

%Note that a polyline point is not necessarily a vertex of the
%arrangement (that is, of the underlying Planar Map) and an edge of
%the Planar Map need not be a segment. The edges are only required
%to be x-monotone and pairwise disjoint. In the example below point
%(150, 50) is not a vertex of the planar map. The polyline to which
%it belongs is an edge of the planar map.

\section{The Conic Traits Class}
\label{arr_ssec:tr_conic}
%-------------------------------

\section{The Notification Mechanism}
\label{arr_sec:notif}
%===================================

\section{Extending the \dcel}
\label{arr_sec:ex_dcel}
%============================

\section{Overlaying Arrangements}
\label{arr_sec:overlay}
%================================

\section*{Design and Implementation History}
%===========================================

The code of this package is the result of a long development process.
Initially (and until version~3.1), the code was spread among several
packages, namely \ccc{Topological_map}, \ccc{Planar_map_2},
\ccc{Planar_map_with_intersections_2} and \ccc{Arrangement_2}, that were
developed by~: \newline
Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran,
Sariel Har-Peled, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Ron Wein,
Baruch Zukerman and Tali Zvi.

In version~3.2, as part of the ACS project, the packages have done through
a major re-design, resulting in an improved \ccc{Arrangement_2} package.
The code of the new package was restructured and developed by~: \newline
Efi Fogel, Idit Haran, Ron Wein and Baruch Zukerman.
