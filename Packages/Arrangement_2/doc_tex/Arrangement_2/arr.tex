\newcommand{\reals}{{\rm I\!\hspace{-0.025em} R}}
\newcommand{\calC}{{\cal C}}
\newcommand{\calA}{{\cal A}}
\newcommand{\eps}{{\varepsilon}}
\newcommand{\dcel}{{\sc Dcel}}
\newcommand{\naive}{na\"{\i}ve}
\newcommand{\kdtree}{{\sc Kd}-tree}


% ===============================================================
\section{Introduction}
\label{arr_sec:intro}
% ===================

Given a set $\calC$ of planar curves, their {\em arrangement}
$\calA(\calC)$ is the subdivision they induce on the plane into
zero-dimensional, one-dimensional and two-dimensional cells,
called {\em vertices}, {\em edges} and {\em faces}, respectively.
Arrangements are ubiquitous in the computational-geometry
literature and have many applications in a range of fields ---
see, e.g.,~\cite{as-aa-00,h-a-04}.

As the curves in $\calC$ can intersect and are not necessarily
$x$-monotone, we construct a collection $\calC''$ in two steps. We
first decompose each curve in $\calC$ into maximal $x$-monotone
curves (and possibly isolated points), thus obtaining the
collection $\calC'$. Then we decompose each curve in $\calC'$ into
maximal connected pieces not intersecting any other curve (or
point) in $\calC'$. This way we obtain the collection $\calC''$ of
$x$-monotone subcurves that are pairwise disjoint in their
interiors. This collection may also contain isolated points, if
the curves of $\calC$ contain such points. The arrangement induced
by the collection $\calC''$ can be conveniently embedded as a
planar graph, whose vertices are associated with curve endpoints
or with isolated points and whose edges are associated with
subcurves, and it is easy to see that $\calA(\calC) =
\calA(\calC'')$. This graph can be represented using a {\em
doubly-connected edge list} data-structure (\dcel\ for short),
which consists of containers of vertices, edges and faces and
maintains the incidence relations among these objects.

The main idea behind the \dcel\ data-structure is to represent
each edge using a pair of directed {\em halfedges}, one going from
the (lexicographically) left endpoint of the curve to its right
endpoint, and the other --- known as its {\em twin} halfedge ---
going in the opposite direction. Halfedges are used to separate
faces and to connect vertices (with the exception of {\em isolated
vertices}, which are not connected).

If a vertex $v$ is the target of a halfedge $e$, we say that $v$
and $e$ are {\em incident} to each other. The halfedges incident
to a vertex $v$ form a circular list oriented in a clockwise order
around this vertex (we assume $v$ is not an isolated vertex, as
isolated vertices have no incident halfedges).

Each halfedge $e$ stores a pointer to its {\it incident face},
which is the face lying to its left. Moreover, every halfedge is
followed by another halfedge sharing the same incident face, such
that the target vertex of the halfedge is the same as the source
vertex of the next halfedge. The halfedges are therefore connected
in circular lists and form chains, such that all edges of a chain
are incident to the same face and wind along its boundary. We call
such chains a {\em connected component of the boundary} (or {\em
CCB} for short).

A bounded face has a unique CCB of halfedges winding in a
counterclockwise orientation along its boundary, which is defined
to be its {\em outer CCB}. As the arrangement module supports only
bounded curves, we always have exactly one unbounded face in the
every arrangement, and this unbounded face does not have an outer
boundary. Any other connected component of the boundary of the
face is called a {\em hole} (or {\em inner CCB}), and can be
represented as a circular chain of halfedges winding in a
clockwise orientation around its outer boundary. Note that a hole
is not necessarily a single face --- it may have no area, or
alternatively it may consist of several connected faces.  Every
face can have several holes contained in its interior (or there
may be no holes). In addition, every face may contain isolated
vertices in its interior. See Figure~\ref{arr_fig:seg_dcel} for an
illustration of the various \dcel\ features. For more details on
the \dcel\ data structure see~\cite[Chapter~2]{bkos-cgaa-00}.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/arr_segs.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of interior-disjoint line segment, which
consists of a single connected component inside the unbounded face
$\tilde{f}$, with some of the \dcel\ records that represent it.
The half-edge $e$ (and its twin $e'$) correspond to a line segment
that connects the vertices $v_1$ and $v_2$ and separates the face
$f_1$ from $f_2$. The predecessor $e_{\rm prev}$ and successor
$e_{\rm next}$ of $e$ are part of the chain that form the outer
boundary of the face $f_2$. The face $f_1$ has a more complicated
structure as it contains two holes in its interior: One hole
consists of two adjacent faces $f_3$ and $f_4$, while the other
hole is comprised of two edges. $f_1$ also contains two isolated
vertices $u_1$ and $u_2$ in its interior.}
\label{arr_fig:seg_dcel}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="arr_segs.gif"  border=0 alt="An arrangement of line segments">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The rest of this chapter is organized as follows: In
Section~\ref{arr_sec:arr_class} we review in detail the interface
of the \ccc{Arrangement_2} class-template, which is the central
component in the arrangement package. In
Section~\ref{arr_sec:queries} we show how to efficiently issue
queries on an arrangement. In Section~\ref{arr_sec:gl_funcs} we
review some important global functions that operate on
arrangements, the most important ones being the global insertion
functions. Section~\ref{arr_sec:traits} contains detailed
descriptions of the various geometric traits classes included in
the arrangement package. Using these traits classes it is possible
to construct arrangements of different families of curves. In
Section~\ref{arr_sec:notif} we review the notification mechanism
that allows external classes to keep track of the changes that an
arrangement instance goes through. Section~\ref{arr_sec:ex_dcel}
explains how to extend the \dcel\ records, to store extra data
with them and to efficiently update this data. In
Section~\ref{arr_sec:overlay} we introduce the fundamental
operation of overlaying two arrangements. Finally,
Section~\ref{arr_sec:arr_with_hist} described the
\ccc{Arrangement_with_history_2} class-template that extends the
arrangement by storing additional history records with its curves.

\section{The Main Arrangement Class}
\label{arr_sec:arr_class}
%===================================

The main guideline behind the design of the arrangement package is
the separation of the representation of the planar arrangement
from the various algorithms that operate on it. Another important
guideline is the separation between geometry an topology in the
arrangement representation.

The class \ccc{Arrangement_2<Traits,Dcel>} is a the main class in
the arrangement package. It is used to represent planar
arrangements and provides the interface needed to traverse them
and to maintain them. The arrangement is represented using the
\dcel\ class, which captures the {\em topological structure} of
the planar subdivision, and a geometric {\em traits} class that
defines the family of planar curves that form the arrangement and
supplies a range of geometric predicates (and constructions)
needed to construct and maintain the arrangement.

The separation between topology and geometry is defined by the two
template parameters of the \ccc{Arrangement_2} template:
\begin{itemize}
\item The \ccc{Traits} template-parameter should be instantiated with
a model of the \ccc{ArrangementBasicTraits_2} concept. The traits
class defines the types of $x$-monotone curves and two-dimensional
points --- \ccc{X_monotone_curve_2} and \ccc{Point_2},
respectively --- and supports basic geometric predicates on them.

In the first sections of this chapter we will always use
\ccc{Arr_segment_traits_2}, which enables the construction of
arrangements of line segments, as our traits class. However, the
arrangement package is shipped with several other traits classes
that can handle also polylines (continuous piecewise-linear
curves), conic arcs and arcs of rational functions. We will
exemplify the usage of these traits classes in
Section~\ref{arr_sec:traits}.

\item The \ccc{Dcel} template-parameter should be instantiated with
a class that is a model of the \ccc{ArranagementDcel} concept. The
value of this parameter is by default
\ccc{Arr_default_dcel<Traits>}, and it is recommended for most
users to stick to this default implementation of a \dcel\ class.
However, in some applications it is necessary to extend the
\dcel\ features --- see Section~\ref{arr_sec:ex_dcel} for further
explanations and examples.
\end{itemize}

\subsection{Traversing the Arrangement}
\label{arr_ssec:traverse}
%--------------------------------------

The simplest and most fundamental arrangement operations are the
various traversal methods, that allow users to systematically go
over the relevant features of the arrangement at hand.

As mentioned before, the arrangement is represented as a \dcel,
and therefore stores three containers of vertices, halfedges and
faces. The \ccc{Arrangement_2} class therefore supplies iterators
for these containers. For example, the methods
\ccc{vertices_begin()} and \ccc{vertices_end()} return
\ccc{Arrangement_2::Vertex_iterator} objects that define the valid
range of arrangement vertices. The value type of this iterator is
\ccc{Arrangement_2::Vertex}. Moreover, the vertex-iterator type is
equivalent to \ccc{Arrangement_2::Vertex_handle}, which serves as
a pointer to a vertex. As we see next, all function related to
arrangement features accept handle types as input parameters and
return handle types as their output. Each of the three nested
classes (namely \ccc{Arrangement_2::Vertex},
\ccc{Arrangement_2::Halfedge} and \ccc{Arrangement_2::Face})
support a \ccc{handle()} method that returns a handle to the
object at hand.

In addition to the iterators for arrangement vertices, halfedges
and faces, the arrangement class also support \ccc{edges_begin()}
and \ccc{edges_end()} that return
\ccc{Arrangement_2::Edge_iterator} objects for traversing the
arrangement edges. Note that the value type of this iterator is
\ccc{Arrangement_2::Halfedge}, representing one of the twin
halfedges that form the edge.
%In fact, as twin halfedges always are always contiguous in the
%halfedge container, using this iterator is equivalent to going
%over all halfedges and taking every second halfedge.

All iterator, circulator and handle types also have non-mutable
(a.k.a. {\em const}) counterparts. For example, the arrangement
has a non-constant member function called \ccc{vertices_begin()}
that returns a \ccc{Vertex_iterator} object and another const
member function that returns a a \ccc{Vertex_const_iterator}
object. In fact, all methods listed in this section that return an
iterator, a circulator or a handle have non-mutable counterparts.
It should be noted that, for example, \ccc{Vertex_handle} can be
readily converted to a \ccc{Vertex_const_handle}, but not
vice-versa.

Conversion of a non-mutable handle to a corresponding mutable
handle are however possible, and can be performed using the static
function \ccc{Arrangement_2::non_const_handle()}. This function
has three overloads, one for each type of handle.

\subsubsection{Traversal Methods for an Arrangement Vertex}
\label{arr_sssec:tr_vertex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A vertex is always associated with a geometric entity, namely with
a \ccc{Point_2} object, which can be retrieved by calling the
\ccc{point()} method of the nested \ccc{Vertex} class.

The \ccc{is_isolated()} method is used to determine whether a
vertex is isolated or not. Recall that the incident halfedges
incident to a regular (non-isolated) vertex form a circular list
around this vertex. The \ccc{incident_halfedges()} method returns
a circulator of type
\ccc{Arrangement_2::Halfedge_around_vertex_circulator} that
enables the traversal of this circular list in a clockwise
direction. The value type of this circulator is \ccc{Halfedge}.

The following function prints all the neighbors of a given
arrangement vertex (assuming the \ccc{Point_2} type can be
exported to the standard output using the \ccc{<<} operator). For
simplicity, we assume that the arrangement type and its nested
type are properly defined (see next for more complete examples):
\begin{alltt}
void print_neighboring_vertices (Vertex_const_handle v)
\{
  if (v->is_isolated())
  \{
    std::cout << "The vertex (" << v->point() << ") is isolated" << std::endl;
    return;
  \}

  Halfedge_around_vertex_const_circulator  first, curr;
  Vertex_const_handle                      u;

  std::cout << "The neighbors of the vertex (" << v->point() << ") are:";
  first = curr = v->incident_halfedges();
  do
  \{
    // Note that the current halfedge is (u -> v):
    u = curr->source();
    std::cout << " (" << u->point() << ")";

    ++curr;
  \} while (curr != first);
  std::cout << std::endl;

  return;
\}
\end{alltt}

In case of an isolated vertex, it is possible to obtain the face
that contains this vertex. However, this is done via a method of
the \ccc{Arrangement_2} class, called \ccc{incident_face
(Vertex_handle v)}, and not using one of the methods of the nested
\ccc{Vertex} class.

\subsubsection{Traversal Methods for an Arrangement Halfedge}
\label{arr_sssec:tr_halfedge}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each pair of twin halfedge is associated with an
\ccc{X_monotone_curve_2} object, which can be retrieved by calling
the \ccc{curve()} method of the nested \ccc{Halfedge} class.

The \ccc{source()} and \ccc{target()} methods return handles to
the halfedge source and target vertices, respectively. One can
obtain a handle to the twin halfedge using the \ccc{twin()}
method. From the definition of halfedges, it follows that if
\ccc{he} is a halfedge handle, then:
\begin{itemize}
\item \ccc{he->curve()} is equivalent to \ccc{he->twin()->curve()}.
\item \ccc{he->source()} is equivalent to \ccc{he->twin()->target()}.
\item \ccc{he->target()} is equivalent to \ccc{he->twin()->source()}.
\end{itemize}

Every halfedge has an incident face that lies to its left, which
can be obtained by using the \ccc{face()} method. Recall that a
halfedge is always one link in a connected chain of halfedges that
share the same incident face, known as a {\em CCB}. The
\ccc{prev()} and \ccc{next()} methods return handles to the
previous and next halfedges in the CCB, respectively (note that
\ccc{he->prev()} is not necessarily equivalent to
\ccc{he->twin()->next()}).

As the CCB is actually a circular list, it is natural to traverse
it using a circulator. The \ccc{ccb()} method returns a
\ccc{Arrangement_2::Ccb_halfedge_circulator} object for the
halfedges along the CCB.

The following function prints all $x$-monotone curves and points
along a CCB (assuming that the \ccc{Point_2} and the
\ccc{X_monotone_curve_2} types can be exported to the standard
output using the \ccc{<<} operator):
\begin{alltt}
void print_ccb (Ccb_halfedge_const_circulator circ)
\{
  Ccb_halfedge_const_circulator  curr = circ;
  Halfedge_const_handle          he;

  std::cout << "(" << curr->source()->point() << ")";
  do
  \{
    he = curr->handle();
    std::cout << "   [" << he->curve() << "]   "
              << "(" << he->target()->point() << ")";

    ++curr;
  \} while (curr != circ);
  std::cout << std::endl;

  return;
\}
\end{alltt}


\subsubsection{Traversal Methods for an Arrangement Face}
\label{arr_sssec:tr_face}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As the \ccc{Arrangement_2} class supports only finite curves, the
arrangement always has a single unbounded face, where all other
arrangement features form holes (or isolated vertices) inside this
face. (Note that an empty arrangement contains no other feature
{\em but} the unbounded face.) The function \ccc{unbounded_face()}
returns a handle to this face.

Given a \ccc{Face} object, we can use the \ccc{is_unbounded()}
method to determine whether it is unbounded. Bounded faces have an
outer CCB, and the \ccc{outer_ccb()} method returns a circulator
for the halfedges along this CCB. Note that the halfedges along
this CCB wind in a counterclockwise orientation around the outer
boundary of the face.

A face can also contain disconnected components in its interior,
namely holes and isolated vertices:
\begin{itemize}
\item The \ccc{holes_begin()} and \ccc{holes_end()} methods return
\ccc{Arrangement_2::Holes_iterator} objects that define the range
of holes inside the face. The value type of this iterator is
\ccc{Ccb_halfedge_circulator}, defining the CCB that winds in a
clockwise orientation around a hole.

\item The \ccc{isolated_vertices_begin()} and
\ccc{isolated_vertices_end()} methods return
\ccc{Arrangement_2::Isolated_vertices_iterator} objects that
define the range of isolated vertices inside the face. The value
type of this iterator is \ccc{Vertex}.
\end{itemize}

The following function prints the outer and inner boundaries of a
given face, using the function \ccc{print_ccb()} that was
introduced in the previous subsection:
\begin{alltt}
void print_face (Face_const_handle f)
\{
  // Print the outer boundary.
  if (f->is_unbounded())
  \{
    std::cout << "Unbounded face. " << std::endl;
  \}
  else
  \{
    std::cout << "Outer boundary: ";
    print_ccb (f->outer_ccb());
  \}

  // Print the boundary of each of the holes.
  Holes_const_iterator              hole;
  int                               index = 1;

  for (hole = f->holes_begin(); hole != f->holes_end(); ++hole, ++index)
  \{
    std::cout << "    Hole #" << index << ": ";
    print_ccb (*hole);
  \}

  // Print the isolated vertices.
  Isolated_vertices_const_iterator  iv;

  for (iv = f->isolated_vertices_begin(), index = 1;
       iv != f->isolated_vertices_end(); ++iv, ++index)
  \{
    std::cout << "    Isolated vertex #" << index << ": "
              << "(" << iv->point() << ")" << std::endl;
  \}

  return;
\}
\end{alltt}

\subsubsection{Additional Example}
\label{arr_sssec:tr_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To conclude the review of the various traversal methods, we bring
the following function that prints the current setting of the
arrangement:\footnote{To simplify the code, we assume that the
\ccc{Arrangement_2} type is defined as a proper instantiation of
the \ccc{Arrangement_2<Traits,Dcel>} template and all its nested
types are also defined. The file \ccc{arr_print.h}, which can be
found under the examples folder, includes this function and the
rest of the functions listed in this section. Over there they are
written in a more generic fashion, where the arrangement type
serves as a template parameter for these functions, so different
instantiations of the \ccc{Arrangement_2<Traits,Dcel>} template
can be provided to the same function templates.}
\begin{alltt}
void print_arrangement (const Arrangement_2& arr)
\{
  // Print the arrangement vertices.
  Vertex_const_iterator      vit;

  std::cout << arr.number_of_vertices() << " vertices:" << std::endl;
  for (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit)
  \{
    std::cout << "(" << vit->point() << ")";
    if (vit->is_isolated())
      std::cout << " - Isolated." << std::endl;
    else
      std::cout << " - degree " << vit->degree() << std::endl;
  \}

  // Print the arrangement edges.
  Edge_const_iterator        eit;

  std::cout << arr.number_of_edges() << " edges:" << std::endl;
  for (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)
    std::cout << "[" << eit->curve() << "]" << std::endl;

  // Print the arrangement faces.
  Face_const_iterator        fit;

  std::cout << arr.number_of_faces() << " faces:" << std::endl;
  for (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)
    print_face (fit);

  return;
\}
\end{alltt}

\subsection{Modifying the Arrangement}
\label{arr_ssec:modify}
%-------------------------------------

In this section we review the various member functions of the
\ccc{Arrangement_2} class that allows users to modify the
topological structure of the arrangement by introducing new edges
and vertices, modifying them and removing them.

Please note that the arrangement member-functions that insert new
curves into the arrangement, thus enabling the construction of
planar subdivision, are rather specialized, in the sense that the
user has to have a large amount of a-priori knowledge on the
location of the inserted curve. Indeed, for most purposes it is
more convenient to construct an arrangement using the global
insertion functions. Readers may therefore skip to
Section~\ref{arr_sec:gl_funcs} and go over it before reading the
rest of this section.

\subsubsection{Inserting Non-Intersecting Curves}
\label{arr_sssec:mf_insert_cv}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The most important functions that allow users to modify the
arrangement, and the most frequently used ones, are the
specialized insertion functions of $x$-monotone curves whose
interior is disjoint from any other curve in the existing
arrangement and does not contain any vertex of the arrangement. We
will also assume that the location of the curve in the arrangement
is known.

The reason for these rather harsh restrictions on the nature of
the inserted curves is the decoupling of the topological
arrangement representation from the various algorithms that
operate on it. While the insertion of an $x$-monotone curve whose
interior is disjoint from all existing arrangement features is
quite straightforward (as we see next), inserting curves that
intersect with the arrangement is much more complicated and
requires the application of non-trivial algorithms. These
insertion operations are therefore implemented as global functions
that operate on the arrangement and the inserted curve(s) --- see
Section~\ref{arr_sec:gl_funcs} for more details and ample
examples.


\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
    \begin{tabular}{ccc}
        \input{Arrangement_2/insert_in_face.pstex_t} &
        \input{Arrangement_2/insert_from_vertex.pstex_t} &
        \input{Arrangement_2/insert_at_vertices.pstex_t} \\
    {\small (a)} & {\small (b)} & {\small (c)}\\
    \end{tabular}
\end{center}
\end{ccTexOnly}
\caption{The various specialized insertion procedures. The
inserted $x$-monotone curve is drawn with a light dashed line,
surrounded by two solid arrows that represent the pair of twin
half-edges added to the \dcel. Existing vertices are shown as
black dots while new vertices are shown as light dots. Existing
half-edges that are affected by the insertion operations are drawn
as dashed arrows. (a) Inserting a curve as a new hole inside the
face $f$. (b) Inserting a curve from an existing vertex $u$ that
corresponds to one of its endpoints. (c) Inserting an $x$-monotone
curve whose endpoints are already represented by the vertices
$u_1$ and $u_2$. In our case, the new pair of half-edges close a
new face $f'$, where the hole $h_1$, which used to belong to $f$,
now becomes an enclave in this new face.} \label{arr_fig:insert}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="insert_funcs.gif"  border=0 alt="The various specialized insertion procedures.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

It is not difficult to see that when we insert an $x$-monotone
curve into an existing arrangement, such that the interior of this
curve is disjoint from any arrangement feature, only the following
three scenarios are possible, depending on the status of the
endpoints of the inserted subcurve:
\begin{enumerate}

\item In case both curve endpoints do not correspond to any existing
arrangement vertex we have to create two new vertices
corresponding to the curve endpoints and connect them using a pair
of twin halfedges. This halfedge pair initiates a new hole inside
the face that contains the curve in its interior.

\item If exactly one endpoint corresponds to an existing arrangement
vertex (we distinguish between a vertex that corresponds to the left
endpoint of the inserted curve and a vertex corresponding to its right
endpoint), we have to create a new vertex that corresponds to the other
endpoint of the curve and to connect the two vertices by a pair of
twin halfedges that form an ``antenna'' emanating from the boundary
of an existing connected component (note that if the existing vertex
used to be isolated, this operation is actually equivalent to forming
a new hole inside the face that contains this vertex).

\item Otherwise, if both endpoints correspond to existing arrangement
vertices we connect these vertices using a pair of twin halfedges.
Let us assume the two vertices are not isolated (otherwise the
operation is equivalent to one of the two previous cases). The two
following cases may occur:
\begin{itemize}
\item Two disconnected components are merged into a single connected
component.

\item A new face is created --- actually, it is split from an existing
arrangement face. In this case we also have to examine the holes and
isolated vertices in the existing face and move the relevant ones
inside the new face.
\end{itemize}
\end{enumerate}

The \ccc{Arrangement_2} class offers insertion functions named
\ccc{insert_in_face_interior()}, \ccc{insert_from_left_vertex()},
\ccc{insert_from_right_vertex()} and \ccc{insert_at_vertices()}
that perform the special insertion procedures listed above. The
first function accepts an $x$-monotone curve and an arrangement
face that contains this curve in its interior, while the other
function accept an $x$-monotone and handles to the existing
vertices that correspond to the curve endpoints. Each of the four
functions return a handle to one of the twin halfedges that have
been created, where:
\begin{itemize}
\item \ccc{insert_in_face_interior(c, f)} returns a halfedge directed
from the vertex corresponding to the left endpoint of \ccc{c}
toward the vertex corresponding to its right endpoint.

\item \ccc{insert_from_left_vertex(c, v)} and
\ccc{insert_from_right_vertex(c, v)} return a halfedge whose
source is the vertex $v$ that and whose target is the new vertex
that has just been created.

\item \ccc{insert_at_vertices(c, v1, v2)} returns a halfedge directed
from $v_1$ to $v_2$.
\end{itemize}

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_1.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{The arrangement of the line segments $s_1, \ldots, s_5$
constructed in \ccc{example1.C}. The arrows mark the direction of
the halfedges returned from the various insertion functions.}
\label{arr_fig:ex_1}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_1.gif"  border=0 alt="The segment arrangement constructed in \ccc{example1.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program demonstrates the usage of the four insertion
functions. It creates an arrangement of five line segments, as
depicted in Figure~\ref{arr_fig:ex_1}. As the arrangement is very
simple, we use the simple Cartesian kernel of \cgal\ with integer
coordinates for the segment endpoints. We used the built-in
\ccc{Arr_segment_traits_2} class that enables the efficient
maintenance of arrangements of line segments
--- see more details on this traits class in Section~\ref{arr_sec:traits}:

\ccIncludeExampleCode{../examples/Arrangement_2/example1.C}

Note that the first line segment is inserted in the interior of
the unbounded face, while the other line segments are inserted
using the vertices created by the insertion of previous segments.
The resulting arrangement consists of three faces, where the two
bounded faces form together a hole in the unbounded face.

\subsubsection{Manipulating Isolated Vertices}
\label{arr_sssec:mf_iso_verts}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Isolated points are in general simpler geometric entities than
curves and indeed the member functions that manipulate them are
easier to understand.

The function \ccc{insert_isolated_vertex(p, f)} inserts an
isolated point $p$, located in the interior of a given face $f$,
into the arrangement and returns a handle to the arrangement
vertex it has created and associated with $p$. Naturally, this
function has a precondition that $p$ is really an isolated point,
namely it does not coincide with any existing arrangement vertex
and does not lie on any edge.

As we have already mentioned in Section~\ref{arr_ssec:traverse},
it is possible to obtain the face surrounding an isolated vertex
by calling \ccc{incident_face(v)} (with the precondition that $v$
is an isolated vertex --- other vertices may not necessarily have
a unique incident face).

The function \ccc{remove_isolated_vertex(v)} receives a handle to
an isolated vertex and removes it from the arrangement.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_2.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments containing three isolated
vertices, as constructed in \ccc{example2.C}. The vertices $u_2$
and $u_3$ are eventually deleted from the arrangement.}
\label{arr_fig:ex_2}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_2.gif"  border=0 alt="The segment arrangement constructed in \ccc{example2.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program demonstrates the usage of the arrangement
member-functions for manipulating isolated vertices. It first
inserts three isolated vertices inside the unbounded face, then
inserts four line segments that form a rectangular hole inside the
unbounded face (see Figure~\ref{arr_fig:ex_2} for an
illustration). It finally goes over the vertices and removes those
isolated vertices that are still contained in the unbounded face
($u_2$ and $u_3$ in this case):

\ccIncludeExampleCode{../examples/Arrangement_2/example2.C}

\subsubsection{Manipulating Halfedges}
\label{arr_sssec:mf_halfedges}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the previous subsection we showed how to introduce new isolated
vertices in the arrangement. But how do we create a vertex that
lies on an existing arrangement edge (more precisely, on an
$x$-monotone curve that is associated with an arrangement edge)?

It should be noted that such an operation involves the splitting
of a curve at a given point in its interior, while the traits
class used by \ccc{Arrangement_2} does not necessarily have the
ability to perform such a split operation. However, if users know
how to split an $x$-monotone curve into two at a given point $p$,
they can use the \ccc{split_edge(e, p, c1, c2)} function, were
$c_1$ and $c_2$ are the two subcurves resulting from splitting the
$x$-monotone curve associated with the halfedge $e$ at a point $p$
in its interior. The function splits the halfedge pair into two
pairs, both incident to a new vertex $v$ associated with $p$, and
returns a handle to a halfedge whose source equals $e$'s source
vertex and whose target is the new vertex $v$.

The reverse operation is also possible. Suppose that we have a
vertex $v$ of degree $2$, whose two incident halfedges, $e_1$ and
$e_2$, are associated with the curves $c_1$ and $c_2$. Suppose
further that we know how to merge these two curves into a single
continuous $x$-monotone curve $c$ --- then calling
\ccc{merge_edge(e1, e2, c)} will merge the two edges into a single
edge associated with the curve $c$, resulting in the removal of
the vertex $v$ from the arrangement.

Finally, the function \ccc{remove_edge(e)} removes the edge $e$
from the arrangement. Note that this operation is the reverse of
the various insertion functions, so it may cause a connected
component two split into two, or two face to merge into one, or a
hole to disappear.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
    \begin{tabular}{ccc}
        \input{Arrangement_2/ex_3a.pstex_t} &
        \input{Arrangement_2/ex_3b.pstex_t} &
        \input{Arrangement_2/ex_3c.pstex_t} \\
    {\small (a)} & {\small (b)} & {\small (c)}\\
    \end{tabular}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments containing as constructed
in \ccc{example3.C}. Note that the edges $e_7$ and $e_8$ and the
vertices $w_1$ and $w_2$, introduced in step~(b) are eventually
removed in step~(c).}
\label{arr_fig:ex_3}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_3.gif"  border=0 alt="The segment arrangement constructed in \ccc{example3.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the following example program we show how the edge-manipulation
functions can be used. The program can be separated into three
steps, as demonstrated in Figure~\ref{arr_fig:ex_3}. Note that
here we still stick to integer coordinates, but as we work on a
larger scale we use an unbounded integer number-type (in this
case, the \ccc{Gmpz} type taken from the {\sc Gmp} library)
instead of the built-in \ccc{int} type.\footnote{As a rule of
thumb, one can use a bounded integer type for representing line
segments whose coordinates are bounded by
$\lfloor\sqrt[3]{M}\rfloor$, where $M$ is the maximal
representable integer value.} We also use the standard Cartesian
kernel of \cgal\ as our kernel --- this is recommended when the
kernel is instantiated with a more complex number type:

\ccIncludeExampleCode{../examples/Arrangement_2/example3.C}

Note how we use the halfedge handles returned from
\ccc{split_edge()} and \ccc{merge_edge()}. Also note the insertion
of the isolated vertex $v_6$ inside the triangular face (the
incident face of $e_7$). This vertex is eventually connected to
other vertices, so it stops being isolated.

In this context, we should mention the two member functions
\ccc{modify_vertex(v, p)}, which sets $p$ to be the point
associated with the vertex $v$, and \ccc{modify_edge(e, c)}, which
sets $c$ to be the $x$-monotone curve associated with the halfedge
$e$. To avoid the invalidation of the geometric structure of the
arrangement, these functions have preconditions that $p$ is
geometrically equivalent to \ccc{v->point()} and $c$ is equivalent
to \ccc{e->curve()} (i.e., the two curves have the same graph),
respectively. It therefore seems that these two functions are of
little use. However, we should keep in mind that there may be
extraneous data (probably non-geometric) associated with the point
objects or with the curve objects, as defined by the traits class,
so we are thus able to modify this data --- see more details in
Section~\ref{arr_sec:traits}.

In addition, we can use these functions to replace a geometric
object (a point or a curve) with an equivalent object that has a
more compact representation. For example, we can replace the point
$(\frac{20}{40}, \frac{99}{33})$ associated with some vertex $v$,
by $(\frac{1}{2}, 3)$.

\begin{ccAdvanced}
\subsubsection{Advanced Insertion Functions}
\label{arr_sssec:adv_insert}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Assume that the specialized insertion function
\ccc{insert_from_left_vertex(c,v)} is invoked for a curve $c$
whose right endpoint is already associated with a non-isolated
vertex $v$, namely it has already several edges incident to it. It
is necessary in this case to locate the right place for the
inserted curve $c$ around $v$. In fact, it is sufficient to locate
one of the halfedges \ccc{pred} directed toward $v$ such that $c$
is located between \ccc{pred} and \ccc{pred->next()} in a
clockwise direction around $v$, in order to perform the insertion
(see Figure~\ref{arr_fig:insert} for an illustration). This may
take $O(d)$ time where $d$ is the degree of the vertex. However,
if the halfedge \ccc{pred} is known in advance, the insertion can
be carried out in constant time.

The \ccc{Arrangement_2} class provides the advanced versions of
\ccc{insert_from_left_vertex()} and
\ccc{insert_from_right_vertex()} that accept a halfedge \ccc{pred}
as specified above, instead of a vertex $v$. These functions are
more efficient, as they take constant time and do not perform any
geometric operations, thus they should be used when the halfedge
\ccc{pred} is known. In case that the vertex $v$ is isolated or
that the predecessor halfedge for the new inserted curve is not
known, the simpler versions of these insertion functions should be
used.

Similarly, there exist two overrides of the
\ccc{insert_at_vertices()} function: One that accept the two
predecessor halfedges around the two vertices $v_1$ and $v_2$ that
correspond to the curve endpoints, and one that accepts a handle
for one vertex and a predecessor halfedge around the second
vertex.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_4.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of line segments, as constructed in
\ccc{example4.C}. Note that $p_0$ is initially inserted as an
isolated point and later on connected to the other four vertices.}
\label{arr_fig:ex_4}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_4.gif"  border=0 alt="The segment arrangement constructed in \ccc{example4.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program shows how to construct the arrangement
depicted in Figure~\ref{arr_fig:ex_4} using the specialized
insertion functions that accept predecessor halfedges:

\ccIncludeExampleCode{../examples/Arrangement_2/example4.C}
\end{ccAdvanced}

\section{Issuing Queries on an Arrangement}
\label{arr_sec:queries}
%==========================================

One of the most important query types defined on arrangements is
the {\em point-location} query: Given a point, find the
arrangement cell that contains it. Typically, the result of a
point-location query is one of the arrangement faces, but in
degenerate situations the query point can be located on an edge or
coincide with a vertex.

Point-location queries are not only common in many applications,
they also play an important role in the global insertion functions
(see Section~\ref{arr_sec:gl_funcs}). It is therefore crucial to
have the ability of effectively answering such queries for any
arrangement instance.

\subsection{Point-Location Queries}
\label{arr_ssec:pl}
%----------------------------------

The arrangement package includes several classes (more precisely,
class templates parameterized by an arrangement class) that model
the \ccc{ArrangementPointLocation_2} concept --- namely, they all
have a member function called \ccc{locate(q)} that accepts a query
point $q$ and outputs a \cgal\ \ccc{Object} that wraps a handle to
the arrangement cell containing the query point. This object can
be assigned to either a \ccc{Face_const_handle},
\ccc{Halfedge_const_handle} or a \ccc{Vertex_const_handle}.

Note that the handles returned by the \ccc{locate()} functions are
\ccc{const} (non-mutable) handles. If necessary, such handles may
be casted to mutable handles using the static functions
\ccc{Arrangement_2::non_const_handle()} provided by the
arrangement class.

An instance of any point-location class is always attached to an
\ccc{Arrangement_2} instance. This attachment can be performed
when the point-location instance is constructed, or at a later
time, using the \ccc{init(arr)} method, where \ccc{arr} is the
attached \ccc{Arrangement_2} instance.

The following function template, which can be found in the example
file \ccc{point_location_utils.h}, accepts a point-location object
(whose type can be any of the models to the
\ccc{ArrangementPointLocation_2} concept) and a query point, and
prints out the result of the point-location query for the given
point. The point-location object \ccc{pl} is assumed to be already
associated with an arrangement:

\begin{alltt}
template <class PointLocation>
void point_location_query
        (const PointLocation& pl,
         const typename PointLocation::Arrangement_2::Point_2& q)
\{
  // Perform the point-location query.
  CGAL::Object    obj = pl.locate (q);

  // Print the result.
  typedef typename PointLocation::Arrangement_2  Arrangement_2;

  typename Arrangement_2::Vertex_const_handle    v;
  typename Arrangement_2::Halfedge_const_handle  e;
  typename Arrangement_2::Face_const_handle      f;

  if (CGAL::assign (f, obj))
  \{
    // q is located inside a face:
    if (f->is_unbounded())
      std::cout << "Inside the unbounded face." << std::endl;
    else
      std::cout << "Inside a bounded face." << std::endl;
  \}
  else if (CGAL::assign (e, obj))
  \{
    // q is located on an edge:
    std::cout << "On an edge: " << e->curve() << std::endl;
  \}
  else if (CGAL::assign (v, obj))
  \{
    // q is located on a vertex:
    if (v->is_isolated())
      std::cout << "On an isolated vertex: " << v->point() << std::endl;
    else
      std::cout << "On a vertex: " << v->point() << std::endl;
  \}
  else
  \{
    CGAL_assertion_msg (false, "Invalid object.");
  \}

  return;
\}
\end{alltt}

\subsubsection{Choosing a Point-Location Strategy}
\label{arr_sssec:pl_strat}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each of the various point-location classes employs a different
algorithm or {\em strategy} for answering queries:
\begin{itemize}
\item \ccc{Arr_naive_point_location<Arrangement>} locate the query
point \naive ly, by exhaustively scanning all arrangement cells.

\item \ccc{Arr_walk_along_a_line_point_location<Arrangement>}
simulates a traversal along an imaginary vertical ray emanating
from the query point: It starts from the unbounded face of the
arrangement and moves downward toward the query point until
locating the arrangement cell containing it.

\item \ccc{Arr_landmarks_point_location<Arrangement,Generator>}
uses a set of ``landmark'' points whose location in the
arrangement is known. Given a query point, it uses a \kdtree\ to
find the nearest landmark and then traverses the straight line
segment connecting this landmark to the query point.

There are various strategies to select the landmark set in the
arrangement, where the strategy is determined by the
\ccc{Generator} template parameter. By default, the generator
class \ccc{Arr_landmarks_vertices_generator} is used and the
arrangement vertices are the selected landmarks, but other
landmark-generating strategies, such as sampling random points or
choosing points on a grid, are also available --- see the
reference manual for more details.

\item \ccc{Arr_trapezoid_ric_point_location<Arrangement>} implements
Mulmuley's point-location algorithm~\cite{m-fppa-90} (see
also~\cite[Chapter~6]{bkos-cgaa-00}). The
arrangement faces are decomposed into simpler cells of constant
complexity known as {\em pseudo-trapezoids} and a search-structure
(a directed acyclic graph) is constructed on top of these cells,
allowing to locate the pseudo-trapezoid (hence the arrangement
cell) containing a query point in expected logarithmic time.
\end{itemize}

The main advantage of the first two strategies is that they do not
require any extra data, so the respective classes just store a
pointer to an arrangement object and operate directly on it.
Attaching such point-location objects to an existing arrangement
has virtually no running-time cost at all, but the query time is
linear in the size of the arrangement (the performance of the
``walk'' strategy is much better in practice, but its worst-case
performance is linear). Using these strategies are therefore
recommended only when a relatively small number of point-location
queries are issued by the application, or when the arrangement is
constantly changing (i.e., changes in the arrangement structure
are more frequent that point-location queries).

On the other hand, the landmarks and the trapezoid RIC strategies
require auxiliary data structures on top of the arrangement, which
they need to construct once they are attached to arrangement
object and need to keep up-to-date as this arrangement changes.
The data structures needed by both strategies can be constructed
in $O(n \log n)$ time (where $n$ is the size of the arrangement),
but the construction needed by the landmark algorithm is in
practice one order of magnitude faster. In addition, although both
resulting data structures are asymptotically linear in size, the
\kdtree\ that the landmarks algorithm stores needs significantly
less memory. We note that Mulmuley's algorithm guarantees a
logarithmic query time, while the query time for the landmarks
strategy is only logarithmic on average --- and we may have
scenarios where the query time can be linear. In practice however,
the query times of both strategies are competitive.

The main drawback in the current implementation of the landmarks
strategy is that while the updating the auxiliary data structures
related to the trapezoidal decomposition is done very efficiently,
the \kdtree\ maintained by the landmarks algorithm needs to be
frequently rebuilt as the arrangement changes. In addition, using
the landmarks point-location class adds some extra requirement
from the traits class (that is, the traits class should be a model
of a refined concept \ccc{ArrangementLandmarkTraits_2} --- see
Section~\ref{arr_sec:traits} for the details). However, most
built-in traits classes that come with the \cgal\ public release
support these extra operations.

It is therefore recommended to use the
\ccc{Arr_landmarks_point_location} class when the application
frequently issues point-location queries on a rather static
arrangement that only seldom changes. If the arrangement is more
dynamic and is frequently going through changes, the
\ccc{Arr_trapezoid_ric_point_location} class should be the
selected point-location strategy.

\subsubsection{An Example}
\label{arr_sssec:pl_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_5.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{The arrangement of line segments, as constructed in
\ccc{example5.C}, \ccc{example6.C} and \ccc{example7.C}. The
arrangement vertices are drawn in light dots, while the query
points $q_1, \ldots, q_6$ are marked with crosses.}
\label{arr_fig:ex_5}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_5.gif"  border=0 alt="The segment arrangement constructed in \ccc{example5.C}, \ccc{example6.C} and \ccc{example7.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program constructs a simple arrangement of five line
segments that form a pentagonal face, with a single isolated
vertex in its interior, as depicted in Figure~\ref{arr_fig:ex_5}
(the details of the arrangement construction are omitted from the
main program, and can be found in \ccc{point_location_utils.h}).
It then employs the \naive\ and the landmark strategies to issue
several point-location queries on this arrangement:

\ccIncludeExampleCode{../examples/Arrangement_2/example5.C}

Note that the program uses the auxiliary
\ccc{point_location_query()} function template to nicely print the
result of each query.

\subsection{Vertical Ray Shooting}
\label{arr_ssec:ray_shoot}
%---------------------------------

Another important query issued on arrangements is the vertical
ray-shooting query: Given a query point, which arrangement feature
do we encounter if we shoot a vertical ray emanating upward (or
downward) from this point? In the general case the ray hits an
edge, but it is possible that it hits a vertex, or that the
arrangement does not have any feature lying directly above (or
below) the query point.

The \ccc{Arr_naive_point_location}, the
\ccc{Arr_walk_along_a_line_point_location} and the
\ccc{Arr_trapezoid_ric_point_location} classes are also models of
the \ccc{ArrangementVerticalRayShoot_2} concept. That is, they all
have member functions called \ccc{ray_shoot_up(q)} and
\ccc{ray_shoot_down(q)} that accept a query point $q$ and output a
\cgal\ \ccc{Object}. This can be assigned to either a
\ccc{Halfedge_const_handle} or to a \ccc{Vertex_const_handle}.
Alternatively, the returned value is an empty object if there is
no edge or vertex lying directly above (or below) $q$.

The following function template, also located in the example file
\ccc{point_location_utils.h}, accepts a vertical ray-shooting
object, whose type can be any of the models to the
\ccc{ArrangementVerticalRayShoot_2} concept and prints out the
result of the upward vertical ray-shooting operations from a given
query point. The ray-shooting object \ccc{vrs} is assumed to be
already associated with an arrangement:

\begin{alltt}
template <class VerticalRayShoot>
void vertical_ray_shooting_query
    (const VerticalRayShoot& vrs,
     const typename VerticalRayShoot::Arrangement_2::Point_2& q)
\{
  // Perform the point-location query.
  CGAL::Object    obj = vrs.ray_shoot_up (q);

  // Print the result.
  typedef typename VerticalRayShoot::Arrangement_2  Arrangement_2;

  typename Arrangement_2::Vertex_const_handle    v;
  typename Arrangement_2::Halfedge_const_handle  e;

  if (CGAL::assign (e, obj))
  \{
    // We hit an edge:
    std::cout << "Hit an edge: " << e->curve() << std::endl;
  \}
  else if (CGAL::assign (v, obj))
  \{
    // We hit a vertex:
    if (v->is_isolated())
      std::cout << "Hit an isolated vertex: " << v->point() << std::endl;
    else
      std::cout << "Hit a vertex: " << v->point() << std::endl;
  \}
  else
  \{
    // We did not hit anything:
    CGAL_assertion_msg (obj.is_empty(), "Invalid object.");

    std::cout << "Hit nothing." << std::endl;
  \}

  return;
\}
\end{alltt}

The following program uses the auxiliary function listed above to
perform vertical ray-shooting queries on an arrangement. Note that
the arrangement and the query points are exactly the same as in
\ccc{example5.C} --- see Figure~\ref{arr_fig:ex_5}:

\ccIncludeExampleCode{../examples/Arrangement_2/example6.C}

The number type we use in this example is \cgal's built-in
\ccc{MP_Float} type which is a floating-point number with an
unbounded mantissa. It supports construction from an integer or
from a machine \ccc{float} or \ccc{double} and performs additions,
subtractions and multiplications in an exact number.

\subsection{Batched Point-Location}
\label{arr_ssec:batched_pl}
%----------------------------------

Suppose that at a given moment our application has to issue a
relatively large number $m$ of point-location queries on a
specific arrangement instance. It is possible of course to define
a point-location object and to issue separate queries on the
arrangement. However, as explained in Section~\ref{arr_ssec:pl},
choosing a simple point-location strategy (either the \naive\ or
the walk strategy) means inefficient queries, while the more
sophisticated strategies need to construct auxiliary structures
that incur extra running times.

On the other hand, the arrangement package includes a global
\ccc{locate()} function that accepts an arrangement a range of
query points as its input and sweeps through the arrangement to
locate the points simultaneously. The function outputs the query
results as pairs, where each pair is comprised of a query point
and a \cgal\ \ccc{Object} that represents the cell containing the
point (see also Section~\ref{arr_ssec:pl}). The output pairs are
sorted in increasing $xy$-lexicographical order.

The batched point-location operation can be performed in
$O\left((m+n)\log{(m+n)}\right)$ time, where $n$ is the size of
the arrangement. This means that when the number $m$ of
point-location queries is of the same order of magnitude as $n$,
this operation is more efficient than issuing separate queries.
Experimental results also backup the theoretical time bounds.
Moreover, the batched point-location operation is also
advantageous as it does not have to construct and maintain
additional data structures.

The following program issues a batched point-location query, which
is essentially equivalent to the six separate queries performed in
\ccc{example5.C} (see Section~\ref{arr_ssec:pl}):

\ccIncludeExampleCode{../examples/Arrangement_2/example7.C}

\section{Global Arrangement Functions}
\label{arr_sec:gl_funcs}
%=====================================

In Section~\ref{arr_sec:arr_class} we reviewed in detail the
\ccc{Arrangement_2} class, which represents two-dimensional
subdivisions of bounded planar curves, and mentioned that its
interface is minimal in the sense that the member functions hardly
perform any geometric algorithms and are mainly used for
maintaining the topological structure of the subdivision. In this
section we go over the global functions that operate on
arrangements, implementing operations that require non-trivial
geometric algorithms or loading some extra requirements on the
traits class.

\subsection{Incremental Insertion Functions}
\label{arr_ssec:inc_insert}
%-------------------------------------------

\subsubsection{Inserting Non-Intersecting Curves}
\label{arr_sssec:insert_non_x}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In Section~\ref{arr_sec:arr_class} we explained how to construct
arrangements of $x$-monotone curves that are pairwise disjoint in
their interior, when the location of the segment endpoints in the
arrangement is known. We now relax this assumption and assume that
we wish to insert a $x$-monotone curve $c$ into an existing
arrangement such that its interior is disjoint from all existing
arrangement edges and vertices, but its location is unknown.

The global function \ccc{insert_non_intersecting(arr, c, pl)}
performs this exact operation: Its insert the $x$-monotone curve
\ccc{c} into the arrangement \ccc{arr}. The third argument
\ccc{pl} is a point-location object attached to the arrangement,
which is used for performing the insertion: It locates both curve
endpoints in the arrangement, where each endpoint is expected to
either coincide with an existing vertex or lie inside a face.
Based on the query results, it is possible to invoke one of the
specialized insertion functions (see
Section~\ref{arr_sec:arr_class}) and insert $c$ at its proper
position.\footnote{The \ccc{insert_non_intersecting()} function,
as all other functions reviewed in this section, is thus a
function template, parameterized by an arrangement class and a
point-location class (a model of the
\ccc{ArrangementPointLocation_2} concept).} The insertion operation
thus requires hardly any geometric operations on top on the ones
needed to answer the point-location queries. Moreover, it is
sufficient that the arrangement class is instantiated with a
traits class that models the \ccc{ArrangementBasicTraits_2}
concept (or the \ccc{ArrangementLandmarkTraits_2} concept, if the
landmarks point-location strategy is used), which does not have to
support the computation of intersection points between curves.

The global function \ccc{insert_non_intersecting(arr, c)} is also
available. Instead of accepting a user-defined point-location
object, it defines a local instance of the walk point-location
class and uses it to insert the curve.

\subsubsection{Inserting $x$-Monotone Curves}
\label{arr_sssec:insert_x_mon}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The \ccc{insert_non_intersecting()} function is indeed very
efficient, but its preconditions on the input curves are still
rather restricting. Let us assume that the arrangement is
instantiated with a traits class that models the refined
\ccc{ArrangementXMonotoneTraits_2} concept and supports
intersection computations (see Section~\ref{arr_sec:traits} for
the exact details). Given an $x$-monotone curve, it is sufficient
to locate its left endpoint in the arrangement and to trace its
{\em zone} --- namely the set of arrangement features it crosses
--- until reaching the right endpoint. Each time the new curve $c$
traverses an existing vertex or an edge we have to split it into
subcurves (in the latter case, we have to split the curve
associated with the existing halfedge as well) and associate new
edges with the resulting subcurves.

The global function \ccc{insert_x_monotone(arr, c, pl)} performs
this insertion operation: It accepts an $x$-monotone curve \ccc{c}
which may intersect the arrangement \ccc{arr} and inserts it into
the arrangement by computing its zone. Users may supply a
point-location object \ccc{pl}, or use the default walk
point-location strategy (namely, the function
\ccc{insert_x_monotone(arr, c)} is also available). The
running-time of this insertion function is proportional to the
complexity of the inserted curve's zone.

\subsubsection{Inserting General Curves}
\label{arr_sssec:insert_gen}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

So far all our examples were of arrangements of line segments,
where the \ccc{Arrangement_2} template was instantiated with the
\ccc{Arr_segment_traits_2} class. In this case, the fact that
\ccc{insert_x_monotone()} accepts an $x$-monotone curve does not
seem to be a restriction, as all line segments are $x$-monotone
(note that we consider vertical line segments to be {\em weakly}
$x$-monotone).

Suppose that we construct an arrangement of circles. A circle is
obviously not $x$-monotone, so we cannot use
\ccc{insert_x_monotone()} in this case.\footnote{Note that a key
operation when inserting an $x$-monotone curve is to locate its
left endpoint in the arrangement. A circle, however, does not have
any endpoints!} However, it is possible to subdivide each circle
into two $x$-monotone circular arcs (its upper half and its lower
half) and to insert each $x$-monotone arc separately.

The global function \ccc{insert()} requires that the traits class
used by the arrangement \ccc{arr} is a model of the concept
\ccc{ArrangementTraits_2}, which refines the
\ccc{ArrangementXMonotoneTraits_2} concept: It has to define an
additional \ccc{Curve_2} type (which may differ from the
\ccc{X_monotone_curve_2} type) and support its subdivision into
$x$-monotone curves (see the exact details in
Section~\ref{arr_sec:traits}). The \ccc{insert(arr, c, pl)}
function performs the insertion of the curve $c$, which need not
be $x$-monotone, into the arrangement by subdividing it into
$x$-monotone subcurves and inserting each one separately. Users
may supply a point-location object \ccc{pl}, or use the default
walk point-location strategy by calling \ccc{insert(arr, c)}.

\subsubsection{Inserting Points}
\label{arr_sssec:insert_point}
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While the arrangement class enables us to insert a point as an
isolated vertex in a given face, the global functions
\ccc{insert_vertex(arr, p, pl)} inserts a vertex to \ccc{arr} that
corresponds to the point \ccc{p} at an arbitrary location. It uses
the point-location object \ccc{pl} to locate the point in the
arrangement (by default, the walk point-location strategy is used)
and acts according to the result:
\begin{itemize}
\item If \ccc{p} is located inside a face, it inserts it as an
isolated vertex inside this face.
\item If \ccc{p} lies on an edge, the edge is split to create a
vertex associated with \ccc{p}.
\item Otherwise, \ccc{p} coincides with an existing vertex and
we are done.
\end{itemize}
In all cases, the function returns a handle to the vertex
associated with \ccc{p}.

As the insertion operation may involve splitting curves, the
arrangement \ccc{arr} should be instantiated with a traits class
that models the \ccc{ArrangementXMonotoneTraits_2} concept.

\subsubsection{An Example}
\label{arr_sssec:insert_ex}
%~~~~~~~~~~~~~~~~~~~~~~~~~~

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_8.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of five intersecting line segments, as
constructed in \ccc{example8.C} and \ccc{example9.C}. The segment
endpoints are marked with dark dots and the arrangement vertices
that correspond to intersection points are marked by white dots.
The query point $q$ is marked with a cross and the face that
contains it is shaded.}
\label{arr_fig:ex_8}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_8.gif"  border=0 alt="The segment arrangement constructed in \ccc{example8.C} and \ccc{example9.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following program constructs an arrangement of intersecting
line segments. We know that $s_1$ and $s_2$ do not intersect, so
we use \ccc{insert_non_intersecting()} to insert them into the
empty arrangement. The rest of the segments are inserted using
\ccc{insert_x_monotone()} or \ccc{insert()}, which are equivalent
in case of line segments. The resulting arrangement consists of
$13$ vertices, $16$ edges and $5$ faces, as can be seen in
Figure~\ref{arr_fig:ex_8}.

In the previous examples, all arrangement vertices corresponded to
segment endpoints. In this case we have additional vertices that
correspond to intersection points between two segments. The
coordinates of these intersection points are rational numbers if
the input coordinates are rational (or integer) --- we therefore
use the \ccc{Quotient<int>} number type to represent the
coordinates:

\ccIncludeExampleCode{../examples/Arrangement_2/example8.C}

\subsection{Aggregated Insertion Functions}
\label{arr_ssec:agg_insert}
%------------------------------------------

Let us assume we have to insert a set of $m$ input curves into an
arrangement. It is possible of course to do this incrementally,
inserting the curves one by one, as shown in the previous section.
However, the arrangement package provides three global functions
\ccc{insert_non_intersecting(arr, begin, end)},
\ccc{insert_x_monotone(arr, begin, end)} and \ccc{insert(arr,
begin, end)} that insert a range of curves, given by the input
iterators \ccc{[begin, end)} into an arrangement \ccc{arr}. The
different functions accept a set of pairwise interior-disjoint
$x$-monotone curves, a set of $x$-monotone curves that may
intersect one another, or a set of general (not necessarily
$x$-monotone) \ccc{Curve_2} objects --- exactly as their
incremental counterparts.

We make a distinction between two cases: (i) The given arrangement
\ccc{arr} is empty (has only an unbounded face), so we have to
construct it from scratch. (ii) We have to insert $m$ input curves
to a non-empty arrangement \ccc{arr}.

In the first case, we have to sweep over the input curves, compute
their intersection points and construct the \dcel\ that represents
their planar arrangement. This process can be performed in
$O\left((m + k)\log m\right)$ time, where $k$ is the total number
of intersection points. The running time is asymptotically better
than the time needed for incremental insertion if the arrangement
is relatively sparse (when $k$ is bounded by $\frac{m^2}{\log
m}$), but in practice it is recommended to use this aggregated
construction process even for dense arrangements, since the
sweep-line algorithm needs less geometric operations compared to
the incremental insertion algorithms.

Another important advantage the aggregated insertion functions
have is that they require no point-location queries, thus no
point-location object needs to be attached to the arrangement. As
explained in Section~\ref{arr_ssec:pl}, there is a tradeoff
between construction time and query time in each of the
point-location strategies, which affects the running times of the
incremental insertion process. This tradeoff plays no role in case
of aggregated insertion.

The following example shows how to construct the arrangement of
line segments depicted in Figure~\ref{arr_fig:ex_8} and built
incrementally in \ccc{example8.C}, as shown in the previous
section. We use the aggregated version of
\ccc{insert_x_monotone()} as we deal with line segments. Note that
no point-location object is defined and attached to the
arrangement:

\ccIncludeExampleCode{../examples/Arrangement_2/example9.C}

In case we have to insert a set of $m$ curves into an existing
arrangement, we should consider the size of the arrangement $n$.
As a rule of thumb, if $m = o(\sqrt{n})$ it is usually more
efficient to insert the curves one by one. For larger input sets,
it is recommended to use the aggregated insertion procedures.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_10.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of eleven intersecting line segments, as
constructed in \ccc{example10.C}. The segments of ${\mathcal S}_1$
are drawn in solid lines and the segments of ${\mathcal S}_2$ are
drawn in dark dashed lines. Note that the segment $s$ (light
dashed line) overlaps one of the ${\mathcal S}_1$ segments.}
\label{arr_fig:ex_10}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_10.gif"  border=0 alt="The segment arrangement constructed in \ccc{example10.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In following example we aggregately construct an arrangement of a
set ${\mathcal S}_1$ containing five line segments, then insert a
single segment incrementally, and finally add a set ${\mathcal
S}_2$ with five more line segments in an aggregated fashion. Note
that the line segments of ${\mathcal S}_1$ are pairwise
interior-disjoint, so we use \ccc{insert_non_intersecting()}.
${\mathcal S}_2$ also contain pairwise interior-disjoint segments,
but as they intersect the existing arrangement, we have to use
\ccc{insert_x_monotone()} to insert them. Also note that the
single segment $s$ we insert incrementally overlaps an existing
arrangement edge:

\ccIncludeExampleCode{../examples/Arrangement_2/example10.C}

The number type used in the example above,
\ccc{Quotient<MP_Float>}, is capable of exactly computing the
intersection points as long as the segment endpoints are given as
floating-point numbers.

\subsection{Removing Vertices and Edges}
\label{arr_ssec:gl_remove}
%---------------------------------------

The two following global functions handle the removal of vertices
and edges from an arrangement. The difference between them and the
member functions of the \ccc{Arrangement_2} template is that they
allow the merger of two curves associated with adjacent edges to
form a single edge. Thus, they require that the traits class that
instantiates the arrangement instance is a model of the refined
\ccc{ArrangementXMonotoneTraits_2} concept (see
Section~\ref{arr_sec:traits}).

The function \ccc{remove_vertex(arr, v)} removes the vertex
\ccc{v} from the given arrangement \ccc{arr}, where \ccc{v} is
either an isolated vertex or is a {\em redundant} vertex ---
namely, it has exactly two incident edges that are associated with
two curves that can be merged to form a single $x$-monotone curve.
If neither of the two cases apply, the function returns an
indication that it has failed to remove the vertex.

The function \ccc{remove_vertex(arr, e)} removes the edge \ccc{e}
from the arrangement by simply calling \ccc{arr.remove_edge(e)}
(see Section~\ref{arr_ssec:modify}). In addition, if either of the
end vertices of \ccc{e} becomes redundant after the removal of the
edge, it is removed as well.

The following example demonstrates the usage of the global removal
functions. In creates an arrangement of four line segment forming
an H-shape with a double horizonal line. Then it removes the two
horizontal edges and clears all redundant vertices, such that the
final arrangement consists of just two edges associated with the
vertical line segments:

\ccIncludeExampleCode{../examples/Arrangement_2/example11.C}

\section{Traits Classes}
\label{arr_sec:traits}
%=======================

As mentioned in the introduction of this chapter, the traits class
encapsulates the definitions of the geometric entities and
implements the geometric predicates and constructions needed by
the \ccc{Arrangement_2} and by its peripheral algorithms. We have
also mentioned throughout the chapter that there are different
levels of requirements from the traits class, namely the traits
class can be a model of different concepts, of different
refinement levels.

A model of the basic concept, \ccc{ArranagementBasicTraits_2},
needs to define the types \ccc{Point_2} and
\ccc{X_monotone_curve_2}, where objects of the first type are
associated with arrangement vertices and objects of the latter
type are associated with edges. In addition, it has to support the
following set of predicates:
\begin{itemize}
\item Compare the $x$-coordinates of two points $p$ and $q$.
\item Compare two points $p$ and $q$ lexicographically, by their
$x$-coordinates then by their $y$-coordinates.
\item Return the left endpoint (similarly, the right endpoint) of
an $x$-monotone curve $c$.
\item Given an $x$-monotone curve $c$ and a point $p$ that lies in its
$x$-range, determine whether $p$ lies below, above or on $c$.
\item Given two $x$-monotone curves $c_1$ and $c_2$ that share a
common left endpoint (similarly, right endpoint) $p$, determine
whether $c_1$ lies above or under $c_2$ immediately to the right
(to the left) of $p$, or whether the two curves coincide there.
\item Check two curves for equality (two curves are equal if their
graph is the same).
\end{itemize}
This basic set of predicates is sufficient for constructing
arrangements of $x$-monotone curves and points that are pairwise
disjoint in their interiors and for performing point-location
queries and vertical ray-shooting queries.

The landmarks point-location strategy (see
Section~\ref{arr_ssec:pl}) needs its associated arrangement to be
instantiated with a model of the refined
\ccc{ArranagementLandmarkTraits_2}. A model of this concept must
define an approximated number type (typically \ccc{double}) and
support the additional operations:
\begin{itemize}
\item Given a point \ccc{p}, approximate the $x$ and $y$-coordinates
of \ccc{p} using the approximated number type.
\item Given two points $p_1$ and $p_2$, construct an $x$-monotone
curve connecting $p_1$ and $p_2$.
\end{itemize}

If the traits class models the \ccc{ArranagementXMonotoneTraits_2}
concept, which refines the \ccc{ArranagementBasicTraits_2}
concept, it has to support the following functions:
\begin{itemize}
\item Compute all intersection points and overlapping sections of
two given $x$-monotone curves. If possible, compute also the
multiplicity of each intersection point.\footnote{If the two
curves intersect at a point $p$ but have different tangents, $p$
is of multiplicity 1. If the tangents are also equal but the their
curvatures are not the same, $p$ is of multiplicity 2, etc.}
Knowing the multiplicity of an intersection point is not required,
but it can speed up the arrangement construction.
\item Split an $x$-monotone curve $c$ into two subcurves at a point
$p$ lying in $c$'s interior.
\item Given two $x$-monotone curve $c_1$ and $c_2$ that share a
common endpoint, determine whether $c_1$ and $c_2$ are {\em
mergeable} --- that is, whether they can be merged to form a
single continuous $x$-monotone curve.
\item Merge two mergeable $x$-monotone curve $c_1$ and $c_2$.
\end{itemize}
Using a model of the \ccc{ArranagementXMonotoneTraits_2}, it is
possible to construct arrangements of sets of $x$-monotone curves
(and points) in general settings.

The refined concept \ccc{ArranagementTraits_2} refines the
\ccc{ArranagementXMonotoneTraits_2} concept by adding the notion
of a general, not necessarily $x$-monotone (and not necessarily
connected) curve. A model of this concept must define the
\ccc{Curve_2} type and support the separation of an curve into a
set of continuous $x$-monotone curves and isolated points. For
example, the curve $C:\ (x^2 + y^2)(x^2 + y^2 - 1) = 0$ is the
unit circle (the loci of all points for which $x^2 + y^2  = 1$)
with the origin $(0,0)$ as a singular point in its interior. $C$
should therefore be separated into two circular arcs (the upper
part and the lower part of the unit circle) and a single isolated
point.

Note that the refined model \ccc{ArranagementTraits_2} is required
only when using the global \ccc{insert()} functions (see
Section~\ref{arr_sec:gl_funcs}), which accept a \ccc{Curve_2}
object (in the incremental version) or a range of \ccc{Curve_2}
objects (in the aggregated version).

In the rest of this section we will review the traits classes
included in the public distribution of \cgal, that handle line
segments, polylines and conic arcs. The last subsection overviews
the meta-traits classes distributed with \cgal.

\subsection{Traits Classes for Line Segments}
\label{arr_ssec:tr_segs}
%-----------------------------------------

The \ccc{Arr_segment_traits_2<Kernel>} class has been used so far
in all example programs in this chapter. It is parameterized by a
geometric kernel and uses the \ccc{Kernel::Point_2} type as it
point type. However, it is important to note that the
\ccc{X_monotone_curve_2} type (and the \ccc{Curve_2} type) is {\em
not} identical to the \ccc{Kernel::Segment_2} type. The reason is
that a kernel segment is typically represented by its two
endpoints, and these may have a complicated representation if the
segment has been intersected and split several times (in
comparison with the representation of its original endpoints), and
this fact may significantly slow down the various traits-class
operations involving such a segment. The
\ccc{Arr_segment_traits_2} therefore represents a segment using
its supporting line and two endpoints, such that most computations
are performed on the supporting line, which never changes as the
segment is split. It also caches some additional information with
the segment to speed up the various predicates.

However, it is important to note that an \ccc{X_monotone_curve_2}
object can be constructed from two endpoints or from a kernel
segment. Moreover, an \ccc{X_monotone_curve_2} instance can also
be casted or assigned to a \ccc{Kernel::Segment_2} object. The two
types are thus fully convertible to one another.

The arrangement package also offers a simpler alternative
segment-traits class. The traits class
\ccc{Arr_non_caching_segment_basic_traits<Kernel>} is a model of
the \ccc{ArrangementBasicTraits_2} concept. It uses
\ccc{Kernel::Point_2} as its point type and
\ccc{Kernel::Segment_2} as its $x$-monotone curve type. As this
traits class does not support intersecting and splitting segments,
the kernel representation is efficient enough. It is still less
efficient than \ccc{Arr_segment_traits_2} for constructing
arrangements of pairwise disjoint line segments, but using this
traits class may be preferable as it reduces the memory
consumption a bit, since no extra data is stored with the line
segments.

The class \ccc{Arr_non_caching_segment_traits<Kernel>} inherits
from \ccc{Arr_non_caching_segment_basic_traits<Kernel>} and
extends it to be a model of the \ccc{ArrangementTraits_2} concept.
It may thus be used to construct arrangement of intersecting line
segments, but as explained above, for efficiency reasons it is
recommended to use it only when the arrangement is very sparse and
contains hardly any intersection points.

\subsection{The Polyline Traits Class}
\label{arr_ssec:tr_polylines}
%-----------------------------------

The \ccc{Arr_polyline_traits_2<SegmentTraits>} class can be used
to maintain arrangements of polylines (a.k.a. poly-segments),
which are continuous piecewise linear curves. A polyline can be
created from any range of points, where the $i$th and $(i+1)$st
points in the range represent the endpoints of the $i$th segment
of the polyline. The polyline traits class is templated with a
segment-traits class that supports the basic operations on
segments.

Polylines are the simplest form of a curves that are not
necessarily $x$-monotone. They can be used to approximate more
complicated curves in a convenient manner, as the algebra needed
to handle them is elementary --- rational arithmetic is sufficient
to construct an arrangement of polylines is an exact and robust
manner. Note, however, that a single polyline can be split to an
unbounded number of $x$-monotone polylines, and that the number of
intersection points (or overlapping sections) between two
polylines is also unbounded.

The polyline-traits class is a model of the
\ccc{ArrangementTraits_2} concept and of the
\ccc{ArrangementLandmarkTraits_2} concept. It inherits its point
type from the segment-traits class, and define the polyline type,
which serves as its \ccc{Curve_2}. Polyline curve objects can be
constructed from any range of points. They also support the
traversal methods \ccc{begin()} and \ccc{end()} which return
\ccc{const_iterator} objects for going over the points defining
the polyline. The nested \ccc{X_monotone_curve_2} type inherits
from \ccc{Curve_2}. The points in an $x$-monotone curve are
always stored by an increasing order of their $x$-coordinates.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_12.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of three polylines, as constructed in
\ccc{example12.C}. Dark dots mark vertices associated with
polyline endpoints while white dots mark vertices that correspond
to intersection points. Note that $\pi_2$ is split into three
$x$-monotone polylines and that $\pi_1$ and $\pi_3$ have two
overlapping sections.}
\label{arr_fig:ex_12}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_12.gif"  border=0 alt="The polyline arrangement constructed in \ccc{example12.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following example program constructs an arrangement of three
polylines, as drawn in Figure~\ref{arr_fig:ex_12}. Note that most
points defining the polylines are not associated with arrangement
vertices:

\ccIncludeExampleCode{../examples/Arrangement_2/example12.C}

\subsection{The Conic Traits Class}
\label{arr_ssec:tr_conic}
%-------------------------------

A {\em conic curve} is an algebraic curve of degree 2, namely it
is the locus of all points $(x,y)$ satisfying the equation $C:\ r
x^2 + s y^2 + t xy + u x + v y + w = 0$, where the six
coefficients $\langle r, s, t, u, v, w \rangle$ completely
characterize the curve. The sign of the expression $\Delta_{C} = 4
r s - t^2$ determines the type of curve:
\begin{itemize}
\item If $\Delta_{C} > 0$ the curve is an ellipse. A circle is a
special case of an ellipse, where $r = s$ and $t = 0$.

\item If $\Delta_{C} = 0$ the curve is a parabola --- an unbounded
conic curve with a single connected branch. When $r = s = t = 0$
we have a line, which can be considered as a type of a degenerate
parabola.

\item If $\Delta_{C} < 0$ the curve is a hyperbola --- that is, it
is comprised of two disconnected unbounded branches.
\end{itemize}

As the arrangement package is suitable for bounded curves, we
consider bounded segments of conic curves, referred to as {\em
conic arcs}. A conic arc $a$ may be either (i) a full ellipse, or
(ii) defined by the tuple $\langle C, p_s, p_t, o \rangle$, where
$C$ is a conic curve and $p_s$ and $p_t$ are two points on $C$
(namely $C(p_s) = C(p_t) = 0$) that define the {\em source} and
{\em target} of the arc, respectively. The arc is formed by
traversing $C$ from the source to the target going in the
orientation specified by $o$, which is typically clockwise or
counterclockwise orientation (but may also be collinear in case of
degenerate conic curves).

We will always assume that the conic coefficients $\langle r, s,
t, u, v, w \rangle$ are rational. When dealing with linear curves
(line segments and polylines), similar assumptions guarantee that
all intersection points also have rational coordinates, such that
the arrangement of such curves can be constructed and maintained
using only rational arithmetic. Unfortunately, this does not hold
for conic curves, as the coordinates of intersection points of two
conic curves with rational coefficients are in general algebraic
numbers of degree $4$.\footnote{Namely, they are roots of
polynomials with integer coefficients of degree $4$. However, in
some special cases, for example when handling only circles and
circular arcs, the coordinates of the intersection points are only
of degree $2$, namely they are solutions of quadratic equations.}
In addition, conic arcs may not necessarily be $x$-monotone, and
must be split at points where the tangent to the arc is vertical.
Such points typically have coordinates that are algebraic numbers
of degree $2$.

It is therefore clear that we have to use different number types
to represent the conic coefficients and the point coordinates.
Note that as arrangement vertices induced by intersection points
and points with vertical tangents are likely to have algebraic
coordinates, we also let the original endpoints of the input arcs
$p_s$ and $p_t$ have algebraic coordinates.

The \ccc{Arr_conic_traits_2<RatKernel, AlgKernel, NtTraits>} class
template is designed for efficient handling of arrangements of
bounded conic arcs. The template has three parameters, defined as
follows:
\begin{itemize}
\item The \ccc{RatKernel} class is a geometric kernel whose field
type is an exact rational type. It is used to define basic
geometric entities (e.g., a line segment or a circle) with rational
coefficients. Typically we use one of the standard \cgal\ kernels,
instantiated with the number type \ccc{NtTraits::Rational} (see
below).

\item The \ccc{AlgKernel} class is a geometric kernel whose field
type is an exact algebraic type. It is used to define points with
algebraic coordinates. Typically we use one of the standard
\cgal\ kernels, instantiated with the number type
\ccc{NtTraits::Algebraic} (see below).

\item The \ccc{NtTraits} class (the number-type traits class)
encapsulates all the numeric operations needed for performing the
geometric computation carried out by the geometric traits class.
It defines the \ccc{Integer}, \ccc{Rational} and \ccc{Algebraic}
number-types, and supports several operations on these types, such
as conversion between number types, solving quadratic equations
and extracting the real roots of a polynomial with integer
coefficients. It is highly recommended to use the
\ccc{CORE_algebraic_number_traits} class, which is included in the
arrangement package. It relies on the exact number types
implemented in the {\sc Core} library and performs exact
computations on the number types it defines.
\end{itemize}

The \ccc{Arr_conic_traits_2} is a model of the
\ccc{ArrangementTraits_2} concept and of the the
\ccc{ArrangementLandmarkTraits_2} concept (that is, it supports
the landmarks point-location strategy). Its \ccc{Point_2} type is
derived from \ccc{AlgKernel::Point_2}, while the \ccc{Curve_2}
type represents a bounded, not necessarily $x$-monotone conic arc.
The \ccc{X_monotone_curve_2} type is derived from \ccc{Curve_2},
but its constructors are to be used only by the traits class.
Users should therefore construct only \ccc{Curve_2} objects and
insert them into the arrangement using the \ccc{insert()}
functions.

Conic arcs can be constructed from full ellipses or by specifying
a supporting curve, two endpoints and an orientation. However,
several constructors of \ccc{Curve_2} are available to allow some
special cases, such as circular arcs or line segments. The
\ccc{Curve_2} (and the derived \ccc{X_monotone_curve_2}) classes
also support basic accessor functions such as \ccc{source()},
\ccc{target()} and \ccc{orientation()}.

\subsubsection{Examples}
%~~~~~~~~~~~~~~~~~~~~~~~

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_13.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of three circles, as constructed in
\ccc{example13.C}. Each circle is split into two $x$-monotone
circular arcs, whose endpoints are drawn as dark dots. White dots
mark vertices that correspond to intersection points. The vertex
$v_{\rm max}$ is a common intersection point of all three
circles.}
\label{arr_fig:ex_13}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_13.gif"  border=0 alt="The circle arrangement constructed in \ccc{example13.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the following example we construct an arrangement of three full
circles, as shown in Figure~\ref{arr_fig:ex_13}. We then look for
the vertex of maximal degree, which is the vertex associated with
the point $(4,3)$, as all three circles intersect at this point
and it has six incident edges:

\ccIncludeExampleCode{../examples/Arrangement_2/example13.C}

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_14.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of mixed conic arcs, as constructed in
\ccc{example14.C}.}
\label{arr_fig:ex_14}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_14.gif"  border=0 alt="The conic arc arrangement constructed in \ccc{example14.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following example demonstrates the usage of the various
constructors for conic arcs. The resulting arrangement is drawn in
Figure~\ref{arr_fig:ex_14}. Especially note the constructor of a
circular arc that accepts three points and the constructor that
allows specifying endpoints as intersections of the supporting
conic with two other conic curves. Note that as the preconditions
required by some of these constructors are rather complicated (see
the reference manual for the details), a precondition violation
does not cause the program to terminate --- instead, an {\em
invalid} arc is created. We can verify the validity of an arc by
using the \ccc{is_valid()} method. Needless to say, inserting
invalid arcs into an arrangement is not allowed.

\ccIncludeExampleCode{../examples/Arrangement_2/example14.C}

The last example in this section demonstrates how the conic-traits
class can handle intersection points with multiplicity. The
supporting curves of the two arcs, a circle centered at
$(0,\frac{1}{2})$ with radius $\frac{1}{2}$, and the hyperbola $y
= \frac{x^2}{1-x}$,\footnote{This curve can be also written as $C:
x^2 + xy - y = 0$. It is a hyperbola since $\Delta_{C} = -1$.}
intersect at the origin such that the intersection point has
multiplicity $3$ (note that they both have the same horizontal
tangent at $(0,0)$ and the same curvature $1$). In addition, they
have another intersection point at $(\frac{1}{2},\frac{1}{2})$ of
multiplicity $1$:

\ccIncludeExampleCode{../examples/Arrangement_2/example15.C}

\subsection{Traits Class for Arcs of Rational Functions}
\label{arr_ssec:tr_ratfunc}
%-------------------------------------------------------

A {\em rational function} is given by the equation $y =
\frac{P(x)}{Q(x)}$, where $P$ and $Q$ are polynomials of arbitrary
degrees. In particular, if $Q(x) = 1$ then the function is a
simple polynomial function. A bounded {\em rational arc} is
defined by the graph of a rational function over some internal
$[x_{\rm min}, x_{\rm max}]$, where $Q$ does not have any real
roots in this interval (thus the arc does not contain any poles).
Rational functions, and polynomial functions in particular, are
not only interesting in their own right, they are also very useful
for approximating or interpolating more complicated curves ---
see, e.g.,~\cite[Chapeter~3]{ptvf-nrcpp-02}.

In order to allow robust and exact computations with rational
arcs, we require that the coefficient of the polynomials $P$ and
$Q$ are rational numbers. The $x$-values that determine the
interval over which the arc is defined can however be arbitrary
algebraic numbers.

Using the \ccc{Arr_rational_traits_2<AlgKernel, NtTraits>} class
template it is possible to construct and maintain arrangement of
rational arcs. The template parameters are very similar to the
ones used by the \ccc{Arr_conic_traits_2} class template --- see
the previous section. However, no rational kernel is needed. Also
in this case it is recommended to use the
\ccc{CORE_algebraic_number_traits} class, with a kernel templated
by its \ccc{Algebraic} type.

The \ccc{Arr_rational_traits_2} is a model of the
\ccc{ArrangementTraits_2} concept (but not of the
\ccc{ArrangementLandmarkTraits_2} concept, so it is not possible
to use the landmarks point-location strategy for arrangements of
rational arcs). Its \ccc{Point_2} type is derived from
\ccc{AlgKernel::Point_2}, while the \ccc{Curve_2} and
\ccc{X_monotone_curve_2} types refer to the same class (note that
a rational arc is always $x$-monotone). The traits class also
defined the \ccc{Rat_vector} type, representing a vector of
rational coefficients (whose type is \ccc{NtTraits::Rational}). A
rational arc can be constructed from a single vector of
coefficients, specifying the polynomial $P$ alone (and $Q(x) =
1$), or from two vectors of coefficients, specifying both $P$ and
$Q$.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_16.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of four arcs of rational functions, as
constructed in \ccc{example16.C}.}
\label{arr_fig:ex_16}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_16.gif"  border=0 alt="The rational arc arrangement constructed in \ccc{example16.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following example demonstrates the construction of an
arrangement of rational arcs depicted in
Figure~\ref{arr_fig:ex_16}. Note the usage of the two
constructors, for polynomial arcs and for rational arcs:

\ccIncludeExampleCode{../examples/Arrangement_2/example16.C}

\subsection{Meta-Traits Classes}
\label{arr_ssec:meta_tr}
%-------------------------------

Meta-traits classes serve as {\em decorators} of other geometric
traits classes. They allow attaching user-defined data to curves
(and to points), and automatically manipulate this data,
distributing it to the geometric entities that are constructed. We
note that additional information can also be maintained by
extending the vertex, halfedge, or face types provided of the
\dcel\ class used by the arrangement --- see the details in
Section~\ref{arr_sec:ex_dcel}.

The two meta-traits classes
\ccc{Arr_consolidated_curve_data_traits_2<BaseTraits, Data>} and
the \ccc{Arr_merged_curve_data_traits_2<BaseTraits, Data,
MergeFunc>} are used to attach a data field to curves. Both
classes are templated by a base-traits class, which is one of the
geometric traits classes described in the previous subsections, or
a user-defined traits class. The meta-traits classes derive
themselves from the base-traits class and in particular inherits
it \ccc{Point_2} type. In addition:
\begin{itemize}
\item \ccc{Cruve_2} is derived from the basic \ccc{BaseTraits::Curve_2}
class, adding an extra field of type \ccc{Data} to it.

\item \ccc{X_monotone_cruve_2} is derived from the basic
\ccc{BaseTraits::X_monotone_cruve_2} class, adding a container of
\ccc{Data} objects in case of the consolidated curve-data traits
class, or a single field of type \ccc{Data} in case of the merged
curve-data traits class.
\end{itemize}
Note that the \ccc{Cruve_2} and \ccc{X_monotone_cruve_2} are not
the same, even if the \ccc{BaseTraits::Curve_2} and
\ccc{BaseTraits::X_monotone_cruve_2} are identical (e.g., in case
of the segment-traits class). The extended curve types support the
additional methods \ccc{get_data()} and \ccc{set_data()} for
accessing and modifying the data field. In case of multiple data
fields, the functions \ccc{data_begin()} and \ccc{data_end()}
return \ccc{Data_iterator} objects for accessing the data fields,
while \ccc{add_data()} and \ccc{clear_data()} can be used to
manipulate the data fields.

Users can create an extended curve (or an extended $x$-monotone
curve) from a basic curve and a data object. When curves are
inserted into an arrangement, they may be split, and the
meta-traits class handles their data fields automatically:
\begin{itemize}
\item When a curve is subdivided into $x$-monotone subcurves, its
data field is automatically copied to each of the resulting
subcurves.

\item When an $x$-monotone curve is split into two, the meta-traits
class automatically copies its data field(s) to both resulting
subcurves.

\item When intersecting two $x$-monotone curves $c_1$ and $c_2$, the
result may include overlapping sections, represented as
$x$-monotone curves. The only difference between the two
curve-data traits classes is the way they handle these overlapping
curves:
\begin{itemize}
\item \ccc{Arr_consolidated_curve_data_traits_2} simply associates the
overlapping curves with a container of data objects which
consolidates the data fields stored in $c_1$ and $c_2$.

\item \ccc{Arr_merged_curve_data_traits_2} takes the two data fields of
$c_1$ and $c_2$ and merges them into a single \ccc{Data} object,
using the \ccc{MergeFunc} functor, which is supplied as a
parameter to the traits class-template. The resulting object is
assigned to the data field of the overlapping subcurves.
\end{itemize}

\item Merging two $x$-monotone curves is allowed only if they are
geometrically mergeable (that is, the base-traits class allows to merge
them) and store the same data field(s).
\end{itemize}

\subsubsection{Examples}
%~~~~~~~~~~~~~~~~~~~~~~~

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_17.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of six red and blue segments, as
constructed in \ccc{example17.C}. Dark dots correspond to
red--blue intersection points, while white dots mark the endpoints
of red--blue overlaps.}
\label{arr_fig:ex_17}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_17.gif"  border=0 alt="The red-blue segment arrangement constructed in \ccc{example17.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the following example, we use \ccc{Arr_segment_traits_2} as our
base-traits class, attaching an additional {\em color} field to
the segments using the consolidated curve-data traits class. A
color may be either {\em blue} or {\em red}. Having constructed
the arrangement of colored segments, as illustrated in
Figure~\ref{arr_fig:ex_17}, we detect the vertices that have both
incident blue edges and incident red edges, thus they correspond
to red--blue intersection points. We also locate the edge that
corresponds to overlaps between red and blue line segments:

\ccIncludeExampleCode{../examples/Arrangement_2/example17.C}

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_18.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of four polylines, named A--D, as
constructed in \ccc{example18.C}.}
\label{arr_fig:ex_18}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_18.gif"  border=0 alt="The polyline arrangement constructed in \ccc{example18.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the following example, we use \ccc{Arr_polyline_traits_2} as
our base-traits class, attaching an additional {\em name} field to
each polyline using the merged curve-data traits class. In case of
overlaps, we simply concatenate the names of the overlapping
polylines. Also notice how we replace the curve associated with
the edges that correspond to overlapping polylines with 
geometrically equivalent curves, but with a different data fields:

\ccIncludeExampleCode{../examples/Arrangement_2/example18.C}

\section{The Notification Mechanism}
\label{arr_sec:notif}
%===================================

It is highly important for some applications to know exactly what
happens inside a specific arrangement instance. For example, when
we insert a new curve into an arrangement we may want to keep
track of the faces that are split due to this insertion operation.
Another important example are the point-location strategies that
require auxiliary data structures (see Section~\ref{arr_ssec:pl}),
which must be notified on various local changes in the arrangement
in order to keep their data structures up-to-date. The arrangement
package offers a mechanism that uses {\em observers} that can be
attached to an arrangement instance and receive notifications
about the changes this arrangement goes through.

The \ccc{Arr_observer<Arrangement>} class-template is
parameterized with an arrangement class. It stores a pointer to an
arrangement object, and is capable of receiving notifications {\em
just before} a structural change occurs in the arrangement and
{\em immediately after} such a change takes place.
\ccc{Arr_observer} serves as a base class for other observer
classes and defines a set of virtual notification functions,
giving them all a default empty implementation.

The set of functions can be divided into three categories, as
follows:
\begin{enumerate}
\item Notifiers of changes that affect the entire topological structure
of the arrangement. This category consists of two pairs that
notify the observer of the following changes:
\begin{itemize}
\item The arrangement is cleared.
\item The arrangement is assigned with the contents of another
arrangement.
\end{itemize}
\item Pairs of notifiers of a local change that occurs in the
topological structure. Most notifier functions belong to this
category, were the relevant local changes include:
\begin{itemize}
\item A new vertex is constructed and associated with a point.
\item A edge\footnote{The term ``edge'' refers to a pair of twin
half-edges.} is constructed and associated with an $x$-monotone
curve.
\item An edge is split into two.
\item An existing face is split into two, following the insertion of a
new edge.
\item A hole is created in the interior of a face.
\item Two holes are merged to form a single hole, following the
insertion of a new edge.
\item A hole is moved from one face to another (following a face split).
\item Two edges are merged into one.
\item Two faces are merged into one, following the deletion of an edge
that used to separate them.
\item One hole is split into two, following the deletion of an edge that
used to connect the two components.
\item A vertex is deleted.
\item An edge is deleted.
\item A hole is deleted from the interior of a face.
\end{itemize}
\item Notifiers about a global change initiated by a global function.
This category consists of a single pair of notifiers, neither of
them is called by methods of the \ccc{Arrangement_2} class, but
are invoked by the global functions themselves. It is implied that
no point-location queries (or any other queries for that matter)
are issued between the calls to the \ccc{before_global_change()}
and \ccc{after_global_change()} notification functions.
\end{enumerate}
See the reference manual for a detailed specification of the
\ccc{Arr_observer} class, along with the exact prototypes of all
notification functions.

Each arrangement object stores a list of pointers to
\ccc{Arr_observer} objects, and whenever one of the structural
changes listed in the first two categories above is about to take
place, the arrangement object performs a {\em forward} traversal
of this list and invokes the appropriate function of each
observer. After the change takes place the observer list is
traversed in a {\em backward} manner (from tail to head) and the
appropriate notification function is invoked for each observer.
This allows the nesting of observer objects.

Concrete arrangement-observer classes should inherit from
\ccc{Arr_observer}. A pointer to a valid arrangement object should
be supplied at the observer construction, or alternatively the
observer can be attached to a valid arrangement at a later time.
When this happens, the observer instance adds itself to the
observer list of the associated arrangement and starts receiving
notifications whenever the this arrangement changes. Naturally,
the observer object unregisters itself by removing itself from
this list just before it is destroyed.

The trapezoidal RIC and the landmarks point-location strategies
both use observer to keep their auxiliary data structures
up-to-date. Besides them, users can define their own observer
classes, by inheriting from the base observer class and overriding
the relevant notification functions, as required by their
applications.

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_19.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of five line segments, as constructed in
\ccc{example19.C}. The halfedge $e_v$ (dashed) is eventually
removed, so that the final arrangement consists of four faces (one
unbounded and three bounded ones).}
\label{arr_fig:ex_19}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_19.gif"  border=0 alt="The segment arrangement constructed in \ccc{example19.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The following example shows how to define and use an observer
class. In this case, the observer keeps track of the arrangement
faces, and prints a message whenever a face is split into two due
to the insertion of an edge, and whenever two faces merge into one
due to the deletion of an edge. The layout of the arrangement is
depicted in Figure~\ref{arr_fig:ex_19}:

\ccIncludeExampleCode{../examples/Arrangement_2/example19.C}

Observers are especially useful when the \dcel\ records are
extended and store additional data, as they help updating this
data on-line. See Section~\ref{arr_sec:ex_dcel} for more details
and examples.

\section{Extending the \dcel}
\label{arr_sec:ex_dcel}
%============================

For many applications of the arrangement package it is necessary to
store additional information (perhaps of non-geometric nature) with
the arrangement cells. As vertices are associated with \ccc{Point_2}
objects and edges (halfedge pairs) are associated with
\ccc{X_monotone_curve_2} objects, both defined by the traits class,
it is possible to extend the traits-class type by using a meta-traits
class, as explained in Section~\label{arr_ssec:meta_tr}, which may
be a sufficient solution for some applications.

However, the \dcel\ faces are not associated with any object, so it
is impossible to extend them using a meta-traits class. The only
solution in this case is to extend the \dcel\ face records. We also
give users the ability to conveniently extend all \dcel\ records
(namely vertices, halfedges and faces), which can also be advantageous
for some applications.

So far we have used the default \ccc{Arr_default_dcel<Traits>} class
in all examples. This was done implicitly, as this class serves as
a default parameter for the \ccc{Arrabgement_2} template. The default
\dcel\ class just associates points with vertices and $x$-monotone
curves with halfedge, but nothing more. In this section we show
how to use alternative \dcel\ templates to easily extend the desired
\dcel\ records.

\subsection{Extending the \dcel\ Faces}
\label{arr_ssec:ex_dcel_face}
%--------------------------------------

The \ccc{Arr_face_extended_dcel<Traits, FaceData>} class-template
is used to associate auxiliray data field of type \ccc{FaceData} to
each data record in the \dcel.

When an \ccc{Arrangement_2} object is parameterized by this \dcel\
class, its nested \ccc{Face} type is extended by the access function
\ccc{data()} and by the modifier \ccc{set_data()}. Using these extra
functions it is straightforward to access and maintain the auxiliary
face-data field.

Note that the extra data fields must be maintained by the application
programmers. They may choose to may construct their arrangement, and
only then go over the faces and attach the appropriate data fields to
the arrangement faces. However, in some cases the face data can only
by computed when the face is created (split from another face, or merged
with another face). In such cases one can use an arrangement observer
tailored for this task, which recieves updates whenever a face is
modified and sets its data field accordingly. 

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_20.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{An arrangement of six line segments, as constructed in
\ccc{example20.C} and \ccc{example21.C} (in \ccc{example21.C} we treat
the segments as directed, so they are drawn as arrows directed from the
source to the target). The indices associated with the halfegdes in
\ccc{example20.C} are shown in brackets.}
\label{arr_fig:ex_20}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_20.gif"  border=0 alt="The segment arrangement constructed in \ccc{example20.C} and \ccc{example21.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

In the next example we construct an arrangement of size line segements
that contains seven bounded faces (see Figure~\ref{arr_fig:ex_20}). We
use an observer that gets notified each time a new face is created and
associates it with a running index (where the index of the unbounded face
is 0). As a result, the faces are numbered according to their creation
order, as one can easily verify by examining the order of the inserted
segments:\footnote{For simplicity, we make a precondition that the
observer is always attached to an empty arrangement. It is not difficult
however to modify the program to handle the general case.}

\ccIncludeExampleCode{../examples/Arrangement_2/example20.C}

\subsection{Extending All \dcel\ Records}
\label{arr_ssec:ex_dcel_all}
%----------------------------------------

The
\ccc{Arr_extended_dcel<Traits, VertexData, HalfedgeData, FaceData>}
class-template is used to associate auxiliray data fields for of
types \ccc{VertexData} \ccc{HalfedgeData} and \ccc{FaceData} to
each \dcel\ vertex, halfedge and face record, respectively.

When an \ccc{Arrangement_2} object is parameterized by this
\dcel\ class, each one of its nested \ccc{Vertex}, \ccc{Halfedge} and
\ccc{Face} classes is extended by the access function \ccc{data()}
and by the modifier \ccc{set_data()}.

The next example shows how to use a \dcel\ with extended vertex,
halfedge and face records. In this example we associate each vertex
with a color, which may be blue, red or white, depending whether the
vertex is isolated, represents a segment endpoint or whether it
represents an intersection point. Each halfedge is associated with
Boolean flag inidcating whether its direction is the same as the
direction of its associated segment (in this example we treat our
segments as directed objects). We also extend each face to store the
size of its outer boundary.

We construct the same arrangement as in the previous example,
depicted in Figure~\ref{arr_fig:ex_20}. Note that here we set values
to all auxiliary data fields once the arrangement has been constructed.
Also note that the data fields are properly maintained when the arrangement
is copied to another arrangement instance:
 
\ccIncludeExampleCode{../examples/Arrangement_2/example21.C}

\section{Overlaying Arrangements}
\label{arr_sec:overlay}
%================================

Assume that we are given two geographic maps, represented as
arrangements with some data objects attached to their faces,
representing some geographic information --- for example, a map of
the annual precipitation in some country and a map of the vegetation
in the same country. It is interesting to overlay the two maps to
locate, for example, the regions where there is a pine forest and
the annual precipitation is between 1000\,mm and 1500\,mm. Computing
the overlay of two planar arrangement is also useful for supporting
Boolean operations on polygons (or generalized polygons,
see~\cite{behsms-cbcab-02}).

The function \ccc{overlay (arr1, arr2, ovl_arr, ovl_traits)} accepts
two input arrangement instances \ccc{arr1} and \ccc{arr2}, and constructs
their overlay instance \ccc{ovl_arr}. All three arrangements must use the
same geometric primitives, namely they should be instances of the
arrangement classes that are all instantiated using the same geometric
traits class. Let us assume that \ccc{arr1} is of type
\ccc{Arrangement_2<Traits,Dcel1>}, \ccc{arr2} is of type
\ccc{Arrangement_2<Traits,Dcel2>} and \ccc{ovl_arr} is of type 
\ccc{Arrangement_2<Traits,ResDcel>}. The \ccc{ovl_traits} parameter is
an instance of an {\em overlay traits-class}, which enables the creation of
\ccc{ResDcel} records in the overlaid arrangement from the \dcel\ features
of \ccc{arr1} and \ccc{arr2} that they correspond to.

In principle, we distinguish among three levels of overlay:
\begin{description}
\item[Simple overlay:]
We compute the overlay of two arrangements that store no additional data
with their \dcel\ records --- that is, they are instantiated using the
default \dcel\ class \ccc{Arr_default_dcel}. Typically, the overlaid
arrangement in this case stores no extra data with its \dcel\ records as
well (or if it does, the additional data fields cannot be computed by
the overlay operation), so by overlaying the two arrangement we just
compute the arrangement of all curves that induce \ccc{arr1} and \ccc{arr2}.
We note that the same result can be obtained using the normal insertion
operations, but users may choose to use overlay computation in order to
achieve better running time.

The \ccc{Arr_default_overlay_traits} class should be used as an overlay
traits-class for such simple overlay operations.

\item[Face overlay:]
We compute the overlay of two arrangements that store additional data
fields with their faces (consider, for example, the geographic-map example
given in the beginning of this section). The resulting overlaid arrangement
will typically also store extraneous data fields with its faces, where the
data field that is attached to an overlaid face can be computed from the
data fields of the two faces (in \ccc{arr1} and \ccc{arr2}) that induce
the overlaid face.

The \ccc{Arr_face_overlay_traits} class should be used as an overlay
traits-class for face-overlay operations. It operates on arrangement whose
\dcel\ representation is based on the \ccc{Arr_face_extended_dcel}
class-template (see Section~\ref{arr_ssec:ex_dcel_face}). The face-overlay
traits-class is templated with a functor that is capable of combining two
face-data fields, of types \ccc{Dcel1::Face_data} and
\ccc{Dcel2::Face_data}, and computing the output \ccc{RedDcel::Face_data}
object. The overlay traits-class uses this function to properly construct
the overlaid faces.

\item[Full overlay:]
We compute the overlay of two arrangements that store additional data
fields with all their \dcel\ records --- that is, their \dcel\ classes
are instantiations of the \ccc{Arr_extended_dcel} class-template (see
Section~\ref{arr_ssec:ex_dcel_all}) --- where the resulting arrangement
also extends it \dcel\ records with data fields computed on the basis
of the overlapping \dcel\ features of the two input arrangements.
\end{description}

In the following subsections we give some example for the simple and the
face-overlay operations and demonstrate how to use the auxiliary overlay
traits-classes. For the full overlay operations users need to implement
their specialized overlay traits-class, which models the \ccc{OverlayTraits}
concept. The details of this concept are given in the reference manual.

\subsection{Example for a Simple Overlay}
\label{arr_ssec:simp_ovl}
%----------------------------------------

\begin{figure}[t]
\begin{ccTexOnly}
\begin{center}
\input{Arrangement_2/ex_22.pstex_t}
\end{center}
\end{ccTexOnly}
\caption{Overlaying two simple arrangements of line segments, as done
in \ccc{example22.C} and \ccc{example23.C}. In \ccc{example23.C} we 
the two bounded faces as {\em marked}, were the intersection of the two
marked faces is denoted as $\hat{f}$.}
\label{arr_fig:ex_22}
%\begin{ccHtmlOnly}
%<P>
%<center>
%  <img src="ex_22.gif"  border=0 alt="The arrangement overlay computed in \ccc{example22.C} and \ccc{example23.C}.">
%</center>
%\end{ccHtmlOnly}
\end{figure}

The next program constructs two simple arrangements, as illustrated in
Figure~\ref{arr_fig:ex_22} and computes their overlay:

\ccIncludeExampleCode{../examples/Arrangement_2/example22.C}

\subsection{Example for a Face Overlay}
\label{arr_ssec:face_ovl}
%--------------------------------------

The following example shows how to compute the intersection of two polygons
using the \ccc{overlay()} function. We use a face-extended \dcel\ class
extended with a Boolean flag to instantiate our arrangement class,
where a polygon is represented as a {\sl marked} arrangement face (whose
flag is set). We use a face-overlay traits class, templated with a functor
that simply performs a logical {\em and} operations on Boolean flags.
As a result, a face in the overlaid arrangement is marked only when it
corresponds to an overlapping region between two marked cells in the input
arrangements (namely it is part of the intersection of the two polygon).

In this example we intersect a square and a rhombus (which actually also
a square), so the resulting polygon is an octagon, represented by the shape
$\hat{f}$ in Figure~\ref{arr_fig:ex_22}:

\ccIncludeExampleCode{../examples/Arrangement_2/example23.C}

\section{Storing the Curve History}
\label{arr_sec:arr_with_hist}
%==================================

\section{Adapting to {\sc Boost} Graphs}
\label{arr_sec:bgl}
%=======================================

\section*{Design and Implementation History}
%===========================================

The code of this package is the result of a long development process.
Initially (and until version~3.1), the code was spread among several
packages, namely \ccc{Topological_map}, \ccc{Planar_map_2},
\ccc{Planar_map_with_intersections_2} and \ccc{Arrangement_2}, that were
developed by~: \newline
Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo Hanniel, Idit Haran,
Sariel Har-Peled, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan, Ron Wein,
Baruch Zukerman and Tali Zvi.

In version~3.2, as part of the ACS project, the packages have done through
a major re-design, resulting in an improved \ccc{Arrangement_2} package.
The code of the new package was restructured and developed by~: \newline
Efi Fogel, Idit Haran, Ron Wein and Baruch Zukerman.

%@incollection{h-a-04
%, author = "Dan Halperin"
%, title = "Arrangements"
%, chapter = 24
%, editor = "Jacob E. Goodman and Joseph O'Rourke"
%, booktitle = "Handbook of Discrete and Computational Geometry"
%, publisher = "Chapman \& Hall/CRC"
%, edition = "2nd"
%, year = 2004
%, pages = "529--562"
%}

%@book{ptvf-nrcpp-02
%, author =	"W. Press and S. Teukolsky and W. Vetterling and B. Flannery"
%, title =	"Numerical Recipes in {C}{\tt ++}"
%, edition =	"2nd"
%, publisher =	"Cambridge University Press"
%, year =	2002
%}
