% begin cgal manual page

\begin{ccRefClass}{Hash_map<D,E,I>}\ccCreationVariable{M}

\ccDefinition

An instance \ccc{M} of the parameterized data type
\ccc{Hash_map<D,E,I>} is an injective mapping from the set of indexed objects of
type \ccc{D}, called the domain type of \ccc{M}, to the set of variables
of data type \ccc{E}, called the element type of \ccc{M}.

An object \ccc{i} of the index data type \ccc{I} delivers a unique integer
index \ccc{i(d)} for objects $d \in D$.

We use \ccc{M(d)} to denote the variable associated to \ccc{d}. All variables
are initialized to \ccc{default_element}, an element of \ccc{E} that is
specified in the definition of \ccc{M}. A subset of \ccc{D} is designated as
the domain of \ccc{M}. Elements are added to \ccc{dom(M)} by the array
operator; however, the domain may also contain indices for which the
access operator was never executed.

There's one default index schemes already defined: \ccc{Handle_index}.  It
allows to index all handles, iterators and circulators.  Thus
\ccc{Hash_map<D,E>} can be used for any handle or iterator type \ccc{D} (handles
are static iterators). 



\ccSetOneOfTwoColumns{5cm}

\ccTypes

\ccNestedType{item}{the item type. 
}

\ccNestedType{domain_type}{the domain type. 
}

\ccNestedType{element_type}{the element type. 
}

\ccNestedType{index_type}{the index type. 
}

\ccNestedType{element_iterator}{a forward iterator over all element entries. 
}

\ccSetOneOfTwoColumns{4cm}

\ccCreation

\ccConstructor{Hash_map<D,E,I>()}{creates an injective function $m$ from $D$ to the set of unused
variables of type $E$, sets \ccc{default_value} to the default value of type \ccc{E}
(if \ccc{E} has no default value then \ccc{default_value} is set to an unspecified
element of \ccc{E}), and initializes $M$ with $m$. 
}

\ccConstructor{Hash_map<D,E,I>(E def)}{creates an injective function $m$ from $D$ to the set of unused
variables of type $E$, sets \ccc{default_value} to \ccc{def}, and initializes $M$ with
$m$. 
}

\ccSetTwoOfThreeColumns{2cm}{4.5cm}

\ccOperations

\ccMethod{void clear() ;}{makes \ccc{M} empty. 
}

\ccMethod{void clear(const E& def) ;}{makes \ccc{M} empty and sets \ccc{default_value} to \ccc{x}.  
}

\ccMethod{bool is_defined(const D& d) ;}{returns true if $d \in \ccc{dom(M)}$. 
}

\ccMethod{E& operator[](const D& d) ;}{returns the variable $M(d)$ and adds $d$ to \ccc{dom(M)}. If \ccc{M}
is a const-object then \ccc{M(d)} is read-only and $d$ is not added to 
\ccc{dom(M)}. 
}

\ccMethod{element_iterator begin()  ;}{returns the element iterator pointing to the first element 
stored. 
}

\ccMethod{element_iterator end()  ;}{returns the element iterator pointing beyond the last element 
stored. 
}

\ccImplementation

\ccc{Hash_maps} are implemented via chained hashing
scheme. Access operations \ccc{M[i]} take expected time $O(1)$. 
The design was derived from the LEDA type map.  



\end{ccRefClass}


