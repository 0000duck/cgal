\begin{ccRefClass}{Delaunay_mesh_2<CDT>}

The class \ccRefName{} derives from
\ccc{Conforming_Delaunay_triangulation_2<CDT>}. The template parameter
\ccc{CDT} has to be a \cgal\ constrained Delaunay triangulation and its
geometric traits class must be a model of the concept
\ccc{DelaunayMeshTraits_2}. This traits class provides not only
constructors and predicates needed by the mesh algorithm, but also defines
the shape and size criteria on the triangles of the mesh.

A \ccRefName{} object is a \ccc{CDT} CDT, in which one can insert points
and constrained segments and every \ccc{CDT}'s availlable operations. After
a call to one of meshing methods, the CDT is meshed according to the
criteria defined in the traits class.

Before the first call to a meshing method, one can insert points and
constrained segments in the \ccRefName{} object, like in a CDT. Meshing
methods will mesh the CDT by refining triangles that are in the default
domain or the domain defined by the seeds. The refinement process needs to
know which faces have to be refined, that's why the base face of the
triangulation \ccc{CDT} has to be a model of the concept
\ccc{MeshFaceBase_2}.

Once a meshing method is called, the CDT is meshed according to
criteria on shape and size defined in the traits. If points or
constrained segments are inserted again in the CDT, the criterias are
no longer garanted.

\todo{Je dois copier-coller la d\'efinition des domaines, et des crit\`eres?}

\ccInclude{CGAL/Delaunay_mesh_2.h}

\ccInheritsFrom

\ccc{Conforming_Delaunay_triangulation_2<CDT>}

\ccParameters

\ccc{CDT} must be a \cgal\ constrained Delaunay triangulation.

\ccTypes 
\ccTypedef{typedef CDT Triangulation;}{the triangulation base class.}
\ccTypedef{typedef CDT::Geom_traits Geom_traits;}{the geometric traits class.}
\ccTypedef{typedef Conforming_Delaunay_triangulation_2<CDT> Conform;}{the
  conforming triangulation base class.}
\ccNestedType{Seeds_iterator}{const iterator over defined seeds. Its
  value type is \ccc{Geom_traits::Point_2}}

\ccCreation
\ccCreationVariable{mesh}

\ccConstructor{Delaunay_mesh_2(const Geom_traits& gt = Geom_traits());}
{Introduces an empty mesh \ccVar.}

\ccMethod{void clear();}{ Deletes all faces and finite vertices
  resulting in an empty triangulation. Internal data structures are
  cleared too. }

\ccHeading{Seeds functions}

The following functions are used to define seeds.

\ccMethod{void  clear_seeds ();}{ Sets seeds to the empty set. All
  finite connected components of the constrained triangulation will be 
  refined.}

\ccMethod{template<class InputIterator>
          void set_seeds(InputIterator begin, InputIterator end,
                         const bool mark=false);}
{ Sets seeds to the sequence [\ccc{begin}, \ccc{end}]. This defines
  conmnected components of the constrained triangulation that will be
  refined (if \ccc{mark=true}) or not refined (if \ccc{mark=false}).
  \ccPrecond The \ccc{value_type} of \ccc{begin} and \ccc{end}
  is \ccc{Geom_traits::Point_2}.}

These ones give the sequences of seeds.

\ccMethod{Seeds_const_iterator  seeds_begin () const;}
{ Start of the seeds sequence. }
\ccGlue
\ccMethod{Seeds_const_iterator  seeds_end () const;}
{ Past the end of the seeds sequence. }

\ccHeading{Meshing methods}

The following method should be called after all points and constrained
segments are inserted in the CDT. It meshes the CDT according to the
\ccc{Geom_traits::Is_bad} predicates on triangles\footnote{Some
  triangles can remain bad according to these criteria. See the user
  manual for details.}. The mesh can be further refined by changing
the geometric traits class and calling \ccc{refine_mesh()} again.

\ccMethod{void refine_mesh(); }
{ Meshes the CDT. }

\ccMethod{ void set_geom_traits(Geom_traits gt);}
{ Assigns \ccc{gt} to the geometric traits object. }

\begin{ccAdvanced}
  The function \ccc{set_geom_traits} scans all faces to recalculate the
  list of bad faces. This function actually has an optionnal argument that
  permit to prevent this recalculation. The filling of the list of bad
  faces can then be done by a call to \ccc{set_bad_faces}.
  
  \ccMethod{ void set_geom_traits(Geom_traits gt, bool
    recalculate_bad_faces = true);}
  { Assigns \ccc{gt} to the geometric traits object. If
    \ccc{recalculate_bad_faces} is \ccc{false}, the list of bad faces is
    let empty and the function \ccc{set_bad_faces} should be called before
    \ccc{refine_mesh}.}

\ccMethod{template <class InputIterator>
  void set_bad_faces(InputIterator begin,
                     InputIterator end);}
                   { This method permits to set the list of bad triangles
                     directly, from the sequence [begin, end], so that the
                     algorithm will not scan the whole set of triangles to
                     find bad ones. To use if there is a non-naive way to
                     find bad triangles.  \ccPrecond The \ccc{value_type}
                     of \ccc{begin} and \ccc{end} is \ccc{Face_handle}.}

\end{ccAdvanced}


\begin{ccAdvanced}
\ccHeading{Step by step operations}

The \ccRefName{} class allows, for debugging or demos, to play the
meshing algorithm step by step, using the following methods.

\ccMethod{ void init(); }
         { The method must be called after all points and constrained
           segments are inserted and before any call to the following
           method. If some points or segments are then inserted 
           in the CDT, this method must be called again. }

\ccMethod{ bool step_by_step_refine_mesh(); }
         { Applies one step of the algorithm. At one step of the algorithm,
           at most one point is inserted. The algorithm
           sometimes doesn't insert a point at a step. Anyway,
           internal datas of the \ccRefName{} object are modified at
           each step, until \ccc{c.is_conformed()}. If the algorithm
           is finished, the function returns \ccc{false}. If not, it 
           returns \ccc{true}.}

\end{ccAdvanced}

\end{ccRefClass}

%%% For emacs/AucTeX:
%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "ref_manual.tex"  ***
%%% End: ***
