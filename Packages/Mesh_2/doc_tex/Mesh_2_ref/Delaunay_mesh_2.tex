\begin{ccRefClass}{Delaunay_mesh_2<CDT>}

This class implements a 2D mesh generator.

\ccParameters
The template parameter \ccc{CDT} \meshcdtrequires{}

The geometric traits class of the instance of \ccc{CDT} has to be
  a model of the concept \ccc{DelaunayMeshTraits_2}. This traits class
  provides not only constructors and predicates needed by the mesh
  algorithm, but also defines the shape and size criteria on the
  triangles of the mesh.

\ccHeading{Using this class}

The class \ccRefName{} derives from
  \ccc{Conforming_Delaunay_triangulation_2<CDT>} and therefore from
  the constrained Delaunay triangulation \ccc{CDT}. A \ccRefName{}
  object is then a \ccc{CDT}, in which one can insert points and
  constrained segments and performs every \ccc{CDT}'s availlable
  operations. In addition, the class \ccRefName\ has a refinement
  method \ccc{refine_mesh()}. A call to this method refines the
  constrained Delaunay triangulation into a mesh satisfying the size
  and shape criteria specified in the traits class. Note that vertices
  and contrained edges insertions are not overridden. Therefore, any
  insertion can ruin the mesh guarantees until \ccc{refine_mesh()} is
  called again.
  
  The domain to be mesh is defined by the constrained edges and a set
  of seed points. The constrained edges divide the plan into several
  connected components. Usually, the seeds are used to mark the holes,
  that is the connected components which do not have to be meshed and
  and the domain of the mesh is the union of the bounded components
  not including a seed point. Conversely, the seed points can be used
  to mark the connected components which are inside the domain.
  
  The domain has to be bounded. Therefore the unbounded component will
  not be part of it, whatever is the set of seed points. By
  default, if the set of seeds is empty, the domain to be meshed is
  the union of the bounded components. Note that the constrained edges
  have to bound the domain to be meshed and that the domain will be
  empty if the constrained edges do not define bounded components.

The refinement process needs to know which faces have to be
  refined, that's why the base face of the triangulation \ccc{CDT} has
  to be a model of the concept \ccc{MeshFaceBase_2}.

\ccInclude{CGAL/Delaunay_mesh_2.h}

\ccInheritsFrom

\ccc{Conforming_Delaunay_triangulation_2<CDT>}

\ccParameters

\ccc{CDT} must be a \cgal\ constrained Delaunay triangulation.

\ccTypes 
\ccTypedef{typedef CDT Triangulation;}{the triangulation base class.}
\ccTypedef{typedef CDT::Geom_traits Geom_traits;}{the geometric traits class.}
\ccTypedef{typedef Conforming_Delaunay_triangulation_2<CDT> Conform;}{the
  conforming triangulation base class.}
\ccNestedType{Seeds_iterator}{const iterator over defined seeds. Its
  value type is \ccc{Geom_traits::Point_2}}

\ccCreation
\ccCreationVariable{mesh}

\ccConstructor{Delaunay_mesh_2(const Geom_traits& gt = Geom_traits());}
{Introduces an empty mesh \ccVar.}

\ccMethod{void clear();}{ Deletes all faces and finite vertices
  resulting in an empty triangulation. Internal data structures are
  cleared too. }

\ccHeading{Seeds functions}

The following functions are used to define seeds.

\ccMethod{void  clear_seeds ();}{ Sets seeds to the empty set. All
  finite connected components of the constrained triangulation will be 
  refined.}

\ccMethod{template<class InputIterator>
          void set_seeds(InputIterator begin, InputIterator end,
                         const bool mark=false);}                   
                       { Sets seeds to the sequence [\ccc{begin},
                         \ccc{end}]. If \ccc{mark=true}, the mesh domain
                         is the union of the bounded connected
                         components including at least one seed. If
                         \ccc{mark=false}, the domain is the union of
                         the bounded components including no seed. Note
                         that the unbounded component of the plane is
                         never meshed.
                         \ccPrecond The \ccc{value_type} of
                         \ccc{begin} and \ccc{end} is
                         \ccc{Geom_traits::Point_2}.}

These ones give the sequences of seeds.

\ccMethod{Seeds_const_iterator  seeds_begin () const;}
{ Start of the seeds sequence. }
\ccGlue
\ccMethod{Seeds_const_iterator  seeds_end () const;}
{ Past the end of the seeds sequence. }

\ccHeading{Meshing methods}

\ccMethod{void refine_mesh(); }
{ Refines the constrained Delaunay triangulation into a mesh
  satisfying the criteria defined by the traits.
}

\ccMethod{ void set_geom_traits(Geom_traits gt);}
{ Assigns \ccc{gt} to the geometric traits object. }

\begin{ccAdvanced}
  The function \ccc{set_geom_traits} scans all faces to recalculate the
  list of bad faces. This function actually has an optionnal argument that
  permit to prevent this recalculation. The filling of the list of bad
  faces can then be done by a call to \ccc{set_bad_faces}.
  
  \ccMethod{ void set_geom_traits(Geom_traits gt, bool
    recalculate_bad_faces);}
  { Assigns \ccc{gt} to the geometric traits object. If
    \ccc{recalculate_bad_faces} is \ccc{false}, the list of bad faces is
    let empty and the function \ccc{set_bad_faces} should be called before
    \ccc{refine_mesh}.}

\ccMethod{template <class InputIterator>
  void set_bad_faces(InputIterator begin,
                     InputIterator end);}
                   { This method permits to set the list of bad triangles
                     directly, from the sequence [begin, end], so that the
                     algorithm will not scan the whole set of triangles to
                     find bad ones. To use if there is a non-naive way to
                     find bad triangles.  \ccPrecond The \ccc{value_type}
                     of \ccc{begin} and \ccc{end} is \ccc{Face_handle}.}

\end{ccAdvanced}


\begin{ccAdvanced}
\ccHeading{Step by step operations}

The \ccRefName{} class allows, for debugging or demos, to play the
meshing algorithm step by step, using the following methods.

\ccMethod{ void init(); }
         { This method must be called just before the first
             call to the following step by step refinement method,
             that is when all vertices and constrained edges have been
             inserted in the constrained Delaunay triangulation. It
             must be called again before any subsequent calls of the
             step by step refinementmethod if new vertices or constrained
             edges have been inserted since the last call.}

\ccMethod{ bool step_by_step_refine_mesh(); }
         { Applies one step of the algorithm. At one step of the algorithm,
           at most one point is inserted. The algorithm
           sometimes doesn't insert a point at a step. Anyway,
           internal datas of the \ccRefName{} object are modified at
           each step, until \ccc{c.is_conformed()}. If the algorithm
           is finished, the function returns \ccc{false}. If not, it 
           returns \ccc{true}.}

\end{ccAdvanced}

\end{ccRefClass}

%%% For emacs/AucTeX:
%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "ref_manual.tex"  ***
%%% End: ***
