\begin{ccRefClass}{Conforming_Delaunay_triangulation_2<CDT>}

The class \ccRefName{} is an auxiliary base class of
\ccc{Delaunay_mesh_2<CDT>}. It permits to refine a constrained
Delaunay triangulation into a conforming Delaunay or conforming
Gabriel triangulation. For standard needs, consider using the global
fonctions \ccc{make_conforming_Gabriel_2} and
\ccc{make_conforming_Delaunay_2} defined in the same header.

\ccParameters 

The template parameter \ccc{CDT} \meshcdtrequires{}

The geometric traits class of the instance of \ccc{CDT} has to be
  a model of the concept \ccc{ConformingGabrielTriangulationTraits_2}
  or \ccc{ConformingDelaunayTriangulationTraits_2}. Every methods of
  this class (but \ccc{clear()}) exists in two versions: one suffixed
  by \ccc{_Delaunay} and one suffixed by \ccc{_Gabriel}. If only
  \emph{Delaunay} methods are called, the geometric traits class of
  the instance of \ccc{CDT} can be a model of
  \ccc{ConformingDelaunayTriangulationTraits_2}. If some
  \emph{Gabriel} methods are called, the geometric traits class of
  the instance of \ccc{CDT} has to be a model of
  \ccc{ConformingGabrielTriangulationTraits_2}.

\ccHeading{Using this class}

The class \ccRefName\ derives from \ccc{CDT}. A call to the
  method \ccc{make_conforming_Delaunay()} (resp.
  \ccc{make_conforming_Gabriel()}) will refine the contrained Delaunay
  triangulation into a conforming Delaunay (resp. conforming Gabriel)
  triangulation. Note that the insertion methods of vertices or
  constrained edges are not overridden. Thus insertions of new vertices
  or new constrained edges break the conforming Delaunay (or
  conforming Gabriel) property, until a conforming method is called
  again.

The conforming methods insert points into constrained edges, splitting
them into sub-constraints. You can have access to initial inserted
constraints if you instantiate the template parameter by a
\ccc{CGAL::Constrained_triangulation_plus_2<CDT>}.

\ccInclude{CGAL/Conforming_Delaunay_triangulation_2.h}

\ccInheritsFrom

\ccc{CDT}

\ccParameters

\ccc{CDT} must be a \cgal\ constrained Delaunay triangulation.

\ccTypes 
\ccTypedef{typedef CDT Triangulation;}{the triangulation base class.}

\ccCreation
\ccCreationVariable{c}

\ccConstructor{Conforming_Delaunay_triangulation_2(const Geom_traits& gt =
  Geom_traits());}
{Introduces an empty triangulation \ccVar.}

\ccOperations

\ccMethod{ void clear(); }
{ Clear the triangulation and private datas, resulting in a empty
  triangulation. }

\ccHeading{Conforming methods}

\ccMethod{ void make_conforming_Delaunay(); }
{ Refines the triangulation into a conforming Delaunay triangulation.
  After a call to this method, all triangles fulfill the empty circle
  property. }

\ccMethod{ void make_conforming_Gabriel(); }
{ Refines the triangulation into a conforming Gabriel triangulation.
  After a call to this method, all constrained edges $e$ have the
  \emph{Gabriel property}: the circle that have $e$ as diameter
  does not contain any vertex of the triangulation. }

\ccHeading{Checking}
The following methods verify that the constrained triangulation is
conforming Delaunay or conforming Gabriel. These methods scan the
whole triangulation and their complexity is proportional to the number
of edges.

\ccMethod{ bool is_conforming_Delaunay(); }
{ Returns \ccc{true} iff all triangles fulfill the Delaunay property.}

\ccMethod{ bool is_conforming_Gabriel(); }
{ Returns \ccc{true} if all constrained edges have the Gabriel property:
  there circumsphere is empty. }

\begin{ccAdvanced}

\ccHeading{Step by step operations}

The \ccRefName{} class allows, for debugging or demos, to play the
conforming algorithm step by step, using the following methods. They
exist in two versions, depending whether you want the triangulation to
be conforming Delaunay or conforming Gabriel. Any call to a
\ccc{step_by_step_conforming_XX} function requires a previous call to
the corresponding of \ccc{init_XX}.

\ccMethod{ void init_Delaunay(); }
{ The method must be called after all points and constrained segments
  are inserted and before any call to the following methods. If some
  points or segments are then inserted in the triangulation, this
  method must be called again. }

\ccMethod{ bool step_by_step_conforming_Delaunay (); }
{ Applies one step of the algorithm. At one step of the algorithm,
  only one point is inserted. However, the algorithm sometimes doesn't
  insert a point at a step. Anyway, internal datas of the \ccRefName{}
  object are modified at each step, until \ccc{c.is_conforming_done()}
  returns \ccc{true}. If \ccc{c.is_conforming_done()}, returns
  \ccc{false}. If not (when the algorithm is not done), returns
  \ccc{true}.}

\ccMethod{ void init_Gabriel(); }{Analog to
    \ccc{init_Delaunay} for Gabriel conforming.}

\ccMethod{ void step_by_step_conforming_Gabriel (); }{Analog to
  \ccc{step_by_step_conforming_Delaunay()} for Gabriel conforming.}

\ccMethod{ bool is_conforming_done(); }
{ Tests if the step by step conforming algorithm if done or not. If if
  returns \ccc{true}, the following calls to
  \ccc{step_by_step_conforming_XX} will not insert any points, until some
  new contrained segments or points are inserted in the triangulation and
  \ccc{init_XX} is called again. }

\end{ccAdvanced}

\end{ccRefClass}

%%% For emacs/AucTeX:
%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "ref_manual.tex"  ***
%%% End: ***
