\chapter{Quelques détails d'implémentation jetés en vrac}

Le package est composé de deux classes principales:
\ccc{Conforming_Delaunay_triangulation_2<Tr>} et \ccc{Mesh_2<Tr>}, qui dérive de
la première. \ccc{Conforming_Delaunay_triangulation_2<Tr>} permet de conformer une
CDT (Coonform Delaunay Triangulation) de tel sorte que les arêtes
soient de Gabriel ou de Delaunay, et \ccc{Mesh_2<Tr>} permet de
mailler une CDT.

À chacune de ces deux classes est associée une \emph{geometric traits
  class} requise pour la classe de base \ccc{Tr}. \ccc{Mesh_2<Tr>}
nécessite en plus que la face de base de \ccc{Tr} possède un marqueur
booléen pour décider si la face est dans la zone à raffiner ou non.

Les deux classes se comportent toutes les deux comme une CDT, jusqu'à
ce qu'on appelle les fonctions spécifiques à la classe. Chacune de ces
deux classes possèdent des données internes, qui sont automatiquement
initialisées par l'appel d'une fonction de conforming ou de maillage,
par l'intermédiaire d'une fonction \ccc{init()}:
\begin{itemize}
\item \ccc{Conforming_Delaunay_triangulation_2<Tr>} contient la liste (en fait,
  une \ccc{std::multimap}) des \ccc{Clusters} et une liste des arêtes
  à raffiner, qui sont initialisées par \ccc{void init()}\footnote{En
    fait cette méthode est paramétrée par une classe qui définit la
    notion de \emph{conforme}. Voir la section~\ref{policies} sur les
    \emph{conform policies}.}.
\item \ccc{Mesh_2<Tr>} contient en plus une liste des mauvaises faces,
  qui est elle-même remplie par \ccc{Mesh_2<Tr>::init()} ou par
  \ccc{Mesh_2<Tr>::calculate_bad_faces()}. \ccc{Mesh_2<Tr>::init()}
  appelle la fonction \ccc{init()} de la classe de base
  \ccc{Conforming_Delaunay_triangulation_2<Tr>} avec une \emph{policy class} qui
  conforme les arêtes de Gabriel en tenant compte des marques des
  faces. \todo{Ce comportement pourrait être décidé par un tag.}
\end{itemize}

Si après avoir appelé \ccc{init()} on insère à nouveau des points ou
des segments de contraintes, les structures de données doivent être
recalculées par un nouvel appel à \ccc{init()}.

\section{Les \emph{conform policies} de
  \ccc{Conforming_Delaunay_triangulation_2<Tr>}}
\label{policies}

Afin de pouvoir indifféremment conformer de Delaunay, de Gabriel, ou
de \emph{Gabriel\_inside}, une bonne partie des fonctions de la classe
\ccc{Conforming_Delaunay_triangulation_2<Tr>} sont paramétrées par une
\emph{policy class}, qui définit deux choses:
\begin{enumerate}
\item quelles sont les arêtes localement conformes?
\item est-ce qu'une face peut faire partie d'un clusters?
\end{enumerate}
Cette dernière question est nécessaire et constituait le bug
norvégien: un cluster contenait deux arêtes consécutives dont la face
commune était à l'extérieur du domaine. Cela posait un problème car,
selon le critère de \emph{Gabriel\_inside}, elles ne s'encroachaient
pas mutuellement (ou un truc du genre). \textbf{La documentation sur
  ce point est assez floue, et je vais devoir l'éclaircir.}

Parmi les fonctions paramétrées, la fonction appelante est:
\ccc{template <class ConformPolicy> conform(ConformPolicy)} et les
fonctions \ccc{gabriel_conform()} et \ccc{delaunay_conform()} sont
alors juste des wrappers autour de
\ccc{conform(Gabriel_conform_policy_2())} et
\ccc{conform(Delaunay_conform_policy_2())}. La classe \ccc{Mesh_2<Tr>}
appelle elle-même la fonction
\ccc{Conform::conform(Gabriel_conform_inside_policy_2())}.

\section{Pourquoi \ccc{Conforming_Delaunay_triangulation_2<Tr>} est-elle une
  classe?}

Conformément à ce que l'on avait dit, j'ai créé en dehors de la classe
\ccc{Conforming_Delaunay_triangulation_2<Tr>} deux fonctions globales \ccc{void
  gabriel_conform(CDT& t)} et \ccc{void delaunay_conform(CDT& t)} qui
conforment une CDT. Pour pouvoir appeler ces deux fonctions, la
\emph{geom\_traits} de la CDT doit être modèle de
\ccc{ConformTraits_2}.

Une fois qu'on a appelé \ccc{conform(ConfPolicy)} sur un objet de la
classe \ccc{Conforming_Delaunay_triangulation_2<Tr>} on ne peut plus rien faire
d'autre que des opérations usuelles de CDT (à moins de rappeler
\ccc{init()}. On se demande alors pourquoi cette classe est une
classe. En fait elle n'a pas de raison d'être une classe en soit. Elle
l'est uniquement pour servir de classe de base à \ccc{Mesh_2<Tr>} qui,
elle, a besoin de conserver les clusters en données internes (si on
veut raffiner avec des critères plus fort).

\section{Comment une CDT de type \ccc{Mesh_2<Tr>} peut être maillée et
  remaillée?}

Après avoir inséré les points et segments de contraintes dans la CDT,
la fonction \ccc{void refine()} la raffine pour en faire un maillage
conforme aux critères définis dans la \emph{geom\_traits}. Si on
n'insère pas de nouveaux points ou segments, la liste des clusters,
initialisée quand \ccc{refine()} appelle \ccc{init()}, reste valide et
n'a pas besoin d'être recalculée par la suite.

La fonction \ccc{void set_geom_traits(Geom_traits gt)} permet de
définir de nouveaux critères de raffinage, en affectant une nouvelle
\emph{geom\_traits}. La liste des mauvaises faces doit ensuite être
mise à jour et deux méthodes sont mises à disposition pour cela:

\begin{itemize}
\item \ccc{void calculate_bad_faces()}~: remplit la liste des
  mauvaises faces en appliquant le test \ccc{Is_bad} de la
  \emph{geom\_traits} sur chaque face de la triangulation.
\item \ccc{template <class Face_handle_Iterator>
    set_bad_faces(Face_handle_iterator begin, Face_handle_iterator
    end)}~: assigne la séquence de Face\_handle à la liste de
  mauvaises faces. Cette méthode peut être appelée quand il existe un
  moyen de calculer cette liste plus simple que l'itération sur toutes
  les faces.
\end{itemize}

Une fois que l'une de ces deux méthodes a été appelée, les nouveaux
critères de raffinage sont pris en compte lors d'un nouvel appel à
\ccc{refine()}. 
