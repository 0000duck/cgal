% Interval Arithmetic documentation.
%   $Revision$
%   $Date$

\begin{ccClass} {CGAL_Interval_nt}
\ccSubsection{Interval Arithmetic}
\label{interval}
\ccChapterAuthor{Sylvain Pion}

This chapter describes briefly what interval arithmetic is, its implementation
in {\cgal}, and its possible use by geometric programs.
The main reason for having interval arithmetic in {\cgal} is its integration
into the filtered robust and fast predicates scheme, but we also provide a
number type so that you can use it separately if you find any use for it.

% This control is
% provided via the comparison operators.  When there is an unsafe comparison
% between intervals, either a warning or an exception (see below) is raised.
% Otherwise, it means that if you do the same computation with doubles, your
% program will have the correct output (with the exact same input data).

The purpose of interval arithmetic is to provide an efficient way to bound
the roundoff errors made by floating point computations.
You can choose the behaviour of your program depending on these errors; that
is what is done for the filtered robust predicates (see Section~\ref{filter}).
You can find more theoretical information on this topic in
\cite{bbp-iayea-98}.
% \cite{bbp-iayed-98scg}. % worked here, but changed by Remco.

\ccDefinition
Interval arithmetic is a large concept and we will only consider here a 
simple arithmetic based on intervals whose bounds are {\it double}s.
So each variable is an interval representing any value inside the interval.
All arithmetic operations (+, -, $*$, $/$, $\sqrt{}$, \ccc{CGAL_square()},
\ccc{CGAL_min()},
\ccc{CGAL_max()} and \ccc{CGAL_abs()}) on intervals preserve the inclusion.
This property can be expressed by the following formula ($x$ and $y$ are
reals, $X$ and $Y$ are intervals, $\mathcal{OP}$ is an arithmetic operation):

$$
\forall\ x \in X, \forall\ y \in Y, (x\ \mathcal{OP}\ y)
\in (X\ \mathcal{OP}\ Y)
$$

For example, if the final result of a sequence of arithmetic operations is
an interval that does not contain zero, then you can safely determine its sign.

\ccInclude{CGAL/Interval_arithmetic.h}

\ccCreation

\ccConstructor{CGAL_Interval_nt(double d);}
{introduces the interval [d;d].}

\ccConstructor{CGAL_Interval_nt(double i, double s);}
{introduces the interval [i;s].}

Several functions \ccc{CGAL_convert_to<CGAL_Interval_nt>(NT)} provide a cast
from all supported numerical types, to an interval \ccc{CGAL_Interval_nt}
containing the value.  The following types are supported: \ccc{leda_real},
\ccc{leda_rational}, \ccc{leda_integer}, \ccc{leda_bigfloat}, \ccc{CGAL_Gmpz},
\ccc{CGAL_Fixed_precision_nt}, and all built-in types.
The user can add such functions for his own number types.


\ccOperations
\ccSetThreeColumns{CGAL_Interval_nt}{}{\hspace*{8cm}}

All functions required by a class to be considered as a {\cgal} number type
(see~\ref{Numbertype}) are present, as well as the utility functions,
sometimes with a particular semantic which is described below.  There are also
access functions to the bounds of the intervals.

\ccCreationVariable{I}

\ccMethod{CGAL_Interval_nt operator/(CGAL_Interval_nt J);} {returns
[$-\infty$;$+\infty$] when the denominator contains 0.}

\ccFunction{CGAL_Interval_nt sqrt(CGAL_Interval_nt I);} {returns
[0;sqrt(upper\_bound(I))] when only the lower bound is negative (expectable
case with roundoff errors), and is unspecified when the upper bound also is
negative (unexpected case).}

\ccFunction{double CGAL_to_double(CGAL_Interval_nt I);} {returns the
middle of the interval, as a double approximation of the interval.}

\ccMethod{double lower_bound();} {returns the lower bound of the interval.}
\ccMethod{double upper_bound();} {returns the upper bound of the interval.}

The comparison operators ($<$, $>$, $<=$, $>=$, $==$, $!=$, \ccc{CGAL_sign()}
and \ccc{CGAL_compare()}) have the following semantic: it is the intuitive
one when for all couples of values in both intervals, the comparison
is identical (case of non-overlapping intervals).  This can be expressed
by the following formula ($x$ and $y$ are reals, $X$ and $Y$ are
intervals, $\mathcal{OP}$ is a comparison operator):

$$
\left(\forall x \in X, \forall y \in Y, (x\ \mathcal{OP}\ y) = true\right)
\Rightarrow (X\ \mathcal{OP}\ Y) = true
$$
and
$$
\left(\forall x \in X, \forall y \in Y, (x\ \mathcal{OP}\ y) = false\right)
\Rightarrow (X\ \mathcal{OP}\ Y) =false
$$

Otherwise, the comparison is not safe.  Then the behaviour is the following:
\begin{itemize}
\item By default, the exception
    \ccc{CGAL_Interval_nt_advanced::unsafe_comparison} is thrown.
\item If you compile with the flag \ccc{-DCGAL_IA_NO_EXCEPTION}, the exception
    is not thrown, but you get a warning instead.
    The return value is unspecified.
\item Moreover, you can also get rid of the warning by adding
    \ccc{-DCGAL_IA_NO_WARNINGS} or \ccc{-DCGAL_NO_WARNINGS}.
    The return value is unspecified too.
\end{itemize}

\ccImplementation

\ccc{CGAL_Interval_nt} derives from \ccc{CGAL_Interval_nt_advanced}, 
see Section~\ref{interval-adv}.  Nearly all operations on
\ccc{CGAL_Interval_nt} need the rounding mode to be set to 'round to nearest'
(which is the default),
and leave it in this state if they have to modify it internally.

% \ccExample
% 
% Here a simple example is given showing how to make safe and fast predicates.
% This kind of problem is going to be resolved automatically by a predicate
% compiler, but before it is available, you can do it by hand.
% Let's consider the \ccc{CGAL_orientation} predicate:
% 
% \begin{verbatim}
% template < class FT >
% CGAL_Orientation CGAL_orientation(const FT &px, const FT &py,
                                  % const FT &qx, const FT &qy,
                                  % const FT &rx, const FT &ry)
% {
  % FT d1 = (px-qx)*(qy-ry);
  % FT d2 = (py-qy)*(qx-rx);
  % return  (d1 < d2) ? CGAL_RIGHTTURN
       % : ((d1 == d2)? CGAL_COLLINEAR : CGAL_LEFTTURN);
% }
% \end{verbatim}
% 
% This function becomes approximately the following, if you want it to be exact~:
% 
% \begin{verbatim}
% #include <CGAL/Interval_arithmetic.h>
% typedef CGAL_Interval_nt Dis;
% 
% CGAL_Orientation CGAL_orientation(const FT &px, const FT &py,
                                  % const FT &qx, const FT &qy,
                                  % const FT &rx, const FT &ry)
% {
  % Dis d1 = ((Dis)px-(Dis)qx)*((Dis)qy-(Dis)ry);
  % Dis d2 = ((Dis)py-(Dis)qy)*((Dis)qx-(Dis)rx);
% 
  % if (d1 == d2) {
    % return CGAL_orientation((leda_real) px, (leda_real) py,
			    % (leda_real) qx, (leda_real) qy,
			    % (leda_real) rx, (leda_real) ry);
  % } else {
    % return (d1 < d2) ? CGAL_RIGHTTURN : CGAL_LEFTTURN;
  % };
% }
% \end{verbatim}

\end{ccClass}

\begin{ccAdvanced}
\samepage
\begin{ccClass} {CGAL_Interval_nt_advanced}
\ccSubsection {Advanced Interval Arithmetic}
\label{interval-adv}

\ccc{CGAL_Interval_nt} derives from \ccc{CGAL_Interval_nt_advanced}.
The advanced class allows you to make faster computations, but you need to set
the rounding mode of the FPU to 'round to infinity' (see below for how to do
that) before doing any computation with this number type, and each function
(arithmetic operators and conversion functions)
leaves the rounding mode in this state if it needs to modify it internally.
See below for details.

% The other noticeable difference is that it throws the exception
% \ccc{CGAL_Interval_nt_advanced::unsafe_comparison} when you make unsafe
% comparisons.  This mechanism is used internally by the filtered predicate
% scheme described in the section~/ref{filter}.

The function \ccc{CGAL_convert_to<CGAL_Interval_nt>()} is replaced by the
function \ccc{CGAL_convert_to<CGAL_Interval_nt_advanced>()} and has the same
requirements concerning the rounding mode as other functions.

\ccInclude{CGAL/Interval_arithmetic.h}

% FPU rounding modes~:

We provide the following functions to change the rounding mode:
\begin{itemize}
\item \ccc{CGAL_FPU_set_rounding_to_zero()}
\item \ccc{CGAL_FPU_set_rounding_to_nearest()}
\item \ccc{CGAL_FPU_set_rounding_to_infinity()}
\item \ccc{CGAL_FPU_set_rounding_to_minus_infinity()}
\end{itemize}

\ccImplementation

The basic idea is to use the directed rounding modes specified by the 
{\it IEEE 754} standard, which are implemented by almost all processors 
nowadays.
It states that you have the possibility, concerning the basic floating point
operations ($+,-,*,/,\sqrt{}$) to specify the rounding mode of each operation
instead of using the default, which is set to 'round to the nearest'.
This feature allows us to compute easily on \ccc{intervals}.  For example, to
add the two intervals [a.i;a.s] and [b.i;b.s], compute $c.i=a.i+b.i$ rounded
towards minus infinity, and $c.s=a.s+b.s$ rounded towards plus infinity, and
the result is the interval [c.i;c.s].  This method can be extended easily to
the other operations.

The problem is that we have to change the rounding mode very often, and the
functions of the C library doing this operation are slow and not portable.
That's why assembly versions are used as often as possible.
Another trick is to store the opposite of the lower bound, instead of the
lower bound itself, which allows us to never change the rounding mode inside
simple operations.  Therefore, all basic operations, which are in the class 
\ccc{CGAL_Interval_nt_advanced} assume that the rounding mode is set to 
'round to infinity', and everything works with this correctly set.  
The class \ccc{CGAL_Interval_nt} takes care of this, but is a bit slower.

So, if the user needs the speed of \ccc{CGAL_Interval_nt_advanced}, he must
take care of setting the rounding mode to 'round to infinity' before each
operations on this number type.  And if other operations might be affected by
this, he must take care to reset it to 'round to the nearest' before them.

% Note also that NaNs are not handled, so be careful with that
% (especially if you `divide by zero').

Platform support:\\
This part of {\cgal} must be explicitly ported to each non yet supported
platform.  For Intel, Sparc and Mips, only the GNU compilers use assembly
code.  The MipsPro compiler uses the slow C code instead, and do not
support the construction \ccc{CGAL_convert_to<>()} right now.

% Here is the current state of supported platforms:
% 
% \begin{itemize}
% \item Sparc
% %\begin{itemize}\itemsep0pt\topsep0pt\partopsep0pt\parskip0pt\parsep0pt
% \begin{itemize}
% \item g++ uses the assembly versions, independent of the OS (Solaris tested).
% \item CC (Solaris) uses the C library functions to change the rounding modes.
% \end{itemize}
% \item Intel
% \begin{itemize}
% \item g++ uses the assembly versions, independent of the OS (tested for Linux).
% \item For Windows (NT, 95), Solaris, and others the code is not (yet) ported.
% \end{itemize}
% \item Alpha
% \begin{itemize}
% \item g++ 2.8 supports the "-mfp-rounding-mode=d" command line option
      % to set the dynamic rounding mode.
% \item For CC the situation is unknown (try command line option like "-fprm d").
% \end{itemize}
% \item Mips
% \begin{itemize}
% \item g++ and CC use the C library functions.
% \end{itemize}
% \end{itemize}

\end{ccClass}

\end{ccAdvanced}


\begin{ccClass} {CGAL_Filtered_exact<CT,ET>}
\ccSubsection{Robust filtered predicates}
\label{filter}

The class \ccc{CGAL_Filtered_exact<CT,ET>} is a wrapper type for the number
type \ccc{CT}, with the difference
that all predicates are specialized such that they are guaranteed to be exact.
Speed is achieved via a filtering scheme using interval arithmetic (see
Section~\ref{interval-adv}).  Here are the necessary requirements:

\begin{itemize}
\item \ccc{CT} is the construction and storage type.  The only data member of
      the class \ccc{CGAL_Filtered_exact<CT,ET>} is the \ccc{value} of type
      \ccc{CT}.
      All arithmetic operations called
      outside the predicates will be executed with this number type.  You can
      disable this feature by compiling with the flag
      \ccc{-DCGAL_DENY_INEXACT_OPERATIONS_ON_FILTER} (it allows the programmer
      to spot the inexact operations that should be incorporated in the
      predicates).
      The arithmetic operations called from the predicates are always computed
      exactly.
\item The \ccc{ET} type must be able to compute exactly the operations involved
      in the predicates called.
\item A \ccc{CGAL_convert_to<CGAL_Interval_nt_advanced>(CT)} function must
      be provided, that returns an interval containing the value of the
      argument of type \ccc{CT}.
      This conversion function has to be as fast as possible, and exact (in the
      sense that the interval must contain surely the initial value).  This
      function is provided for the usual types \ccc{CGAL_Gmpz}, \ccc{leda_real},
      \ccc{leda_rational}, \ccc{leda_bigfloat}, \ccc{leda_integer}, and the
      built-in types.  The user can add his own types.
%      (Note: This might become an additional requirement for number types).
\item A \ccc{CGAL_convert_to<ET>(CT)} function must also be provided, that
      returns a number of type \ccc{ET} representing exactly the argument of
      type \ccc{CT}.  It's a conversion function that is used for the exact
      computation, when the filter fails.
      This conversion has to be done exactly.
\end{itemize}

\ccExample

You might use at the beginning of your program a \ccc{typedef} as follows:

\begin{verbatim}
    #include<CGAL/Arithmetic_filter.h>
    #include<CGAL/leda_real.h>
    #include<CGAL/double.h>
    typedef CGAL_Filtered_exact<double, leda_real> NT;
\end{verbatim}

Or if you are sure that the predicates involved do not use divisions nor
square roots:

\begin{verbatim}
    #include<CGAL/Arithmetic_filter.h>
    #include<CGAL/Gmpz.h>
    #include<CGAL/int.h>
    typedef CGAL_Filtered_exact<int, CGAL_Gmpz> NT;
\end{verbatim}

And if you know that the double variables contain integer values, you can
use:

\begin{verbatim}
    #include<CGAL/Arithmetic_filter.h>
    #include<CGAL/Gmpz.h>
    #include<CGAL/double.h>
    typedef CGAL_Filtered_exact<double, CGAL_Gmpz> NT;
\end{verbatim}

\ccImplementation

The template definition of the low level predicates of CGAL are overloaded for
the type \ccc{CGAL_Filtered_exact<CT,ET>}.  It is a partial specialisation,
which implies that this is not supported by the compilers that do not support
this C++ feature (MipsPro 7.2).

For each predicate file, the overloaded code is generated automatically by a
\ccc{PERL} script
(\ccc{examples/Interval_arithmetic/filtered_predicate_converter}) that you can
use for your own predicates (see \ccc{examples/Interval_arithmetic/README}).
This script parses the template declaration of the functions and generates the
overloaded code the following way:
\begin{itemize}
\item convert the entries to intervals using
    \ccc{CGAL_convert_to<CGAL_Interval_nt_advanced>(CT)},
\item call the original template function with the type
    \ccc{CGAL_Interval_nt_advanced},
\item if no exception is thrown, return the value,
\item if an exception is thrown (the filter failed), convert the original
    entries using \ccc{CGAL_convert_to<ET>(CT)},
\item and call the original template function with the type \ccc{ET}.
\end{itemize}

\ccExample

The low level template predicates of CGAL are in files named
\ccc{CGAL/predicates_on_ftC2.h} (resp. ftC3, rtH2, rtH3), the script is used
to produce the files \ccc{CGAL/Arithmetic_filter/predicates_on_ftC2.h} (resp.
ftC3, rtH2, rtH3).

\end{ccClass}
