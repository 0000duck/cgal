% $Revision$
% $Date$
% author : Sylvain Pion

\begin{ccRefClass} {Lazy_exact_nt<NT>}
%\subsection{Lazy wrapper for exact number types}
\label{lazy_exact_nt}

\ccDefinition
An object of the class \ccc{Lazy_exact_nt<NT>} is able to represent any number
which \ccc{NT} is able to represent.  The arithmetic operations it can do are
those \ccc{NT} can do, limited to the 4 basic operations, the square root and
the comparisons.
The idea is that \ccc{Lazy_exact_nt<NT>} works exactly like \ccc{NT}, except
that it is faster because it tries to only compute an approximation of the
value, and only refers to \ccc{NT} when needed.  The goal is to speed up exact
computations done by any exact but slow number type \ccc{NT}.

In addition to the filtering at each arithmetic operation, the predicates
are overloaded in the same way as for \ccc{Filtered_exact}, so you get the
additional speed up without requiring to encapsulate \ccc{Lazy_exact_nt<NT>}
into \ccc{Filtered_exact}.  You still need to include
\ccc{CGAL/Filtered_exact.h} in order to include the overloaded functions.
These overloaded functions do not work if the compiler does not support
partial overloading of function templates, e.g. Visual C++ (so you miss an
additional speed up in this case).

\ccInclude{CGAL/Lazy_exact_nt.h}

\ccIsModel
FieldNumberType

\ccCreation
\ccCreationVariable{m}

\ccConstructor{Lazy_exact_nt();}
{introduces an uninitialized variable \ccVar.}
\ccGlue
%\ccConstructor{Lazy_exact_nt(const Lazy_exact_nt &);}
%{copy constructor.}
%\ccGlue
\ccConstructor{Lazy_exact_nt(int i)}
{introduces the integral value \ccc{i}.}
\ccGlue
\ccConstructor{Lazy_exact_nt(double d)}
{introduces the floating point value \ccc{d} (works only if \ccc{NT} has a
constructor from a double too).}
\ccGlue
\ccConstructor{Lazy_exact_nt(NT n)}
{introduces the value \ccc{n}.}
\ccGlue
\ccConstructor{template <class NT1> Lazy_exact_nt(Lazy_exact_nt<NT1> n)}
{introduces the value \ccc{n}. \ccc{NT1} needs to be convertible to \ccc{NT}
(and this conversion will only be done if necessary).}

\ccOperations

\ccMethod{NT exact();} {returns the corresponding NT value.}

\ccMethod{Interval_nt<true> approx();} {returns an interval containing the
exact value.}

\ccMethod{Interval_nt<false> interval();} {returns an interval containing the 
exact value.}

\ccFunction{std::ostream& operator<<(std::ostream& out,
                                     const Lazy_exact_nt<NT>& m);}
{writes \ccc{m} to ostream \ccc{out} in an interval format.}

\ccFunction{std::istream& operator>>(std::istream& in, Lazy_exact_nt<NT>& m);}
{reads a \ccc{NT} from \ccc{in}, then converts it to a \ccc{Lazy_exact_nt<NT>}.}

\ccExample

\begin{verbatim}
#include <CGAL/Cartesian.h>
#include <CGAL/MP_Float.h>
#include <CGAL/Lazy_exact_nt.h>
#include <CGAL/Quotient.h>

typedef CGAL::Lazy_exact_nt<CGAL::Quotient<CGAL::MP_Float> > NT;
typedef CGAL::Cartesian<NT> K;
\end{verbatim}

\end{ccRefClass} 

