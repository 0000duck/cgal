- Real/Expr: ?  See also http://www.cs.nyu.edu/exact/core/.
- Implanter les optimisations suivantes compatibles IEEE 754 dans egcs:
  - (-a)*(-b) => a*b  (idem pour /)
  - (-a)>0    => a<0
  - (-a)+b    => b-a ...
  - (-a)*b    => -(a*b) ssi -ffast-math
  - bug à fixer: cf get_empiric_rounding_mode(), où "volatile" est nécessaire.
- Comment intégrer ces foutus pré-calculs ?  Faire un draft de propal.
- Implanter la propal pour modular ?
  Ça devra se faire un jour anyway, de porter le code au C++...
- Voir si on pourrait faire un filtre "static adaptatif" avec le NT d'Olivier
  qui calcule la borne d'erreur, et mes scripts (voir si y'a pas trop de
  branches, etc...).

Concerning the code itself:

- Est-ce que les spécialisations doivent être sous CVS ?
- Essayer de bencher avec -fbranch-probabilities ?  Ça pourrait être pas mal.
- Expertiser le bench de Stefan.
- Stop constant propagation (could be considered a compiler bug, or at least
  misfeature).  It's not specific to Intel, it would be nice if egcs had
  better control over that (work on that ?).  It can easily be fixed by
  "CGAL_IA_FORCE_TO_DOUBLE" in the constructors.
- On Intel, due to lack of IEEE support, after each critical operation, I need
  to "CGAL_IA_FORCE_TO_DOUBLE".  Would be nice if egcs had a good option for
  that.  I should try/bench the other solution: use "long double" bounds.
- Drop the class Interval_nt ?
  Or have a boolean template parameter, instead or the derivation ?
- FPU_get_and_set_cw (), c'est plus joli, et ça peut être plus efficace.
- Filter_Cache: Faire des benchs, et une test-suite qui soit raisonnable.
  Hum, rajouter un booléen pour calculer le cache seulement sur demande ?
  (ça évite de le faire inutilement pour les variables intermédiaires,
  mais ça prend un chouia plus de place... mais en comparaison du reste...)
  Utiliser plutôt Tag_true/Tag_false si possible.
- sign_det_2x2() optimisé pour l'IA (+ bench de triangulation).
  (ça a l'air bien chiant, plutôt décrire vaguement dans la thèse, et
  implanter les filtres "statiques adaptatifs").
- Workarounds (pour MipsPro [et M$VC]):
  - specializations partielles: vérifier que c'est bien le bon CGAL_CFG_..
                                que j'utilise.
				NB: si on linke 2 .o comme ça => multiple def...
  - The convert_to workaround could be enabled even for all compilers ?
    It would simplify the code, but:  slow down ?  still work for Quotient ?
- Vérifier que EGCS optimise les expressions x*IA(1), IA(1)*x, x*IA(0), etc...
  C'est apparemment loin d'être le cas.  Il inline, mais laisse les tests...
  Il n'a pas l'air de propager les constantes à travers IA(1), même s'il
  inline !!!
- Avoir un flag dynamic (static member) qui dit si exception ou pas, voire un
  function pointer pour overlap_action() ?
  Et modifier le comportement dans les fonctions save/restore ?
- converter (long longs), (long doubles)...  au moins documenter que c'est pas
  supporté pour le moment.  Hint: (double) +/- 1ulp.
? Currently, some types (leda_*, GMP) need the rounding to nearest for doing
  the conversion to Interval.  That's bad because double doesn't, and is the
  case that must be optimized.  Maybe have a Tag for each NT saying if/how it
  needs the rounding to do the conversion ?
  Remark: the fast case is for the builtin types, so others (that care of the
  rounding mode) can be slowed down...
? SUN: Add "-Wa,-xarch=v8plus" to fix the following "error":
  /usr/ccs/bin/as: "/var/tmp/ccBHnU0T.s", line 861: warning: 3 instructions
  required between ldfsr and next FBfcc; nops inserted
- Sparc 64 support (Solaris 2.7 only for the moment): cf glibc-2.1.1
- In the future: see the C++ Standard numeric_limits<>, section 18.2.

Concerning the script:

- Try to be less pedantic (accept more C++).
- Add a warning/check to the argument being "const".
- Add determinant_signs.h to the list of filtered files ?  And send the 3
  lines to Stefan to add to the end of the original determinant.h.
- Produire un fichier avec juste les déclarations, et un autre avec les
  définitions, ça aidera à faire une library séparée de trucs précompilés.

Concerning the doc:

- Dans la doc html de CGAL-2.0, mes enums sont répertoriés 2 fois dans
  l'index, sûrement un bug de cc_manual compliance de ma part.
  de même plus loin, ma fct to_double(Ia) n'est pas pareille que les autres.
- RV: "documenter le mécanisme pour les prédicats? Il me semblerait utile de
  rajouter une section d'introduction ou bien à la fin du chapitre, pour
  expliquer comment utiliser les filtres. Peut-être une référence à ton
  chapitre sur l'arithmétique d'intervalles..."
- add a pointer to my MISC'99 paper.
- Document "IA::number_of_failures", once overlap_action() is made
  customisable.
- Documenter le mécanisme de cache.
- Documenter .exact(), .interval() et .value().
- Passer au nouveau format de doc.

Concerning the test-suite:

- CGAL_IA_DEBUG ne marche pas sur sparc (FPU_get_cw ne rend pas ce qu'il
  faut...).
- Refaire un petit coup de GCOV, pour voir où ça en est.
- test-suite: rajouter un test simple qui vérifie que les exceptions marchent.
- Faire une test-suite un peu plus extensive des filtres.  En particulier les
  types templatés, etc...
- test new converter functions ?  [use flag -DCGAL_IA_DEBUG]
- test NaNs (and Infs?).  Comparisons with these should throw the exception...
  Et vérifier s'ils sont bien propagés correctement (par min/max, ou même *).
