- CLN: finish the wrapper(s) [and add the converters]. (+doc)
- Real/Expr: idem.  See also http://www.cs.nyu.edu/exact/core/.
- Implanter les optimisations suivantes compatibles IEEE 754 dans egcs:
  - (-a)*(-b) => a*b  (idem pour /)
  - (-a)>0    => a<0
  - (-a)+b    => b-a ...
  - (-a)*b    => -(a*b) ssi -ffast-math
  - bug à fixer: cf get_empiric_rounding_mode(), où "volatile" est nécessaire.
- Comment intégrer ces foutus pré-calculs ?  Faire un draft de propal.
- Faire aussi une propal pour include/CGAL/Predicates/*.

Concerning the code itself:

- FPU_get_and_set_cw (), c'est plus joli, et ça peut être plus efficace.
- Les opérateurs (double, Interval_nt (pas advanced)) ne sont pas protégés par
  le rounding mode +inf...
- Filter_Cache: Faire des benchs, et une test-suite qui soit raisonnable.
  Hum, rajouter un booléen pour calculer le cache seulement sur demande ?
  (ça évite de le faire inutilement pour les variables intermédiaires,
  mais ça prend un chouia plus de place... mais en comparaison du reste...)
- sign_det_2x2() optimisé pour l'IA (+ bench de triangulation).
  (et régler le sort de include/CGAL/Interval_arithmetic/determinant.h.)
	include/CGAL/Interval_arithmetic/determinant.h has no header.
	Header check failed for include/CGAL/Interval_arithmetic/determinant.h.
	Creating a default header.
- Workarounds (pour MipsPro [et M$VC]):
  - specializations partielles: vérifier que c'est bien le bon CGAL_CFG_..
                                que j'utilise.
				NB: si on linke 2 .o comme ça => multiple def...
  - The convert_to workaround could be enabled even for all compilers ?
    It would simplify the code, but:  slow down ?  still work for Quotient ?
- Mariette dit que g++ 2.8.1 supporte pas
  Filtered_exact<Quotient<Gmpz>,Quotient<Gmpz>>.  A vérifier et corriger.
- Vérifier que EGCS optimise les expressions x*IA(1), IA(1)*x, x*IA(0), etc...
  C'est apparemment loin d'être le cas.  Il inline, mais laisse les tests...
  Il n'a pas l'air de propager les constantes à travers IA(1), même s'il
  inline !!!
- Refaire un petit coup de GCOV, pour voir où ça en est.
- Avoir un flag dynamic (static member) qui dit si exception ou pas, voire un
  function pointer pour overlap_action() ?
  Et modifier le comportement dans les fonctions save/restore ?
- essayer de mettre a et b "register", et voir le changement de l'assembly.
- converter (long longs), (long doubles)...  au moins documenter que c'est pas
  supporté pour le moment.  Hint: (double) +/- 1ulp.
? try if __attribute__((const)) for GNU on my operators is ok, and speed up ?
  what about putting it on predicates too ?
? Currently, some types (leda_*, GMP) need the rounding to nearest for doing
  the conversion to Interval.  That's bad because double doesn't, and is the
  case that must be optimized.  Maybe have a Tag for each NT saying if/how it
  needs the rounding to do the conversion ?
  Remark: the fast case is for the builtin types, so others (that care of the
  rounding mode) can be slowed down...
? SUN: Add "-Wa,-xarch=v8plus" to fix the following "error":
  /usr/ccs/bin/as: "/var/tmp/ccBHnU0T.s", line 861: warning: 3 instructions
  required between ldfsr and next FBfcc; nops inserted
  In which case is it produced ?  I can't see it anymore.

Concerning the script:

- Add determinant_signs.h to the list of filtered files ?  And send the 3
  lines to Stefan to add to the end of the original determinant.h.
- Produire un fichier avec juste les déclarations, et un autre avec les
  définitions, ça aidera à faire une library séparée de trucs précompilés.
- Add a comment for the parser script, e.g. /*No_Filter*/, because some
  predicates don't need to be filtered (compare_x, lexico,..)..
  Or try to guess when parsing ?  Anyway for the filtered constructions, the
  scheme will have to be rethought.
? Clean it up, and comment it...

Concerning the doc:

- change the status of homogeneous predicates when available...
- faire un fichier long_description comme ça doit se faire.
- Tell the status for Mips (the rounding mode).
- Tell the status for MipsPro (the workaround about partial specializations).
  (#define CGAL_IA_ET, CGAL_IA_CT... cf tst5.C).
- add a pointer to my MISC'99 paper.
- Document "IA::number_of_failures".
- Documenter le mécanisme de cache.

Concerning the test-suite:

- test-suite: rajouter un test simple qui vérifie que les exceptions marchent.
- Faire une test-suite un peu plus extensive des filtres.  En particulier les
  types templatés, etc...
- test new converter functions ?  [use flag -DCGAL_IA_DEBUG]
- test NaNs (and Infs?).  Comparisons with these should throw the exception...
  Et vérifier s'ils sont bien propagés correctement (par min/max, ou même *).
