- CLN: finish the wrapper(s) [and add the converters]. (+doc)
- Real/Expr: idem (?).  See also http://www.cs.nyu.edu/exact/core/.
- Implanter les optimisations suivantes compatibles IEEE 754 dans egcs:
  - (-a)*(-b) => a*b  (idem pour /)
  - (-a)>0    => a<0
  - (-a)+b    => b-a ...
  - (-a)*b    => -(a*b) ssi -ffast-math
  - bug à fixer: cf get_empiric_rounding_mode(), où "volatile" est nécessaire.
- Comment intégrer ces foutus pré-calculs ?  Faire un draft de propal.
- Implanter la propal pour modular ?
  Ça devra se faire un jour anyway, de porter le code au C++...
- Voir si on pourrait faire un filtre "static adaptatif" avec le NT d'Olivier
  qui calcule la borne d'erreur, et mes scripts (voir si y'a pas trop de
  branches, etc...).

Concerning the code itself:

- Vérifier si la version PPC contribuée par Pierre peut marcher sur
  Linux/glibc/*.
- Est-ce que les spécialisations doivent être sous CVS ?
- Essayer de bencher avec -fbranch-probabilities ?  Ça pourrait être pas mal.
- Expertiser le bench de Stefan.
- Stop constant propagation (could be considered a compiler bug, or at least
  misfeature).  It's not specific to Intel, it would be nice if egcs had
  better control over that (work on that ?).  It can easily be fixed by
  "CGAL_IA_FORCE_TO_DOUBLE" in the constructors.
- On Intel, due to lack of IEEE support, after each critical operation, I need
  to "CGAL_IA_FORCE_TO_DOUBLE".  Would be nice if egcs had a good option for
  that.  I should try/bench the other solution: use "long double" bounds.
- Drop the class Interval_nt ?
  Or have a boolean template parameter, instead or the derivation ?
- FPU_get_and_set_cw (), c'est plus joli, et ça peut être plus efficace.
- Filter_Cache: Faire des benchs, et une test-suite qui soit raisonnable.
  Hum, rajouter un booléen pour calculer le cache seulement sur demande ?
  (ça évite de le faire inutilement pour les variables intermédiaires,
  mais ça prend un chouia plus de place... mais en comparaison du reste...)
  Utiliser plutôt Tag_true/Tag_false si possible.
- sign_det_2x2() optimisé pour l'IA (+ bench de triangulation).
  (ça a l'air bien chiant, plutôt décrire vaguement dans la thèse, et
  implanter les filtres "statiques adaptatifs").
- Workarounds (pour MipsPro [et M$VC]):
  - specializations partielles: vérifier que c'est bien le bon CGAL_CFG_..
                                que j'utilise.
				NB: si on linke 2 .o comme ça => multiple def...
  - The convert_to workaround could be enabled even for all compilers ?
    It would simplify the code, but:  slow down ?  still work for Quotient ?
- Vérifier que EGCS optimise les expressions x*IA(1), IA(1)*x, x*IA(0), etc...
  C'est apparemment loin d'être le cas.  Il inline, mais laisse les tests...
  Il n'a pas l'air de propager les constantes à travers IA(1), même s'il
  inline !!!
- Avoir un flag dynamic (static member) qui dit si exception ou pas, voire un
  function pointer pour overlap_action() ?
  Et modifier le comportement dans les fonctions save/restore ?
- converter (long longs), (long doubles)...  au moins documenter que c'est pas
  supporté pour le moment.  Hint: (double) +/- 1ulp.
? try if __attribute__((const)) for GNU on my operators is ok, and speed up ?
  what about putting it on predicates too ?
? Currently, some types (leda_*, GMP) need the rounding to nearest for doing
  the conversion to Interval.  That's bad because double doesn't, and is the
  case that must be optimized.  Maybe have a Tag for each NT saying if/how it
  needs the rounding to do the conversion ?
  Remark: the fast case is for the builtin types, so others (that care of the
  rounding mode) can be slowed down...
? SUN: Add "-Wa,-xarch=v8plus" to fix the following "error":
  /usr/ccs/bin/as: "/var/tmp/ccBHnU0T.s", line 861: warning: 3 instructions
  required between ldfsr and next FBfcc; nops inserted
  In which case is it produced ?  I can't see it anymore.
- Sparc 64 support: dans glibc-2.1.1, il y a le patch suivant, qu'il
  conviendrait d'adapter (?):
    +#if __WORDSIZE == 64
    +/* Type of the control word.  */
    +typedef unsigned long fpu_control_t;
    +
    +#define _FPU_GETCW(cw) __asm__ ("stx %%fsr,%0" : "=m" (*&cw))
    +#define _FPU_SETCW(cw) __asm__ ("ldx %0,%%fsr" : : "m" (*&cw))
    +#else
- In the future: see the C++ Standard numeric_limits<>, section 18.2.

Concerning the script:

- Try to match the types "CGAL::Sign" ?
  et ne pas être pédantic sur les espaces qui manquent...
- Add a warning/check to the argument being "const".
- Add determinant_signs.h to the list of filtered files ?  And send the 3
  lines to Stefan to add to the end of the original determinant.h.
- Produire un fichier avec juste les déclarations, et un autre avec les
  définitions, ça aidera à faire une library séparée de trucs précompilés.
- Add a comment for the parser script, e.g. /*No_Filter*/, because some
  predicates don't need to be filtered (compare_x, lexico,..)..
  Or try to guess when parsing ?  Anyway for the filtered constructions, the
  scheme will have to be rethought.
? Clean it up, and comment it...

Concerning the doc:

- Dans la doc html de CGAL-2.0, mes enums sont répertoriés 2 fois dans
  l'index, sûrement un bug de cc_manual compliance de ma part.
  de même plus loin, ma fct to_double(Ia) n'est pas pareille que les autres.
- documenter une fonction CGAL::force_ieee_754_double_precision(), dans la
  doc, pour que le user puisse forcer sur __i386 si ça lui chante.  Dans la
  doc, à l'endroit de l'intro de la support library (rajouter un
  include/CGAL/FPU.h qui fasse juste ça ?)
- documenter le mécanisme pour les prédicats? Il me semblerait utile de
  rajouter une section d'introduction ou bien à la fin du chapitre, pour
  expliquer comment utiliser les filtres. Peut-être une référence à ton
  chapitre sur l'arithmétique d'intervalles...
- change the status of homogeneous predicates when available...
- add a pointer to my MISC'99 paper.
- Document "IA::number_of_failures".
- Documenter le mécanisme de cache.
- Documenter .exact(), .interval() et .value().
- Passer au nouveau format de doc.

Concerning the test-suite:

- CGAL_IA_DEBUG ne marche pas sur sparc (FPU_get_cw ne rend pas ce qu'il
  faut...).
- Refaire un petit coup de GCOV, pour voir où ça en est.
- test-suite: rajouter un test simple qui vérifie que les exceptions marchent.
- Faire une test-suite un peu plus extensive des filtres.  En particulier les
  types templatés, etc...
- test new converter functions ?  [use flag -DCGAL_IA_DEBUG]
- test NaNs (and Infs?).  Comparisons with these should throw the exception...
  Et vérifier s'ils sont bien propagés correctement (par min/max, ou même *).
