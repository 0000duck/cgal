- CLN: finish the wrapper(s) [and add the converters]. (+doc)
- Real/Expr: idem.  See also http://www.cs.nyu.edu/exact/core/.
- Implanter les optimisations suivantes compatibles IEEE 754 dans egcs:
  - (-a)*(-b) => a*b  (idem pour /)
  - (-a)>0    => a<0
  - (-a)+b    => b-a ...
  - (-a)*b    => -(a*b) ssi -ffast-math
  - bug à fixer: cf get_empiric_rounding_mode(), où "volatile" est nécessaire.
- Comment intégrer ces foutus pré-calculs ?  Faire un draft de propal.
- Faire aussi une propal pour include/CGAL/Predicates/*.

Concerning the code itself:

- Avoir un flag dynamic (static member) qui dit si exception ou pas, voire un
  function pointer pour overlap_action() ?
  Et modifier le comportement dans les fonctions save/restore ?
- MipsPro: Essayer de faire marcher (ask Michael).
- essayer de mettre a et b "register", et voir le changement de l'assembly.
- sign_det_2x2() optimisé pour l'IA (+ bench de triangulation).
- converter (long longs), (long doubles)...  au moins documenter que c'est pas
  supporté pour le moment.  Hint: (double) +/- 1ulp.
- Faire un testfile pour vérifier que la version assembleur est supportée.
  Tester IRIX5 profiterai aussi pour __SGI_ieeefp_h...
- Permettre de cacher (NT tag ?) les conversions en intervalles.
  C'est pas un cache, mais un stockage forcé, et il faut l'updater
  si la value est modifiée...
? try if __attribute__((const)) for GNU on my operators is ok, and speed up ?
  what about putting it on predicates too ?
? Currently, some types (leda_*, GMP) need the rounding to nearest for doing
  the conversion to Interval.  That's bad because double doesn't, and is the
  case that must be optimized.  Maybe have a Tag for each NT saying if/how it
  needs the rounding to do the conversion ?
  Remark: the fast case is for the builtin types, so others (that care of the
  rounding mode) can be slowed down...
? SUN: Add "-Wa,-xarch=v8plus" to fix the following "error":
  /usr/ccs/bin/as: "/var/tmp/ccBHnU0T.s", line 861: warning: 3 instructions
  required between ldfsr and next FBfcc; nops inserted
? Looker BIAS s'il utiliser l'assembleur pour Borland/MipsPro/SunPro/Visual...
  Visiblement, BIAS, c'est très nacze.
? -ffast-math (essayer la test/bench-suite, et lire la doc, c'est compatible?)

Concerning the script:

- Add the option to produce a complete specialization (for Mips, Visual...):
  remove the template, and instantiate for the given type, e.g.
  Filter<double,leda_real>.
- Add determinant_signs.h to the list of filtered files ?  And send the 3
  lines to Stefan to add to the end of the original determinant.h.
- Produire un fichier avec juste les déclarations, et un autre avec les
  définitions, ça aidera à faire une library séparée de trucs précompilés.
- Add a comment for the parser script, e.g. /*No_Filter*/, because some
  predicates don't need to be filtered (compare_x, lexico,..)..
  Or try to guess when parsing ?  Anyway for the filtered constructions, the
  scheme will have to be rethought.
? Clean it up, and comment it...

Concerning the doc:

- change the status of homogeneous predicates when available...
- faire un fichier long_description comme ça doit se faire.
- say we don't have Assembly on Mips by default (and change the code), but
  should work on IRIX 6.
- Document CGAL_IA_DONT_USE_ASSEMBLY which disables the use of assembly.  It's
  on by default, but is needed on IRIX 5.3 and its buggy assembler.  Will be
  the default solution till I have some machine language code.
  Or better, add a flag to the install procedure ?
- add a pointer to my MISC'99 paper.
- Documenter "IA::number_of_failures".

Concerning the test-suite:

- test new converter functions ?  [use flag -DCGAL_IA_DEBUG]
- test NaNs (and Infs?).  Comparisons with these should throw the exception...
  Et vérifier s'ils sont bien propagés correctement (par min/max, ou même *).
