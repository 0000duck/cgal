// ======================================================================
//
// Copyright (c) 1999,2000,2001 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/predicates/kernel_ftC2.h
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by
// scripts/filtered_predicates_generator.pl

#ifndef CGAL_ARITHMETIC_FILTER_PREDICATES_KERNEL_FTC2_H
#define CGAL_ARITHMETIC_FILTER_PREDICATES_KERNEL_FTC2_H

#include <CGAL/Profile_counter.h>

CGAL_BEGIN_NAMESPACE

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
bool
equal_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2c)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA equal_lineC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return equal_lineC2(
		l1a.interval(),
		l1b.interval(),
		l1c.interval(),
		l2a.interval(),
		l2b.interval(),
		l2c.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA equal_lineC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return equal_lineC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_equal_lineC2_6
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5,_epsilon_6;

  static bool update_epsilon(
	const Static_filter_error &l1a,
	const Static_filter_error &l1b,
	const Static_filter_error &l1c,
	const Static_filter_error &l2a,
	const Static_filter_error &l2b,
	const Static_filter_error &l2c,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3,
	double & epsilon_4,
	double & epsilon_5,
	double & epsilon_6)
  {
    typedef Static_filter_error FT;
  
      if (Static_Filtered_sign_of_determinant2x2_4::update_epsilon(l1a, l1b, l2a, l2b,
  		epsilon_0) != ZERO)
          return false; 
      CGAL::Sign s1a = CGAL_NTS Static_Filtered_sign_1::update_epsilon(l1a,
  		epsilon_1);
      if (s1a != ZERO)
          return s1a == CGAL_NTS Static_Filtered_sign_1::update_epsilon(l2a,
  		epsilon_2)
  	    && Static_Filtered_sign_of_determinant2x2_4::update_epsilon(l1a, l1c, l2a, l2c,
  		epsilon_3) == ZERO;
      return CGAL_NTS Static_Filtered_sign_1::update_epsilon(l1b,
  		epsilon_4) == CGAL_NTS Static_Filtered_sign_1::update_epsilon(l2b,
  		epsilon_5)
  	&& Static_Filtered_sign_of_determinant2x2_4::update_epsilon(l1b, l1c, l2b, l2c,
  		epsilon_6) == ZERO;
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5,_epsilon_6);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static bool epsilon_variant(
	const Restricted_double &l1a,
	const Restricted_double &l1b,
	const Restricted_double &l1c,
	const Restricted_double &l2a,
	const Restricted_double &l2b,
	const Restricted_double &l2c,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3,
	const double & epsilon_4,
	const double & epsilon_5,
	const double & epsilon_6)
  {
    typedef Restricted_double FT;
  
      if (Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(l1a, l1b, l2a, l2b,
  		epsilon_0) != ZERO)
          return false; 
      CGAL::Sign s1a = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l1a,
  		epsilon_1);
      if (s1a != ZERO)
          return s1a == CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l2a,
  		epsilon_2)
  	    && Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(l1a, l1c, l2a, l2c,
  		epsilon_3) == ZERO;
      return CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l1b,
  		epsilon_4) == CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l2b,
  		epsilon_5)
  	&& Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(l1b, l1c, l2b, l2c,
  		epsilon_6) == ZERO;
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
bool
equal_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2c)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_equal_lineC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(l1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2c.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA equal_lineC2 updates");
    ++updates;
#endif
    Static_Filtered_equal_lineC2_6::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA equal_lineC2 calls");
    ++calls;
#endif
    return Static_Filtered_equal_lineC2_6::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		Static_Filtered_equal_lineC2_6::_epsilon_0,
		Static_Filtered_equal_lineC2_6::_epsilon_1,
		Static_Filtered_equal_lineC2_6::_epsilon_2,
		Static_Filtered_equal_lineC2_6::_epsilon_3,
		Static_Filtered_equal_lineC2_6::_epsilon_4,
		Static_Filtered_equal_lineC2_6::_epsilon_5,
		Static_Filtered_equal_lineC2_6::_epsilon_6);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA equal_lineC2 failures");
    ++failures;
#endif
    return equal_lineC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
bool
equal_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2c)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_equal_lineC2_6::_bound; )
  CGAL_assertion(!(
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST equal_lineC2 calls");
    ++calls;
#endif
    return Static_Filtered_equal_lineC2_6::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		Static_Filtered_equal_lineC2_6::_epsilon_0,
		Static_Filtered_equal_lineC2_6::_epsilon_1,
		Static_Filtered_equal_lineC2_6::_epsilon_2,
		Static_Filtered_equal_lineC2_6::_epsilon_3,
		Static_Filtered_equal_lineC2_6::_epsilon_4,
		Static_Filtered_equal_lineC2_6::_epsilon_5,
		Static_Filtered_equal_lineC2_6::_epsilon_6);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST equal_lineC2 failures");
    ++failures;
#endif
    return equal_lineC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lc,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &hb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &hc)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_xC2(
		px.interval(),
		la.interval(),
		lb.interval(),
		lc.interval(),
		ha.interval(),
		hb.interval(),
		hc.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_xC2(
		px.exact(),
		la.exact(),
		lb.exact(),
		lc.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_xC2_7
{
  static double _bound;
  static double _epsilon_0,_epsilon_1;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &la,
	const Static_filter_error &lb,
	const Static_filter_error &lc,
	const Static_filter_error &ha,
	const Static_filter_error &hb,
	const Static_filter_error &hc,
	double & epsilon_0,
	double & epsilon_1)
  {
    typedef Static_filter_error FT;
  
    
    FT num = det2x2_by_formula( lb, lc, hb, hc);
    FT den = det2x2_by_formula( la, lb, ha, hb);
    Sign s = CGAL_NTS Static_Filtered_sign_1::update_epsilon(den,
  		epsilon_0);
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result( s * CGAL_NTS Static_Filtered_compare_2::update_epsilon( px * den, num,
  		epsilon_1) );
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,_epsilon_0,_epsilon_1);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &la,
	const Restricted_double &lb,
	const Restricted_double &lc,
	const Restricted_double &ha,
	const Restricted_double &hb,
	const Restricted_double &hc,
	const double & epsilon_0,
	const double & epsilon_1)
  {
    typedef Restricted_double FT;
  
    
    FT num = det2x2_by_formula( lb, lc, hb, hc);
    FT den = det2x2_by_formula( la, lb, ha, hb);
    Sign s = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(den,
  		epsilon_0);
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result( s * CGAL_NTS Static_Filtered_compare_2::epsilon_variant( px * den, num,
  		epsilon_1) );
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lc,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &hb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &hc)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_xC2_7::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(lc.to_double()) > SAF_bound ||
	fabs(ha.to_double()) > SAF_bound ||
	fabs(hb.to_double()) > SAF_bound ||
	fabs(hc.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(la.to_double()));
    NEW_bound = max(NEW_bound, fabs(lb.to_double()));
    NEW_bound = max(NEW_bound, fabs(lc.to_double()));
    NEW_bound = max(NEW_bound, fabs(ha.to_double()));
    NEW_bound = max(NEW_bound, fabs(hb.to_double()));
    NEW_bound = max(NEW_bound, fabs(hc.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_xC2_7::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_xC2_7::epsilon_variant(
		px.dbl(),
		la.dbl(),
		lb.dbl(),
		lc.dbl(),
		ha.dbl(),
		hb.dbl(),
		hc.dbl(),
		Static_Filtered_compare_xC2_7::_epsilon_0,
		Static_Filtered_compare_xC2_7::_epsilon_1);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_xC2 failures");
    ++failures;
#endif
    return compare_xC2(
		px.exact(),
		la.exact(),
		lb.exact(),
		lc.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lc,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &hb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &hc)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_xC2_7::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(lc.to_double()) > SAF_bound ||
	fabs(ha.to_double()) > SAF_bound ||
	fabs(hb.to_double()) > SAF_bound ||
	fabs(hc.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_xC2_7::epsilon_variant(
		px.dbl(),
		la.dbl(),
		lb.dbl(),
		lc.dbl(),
		ha.dbl(),
		hb.dbl(),
		hc.dbl(),
		Static_Filtered_compare_xC2_7::_epsilon_0,
		Static_Filtered_compare_xC2_7::_epsilon_1);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_xC2 failures");
    ++failures;
#endif
    return compare_xC2(
		px.exact(),
		la.exact(),
		lb.exact(),
		lc.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lc,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2c)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_xC2(
		la.interval(),
		lb.interval(),
		lc.interval(),
		h1a.interval(),
		h1b.interval(),
		h1c.interval(),
		h2a.interval(),
		h2b.interval(),
		h2c.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_xC2(
		la.exact(),
		lb.exact(),
		lc.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_xC2_9
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3;

  static Comparison_result update_epsilon(
	const Static_filter_error &la,
	const Static_filter_error &lb,
	const Static_filter_error &lc,
	const Static_filter_error &h1a,
	const Static_filter_error &h1b,
	const Static_filter_error &h1c,
	const Static_filter_error &h2a,
	const Static_filter_error &h2b,
	const Static_filter_error &h2c,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3)
  {
    typedef Static_filter_error FT;
  
    
    FT num1 = det2x2_by_formula( la, lc, h1a, h1c);
    FT num2 = det2x2_by_formula( la, lc, h2a, h2c);
    FT num  = det2x2_by_formula(h1a,h1c,h2a,h2c)*lb
              + det2x2_by_formula(num1,num2,h1b,h2b);
    FT den1 = det2x2_by_formula( la, lb, h1a, h1b);
    FT den2 = det2x2_by_formula( la, lb, h2a, h2b);
    return Comparison_result( CGAL_NTS Static_Filtered_sign_1::update_epsilon(lb,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::update_epsilon(num,
  		epsilon_1) *
                              CGAL_NTS Static_Filtered_sign_1::update_epsilon(den1,
  		epsilon_2) * CGAL_NTS Static_Filtered_sign_1::update_epsilon(den2,
  		epsilon_3));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &la,
	const Restricted_double &lb,
	const Restricted_double &lc,
	const Restricted_double &h1a,
	const Restricted_double &h1b,
	const Restricted_double &h1c,
	const Restricted_double &h2a,
	const Restricted_double &h2b,
	const Restricted_double &h2c,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3)
  {
    typedef Restricted_double FT;
  
    
    FT num1 = det2x2_by_formula( la, lc, h1a, h1c);
    FT num2 = det2x2_by_formula( la, lc, h2a, h2c);
    FT num  = det2x2_by_formula(h1a,h1c,h2a,h2c)*lb
              + det2x2_by_formula(num1,num2,h1b,h2b);
    FT den1 = det2x2_by_formula( la, lb, h1a, h1b);
    FT den2 = det2x2_by_formula( la, lb, h2a, h2b);
    return Comparison_result( CGAL_NTS Static_Filtered_sign_1::epsilon_variant(lb,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(num,
  		epsilon_1) *
                              CGAL_NTS Static_Filtered_sign_1::epsilon_variant(den1,
  		epsilon_2) * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(den2,
  		epsilon_3));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lc,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2c)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_xC2_9::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(lc.to_double()) > SAF_bound ||
	fabs(h1a.to_double()) > SAF_bound ||
	fabs(h1b.to_double()) > SAF_bound ||
	fabs(h1c.to_double()) > SAF_bound ||
	fabs(h2a.to_double()) > SAF_bound ||
	fabs(h2b.to_double()) > SAF_bound ||
	fabs(h2c.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(la.to_double()));
    NEW_bound = max(NEW_bound, fabs(lb.to_double()));
    NEW_bound = max(NEW_bound, fabs(lc.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2c.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_xC2_9::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_xC2_9::epsilon_variant(
		la.dbl(),
		lb.dbl(),
		lc.dbl(),
		h1a.dbl(),
		h1b.dbl(),
		h1c.dbl(),
		h2a.dbl(),
		h2b.dbl(),
		h2c.dbl(),
		Static_Filtered_compare_xC2_9::_epsilon_0,
		Static_Filtered_compare_xC2_9::_epsilon_1,
		Static_Filtered_compare_xC2_9::_epsilon_2,
		Static_Filtered_compare_xC2_9::_epsilon_3);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_xC2 failures");
    ++failures;
#endif
    return compare_xC2(
		la.exact(),
		lb.exact(),
		lc.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lc,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2c)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_xC2_9::_bound; )
  CGAL_assertion(!(
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(lc.to_double()) > SAF_bound ||
	fabs(h1a.to_double()) > SAF_bound ||
	fabs(h1b.to_double()) > SAF_bound ||
	fabs(h1c.to_double()) > SAF_bound ||
	fabs(h2a.to_double()) > SAF_bound ||
	fabs(h2b.to_double()) > SAF_bound ||
	fabs(h2c.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_xC2_9::epsilon_variant(
		la.dbl(),
		lb.dbl(),
		lc.dbl(),
		h1a.dbl(),
		h1b.dbl(),
		h1c.dbl(),
		h2a.dbl(),
		h2b.dbl(),
		h2c.dbl(),
		Static_Filtered_compare_xC2_9::_epsilon_0,
		Static_Filtered_compare_xC2_9::_epsilon_1,
		Static_Filtered_compare_xC2_9::_epsilon_2,
		Static_Filtered_compare_xC2_9::_epsilon_3);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_xC2 failures");
    ++failures;
#endif
    return compare_xC2(
		la.exact(),
		lb.exact(),
		lc.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2c)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_xC2(
		l1a.interval(),
		l1b.interval(),
		l1c.interval(),
		h1a.interval(),
		h1b.interval(),
		h1c.interval(),
		l2a.interval(),
		l2b.interval(),
		l2c.interval(),
		h2a.interval(),
		h2b.interval(),
		h2c.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_xC2_12
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2;

  static Comparison_result update_epsilon(
	const Static_filter_error &l1a,
	const Static_filter_error &l1b,
	const Static_filter_error &l1c,
	const Static_filter_error &h1a,
	const Static_filter_error &h1b,
	const Static_filter_error &h1c,
	const Static_filter_error &l2a,
	const Static_filter_error &l2b,
	const Static_filter_error &l2c,
	const Static_filter_error &h2a,
	const Static_filter_error &h2b,
	const Static_filter_error &h2c,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2)
  {
    typedef Static_filter_error FT;
  
    FT num1 = det2x2_by_formula( l1b, l1c, h1b, h1c);
    FT den1 = det2x2_by_formula( l1a, l1b, h1a, h1b);
    FT num2 = det2x2_by_formula( l2b, l2c, h2b, h2c);
    FT den2 = det2x2_by_formula( l2a, l2b, h2a, h2b);
    Sign s = Sign (CGAL_NTS Static_Filtered_sign_1::update_epsilon(den1,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::update_epsilon(den2,
  		epsilon_1));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result( s * Static_Filtered_sign_of_determinant2x2_4::update_epsilon(num1, num2,
  			                               den1, den2,
  		epsilon_2));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &l1a,
	const Restricted_double &l1b,
	const Restricted_double &l1c,
	const Restricted_double &h1a,
	const Restricted_double &h1b,
	const Restricted_double &h1c,
	const Restricted_double &l2a,
	const Restricted_double &l2b,
	const Restricted_double &l2c,
	const Restricted_double &h2a,
	const Restricted_double &h2b,
	const Restricted_double &h2c,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2)
  {
    typedef Restricted_double FT;
  
    FT num1 = det2x2_by_formula( l1b, l1c, h1b, h1c);
    FT den1 = det2x2_by_formula( l1a, l1b, h1a, h1b);
    FT num2 = det2x2_by_formula( l2b, l2c, h2b, h2c);
    FT den2 = det2x2_by_formula( l2a, l2b, h2a, h2b);
    Sign s = Sign (CGAL_NTS Static_Filtered_sign_1::epsilon_variant(den1,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(den2,
  		epsilon_1));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result( s * Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(num1, num2,
  			                               den1, den2,
  		epsilon_2));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2c)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_xC2_12::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(h1a.to_double()) > SAF_bound ||
	fabs(h1b.to_double()) > SAF_bound ||
	fabs(h1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound ||
	fabs(h2a.to_double()) > SAF_bound ||
	fabs(h2b.to_double()) > SAF_bound ||
	fabs(h2c.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(l1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2c.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2c.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_xC2_12::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_xC2_12::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		h1a.dbl(),
		h1b.dbl(),
		h1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		h2a.dbl(),
		h2b.dbl(),
		h2c.dbl(),
		Static_Filtered_compare_xC2_12::_epsilon_0,
		Static_Filtered_compare_xC2_12::_epsilon_1,
		Static_Filtered_compare_xC2_12::_epsilon_2);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_xC2 failures");
    ++failures;
#endif
    return compare_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2c)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_xC2_12::_bound; )
  CGAL_assertion(!(
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(h1a.to_double()) > SAF_bound ||
	fabs(h1b.to_double()) > SAF_bound ||
	fabs(h1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound ||
	fabs(h2a.to_double()) > SAF_bound ||
	fabs(h2b.to_double()) > SAF_bound ||
	fabs(h2c.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_xC2_12::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		h1a.dbl(),
		h1b.dbl(),
		h1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		h2a.dbl(),
		h2b.dbl(),
		h2c.dbl(),
		Static_Filtered_compare_xC2_12::_epsilon_0,
		Static_Filtered_compare_xC2_12::_epsilon_1,
		Static_Filtered_compare_xC2_12::_epsilon_2);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_xC2 failures");
    ++failures;
#endif
    return compare_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lc)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_y_at_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_y_at_xC2(
		px.interval(),
		py.interval(),
		la.interval(),
		lb.interval(),
		lc.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_y_at_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_y_at_xC2(
		px.exact(),
		py.exact(),
		la.exact(),
		lb.exact(),
		lc.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_y_at_xC2_5
{
  static double _bound;
  static double _epsilon_0,_epsilon_1;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &la,
	const Static_filter_error &lb,
	const Static_filter_error &lc,
	double & epsilon_0,
	double & epsilon_1)
  {
    typedef Static_filter_error FT;
  
    Sign s = CGAL_NTS Static_Filtered_sign_1::update_epsilon(lb,
  		epsilon_0);
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result (s * CGAL_NTS Static_Filtered_sign_1::update_epsilon(la*px + lb*py + lc,
  		epsilon_1));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,_epsilon_0,_epsilon_1);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &la,
	const Restricted_double &lb,
	const Restricted_double &lc,
	const double & epsilon_0,
	const double & epsilon_1)
  {
    typedef Restricted_double FT;
  
    Sign s = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(lb,
  		epsilon_0);
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result (s * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(la*px + lb*py + lc,
  		epsilon_1));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lc)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_y_at_xC2_5::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(lc.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(la.to_double()));
    NEW_bound = max(NEW_bound, fabs(lb.to_double()));
    NEW_bound = max(NEW_bound, fabs(lc.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_y_at_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_y_at_xC2_5::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_5::epsilon_variant(
		px.dbl(),
		py.dbl(),
		la.dbl(),
		lb.dbl(),
		lc.dbl(),
		Static_Filtered_compare_y_at_xC2_5::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_5::_epsilon_1);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		px.exact(),
		py.exact(),
		la.exact(),
		lb.exact(),
		lc.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lc)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_y_at_xC2_5::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(lc.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_5::epsilon_variant(
		px.dbl(),
		py.dbl(),
		la.dbl(),
		lb.dbl(),
		lc.dbl(),
		Static_Filtered_compare_y_at_xC2_5::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_5::_epsilon_1);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		px.exact(),
		py.exact(),
		la.exact(),
		lb.exact(),
		lc.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2c)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_y_at_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_y_at_xC2(
		px.interval(),
		l1a.interval(),
		l1b.interval(),
		l1c.interval(),
		l2a.interval(),
		l2b.interval(),
		l2c.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_y_at_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_y_at_xC2(
		px.exact(),
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_y_at_xC2_7
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &l1a,
	const Static_filter_error &l1b,
	const Static_filter_error &l1c,
	const Static_filter_error &l2a,
	const Static_filter_error &l2b,
	const Static_filter_error &l2c,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2)
  {
    typedef Static_filter_error FT;
  
    Sign s = Sign (CGAL_NTS Static_Filtered_sign_1::update_epsilon(l1b,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::update_epsilon(l2b,
  		epsilon_1));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result ( s * Static_Filtered_sign_of_determinant2x2_4::update_epsilon(l2a*px+l2c, l2b,
                                                          l1a*px+l1c, l1b,
  		epsilon_2));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &l1a,
	const Restricted_double &l1b,
	const Restricted_double &l1c,
	const Restricted_double &l2a,
	const Restricted_double &l2b,
	const Restricted_double &l2c,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2)
  {
    typedef Restricted_double FT;
  
    Sign s = Sign (CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l1b,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l2b,
  		epsilon_1));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result ( s * Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(l2a*px+l2c, l2b,
                                                          l1a*px+l1c, l1b,
  		epsilon_2));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2c)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_y_at_xC2_7::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2c.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_y_at_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_y_at_xC2_7::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_7::epsilon_variant(
		px.dbl(),
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		Static_Filtered_compare_y_at_xC2_7::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_7::_epsilon_1,
		Static_Filtered_compare_y_at_xC2_7::_epsilon_2);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		px.exact(),
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2c)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_y_at_xC2_7::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_7::epsilon_variant(
		px.dbl(),
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		Static_Filtered_compare_y_at_xC2_7::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_7::_epsilon_1,
		Static_Filtered_compare_y_at_xC2_7::_epsilon_2);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		px.exact(),
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &hb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &hc)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_y_at_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_y_at_xC2(
		l1a.interval(),
		l1b.interval(),
		l1c.interval(),
		l2a.interval(),
		l2b.interval(),
		l2c.interval(),
		ha.interval(),
		hb.interval(),
		hc.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_y_at_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_y_at_xC2_9
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2;

  static Comparison_result update_epsilon(
	const Static_filter_error &l1a,
	const Static_filter_error &l1b,
	const Static_filter_error &l1c,
	const Static_filter_error &l2a,
	const Static_filter_error &l2b,
	const Static_filter_error &l2c,
	const Static_filter_error &ha,
	const Static_filter_error &hb,
	const Static_filter_error &hc,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2)
  {
    typedef Static_filter_error FT;
  
    Sign s = Sign (Static_Filtered_sign_of_determinant2x2_4::update_epsilon(l1a, l1b, l2a, l2b,
  		epsilon_0) *
  		 CGAL_NTS Static_Filtered_sign_1::update_epsilon(hb,
  		epsilon_1));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result( s * Static_Filtered_sign_of_determinant3x3_9::update_epsilon(l1a, l1b, l1c,
                                                         l2a, l2b, l2c,
                                                         ha,  hb,  hc,
  		epsilon_2));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &l1a,
	const Restricted_double &l1b,
	const Restricted_double &l1c,
	const Restricted_double &l2a,
	const Restricted_double &l2b,
	const Restricted_double &l2c,
	const Restricted_double &ha,
	const Restricted_double &hb,
	const Restricted_double &hc,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2)
  {
    typedef Restricted_double FT;
  
    Sign s = Sign (Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(l1a, l1b, l2a, l2b,
  		epsilon_0) *
  		 CGAL_NTS Static_Filtered_sign_1::epsilon_variant(hb,
  		epsilon_1));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result( s * Static_Filtered_sign_of_determinant3x3_9::epsilon_variant(l1a, l1b, l1c,
                                                         l2a, l2b, l2c,
                                                         ha,  hb,  hc,
  		epsilon_2));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &hb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &hc)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_y_at_xC2_9::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound ||
	fabs(ha.to_double()) > SAF_bound ||
	fabs(hb.to_double()) > SAF_bound ||
	fabs(hc.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(l1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2c.to_double()));
    NEW_bound = max(NEW_bound, fabs(ha.to_double()));
    NEW_bound = max(NEW_bound, fabs(hb.to_double()));
    NEW_bound = max(NEW_bound, fabs(hc.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_y_at_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_y_at_xC2_9::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_9::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		ha.dbl(),
		hb.dbl(),
		hc.dbl(),
		Static_Filtered_compare_y_at_xC2_9::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_9::_epsilon_1,
		Static_Filtered_compare_y_at_xC2_9::_epsilon_2);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &hb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &hc)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_y_at_xC2_9::_bound; )
  CGAL_assertion(!(
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound ||
	fabs(ha.to_double()) > SAF_bound ||
	fabs(hb.to_double()) > SAF_bound ||
	fabs(hc.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_9::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		ha.dbl(),
		hb.dbl(),
		hc.dbl(),
		Static_Filtered_compare_y_at_xC2_9::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_9::_epsilon_1,
		Static_Filtered_compare_y_at_xC2_9::_epsilon_2);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &h2c)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_y_at_xC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_y_at_xC2(
		l1a.interval(),
		l1b.interval(),
		l1c.interval(),
		l2a.interval(),
		l2b.interval(),
		l2c.interval(),
		h1a.interval(),
		h1b.interval(),
		h1c.interval(),
		h2a.interval(),
		h2b.interval(),
		h2c.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_y_at_xC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_y_at_xC2_12
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3;

  static Comparison_result update_epsilon(
	const Static_filter_error &l1a,
	const Static_filter_error &l1b,
	const Static_filter_error &l1c,
	const Static_filter_error &l2a,
	const Static_filter_error &l2b,
	const Static_filter_error &l2c,
	const Static_filter_error &h1a,
	const Static_filter_error &h1b,
	const Static_filter_error &h1c,
	const Static_filter_error &h2a,
	const Static_filter_error &h2b,
	const Static_filter_error &h2c,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3)
  {
    typedef Static_filter_error FT;
  
    
    FT num = det2x2_by_formula( l1b, l1c, l2b, l2c);
    FT den = det2x2_by_formula( l1a, l1b, l2a, l2b);
    Sign s = Sign (CGAL_NTS Static_Filtered_sign_1::update_epsilon(h1b,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::update_epsilon(h2b,
  		epsilon_1) * CGAL_NTS Static_Filtered_sign_1::update_epsilon(den,
  		epsilon_2));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result ( s * Static_Filtered_sign_of_determinant2x2_4::update_epsilon(h2a*num+h2c*den, h2b,
                                                          h1a*num+h1c*den, h1b,
  		epsilon_3));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &l1a,
	const Restricted_double &l1b,
	const Restricted_double &l1c,
	const Restricted_double &l2a,
	const Restricted_double &l2b,
	const Restricted_double &l2c,
	const Restricted_double &h1a,
	const Restricted_double &h1b,
	const Restricted_double &h1c,
	const Restricted_double &h2a,
	const Restricted_double &h2b,
	const Restricted_double &h2c,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3)
  {
    typedef Restricted_double FT;
  
    
    FT num = det2x2_by_formula( l1b, l1c, l2b, l2c);
    FT den = det2x2_by_formula( l1a, l1b, l2a, l2b);
    Sign s = Sign (CGAL_NTS Static_Filtered_sign_1::epsilon_variant(h1b,
  		epsilon_0) * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(h2b,
  		epsilon_1) * CGAL_NTS Static_Filtered_sign_1::epsilon_variant(den,
  		epsilon_2));
    CGAL_kernel_assertion( s != ZERO );
    return Comparison_result ( s * Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(h2a*num+h2c*den, h2b,
                                                          h1a*num+h1c*den, h1b,
  		epsilon_3));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &h2c)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_y_at_xC2_12::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound ||
	fabs(h1a.to_double()) > SAF_bound ||
	fabs(h1b.to_double()) > SAF_bound ||
	fabs(h1c.to_double()) > SAF_bound ||
	fabs(h2a.to_double()) > SAF_bound ||
	fabs(h2b.to_double()) > SAF_bound ||
	fabs(h2c.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(l1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2c.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(h1c.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2b.to_double()));
    NEW_bound = max(NEW_bound, fabs(h2c.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_y_at_xC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_y_at_xC2_12::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_12::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		h1a.dbl(),
		h1b.dbl(),
		h1c.dbl(),
		h2a.dbl(),
		h2b.dbl(),
		h2c.dbl(),
		Static_Filtered_compare_y_at_xC2_12::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_12::_epsilon_1,
		Static_Filtered_compare_y_at_xC2_12::_epsilon_2,
		Static_Filtered_compare_y_at_xC2_12::_epsilon_3);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_xC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h1c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &h2c)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_y_at_xC2_12::_bound; )
  CGAL_assertion(!(
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l1c.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound ||
	fabs(l2c.to_double()) > SAF_bound ||
	fabs(h1a.to_double()) > SAF_bound ||
	fabs(h1b.to_double()) > SAF_bound ||
	fabs(h1c.to_double()) > SAF_bound ||
	fabs(h2a.to_double()) > SAF_bound ||
	fabs(h2b.to_double()) > SAF_bound ||
	fabs(h2c.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_y_at_xC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_xC2_12::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l1c.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		l2c.dbl(),
		h1a.dbl(),
		h1b.dbl(),
		h1c.dbl(),
		h2a.dbl(),
		h2b.dbl(),
		h2c.dbl(),
		Static_Filtered_compare_y_at_xC2_12::_epsilon_0,
		Static_Filtered_compare_y_at_xC2_12::_epsilon_1,
		Static_Filtered_compare_y_at_xC2_12::_epsilon_2,
		Static_Filtered_compare_y_at_xC2_12::_epsilon_3);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_y_at_xC2 failures");
    ++failures;
#endif
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_x_segment_C2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1sy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1ty,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2sy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2ty)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_y_at_x_segment_C2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_y_at_x_segment_C2(
		px.interval(),
		s1sx.interval(),
		s1sy.interval(),
		s1tx.interval(),
		s1ty.interval(),
		s2sx.interval(),
		s2sy.interval(),
		s2tx.interval(),
		s2ty.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_y_at_x_segment_C2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_y_at_x_segment_C2(
		px.exact(),
		s1sx.exact(),
		s1sy.exact(),
		s1tx.exact(),
		s1ty.exact(),
		s2sx.exact(),
		s2sy.exact(),
		s2tx.exact(),
		s2ty.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_y_at_x_segment_C2_9
{
  static double _bound;
  static double ;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &s1sx,
	const Static_filter_error &s1sy,
	const Static_filter_error &s1tx,
	const Static_filter_error &s1ty,
	const Static_filter_error &s2sx,
	const Static_filter_error &s2sy,
	const Static_filter_error &s2tx,
	const Static_filter_error &s2ty,)
  {
    typedef Static_filter_error FT;
  
      
      
      
      
      
  
      CGAL_kernel_precondition(px >= min(s1sx, s1tx) && px <= max(s1sx, s1tx));
      CGAL_kernel_precondition(px >= min(s2sx, s2tx) && px <= max(s2sx, s2tx));
  
      if (s1sx != s1tx && s2sx != s2tx) {
  	FT s1stx = s1sx-s1tx;
  	FT s2stx = s2sx-s2tx;
  
  	return Comparison_result(
  	    CGAL_NTS Static_Filtered_compare_2::update_epsilon(s1sx, s1tx,
  		epsilon_0) *
  	    CGAL_NTS Static_Filtered_compare_2::update_epsilon(s2sx, s2tx,
  		epsilon_1) *
  	    CGAL_NTS Static_Filtered_compare_2::update_epsilon(-(s1sx-px)*(s1sy-s1ty)*s2stx,
  		             (s2sy-s1sy)*s2stx*s1stx
  		             -(s2sx-px)*(s2sy-s2ty)*s1stx ,
  		epsilon_2));
      }
      else {
  	if (s1sx == s1tx) { 
  	    Comparison_result c1, c2;
  	    c1 = Static_Filtered_compare_y_at_xC2_6::update_epsilon(px, s1sy, s2sx, s2sy, s2tx, s2ty,
  		epsilon_);
  	    c2 = Static_Filtered_compare_y_at_xC2_6::update_epsilon(px, s1ty, s2sx, s2sy, s2tx, s2ty,
  		epsilon_);
  	    if (c1 == c2)
  		return c1;
  	    return EQUAL;
  	}
  	
  	Comparison_result c3, c4;
  	c3 = Static_Filtered_compare_y_at_xC2_6::update_epsilon(px, s2sy, s1sx, s1sy, s1tx, s1ty,
  		epsilon_);
  	c4 = Static_Filtered_compare_y_at_xC2_6::update_epsilon(px, s2ty, s1sx, s1sy, s1tx, s1ty,
  		epsilon_);
  	if (c3 == c4)
  	    return opposite(c3);
  	return EQUAL;
      }
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &s1sx,
	const Restricted_double &s1sy,
	const Restricted_double &s1tx,
	const Restricted_double &s1ty,
	const Restricted_double &s2sx,
	const Restricted_double &s2sy,
	const Restricted_double &s2tx,
	const Restricted_double &s2ty,)
  {
    typedef Restricted_double FT;
  
      
      
      
      
      
  
      CGAL_kernel_precondition(px >= min(s1sx, s1tx) && px <= max(s1sx, s1tx));
      CGAL_kernel_precondition(px >= min(s2sx, s2tx) && px <= max(s2sx, s2tx));
  
      if (s1sx != s1tx && s2sx != s2tx) {
  	FT s1stx = s1sx-s1tx;
  	FT s2stx = s2sx-s2tx;
  
  	return Comparison_result(
  	    CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s1sx, s1tx,
  		epsilon_0) *
  	    CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s2sx, s2tx,
  		epsilon_1) *
  	    CGAL_NTS Static_Filtered_compare_2::epsilon_variant(-(s1sx-px)*(s1sy-s1ty)*s2stx,
  		             (s2sy-s1sy)*s2stx*s1stx
  		             -(s2sx-px)*(s2sy-s2ty)*s1stx ,
  		epsilon_2));
      }
      else {
  	if (s1sx == s1tx) { 
  	    Comparison_result c1, c2;
  	    c1 = Static_Filtered_compare_y_at_xC2_6::epsilon_variant(px, s1sy, s2sx, s2sy, s2tx, s2ty,
  		epsilon_);
  	    c2 = Static_Filtered_compare_y_at_xC2_6::epsilon_variant(px, s1ty, s2sx, s2sy, s2tx, s2ty,
  		epsilon_);
  	    if (c1 == c2)
  		return c1;
  	    return EQUAL;
  	}
  	
  	Comparison_result c3, c4;
  	c3 = Static_Filtered_compare_y_at_xC2_6::epsilon_variant(px, s2sy, s1sx, s1sy, s1tx, s1ty,
  		epsilon_);
  	c4 = Static_Filtered_compare_y_at_xC2_6::epsilon_variant(px, s2ty, s1sx, s1sy, s1tx, s1ty,
  		epsilon_);
  	if (c3 == c4)
  	    return opposite(c3);
  	return EQUAL;
      }
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_x_segment_C2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1sy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1ty,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2sy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2ty)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_y_at_x_segment_C2_9::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(s1sx.to_double()) > SAF_bound ||
	fabs(s1sy.to_double()) > SAF_bound ||
	fabs(s1tx.to_double()) > SAF_bound ||
	fabs(s1ty.to_double()) > SAF_bound ||
	fabs(s2sx.to_double()) > SAF_bound ||
	fabs(s2sy.to_double()) > SAF_bound ||
	fabs(s2tx.to_double()) > SAF_bound ||
	fabs(s2ty.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1sx.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1sy.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1tx.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1ty.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2sx.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2sy.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2tx.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2ty.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_y_at_x_segment_C2 updates");
    ++updates;
#endif
    Static_Filtered_compare_y_at_x_segment_C2_9::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_y_at_x_segment_C2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_x_segment_C2_9::epsilon_variant(
		px.dbl(),
		s1sx.dbl(),
		s1sy.dbl(),
		s1tx.dbl(),
		s1ty.dbl(),
		s2sx.dbl(),
		s2sy.dbl(),
		s2tx.dbl(),
		s2ty.dbl(),);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_y_at_x_segment_C2 failures");
    ++failures;
#endif
    return compare_y_at_x_segment_C2(
		px.exact(),
		s1sx.exact(),
		s1sy.exact(),
		s1tx.exact(),
		s1ty.exact(),
		s2sx.exact(),
		s2sy.exact(),
		s2tx.exact(),
		s2ty.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Comparison_result
compare_y_at_x_segment_C2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1sy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1ty,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2sy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2ty)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_y_at_x_segment_C2_9::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(s1sx.to_double()) > SAF_bound ||
	fabs(s1sy.to_double()) > SAF_bound ||
	fabs(s1tx.to_double()) > SAF_bound ||
	fabs(s1ty.to_double()) > SAF_bound ||
	fabs(s2sx.to_double()) > SAF_bound ||
	fabs(s2sy.to_double()) > SAF_bound ||
	fabs(s2tx.to_double()) > SAF_bound ||
	fabs(s2ty.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_y_at_x_segment_C2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_y_at_x_segment_C2_9::epsilon_variant(
		px.dbl(),
		s1sx.dbl(),
		s1sy.dbl(),
		s1tx.dbl(),
		s1ty.dbl(),
		s2sx.dbl(),
		s2sy.dbl(),
		s2tx.dbl(),
		s2ty.dbl(),);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_y_at_x_segment_C2 failures");
    ++failures;
#endif
    return compare_y_at_x_segment_C2(
		px.exact(),
		s1sx.exact(),
		s1sy.exact(),
		s1tx.exact(),
		s1ty.exact(),
		s2sx.exact(),
		s2sy.exact(),
		s2tx.exact(),
		s2ty.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
bool
equal_directionC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &dx1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &dy1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &dx2,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &dy2)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA equal_directionC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return equal_directionC2(
		dx1.interval(),
		dy1.interval(),
		dx2.interval(),
		dy2.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA equal_directionC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return equal_directionC2(
		dx1.exact(),
		dy1.exact(),
		dx2.exact(),
		dy2.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_equal_directionC2_4
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4;

  static bool update_epsilon(
	const Static_filter_error &dx1,
	const Static_filter_error &dy1,
	const Static_filter_error &dx2,
	const Static_filter_error &dy2,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3,
	double & epsilon_4) 
  {
    typedef Static_filter_error FT;
  
    return CGAL_NTS Static_Filtered_sign_1::update_epsilon(dx1,
  		epsilon_0) == CGAL_NTS Static_Filtered_sign_1::update_epsilon(dx2,
  		epsilon_1)
        && CGAL_NTS Static_Filtered_sign_1::update_epsilon(dy1,
  		epsilon_2) == CGAL_NTS Static_Filtered_sign_1::update_epsilon(dy2,
  		epsilon_3)
        && Static_Filtered_sign_of_determinant2x2_4::update_epsilon(dx1, dy1, dx2, dy2,
  		epsilon_4) == ZERO;
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static bool epsilon_variant(
	const Restricted_double &dx1,
	const Restricted_double &dy1,
	const Restricted_double &dx2,
	const Restricted_double &dy2,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3,
	const double & epsilon_4) 
  {
    typedef Restricted_double FT;
  
    return CGAL_NTS Static_Filtered_sign_1::epsilon_variant(dx1,
  		epsilon_0) == CGAL_NTS Static_Filtered_sign_1::epsilon_variant(dx2,
  		epsilon_1)
        && CGAL_NTS Static_Filtered_sign_1::epsilon_variant(dy1,
  		epsilon_2) == CGAL_NTS Static_Filtered_sign_1::epsilon_variant(dy2,
  		epsilon_3)
        && Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(dx1, dy1, dx2, dy2,
  		epsilon_4) == ZERO;
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
bool
equal_directionC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &dx1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &dy1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &dx2,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &dy2)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_equal_directionC2_4::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(dx1.to_double()) > SAF_bound ||
	fabs(dy1.to_double()) > SAF_bound ||
	fabs(dx2.to_double()) > SAF_bound ||
	fabs(dy2.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(dx1.to_double()));
    NEW_bound = max(NEW_bound, fabs(dy1.to_double()));
    NEW_bound = max(NEW_bound, fabs(dx2.to_double()));
    NEW_bound = max(NEW_bound, fabs(dy2.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA equal_directionC2 updates");
    ++updates;
#endif
    Static_Filtered_equal_directionC2_4::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA equal_directionC2 calls");
    ++calls;
#endif
    return Static_Filtered_equal_directionC2_4::epsilon_variant(
		dx1.dbl(),
		dy1.dbl(),
		dx2.dbl(),
		dy2.dbl(),
		Static_Filtered_equal_directionC2_4::_epsilon_0,
		Static_Filtered_equal_directionC2_4::_epsilon_1,
		Static_Filtered_equal_directionC2_4::_epsilon_2,
		Static_Filtered_equal_directionC2_4::_epsilon_3,
		Static_Filtered_equal_directionC2_4::_epsilon_4);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA equal_directionC2 failures");
    ++failures;
#endif
    return equal_directionC2(
		dx1.exact(),
		dy1.exact(),
		dx2.exact(),
		dy2.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
bool
equal_directionC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &dx1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &dy1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &dx2,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &dy2)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_equal_directionC2_4::_bound; )
  CGAL_assertion(!(
	fabs(dx1.to_double()) > SAF_bound ||
	fabs(dy1.to_double()) > SAF_bound ||
	fabs(dx2.to_double()) > SAF_bound ||
	fabs(dy2.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST equal_directionC2 calls");
    ++calls;
#endif
    return Static_Filtered_equal_directionC2_4::epsilon_variant(
		dx1.dbl(),
		dy1.dbl(),
		dx2.dbl(),
		dy2.dbl(),
		Static_Filtered_equal_directionC2_4::_epsilon_0,
		Static_Filtered_equal_directionC2_4::_epsilon_1,
		Static_Filtered_equal_directionC2_4::_epsilon_2,
		Static_Filtered_equal_directionC2_4::_epsilon_3,
		Static_Filtered_equal_directionC2_4::_epsilon_4);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST equal_directionC2 failures");
    ++failures;
#endif
    return equal_directionC2(
		dx1.exact(),
		dy1.exact(),
		dx2.exact(),
		dy2.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_slopesC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &l2b)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_slopesC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_slopesC2(
		l1a.interval(),
		l1b.interval(),
		l2a.interval(),
		l2b.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_slopesC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_slopesC2(
		l1a.exact(),
		l1b.exact(),
		l2a.exact(),
		l2b.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_slopesC2_4
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5;

  static Comparison_result update_epsilon(
	const Static_filter_error &l1a,
	const Static_filter_error &l1b,
	const Static_filter_error &l2a,
	const Static_filter_error &l2b,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3,
	double & epsilon_4,
	double & epsilon_5) 
  {
    typedef Static_filter_error FT;
  
     if (l1a == FT(0))  
      return l2b == FT(0) ? SMALLER : Comparison_result(CGAL_NTS Static_Filtered_sign_1::update_epsilon(l2a*l2b,
  		epsilon_0));
     if (l2a == FT(0)) 
      return l1b == FT(0) ? LARGER : Comparison_result(-CGAL_NTS Static_Filtered_sign_1::update_epsilon(l1a*l1b,
  		epsilon_1));
     if (l1b == FT(0)) return l2b == FT(0) ? EQUAL : LARGER;
     if (l2b == FT(0)) return SMALLER;
     int l1_sign = CGAL_NTS Static_Filtered_sign_1::update_epsilon(-l1a * l1b,
  		epsilon_2);
     int l2_sign = CGAL_NTS Static_Filtered_sign_1::update_epsilon(-l2a * l2b,
  		epsilon_3);
  
     if (l1_sign < l2_sign) return SMALLER;
     if (l1_sign > l2_sign) return LARGER;
  
     if (l1_sign > 0)
       return Comparison_result( CGAL_NTS Static_Filtered_sign_1::update_epsilon( CGAL_NTS abs(l1a * l2b) -
                                                 CGAL_NTS abs(l2a * l1b) ,
  		epsilon_4) );
  
     return Comparison_result( CGAL_NTS Static_Filtered_sign_1::update_epsilon( CGAL_NTS abs(l2a * l1b) -
                                               CGAL_NTS abs(l1a * l2b) ,
  		epsilon_5) );
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &l1a,
	const Restricted_double &l1b,
	const Restricted_double &l2a,
	const Restricted_double &l2b,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3,
	const double & epsilon_4,
	const double & epsilon_5) 
  {
    typedef Restricted_double FT;
  
     if (l1a == FT(0))  
      return l2b == FT(0) ? SMALLER : Comparison_result(CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l2a*l2b,
  		epsilon_0));
     if (l2a == FT(0)) 
      return l1b == FT(0) ? LARGER : Comparison_result(-CGAL_NTS Static_Filtered_sign_1::epsilon_variant(l1a*l1b,
  		epsilon_1));
     if (l1b == FT(0)) return l2b == FT(0) ? EQUAL : LARGER;
     if (l2b == FT(0)) return SMALLER;
     int l1_sign = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(-l1a * l1b,
  		epsilon_2);
     int l2_sign = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(-l2a * l2b,
  		epsilon_3);
  
     if (l1_sign < l2_sign) return SMALLER;
     if (l1_sign > l2_sign) return LARGER;
  
     if (l1_sign > 0)
       return Comparison_result( CGAL_NTS Static_Filtered_sign_1::epsilon_variant( CGAL_NTS abs(l1a * l2b) -
                                                 CGAL_NTS abs(l2a * l1b) ,
  		epsilon_4) );
  
     return Comparison_result( CGAL_NTS Static_Filtered_sign_1::epsilon_variant( CGAL_NTS abs(l2a * l1b) -
                                               CGAL_NTS abs(l1a * l2b) ,
  		epsilon_5) );
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_slopesC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &l2b)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_slopesC2_4::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(l1a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l1b.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2a.to_double()));
    NEW_bound = max(NEW_bound, fabs(l2b.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_slopesC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_slopesC2_4::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_slopesC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_slopesC2_4::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		Static_Filtered_compare_slopesC2_4::_epsilon_0,
		Static_Filtered_compare_slopesC2_4::_epsilon_1,
		Static_Filtered_compare_slopesC2_4::_epsilon_2,
		Static_Filtered_compare_slopesC2_4::_epsilon_3,
		Static_Filtered_compare_slopesC2_4::_epsilon_4,
		Static_Filtered_compare_slopesC2_4::_epsilon_5);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_slopesC2 failures");
    ++failures;
#endif
    return compare_slopesC2(
		l1a.exact(),
		l1b.exact(),
		l2a.exact(),
		l2b.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_slopesC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l1b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &l2b)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_slopesC2_4::_bound; )
  CGAL_assertion(!(
	fabs(l1a.to_double()) > SAF_bound ||
	fabs(l1b.to_double()) > SAF_bound ||
	fabs(l2a.to_double()) > SAF_bound ||
	fabs(l2b.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_slopesC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_slopesC2_4::epsilon_variant(
		l1a.dbl(),
		l1b.dbl(),
		l2a.dbl(),
		l2b.dbl(),
		Static_Filtered_compare_slopesC2_4::_epsilon_0,
		Static_Filtered_compare_slopesC2_4::_epsilon_1,
		Static_Filtered_compare_slopesC2_4::_epsilon_2,
		Static_Filtered_compare_slopesC2_4::_epsilon_3,
		Static_Filtered_compare_slopesC2_4::_epsilon_4,
		Static_Filtered_compare_slopesC2_4::_epsilon_5);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_slopesC2 failures");
    ++failures;
#endif
    return compare_slopesC2(
		l1a.exact(),
		l1b.exact(),
		l2a.exact(),
		l2b.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_slopesC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1_src_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1_src_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1_tgt_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s1_tgt_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2_src_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2_src_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2_tgt_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &s2_tgt_y)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_slopesC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_slopesC2(
		s1_src_x.interval(),
		s1_src_y.interval(),
		s1_tgt_x.interval(),
		s1_tgt_y.interval(),
		s2_src_x.interval(),
		s2_src_y.interval(),
		s2_tgt_x.interval(),
		s2_tgt_y.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_slopesC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_slopesC2(
		s1_src_x.exact(),
		s1_src_y.exact(),
		s1_tgt_x.exact(),
		s1_tgt_y.exact(),
		s2_src_x.exact(),
		s2_src_y.exact(),
		s2_tgt_x.exact(),
		s2_tgt_y.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_slopesC2_8
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5,_epsilon_6,_epsilon_7,_epsilon_8,_epsilon_9,_epsilon_10,_epsilon_11;

  static Comparison_result update_epsilon(
	const Static_filter_error &s1_src_x,
	const Static_filter_error &s1_src_y,
	const Static_filter_error &s1_tgt_x,
	const Static_filter_error &s1_tgt_y,
	const Static_filter_error &s2_src_x,
	const Static_filter_error &s2_src_y,
	const Static_filter_error &s2_tgt_x,
	const Static_filter_error &s2_tgt_y,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3,
	double & epsilon_4,
	double & epsilon_5,
	double & epsilon_6,
	double & epsilon_7,
	double & epsilon_8,
	double & epsilon_9,
	double & epsilon_10,
	double & epsilon_11) 
  {
    typedef Static_filter_error FT;
  
     Comparison_result cmp_y1 = CGAL_NTS Static_Filtered_compare_2::update_epsilon(s1_src_y, s1_tgt_y,
  		epsilon_0);
     if (cmp_y1 == EQUAL) 
     {
        Comparison_result cmp_x2 = CGAL_NTS Static_Filtered_compare_2::update_epsilon(s2_src_x, s2_tgt_x,
  		epsilon_1);
  
        if (cmp_x2 == EQUAL) return SMALLER;
        return Comparison_result (- CGAL_NTS Static_Filtered_sign_1::update_epsilon((s2_src_y - s2_tgt_y) *
                                                  (s2_src_x - s2_tgt_x),
  		epsilon_2) );
     }
  
     Comparison_result cmp_y2 = CGAL_NTS Static_Filtered_compare_2::update_epsilon(s2_src_y, s2_tgt_y,
  		epsilon_3);
     if (cmp_y2 == EQUAL)
     {
        Comparison_result cmp_x1 = CGAL_NTS Static_Filtered_compare_2::update_epsilon(s1_src_x, s1_tgt_x,
  		epsilon_4);
  
        if (cmp_x1 == EQUAL) return LARGER;
        return Comparison_result ( CGAL_NTS Static_Filtered_sign_1::update_epsilon((s1_src_y - s1_tgt_y) *
                                                 (s1_src_x - s1_tgt_x),
  		epsilon_5) );
     }
  
     Comparison_result cmp_x1 = CGAL_NTS Static_Filtered_compare_2::update_epsilon(s1_src_x, s1_tgt_x,
  		epsilon_6);
     Comparison_result cmp_x2 = CGAL_NTS Static_Filtered_compare_2::update_epsilon(s2_src_x, s2_tgt_x,
  		epsilon_7);
  
     if (cmp_x1 == EQUAL) return cmp_x2 == EQUAL ? EQUAL : LARGER;
  
     if (cmp_x2 == EQUAL) return SMALLER;
  
     FT s1_xdiff = s1_src_x - s1_tgt_x;
     FT s1_ydiff = s1_src_y - s1_tgt_y;
     FT s2_xdiff = s2_src_x - s2_tgt_x;
     FT s2_ydiff = s2_src_y - s2_tgt_y;
     Sign s1_sign = CGAL_NTS Static_Filtered_sign_1::update_epsilon(s1_ydiff * s1_xdiff,
  		epsilon_8);
     Sign s2_sign = CGAL_NTS Static_Filtered_sign_1::update_epsilon(s2_ydiff * s2_xdiff,
  		epsilon_9);
  
     if (s1_sign < s2_sign) return SMALLER;
     if (s1_sign > s2_sign) return LARGER;
  
     if (s1_sign > 0)
       return Comparison_result(
               CGAL_NTS Static_Filtered_sign_1::update_epsilon( CGAL_NTS abs(s1_ydiff * s2_xdiff) -
                               CGAL_NTS abs(s2_ydiff * s1_xdiff),
  		epsilon_10) );
  
     return Comparison_result(
              CGAL_NTS Static_Filtered_sign_1::update_epsilon( CGAL_NTS abs(s2_ydiff * s1_xdiff) -
                              CGAL_NTS abs(s1_ydiff * s2_xdiff),
  		epsilon_11) );
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5,_epsilon_6,_epsilon_7,_epsilon_8,_epsilon_9,_epsilon_10,_epsilon_11);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &s1_src_x,
	const Restricted_double &s1_src_y,
	const Restricted_double &s1_tgt_x,
	const Restricted_double &s1_tgt_y,
	const Restricted_double &s2_src_x,
	const Restricted_double &s2_src_y,
	const Restricted_double &s2_tgt_x,
	const Restricted_double &s2_tgt_y,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3,
	const double & epsilon_4,
	const double & epsilon_5,
	const double & epsilon_6,
	const double & epsilon_7,
	const double & epsilon_8,
	const double & epsilon_9,
	const double & epsilon_10,
	const double & epsilon_11) 
  {
    typedef Restricted_double FT;
  
     Comparison_result cmp_y1 = CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s1_src_y, s1_tgt_y,
  		epsilon_0);
     if (cmp_y1 == EQUAL) 
     {
        Comparison_result cmp_x2 = CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s2_src_x, s2_tgt_x,
  		epsilon_1);
  
        if (cmp_x2 == EQUAL) return SMALLER;
        return Comparison_result (- CGAL_NTS Static_Filtered_sign_1::epsilon_variant((s2_src_y - s2_tgt_y) *
                                                  (s2_src_x - s2_tgt_x),
  		epsilon_2) );
     }
  
     Comparison_result cmp_y2 = CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s2_src_y, s2_tgt_y,
  		epsilon_3);
     if (cmp_y2 == EQUAL)
     {
        Comparison_result cmp_x1 = CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s1_src_x, s1_tgt_x,
  		epsilon_4);
  
        if (cmp_x1 == EQUAL) return LARGER;
        return Comparison_result ( CGAL_NTS Static_Filtered_sign_1::epsilon_variant((s1_src_y - s1_tgt_y) *
                                                 (s1_src_x - s1_tgt_x),
  		epsilon_5) );
     }
  
     Comparison_result cmp_x1 = CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s1_src_x, s1_tgt_x,
  		epsilon_6);
     Comparison_result cmp_x2 = CGAL_NTS Static_Filtered_compare_2::epsilon_variant(s2_src_x, s2_tgt_x,
  		epsilon_7);
  
     if (cmp_x1 == EQUAL) return cmp_x2 == EQUAL ? EQUAL : LARGER;
  
     if (cmp_x2 == EQUAL) return SMALLER;
  
     FT s1_xdiff = s1_src_x - s1_tgt_x;
     FT s1_ydiff = s1_src_y - s1_tgt_y;
     FT s2_xdiff = s2_src_x - s2_tgt_x;
     FT s2_ydiff = s2_src_y - s2_tgt_y;
     Sign s1_sign = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(s1_ydiff * s1_xdiff,
  		epsilon_8);
     Sign s2_sign = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(s2_ydiff * s2_xdiff,
  		epsilon_9);
  
     if (s1_sign < s2_sign) return SMALLER;
     if (s1_sign > s2_sign) return LARGER;
  
     if (s1_sign > 0)
       return Comparison_result(
               CGAL_NTS Static_Filtered_sign_1::epsilon_variant( CGAL_NTS abs(s1_ydiff * s2_xdiff) -
                               CGAL_NTS abs(s2_ydiff * s1_xdiff),
  		epsilon_10) );
  
     return Comparison_result(
              CGAL_NTS Static_Filtered_sign_1::epsilon_variant( CGAL_NTS abs(s2_ydiff * s1_xdiff) -
                              CGAL_NTS abs(s1_ydiff * s2_xdiff),
  		epsilon_11) );
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_slopesC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1_src_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1_src_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1_tgt_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s1_tgt_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2_src_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2_src_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2_tgt_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &s2_tgt_y)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_slopesC2_8::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(s1_src_x.to_double()) > SAF_bound ||
	fabs(s1_src_y.to_double()) > SAF_bound ||
	fabs(s1_tgt_x.to_double()) > SAF_bound ||
	fabs(s1_tgt_y.to_double()) > SAF_bound ||
	fabs(s2_src_x.to_double()) > SAF_bound ||
	fabs(s2_src_y.to_double()) > SAF_bound ||
	fabs(s2_tgt_x.to_double()) > SAF_bound ||
	fabs(s2_tgt_y.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(s1_src_x.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1_src_y.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1_tgt_x.to_double()));
    NEW_bound = max(NEW_bound, fabs(s1_tgt_y.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2_src_x.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2_src_y.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2_tgt_x.to_double()));
    NEW_bound = max(NEW_bound, fabs(s2_tgt_y.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_slopesC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_slopesC2_8::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_slopesC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_slopesC2_8::epsilon_variant(
		s1_src_x.dbl(),
		s1_src_y.dbl(),
		s1_tgt_x.dbl(),
		s1_tgt_y.dbl(),
		s2_src_x.dbl(),
		s2_src_y.dbl(),
		s2_tgt_x.dbl(),
		s2_tgt_y.dbl(),
		Static_Filtered_compare_slopesC2_8::_epsilon_0,
		Static_Filtered_compare_slopesC2_8::_epsilon_1,
		Static_Filtered_compare_slopesC2_8::_epsilon_2,
		Static_Filtered_compare_slopesC2_8::_epsilon_3,
		Static_Filtered_compare_slopesC2_8::_epsilon_4,
		Static_Filtered_compare_slopesC2_8::_epsilon_5,
		Static_Filtered_compare_slopesC2_8::_epsilon_6,
		Static_Filtered_compare_slopesC2_8::_epsilon_7,
		Static_Filtered_compare_slopesC2_8::_epsilon_8,
		Static_Filtered_compare_slopesC2_8::_epsilon_9,
		Static_Filtered_compare_slopesC2_8::_epsilon_10,
		Static_Filtered_compare_slopesC2_8::_epsilon_11);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_slopesC2 failures");
    ++failures;
#endif
    return compare_slopesC2(
		s1_src_x.exact(),
		s1_src_y.exact(),
		s1_tgt_x.exact(),
		s1_tgt_y.exact(),
		s2_src_x.exact(),
		s2_src_y.exact(),
		s2_tgt_x.exact(),
		s2_tgt_y.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_MEDIUM_INLINE */
Comparison_result
compare_slopesC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1_src_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1_src_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1_tgt_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s1_tgt_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2_src_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2_src_y,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2_tgt_x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &s2_tgt_y)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_slopesC2_8::_bound; )
  CGAL_assertion(!(
	fabs(s1_src_x.to_double()) > SAF_bound ||
	fabs(s1_src_y.to_double()) > SAF_bound ||
	fabs(s1_tgt_x.to_double()) > SAF_bound ||
	fabs(s1_tgt_y.to_double()) > SAF_bound ||
	fabs(s2_src_x.to_double()) > SAF_bound ||
	fabs(s2_src_y.to_double()) > SAF_bound ||
	fabs(s2_tgt_x.to_double()) > SAF_bound ||
	fabs(s2_tgt_y.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_slopesC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_slopesC2_8::epsilon_variant(
		s1_src_x.dbl(),
		s1_src_y.dbl(),
		s1_tgt_x.dbl(),
		s1_tgt_y.dbl(),
		s2_src_x.dbl(),
		s2_src_y.dbl(),
		s2_tgt_x.dbl(),
		s2_tgt_y.dbl(),
		Static_Filtered_compare_slopesC2_8::_epsilon_0,
		Static_Filtered_compare_slopesC2_8::_epsilon_1,
		Static_Filtered_compare_slopesC2_8::_epsilon_2,
		Static_Filtered_compare_slopesC2_8::_epsilon_3,
		Static_Filtered_compare_slopesC2_8::_epsilon_4,
		Static_Filtered_compare_slopesC2_8::_epsilon_5,
		Static_Filtered_compare_slopesC2_8::_epsilon_6,
		Static_Filtered_compare_slopesC2_8::_epsilon_7,
		Static_Filtered_compare_slopesC2_8::_epsilon_8,
		Static_Filtered_compare_slopesC2_8::_epsilon_9,
		Static_Filtered_compare_slopesC2_8::_epsilon_10,
		Static_Filtered_compare_slopesC2_8::_epsilon_11);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_slopesC2 failures");
    ++failures;
#endif
    return compare_slopesC2(
		s1_src_x.exact(),
		s1_src_y.exact(),
		s1_tgt_x.exact(),
		s1_tgt_y.exact(),
		s2_src_x.exact(),
		s2_src_y.exact(),
		s2_tgt_x.exact(),
		s2_tgt_y.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
compare_deltax_deltayC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &sy)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA compare_deltax_deltayC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return compare_deltax_deltayC2(
		px.interval(),
		qx.interval(),
		ry.interval(),
		sy.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA compare_deltax_deltayC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return compare_deltax_deltayC2(
		px.exact(),
		qx.exact(),
		ry.exact(),
		sy.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_compare_deltax_deltayC2_4
{
  static double _bound;
  static double _epsilon_0;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &qx,
	const Static_filter_error &ry,
	const Static_filter_error &sy,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return CGAL_NTS Static_Filtered_compare_2::update_epsilon(CGAL_NTS abs(px-qx), CGAL_NTS abs(ry-sy),
  		epsilon_0);
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &qx,
	const Restricted_double &ry,
	const Restricted_double &sy,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return CGAL_NTS Static_Filtered_compare_2::epsilon_variant(CGAL_NTS abs(px-qx), CGAL_NTS abs(ry-sy),
  		epsilon_0);
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
compare_deltax_deltayC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &sy)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_compare_deltax_deltayC2_4::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(sy.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    NEW_bound = max(NEW_bound, fabs(sy.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA compare_deltax_deltayC2 updates");
    ++updates;
#endif
    Static_Filtered_compare_deltax_deltayC2_4::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA compare_deltax_deltayC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_deltax_deltayC2_4::epsilon_variant(
		px.dbl(),
		qx.dbl(),
		ry.dbl(),
		sy.dbl(),
		Static_Filtered_compare_deltax_deltayC2_4::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA compare_deltax_deltayC2 failures");
    ++failures;
#endif
    return compare_deltax_deltayC2(
		px.exact(),
		qx.exact(),
		ry.exact(),
		sy.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
compare_deltax_deltayC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &sy)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_compare_deltax_deltayC2_4::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(sy.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST compare_deltax_deltayC2 calls");
    ++calls;
#endif
    return Static_Filtered_compare_deltax_deltayC2_4::epsilon_variant(
		px.dbl(),
		qx.dbl(),
		ry.dbl(),
		sy.dbl(),
		Static_Filtered_compare_deltax_deltayC2_4::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST compare_deltax_deltayC2 failures");
    ++failures;
#endif
    return compare_deltax_deltayC2(
		px.exact(),
		qx.exact(),
		ry.exact(),
		sy.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Orientation
orientationC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA orientationC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return orientationC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		rx.interval(),
		ry.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA orientationC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return orientationC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_orientationC2_6
{
  static double _bound;
  static double _epsilon_0;

  static Orientation update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &rx,
	const Static_filter_error &ry,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return Orientation (Static_Filtered_sign_of_determinant2x2_4::update_epsilon(qx-px, qy-py,
                                               rx-px, ry-py,
  		epsilon_0));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Orientation epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &rx,
	const Restricted_double &ry,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return Orientation (Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(qx-px, qy-py,
                                               rx-px, ry-py,
  		epsilon_0));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Orientation
orientationC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_orientationC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(rx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA orientationC2 updates");
    ++updates;
#endif
    Static_Filtered_orientationC2_6::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA orientationC2 calls");
    ++calls;
#endif
    return Static_Filtered_orientationC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		Static_Filtered_orientationC2_6::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA orientationC2 failures");
    ++failures;
#endif
    return orientationC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Orientation
orientationC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_orientationC2_6::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST orientationC2 calls");
    ++calls;
#endif
    return Static_Filtered_orientationC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		Static_Filtered_orientationC2_6::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST orientationC2 failures");
    ++failures;
#endif
    return orientationC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Angle
angleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA angleC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return angleC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		rx.interval(),
		ry.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA angleC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return angleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_angleC2_6
{
  static double _bound;
  static double _epsilon_0;

  static Angle update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &rx,
	const Static_filter_error &ry,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return (Angle) CGAL_NTS Static_Filtered_sign_1::update_epsilon((px-qx)*(rx-qx)+(py-qy)*(ry-qy),
  		epsilon_0);
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Angle epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &rx,
	const Restricted_double &ry,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return (Angle) CGAL_NTS Static_Filtered_sign_1::epsilon_variant((px-qx)*(rx-qx)+(py-qy)*(ry-qy),
  		epsilon_0);
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Angle
angleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_angleC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(rx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA angleC2 updates");
    ++updates;
#endif
    Static_Filtered_angleC2_6::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA angleC2 calls");
    ++calls;
#endif
    return Static_Filtered_angleC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		Static_Filtered_angleC2_6::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA angleC2 failures");
    ++failures;
#endif
    return angleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Angle
angleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_angleC2_6::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST angleC2 calls");
    ++calls;
#endif
    return Static_Filtered_angleC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		Static_Filtered_angleC2_6::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST angleC2 failures");
    ++failures;
#endif
    return angleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Oriented_side
side_of_oriented_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ty)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA side_of_oriented_circleC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return side_of_oriented_circleC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		rx.interval(),
		ry.interval(),
		tx.interval(),
		ty.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA side_of_oriented_circleC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return side_of_oriented_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		tx.exact(),
		ty.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_side_of_oriented_circleC2_8
{
  static double _bound;
  static double _epsilon_0;

  static Oriented_side update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &rx,
	const Static_filter_error &ry,
	const Static_filter_error &tx,
	const Static_filter_error &ty,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    
    
    
    
    
    
    FT qpx = qx-px;
    FT qpy = qy-py;
    FT rpx = rx-px;
    FT rpy = ry-py;
    FT tpx = tx-px;
    FT tpy = ty-py;
  
  
  
  
    return Oriented_side(Static_Filtered_sign_of_determinant2x2_4::update_epsilon(
                               qpx*tpy - qpy*tpx, tpx*(tx-qx) + tpy*(ty-qy),
                               qpx*rpy - qpy*rpx, rpx*(rx-qx) + rpy*(ry-qy),
  		epsilon_0));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Oriented_side epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &rx,
	const Restricted_double &ry,
	const Restricted_double &tx,
	const Restricted_double &ty,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    
    
    
    
    
    
    FT qpx = qx-px;
    FT qpy = qy-py;
    FT rpx = rx-px;
    FT rpy = ry-py;
    FT tpx = tx-px;
    FT tpy = ty-py;
  
  
  
  
    return Oriented_side(Static_Filtered_sign_of_determinant2x2_4::epsilon_variant(
                               qpx*tpy - qpy*tpx, tpx*(tx-qx) + tpy*(ty-qy),
                               qpx*rpy - qpy*rpx, rpx*(rx-qx) + rpy*(ry-qy),
  		epsilon_0));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Oriented_side
side_of_oriented_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ty)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_side_of_oriented_circleC2_8::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(tx.to_double()) > SAF_bound ||
	fabs(ty.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(rx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    NEW_bound = max(NEW_bound, fabs(tx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ty.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA side_of_oriented_circleC2 updates");
    ++updates;
#endif
    Static_Filtered_side_of_oriented_circleC2_8::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA side_of_oriented_circleC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_oriented_circleC2_8::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		tx.dbl(),
		ty.dbl(),
		Static_Filtered_side_of_oriented_circleC2_8::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA side_of_oriented_circleC2 failures");
    ++failures;
#endif
    return side_of_oriented_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		tx.exact(),
		ty.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Oriented_side
side_of_oriented_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ty)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_side_of_oriented_circleC2_8::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(tx.to_double()) > SAF_bound ||
	fabs(ty.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST side_of_oriented_circleC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_oriented_circleC2_8::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		tx.dbl(),
		ty.dbl(),
		Static_Filtered_side_of_oriented_circleC2_8::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST side_of_oriented_circleC2 failures");
    ++failures;
#endif
    return side_of_oriented_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		tx.exact(),
		ty.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Bounded_side
side_of_bounded_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ty)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA side_of_bounded_circleC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return side_of_bounded_circleC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		rx.interval(),
		ry.interval(),
		tx.interval(),
		ty.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA side_of_bounded_circleC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return side_of_bounded_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		tx.exact(),
		ty.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_side_of_bounded_circleC2_8
{
  static double _bound;
  static double _epsilon_0,_epsilon_1;

  static Bounded_side update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &rx,
	const Static_filter_error &ry,
	const Static_filter_error &tx,
	const Static_filter_error &ty,
	double & epsilon_0,
	double & epsilon_1)
  {
    typedef Static_filter_error FT;
  
    return Bounded_side( Static_Filtered_side_of_oriented_circleC2_8::update_epsilon(px,py,qx,qy,rx,ry,tx,ty,
  		epsilon_0)
                                   * Static_Filtered_orientationC2_6::update_epsilon(px,py,qx,qy,rx,ry,
  		epsilon_1) );
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Bounded_side epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &rx,
	const Restricted_double &ry,
	const Restricted_double &tx,
	const Restricted_double &ty,
	const double & epsilon_0,
	const double & epsilon_1)
  {
    typedef Restricted_double FT;
  
    return Bounded_side( Static_Filtered_side_of_oriented_circleC2_8::epsilon_variant(px,py,qx,qy,rx,ry,tx,ty,
  		epsilon_0)
                                   * Static_Filtered_orientationC2_6::epsilon_variant(px,py,qx,qy,rx,ry,
  		epsilon_1) );
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Bounded_side
side_of_bounded_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ty)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_side_of_bounded_circleC2_8::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(tx.to_double()) > SAF_bound ||
	fabs(ty.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(rx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    NEW_bound = max(NEW_bound, fabs(tx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ty.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA side_of_bounded_circleC2 updates");
    ++updates;
#endif
    Static_Filtered_side_of_bounded_circleC2_8::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA side_of_bounded_circleC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_bounded_circleC2_8::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		tx.dbl(),
		ty.dbl(),
		Static_Filtered_side_of_bounded_circleC2_8::_epsilon_0,
		Static_Filtered_side_of_bounded_circleC2_8::_epsilon_1);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA side_of_bounded_circleC2 failures");
    ++failures;
#endif
    return side_of_bounded_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		tx.exact(),
		ty.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Bounded_side
side_of_bounded_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ty)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_side_of_bounded_circleC2_8::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(tx.to_double()) > SAF_bound ||
	fabs(ty.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST side_of_bounded_circleC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_bounded_circleC2_8::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		tx.dbl(),
		ty.dbl(),
		Static_Filtered_side_of_bounded_circleC2_8::_epsilon_0,
		Static_Filtered_side_of_bounded_circleC2_8::_epsilon_1);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST side_of_bounded_circleC2 failures");
    ++failures;
#endif
    return side_of_bounded_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		tx.exact(),
		ty.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Bounded_side
side_of_bounded_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ty)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA side_of_bounded_circleC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return side_of_bounded_circleC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		tx.interval(),
		ty.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA side_of_bounded_circleC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return side_of_bounded_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		tx.exact(),
		ty.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_side_of_bounded_circleC2_6
{
  static double _bound;
  static double _epsilon_0;

  static Bounded_side update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &tx,
	const Static_filter_error &ty,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    
    return Bounded_side( CGAL_NTS Static_Filtered_compare_2::update_epsilon((tx-px)*(qx-tx), (ty-py)*(ty-qy),
  		epsilon_0) );
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Bounded_side epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &tx,
	const Restricted_double &ty,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    
    return Bounded_side( CGAL_NTS Static_Filtered_compare_2::epsilon_variant((tx-px)*(qx-tx), (ty-py)*(ty-qy),
  		epsilon_0) );
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Bounded_side
side_of_bounded_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ty)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_side_of_bounded_circleC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(tx.to_double()) > SAF_bound ||
	fabs(ty.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(tx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ty.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA side_of_bounded_circleC2 updates");
    ++updates;
#endif
    Static_Filtered_side_of_bounded_circleC2_6::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA side_of_bounded_circleC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_bounded_circleC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		tx.dbl(),
		ty.dbl(),
		Static_Filtered_side_of_bounded_circleC2_6::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA side_of_bounded_circleC2 failures");
    ++failures;
#endif
    return side_of_bounded_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		tx.exact(),
		ty.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* CGAL_KERNEL_LARGE_INLINE */
Bounded_side
side_of_bounded_circleC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &tx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ty)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_side_of_bounded_circleC2_6::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(tx.to_double()) > SAF_bound ||
	fabs(ty.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST side_of_bounded_circleC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_bounded_circleC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		tx.dbl(),
		ty.dbl(),
		Static_Filtered_side_of_bounded_circleC2_6::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST side_of_bounded_circleC2 failures");
    ++failures;
#endif
    return side_of_bounded_circleC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		tx.exact(),
		ty.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_dist_to_pointC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA cmp_dist_to_pointC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return cmp_dist_to_pointC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		rx.interval(),
		ry.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA cmp_dist_to_pointC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return cmp_dist_to_pointC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_cmp_dist_to_pointC2_6
{
  static double _bound;
  static double _epsilon_0;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &rx,
	const Static_filter_error &ry,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return CGAL_NTS Static_Filtered_compare_2::update_epsilon(squared_distanceC2(px,py,qx,qy),
                            squared_distanceC2(px,py,rx,ry),
  		epsilon_0);
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &rx,
	const Restricted_double &ry,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return CGAL_NTS Static_Filtered_compare_2::epsilon_variant(squared_distanceC2(px,py,qx,qy),
                            squared_distanceC2(px,py,rx,ry),
  		epsilon_0);
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_dist_to_pointC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_cmp_dist_to_pointC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(rx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA cmp_dist_to_pointC2 updates");
    ++updates;
#endif
    Static_Filtered_cmp_dist_to_pointC2_6::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA cmp_dist_to_pointC2 calls");
    ++calls;
#endif
    return Static_Filtered_cmp_dist_to_pointC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		Static_Filtered_cmp_dist_to_pointC2_6::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA cmp_dist_to_pointC2 failures");
    ++failures;
#endif
    return cmp_dist_to_pointC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_dist_to_pointC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_cmp_dist_to_pointC2_6::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST cmp_dist_to_pointC2 calls");
    ++calls;
#endif
    return Static_Filtered_cmp_dist_to_pointC2_6::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		Static_Filtered_cmp_dist_to_pointC2_6::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST cmp_dist_to_pointC2 failures");
    ++failures;
#endif
    return cmp_dist_to_pointC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_signed_dist_to_directionC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA cmp_signed_dist_to_directionC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return cmp_signed_dist_to_directionC2(
		la.interval(),
		lb.interval(),
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA cmp_signed_dist_to_directionC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return cmp_signed_dist_to_directionC2(
		la.exact(),
		lb.exact(),
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_cmp_signed_dist_to_directionC2_6
{
  static double _bound;
  static double _epsilon_0;

  static Comparison_result update_epsilon(
	const Static_filter_error &la,
	const Static_filter_error &lb,
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return CGAL_NTS Static_Filtered_compare_2::update_epsilon(scaled_distance_to_directionC2(la,lb,px,py),
                            scaled_distance_to_directionC2(la,lb,qx,qy),
  		epsilon_0);
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &la,
	const Restricted_double &lb,
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return CGAL_NTS Static_Filtered_compare_2::epsilon_variant(scaled_distance_to_directionC2(la,lb,px,py),
                            scaled_distance_to_directionC2(la,lb,qx,qy),
  		epsilon_0);
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_signed_dist_to_directionC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_cmp_signed_dist_to_directionC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(la.to_double()));
    NEW_bound = max(NEW_bound, fabs(lb.to_double()));
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA cmp_signed_dist_to_directionC2 updates");
    ++updates;
#endif
    Static_Filtered_cmp_signed_dist_to_directionC2_6::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA cmp_signed_dist_to_directionC2 calls");
    ++calls;
#endif
    return Static_Filtered_cmp_signed_dist_to_directionC2_6::epsilon_variant(
		la.dbl(),
		lb.dbl(),
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		Static_Filtered_cmp_signed_dist_to_directionC2_6::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA cmp_signed_dist_to_directionC2 failures");
    ++failures;
#endif
    return cmp_signed_dist_to_directionC2(
		la.exact(),
		lb.exact(),
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_signed_dist_to_directionC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &la,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &lb,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_cmp_signed_dist_to_directionC2_6::_bound; )
  CGAL_assertion(!(
	fabs(la.to_double()) > SAF_bound ||
	fabs(lb.to_double()) > SAF_bound ||
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST cmp_signed_dist_to_directionC2 calls");
    ++calls;
#endif
    return Static_Filtered_cmp_signed_dist_to_directionC2_6::epsilon_variant(
		la.dbl(),
		lb.dbl(),
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		Static_Filtered_cmp_signed_dist_to_directionC2_6::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST cmp_signed_dist_to_directionC2 failures");
    ++failures;
#endif
    return cmp_signed_dist_to_directionC2(
		la.exact(),
		lb.exact(),
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_signed_dist_to_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &sy)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA cmp_signed_dist_to_lineC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return cmp_signed_dist_to_lineC2(
		px.interval(),
		py.interval(),
		qx.interval(),
		qy.interval(),
		rx.interval(),
		ry.interval(),
		sx.interval(),
		sy.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA cmp_signed_dist_to_lineC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return cmp_signed_dist_to_lineC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		sx.exact(),
		sy.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_cmp_signed_dist_to_lineC2_8
{
  static double _bound;
  static double _epsilon_0;

  static Comparison_result update_epsilon(
	const Static_filter_error &px,
	const Static_filter_error &py,
	const Static_filter_error &qx,
	const Static_filter_error &qy,
	const Static_filter_error &rx,
	const Static_filter_error &ry,
	const Static_filter_error &sx,
	const Static_filter_error &sy,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return CGAL_NTS Static_Filtered_compare_2::update_epsilon(scaled_distance_to_lineC2(px,py,qx,qy,rx,ry),
                            scaled_distance_to_lineC2(px,py,qx,qy,sx,sy),
  		epsilon_0);
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Comparison_result epsilon_variant(
	const Restricted_double &px,
	const Restricted_double &py,
	const Restricted_double &qx,
	const Restricted_double &qy,
	const Restricted_double &rx,
	const Restricted_double &ry,
	const Restricted_double &sx,
	const Restricted_double &sy,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return CGAL_NTS Static_Filtered_compare_2::epsilon_variant(scaled_distance_to_lineC2(px,py,qx,qy,rx,ry),
                            scaled_distance_to_lineC2(px,py,qx,qy,sx,sy),
  		epsilon_0);
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_signed_dist_to_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &sy)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_cmp_signed_dist_to_lineC2_8::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(sx.to_double()) > SAF_bound ||
	fabs(sy.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(px.to_double()));
    NEW_bound = max(NEW_bound, fabs(py.to_double()));
    NEW_bound = max(NEW_bound, fabs(qx.to_double()));
    NEW_bound = max(NEW_bound, fabs(qy.to_double()));
    NEW_bound = max(NEW_bound, fabs(rx.to_double()));
    NEW_bound = max(NEW_bound, fabs(ry.to_double()));
    NEW_bound = max(NEW_bound, fabs(sx.to_double()));
    NEW_bound = max(NEW_bound, fabs(sy.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA cmp_signed_dist_to_lineC2 updates");
    ++updates;
#endif
    Static_Filtered_cmp_signed_dist_to_lineC2_8::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA cmp_signed_dist_to_lineC2 calls");
    ++calls;
#endif
    return Static_Filtered_cmp_signed_dist_to_lineC2_8::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		sx.dbl(),
		sy.dbl(),
		Static_Filtered_cmp_signed_dist_to_lineC2_8::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA cmp_signed_dist_to_lineC2 failures");
    ++failures;
#endif
    return cmp_signed_dist_to_lineC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		sx.exact(),
		sy.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Comparison_result
cmp_signed_dist_to_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &px,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &py,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &qy,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &rx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &ry,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &sx,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &sy)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_cmp_signed_dist_to_lineC2_8::_bound; )
  CGAL_assertion(!(
	fabs(px.to_double()) > SAF_bound ||
	fabs(py.to_double()) > SAF_bound ||
	fabs(qx.to_double()) > SAF_bound ||
	fabs(qy.to_double()) > SAF_bound ||
	fabs(rx.to_double()) > SAF_bound ||
	fabs(ry.to_double()) > SAF_bound ||
	fabs(sx.to_double()) > SAF_bound ||
	fabs(sy.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST cmp_signed_dist_to_lineC2 calls");
    ++calls;
#endif
    return Static_Filtered_cmp_signed_dist_to_lineC2_8::epsilon_variant(
		px.dbl(),
		py.dbl(),
		qx.dbl(),
		qy.dbl(),
		rx.dbl(),
		ry.dbl(),
		sx.dbl(),
		sy.dbl(),
		Static_Filtered_cmp_signed_dist_to_lineC2_8::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST cmp_signed_dist_to_lineC2 failures");
    ++failures;
#endif
    return cmp_signed_dist_to_lineC2(
		px.exact(),
		py.exact(),
		qx.exact(),
		qy.exact(),
		rx.exact(),
		ry.exact(),
		sx.exact(),
		sy.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Oriented_side
side_of_oriented_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &y)
{
  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("IA side_of_oriented_lineC2 calls");
    ++calls;
#endif
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return side_of_oriented_lineC2(
		a.interval(),
		b.interval(),
		c.interval(),
		x.interval(),
		y.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("IA side_of_oriented_lineC2 failures");
    ++failures;
#endif
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return side_of_oriented_lineC2(
		a.exact(),
		b.exact(),
		c.exact(),
		x.exact(),
		y.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_side_of_oriented_lineC2_5
{
  static double _bound;
  static double _epsilon_0;

  static Oriented_side update_epsilon(
	const Static_filter_error &a,
	const Static_filter_error &b,
	const Static_filter_error &c,
	const Static_filter_error &x,
	const Static_filter_error &y,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
    return Oriented_side(CGAL_NTS Static_Filtered_sign_1::update_epsilon(a*x+b*y+c,
  		epsilon_0));
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Oriented_side epsilon_variant(
	const Restricted_double &a,
	const Restricted_double &b,
	const Restricted_double &c,
	const Restricted_double &x,
	const Restricted_double &y,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
    return Oriented_side(CGAL_NTS Static_Filtered_sign_1::epsilon_variant(a*x+b*y+c,
  		epsilon_0));
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Oriented_side
side_of_oriented_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &y)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_side_of_oriented_lineC2_5::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(c.to_double()) > SAF_bound ||
	fabs(x.to_double()) > SAF_bound ||
	fabs(y.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(a.to_double()));
    NEW_bound = max(NEW_bound, fabs(b.to_double()));
    NEW_bound = max(NEW_bound, fabs(c.to_double()));
    NEW_bound = max(NEW_bound, fabs(x.to_double()));
    NEW_bound = max(NEW_bound, fabs(y.to_double()));
    // Re-adjust the context.
#ifdef CGAL_PROFILE
    static Profile_counter updates("SA side_of_oriented_lineC2 updates");
    ++updates;
#endif
    Static_Filtered_side_of_oriented_lineC2_5::new_bound(NEW_bound);
  }

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("SA side_of_oriented_lineC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_oriented_lineC2_5::epsilon_variant(
		a.dbl(),
		b.dbl(),
		c.dbl(),
		x.dbl(),
		y.dbl(),
		Static_Filtered_side_of_oriented_lineC2_5::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
#ifdef CGAL_PROFILE
    static Profile_counter failures("SA side_of_oriented_lineC2 failures");
    ++failures;
#endif
    return side_of_oriented_lineC2(
		a.exact(),
		b.exact(),
		c.exact(),
		x.exact(),
		y.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/* inline */
Oriented_side
side_of_oriented_lineC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &c,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &x,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &y)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_side_of_oriented_lineC2_5::_bound; )
  CGAL_assertion(!(
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(c.to_double()) > SAF_bound ||
	fabs(x.to_double()) > SAF_bound ||
	fabs(y.to_double()) > SAF_bound));

  try
  {
#ifdef CGAL_PROFILE
    static Profile_counter calls("ST side_of_oriented_lineC2 calls");
    ++calls;
#endif
    return Static_Filtered_side_of_oriented_lineC2_5::epsilon_variant(
		a.dbl(),
		b.dbl(),
		c.dbl(),
		x.dbl(),
		y.dbl(),
		Static_Filtered_side_of_oriented_lineC2_5::_epsilon_0);
  }
  catch (...)
  {
#ifdef CGAL_PROFILE
    static Profile_counter failures("ST side_of_oriented_lineC2 failures");
    ++failures;
#endif
    return side_of_oriented_lineC2(
		a.exact(),
		b.exact(),
		c.exact(),
		x.exact(),
		y.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

CGAL_END_NAMESPACE

#endif // CGAL_ARITHMETIC_FILTER_PREDICATES_KERNEL_FTC2_H
