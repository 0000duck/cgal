// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/predicates_on_ftC2.h
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef CGAL_ARITHMETIC_FILTER_PREDICATES_ON_FTC2_H
#define CGAL_ARITHMETIC_FILTER_PREDICATES_ON_FTC2_H

CGAL_BEGIN_NAMESPACE

inline
Comparison_result
compare_xC2_SAF(
    const Static_filter_error &px,
    const Static_filter_error &l1a,
    const Static_filter_error &l1b,
    const Static_filter_error &l1c,
    const Static_filter_error &l2a,
    const Static_filter_error &l2b,
    const Static_filter_error &l2c,
    double & epsilon_0,
    double & epsilon_1)
{
  typedef Static_filter_error FT;

  Sign sign1 = sign_of_determinant2x2_SAF(l1a, l1b, l2a, l2b,
		epsilon_0);
  Sign sign2 = sign_of_determinant3x3_SAF(l1a, l1b, l1c,
                                      l2a, l2b, l2c,
                                      -FT(1), FT(0), px,
		epsilon_1);
  CGAL_kernel_assertion( sign1 != 0 );
  return Comparison_result (sign1 * sign2);
}

inline
Comparison_result
compare_xC2_SAF(
    const Restricted_double &px,
    const Restricted_double &l1a,
    const Restricted_double &l1b,
    const Restricted_double &l1c,
    const Restricted_double &l2a,
    const Restricted_double &l2b,
    const Restricted_double &l2c,
    const double & epsilon_0,
    const double & epsilon_1)
{
  typedef Restricted_double FT;

  Sign sign1 = sign_of_determinant2x2_SAF(l1a, l1b, l2a, l2b,
		epsilon_0);
  Sign sign2 = sign_of_determinant3x3_SAF(l1a, l1b, l1c,
                                      l2a, l2b, l2c,
                                      -FT(1), FT(0), px,
		epsilon_1);
  CGAL_kernel_assertion( sign1 != 0 );
  return Comparison_result (sign1 * sign2);
}

inline
Comparison_result
compare_xC2(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &l1a,
    const Static_adaptatif_filter &l1b,
    const Static_adaptatif_filter &l1c,
    const Static_adaptatif_filter &l2a,
    const Static_adaptatif_filter &l2b,
    const Static_adaptatif_filter &l2c)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;
  static double SAF_epsilon_1;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(px.value()) > SAF_bound ||
	fabs(l1a.value()) > SAF_bound ||
	fabs(l1b.value()) > SAF_bound ||
	fabs(l1c.value()) > SAF_bound ||
	fabs(l2a.value()) > SAF_bound ||
	fabs(l2b.value()) > SAF_bound ||
	fabs(l2c.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_xC2_SAF(
		Restricted_double(px.value()),
		Restricted_double(l1a.value()),
		Restricted_double(l1b.value()),
		Restricted_double(l1c.value()),
		Restricted_double(l2a.value()),
		Restricted_double(l2b.value()),
		Restricted_double(l2c.value()),
		SAF_epsilon_0,
		SAF_epsilon_1);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(px.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2c.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_xC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0,
		SAF_epsilon_1);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_xC2(
		px.exact(),
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

inline
Comparison_result
compare_xC2_SAF(
    const Static_filter_error &l1a,
    const Static_filter_error &l1b,
    const Static_filter_error &l1c,
    const Static_filter_error &l2a,
    const Static_filter_error &l2b,
    const Static_filter_error &l2c,
    const Static_filter_error &h1a,
    const Static_filter_error &h1b,
    const Static_filter_error &h1c,
    const Static_filter_error &h2a,
    const Static_filter_error &h2b,
    const Static_filter_error &h2c,
    double & epsilon_0,
    double & epsilon_1,
    double & epsilon_2)
{
  typedef Static_filter_error FT;

  Sign sign1 = sign_of_determinant2x2_SAF(l1a, l1b, l2a, l2b,
		epsilon_0);
  Sign sign2 = sign_of_determinant2x2_SAF(h1a, h1b, h2a, h2b,
		epsilon_1);
  
  
  FT FT0(0);
  Sign sign3 = sign_of_determinant4x4_SAF(l1a, l1b, FT0, l1c,
                                      l2a, l2b, FT0, l2c,
                                      h1a, FT0, h1b, h1c,
                                      h2a, FT0, h2b, h2c,
		epsilon_2);
  CGAL_kernel_assertion( (sign1 != 0) && (sign2 != 0) );
  return Comparison_result (- sign1 * sign2 * sign3);
}

inline
Comparison_result
compare_xC2_SAF(
    const Restricted_double &l1a,
    const Restricted_double &l1b,
    const Restricted_double &l1c,
    const Restricted_double &l2a,
    const Restricted_double &l2b,
    const Restricted_double &l2c,
    const Restricted_double &h1a,
    const Restricted_double &h1b,
    const Restricted_double &h1c,
    const Restricted_double &h2a,
    const Restricted_double &h2b,
    const Restricted_double &h2c,
    const double & epsilon_0,
    const double & epsilon_1,
    const double & epsilon_2)
{
  typedef Restricted_double FT;

  Sign sign1 = sign_of_determinant2x2_SAF(l1a, l1b, l2a, l2b,
		epsilon_0);
  Sign sign2 = sign_of_determinant2x2_SAF(h1a, h1b, h2a, h2b,
		epsilon_1);
  
  
  FT FT0(0);
  Sign sign3 = sign_of_determinant4x4_SAF(l1a, l1b, FT0, l1c,
                                      l2a, l2b, FT0, l2c,
                                      h1a, FT0, h1b, h1c,
                                      h2a, FT0, h2b, h2c,
		epsilon_2);
  CGAL_kernel_assertion( (sign1 != 0) && (sign2 != 0) );
  return Comparison_result (- sign1 * sign2 * sign3);
}

inline
Comparison_result
compare_xC2(
    const Static_adaptatif_filter &l1a,
    const Static_adaptatif_filter &l1b,
    const Static_adaptatif_filter &l1c,
    const Static_adaptatif_filter &l2a,
    const Static_adaptatif_filter &l2b,
    const Static_adaptatif_filter &l2c,
    const Static_adaptatif_filter &h1a,
    const Static_adaptatif_filter &h1b,
    const Static_adaptatif_filter &h1c,
    const Static_adaptatif_filter &h2a,
    const Static_adaptatif_filter &h2b,
    const Static_adaptatif_filter &h2c)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;
  static double SAF_epsilon_1;
  static double SAF_epsilon_2;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(l1a.value()) > SAF_bound ||
	fabs(l1b.value()) > SAF_bound ||
	fabs(l1c.value()) > SAF_bound ||
	fabs(l2a.value()) > SAF_bound ||
	fabs(l2b.value()) > SAF_bound ||
	fabs(l2c.value()) > SAF_bound ||
	fabs(h1a.value()) > SAF_bound ||
	fabs(h1b.value()) > SAF_bound ||
	fabs(h1c.value()) > SAF_bound ||
	fabs(h2a.value()) > SAF_bound ||
	fabs(h2b.value()) > SAF_bound ||
	fabs(h2c.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_xC2_SAF(
		Restricted_double(l1a.value()),
		Restricted_double(l1b.value()),
		Restricted_double(l1c.value()),
		Restricted_double(l2a.value()),
		Restricted_double(l2b.value()),
		Restricted_double(l2c.value()),
		Restricted_double(h1a.value()),
		Restricted_double(h1b.value()),
		Restricted_double(h1c.value()),
		Restricted_double(h2a.value()),
		Restricted_double(h2b.value()),
		Restricted_double(h2c.value()),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(l1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2c.value()));
      SAF_bound = std::max(SAF_bound, fabs(h1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(h1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(h1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(h2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(h2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(h2c.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_xC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &la,
    const Static_filter_error &lb,
    const Static_filter_error &lc,
    double & epsilon_0,
    double & epsilon_1)
{
  typedef Static_filter_error FT;

  Sign sign1 = CGAL::sign_SAF(lb,
		epsilon_0);
  Sign sign2 = CGAL::sign_SAF(la*px + lb*py + lc,
		epsilon_1);
  CGAL_kernel_assertion( sign1 != 0 );
  return Comparison_result (sign1 * sign2);
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &la,
    const Restricted_double &lb,
    const Restricted_double &lc,
    const double & epsilon_0,
    const double & epsilon_1)
{
  typedef Restricted_double FT;

  Sign sign1 = CGAL::sign_SAF(lb,
		epsilon_0);
  Sign sign2 = CGAL::sign_SAF(la*px + lb*py + lc,
		epsilon_1);
  CGAL_kernel_assertion( sign1 != 0 );
  return Comparison_result (sign1 * sign2);
}

inline
Comparison_result
compare_y_at_xC2(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &la,
    const Static_adaptatif_filter &lb,
    const Static_adaptatif_filter &lc)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;
  static double SAF_epsilon_1;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(px.value()) > SAF_bound ||
	fabs(py.value()) > SAF_bound ||
	fabs(la.value()) > SAF_bound ||
	fabs(lb.value()) > SAF_bound ||
	fabs(lc.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_y_at_xC2_SAF(
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(la.value()),
		Restricted_double(lb.value()),
		Restricted_double(lc.value()),
		SAF_epsilon_0,
		SAF_epsilon_1);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(px.value()));
      SAF_bound = std::max(SAF_bound, fabs(py.value()));
      SAF_bound = std::max(SAF_bound, fabs(la.value()));
      SAF_bound = std::max(SAF_bound, fabs(lb.value()));
      SAF_bound = std::max(SAF_bound, fabs(lc.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_y_at_xC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0,
		SAF_epsilon_1);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_y_at_xC2(
		px.exact(),
		py.exact(),
		la.exact(),
		lb.exact(),
		lc.exact());
  }
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Static_filter_error &px,
    const Static_filter_error &l1a,
    const Static_filter_error &l1b,
    const Static_filter_error &l1c,
    const Static_filter_error &l2a,
    const Static_filter_error &l2b,
    const Static_filter_error &l2c,
    double & epsilon_0,
    double & epsilon_1,
    double & epsilon_2)
{
  typedef Static_filter_error FT;

  Sign sign1 = CGAL::sign_SAF(l1b,
		epsilon_0);
  Sign sign2 = CGAL::sign_SAF(l2b,
		epsilon_1);
  Sign sign3 = sign_of_determinant2x2_SAF(l1a*px+l1c,l2a*px+l2c,l1b,l2b,
		epsilon_2);
  CGAL_kernel_assertion( (sign1 != 0) && (sign2 != 0) );
  return Comparison_result (- sign1 * sign2 * sign3);
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Restricted_double &px,
    const Restricted_double &l1a,
    const Restricted_double &l1b,
    const Restricted_double &l1c,
    const Restricted_double &l2a,
    const Restricted_double &l2b,
    const Restricted_double &l2c,
    const double & epsilon_0,
    const double & epsilon_1,
    const double & epsilon_2)
{
  typedef Restricted_double FT;

  Sign sign1 = CGAL::sign_SAF(l1b,
		epsilon_0);
  Sign sign2 = CGAL::sign_SAF(l2b,
		epsilon_1);
  Sign sign3 = sign_of_determinant2x2_SAF(l1a*px+l1c,l2a*px+l2c,l1b,l2b,
		epsilon_2);
  CGAL_kernel_assertion( (sign1 != 0) && (sign2 != 0) );
  return Comparison_result (- sign1 * sign2 * sign3);
}

inline
Comparison_result
compare_y_at_xC2(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &l1a,
    const Static_adaptatif_filter &l1b,
    const Static_adaptatif_filter &l1c,
    const Static_adaptatif_filter &l2a,
    const Static_adaptatif_filter &l2b,
    const Static_adaptatif_filter &l2c)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;
  static double SAF_epsilon_1;
  static double SAF_epsilon_2;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(px.value()) > SAF_bound ||
	fabs(l1a.value()) > SAF_bound ||
	fabs(l1b.value()) > SAF_bound ||
	fabs(l1c.value()) > SAF_bound ||
	fabs(l2a.value()) > SAF_bound ||
	fabs(l2b.value()) > SAF_bound ||
	fabs(l2c.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_y_at_xC2_SAF(
		Restricted_double(px.value()),
		Restricted_double(l1a.value()),
		Restricted_double(l1b.value()),
		Restricted_double(l1c.value()),
		Restricted_double(l2a.value()),
		Restricted_double(l2b.value()),
		Restricted_double(l2c.value()),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(px.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2c.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_y_at_xC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_y_at_xC2(
		px.exact(),
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact());
  }
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Static_filter_error &l1a,
    const Static_filter_error &l1b,
    const Static_filter_error &l1c,
    const Static_filter_error &l2a,
    const Static_filter_error &l2b,
    const Static_filter_error &l2c,
    const Static_filter_error &ha,
    const Static_filter_error &hb,
    const Static_filter_error &hc,
    double & epsilon_0,
    double & epsilon_1,
    double & epsilon_2)
{
  typedef Static_filter_error FT;

  Sign sign0 = sign_of_determinant2x2_SAF(l1a,l1b,l2a,l2b,
		epsilon_0);
  Sign sign1 = sign_of_determinant3x3_SAF(ha,hb,hc,l1a,l1b,l1c,l2a,l2b,l2c,
		epsilon_1);
  CGAL_kernel_assertion( (sign0 != ZERO) && (hb != FT(0)) );
  return Comparison_result (sign0 * CGAL::sign_SAF(hb,
		epsilon_2) * sign1);
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Restricted_double &l1a,
    const Restricted_double &l1b,
    const Restricted_double &l1c,
    const Restricted_double &l2a,
    const Restricted_double &l2b,
    const Restricted_double &l2c,
    const Restricted_double &ha,
    const Restricted_double &hb,
    const Restricted_double &hc,
    const double & epsilon_0,
    const double & epsilon_1,
    const double & epsilon_2)
{
  typedef Restricted_double FT;

  Sign sign0 = sign_of_determinant2x2_SAF(l1a,l1b,l2a,l2b,
		epsilon_0);
  Sign sign1 = sign_of_determinant3x3_SAF(ha,hb,hc,l1a,l1b,l1c,l2a,l2b,l2c,
		epsilon_1);
  CGAL_kernel_assertion( (sign0 != ZERO) && (hb != FT(0)) );
  return Comparison_result (sign0 * CGAL::sign_SAF(hb,
		epsilon_2) * sign1);
}

inline
Comparison_result
compare_y_at_xC2(
    const Static_adaptatif_filter &l1a,
    const Static_adaptatif_filter &l1b,
    const Static_adaptatif_filter &l1c,
    const Static_adaptatif_filter &l2a,
    const Static_adaptatif_filter &l2b,
    const Static_adaptatif_filter &l2c,
    const Static_adaptatif_filter &ha,
    const Static_adaptatif_filter &hb,
    const Static_adaptatif_filter &hc)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;
  static double SAF_epsilon_1;
  static double SAF_epsilon_2;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(l1a.value()) > SAF_bound ||
	fabs(l1b.value()) > SAF_bound ||
	fabs(l1c.value()) > SAF_bound ||
	fabs(l2a.value()) > SAF_bound ||
	fabs(l2b.value()) > SAF_bound ||
	fabs(l2c.value()) > SAF_bound ||
	fabs(ha.value()) > SAF_bound ||
	fabs(hb.value()) > SAF_bound ||
	fabs(hc.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_y_at_xC2_SAF(
		Restricted_double(l1a.value()),
		Restricted_double(l1b.value()),
		Restricted_double(l1c.value()),
		Restricted_double(l2a.value()),
		Restricted_double(l2b.value()),
		Restricted_double(l2c.value()),
		Restricted_double(ha.value()),
		Restricted_double(hb.value()),
		Restricted_double(hc.value()),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(l1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2c.value()));
      SAF_bound = std::max(SAF_bound, fabs(ha.value()));
      SAF_bound = std::max(SAF_bound, fabs(hb.value()));
      SAF_bound = std::max(SAF_bound, fabs(hc.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_y_at_xC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		ha.exact(),
		hb.exact(),
		hc.exact());
  }
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Static_filter_error &l1a,
    const Static_filter_error &l1b,
    const Static_filter_error &l1c,
    const Static_filter_error &l2a,
    const Static_filter_error &l2b,
    const Static_filter_error &l2c,
    const Static_filter_error &h1a,
    const Static_filter_error &h1b,
    const Static_filter_error &h1c,
    const Static_filter_error &h2a,
    const Static_filter_error &h2b,
    const Static_filter_error &h2c,
    double & epsilon_0,
    double & epsilon_1,
    double & epsilon_2,
    double & epsilon_3)
{
  typedef Static_filter_error FT;

  FT FT0(0);
  Sign s1 = lexicographical_sign_SAF(h1b, -h1a,
		epsilon_0);
  Sign s2 = lexicographical_sign_SAF(h2b, -h2a,
		epsilon_1);
  Sign s3 = sign_of_determinant2x2_SAF(l1a, l1b, l2a, l2b,
		epsilon_2);
  Sign s4 = sign_of_determinant4x4_SAF(h2a, h2b, FT0, h2c,
                                   l1a, FT0, l1b, l1c,
                                   l2a, FT0, l2b, l2c,
                                   h1a, h1b, FT0, h1c,
		epsilon_3);
  return Comparison_result (s1 * s2 * s3 * s4);
}

inline
Comparison_result
compare_y_at_xC2_SAF(
    const Restricted_double &l1a,
    const Restricted_double &l1b,
    const Restricted_double &l1c,
    const Restricted_double &l2a,
    const Restricted_double &l2b,
    const Restricted_double &l2c,
    const Restricted_double &h1a,
    const Restricted_double &h1b,
    const Restricted_double &h1c,
    const Restricted_double &h2a,
    const Restricted_double &h2b,
    const Restricted_double &h2c,
    const double & epsilon_0,
    const double & epsilon_1,
    const double & epsilon_2,
    const double & epsilon_3)
{
  typedef Restricted_double FT;

  FT FT0(0);
  Sign s1 = lexicographical_sign_SAF(h1b, -h1a,
		epsilon_0);
  Sign s2 = lexicographical_sign_SAF(h2b, -h2a,
		epsilon_1);
  Sign s3 = sign_of_determinant2x2_SAF(l1a, l1b, l2a, l2b,
		epsilon_2);
  Sign s4 = sign_of_determinant4x4_SAF(h2a, h2b, FT0, h2c,
                                   l1a, FT0, l1b, l1c,
                                   l2a, FT0, l2b, l2c,
                                   h1a, h1b, FT0, h1c,
		epsilon_3);
  return Comparison_result (s1 * s2 * s3 * s4);
}

inline
Comparison_result
compare_y_at_xC2(
    const Static_adaptatif_filter &l1a,
    const Static_adaptatif_filter &l1b,
    const Static_adaptatif_filter &l1c,
    const Static_adaptatif_filter &l2a,
    const Static_adaptatif_filter &l2b,
    const Static_adaptatif_filter &l2c,
    const Static_adaptatif_filter &h1a,
    const Static_adaptatif_filter &h1b,
    const Static_adaptatif_filter &h1c,
    const Static_adaptatif_filter &h2a,
    const Static_adaptatif_filter &h2b,
    const Static_adaptatif_filter &h2c)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;
  static double SAF_epsilon_1;
  static double SAF_epsilon_2;
  static double SAF_epsilon_3;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(l1a.value()) > SAF_bound ||
	fabs(l1b.value()) > SAF_bound ||
	fabs(l1c.value()) > SAF_bound ||
	fabs(l2a.value()) > SAF_bound ||
	fabs(l2b.value()) > SAF_bound ||
	fabs(l2c.value()) > SAF_bound ||
	fabs(h1a.value()) > SAF_bound ||
	fabs(h1b.value()) > SAF_bound ||
	fabs(h1c.value()) > SAF_bound ||
	fabs(h2a.value()) > SAF_bound ||
	fabs(h2b.value()) > SAF_bound ||
	fabs(h2c.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_y_at_xC2_SAF(
		Restricted_double(l1a.value()),
		Restricted_double(l1b.value()),
		Restricted_double(l1c.value()),
		Restricted_double(l2a.value()),
		Restricted_double(l2b.value()),
		Restricted_double(l2c.value()),
		Restricted_double(h1a.value()),
		Restricted_double(h1b.value()),
		Restricted_double(h1c.value()),
		Restricted_double(h2a.value()),
		Restricted_double(h2b.value()),
		Restricted_double(h2c.value()),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2,
		SAF_epsilon_3);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(l1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(l2c.value()));
      SAF_bound = std::max(SAF_bound, fabs(h1a.value()));
      SAF_bound = std::max(SAF_bound, fabs(h1b.value()));
      SAF_bound = std::max(SAF_bound, fabs(h1c.value()));
      SAF_bound = std::max(SAF_bound, fabs(h2a.value()));
      SAF_bound = std::max(SAF_bound, fabs(h2b.value()));
      SAF_bound = std::max(SAF_bound, fabs(h2c.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_y_at_xC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0,
		SAF_epsilon_1,
		SAF_epsilon_2,
		SAF_epsilon_3);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_y_at_xC2(
		l1a.exact(),
		l1b.exact(),
		l1c.exact(),
		l2a.exact(),
		l2b.exact(),
		l2c.exact(),
		h1a.exact(),
		h1b.exact(),
		h1c.exact(),
		h2a.exact(),
		h2b.exact(),
		h2c.exact());
  }
}

inline
Comparison_result
compare_deltax_deltayC2_SAF(
    const Static_filter_error &px,
    const Static_filter_error &qx,
    const Static_filter_error &ry,
    const Static_filter_error &sy,
    double & epsilon_0)
{
  typedef Static_filter_error FT;

    return CGAL::compare_SAF(abs(px-qx), abs(ry-sy),
		epsilon_0);
}

inline
Comparison_result
compare_deltax_deltayC2_SAF(
    const Restricted_double &px,
    const Restricted_double &qx,
    const Restricted_double &ry,
    const Restricted_double &sy,
    const double & epsilon_0)
{
  typedef Restricted_double FT;

    return CGAL::compare_SAF(abs(px-qx), abs(ry-sy),
		epsilon_0);
}

inline
Comparison_result
compare_deltax_deltayC2(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &sy)
{
  bool tried = false;
  static double SAF_bound = -1.0;
  static double SAF_epsilon_0;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= SAF_bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
	fabs(px.value()) > SAF_bound ||
	fabs(qx.value()) > SAF_bound ||
	fabs(ry.value()) > SAF_bound ||
	fabs(sy.value()) > SAF_bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return compare_deltax_deltayC2_SAF(
		Restricted_double(px.value()),
		Restricted_double(qx.value()),
		Restricted_double(ry.value()),
		Restricted_double(sy.value()),
		SAF_epsilon_0);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute SAF_bound (tighter or larger).
      SAF_bound = 0;
      SAF_bound = std::max(SAF_bound, fabs(px.value()));
      SAF_bound = std::max(SAF_bound, fabs(qx.value()));
      SAF_bound = std::max(SAF_bound, fabs(ry.value()));
      SAF_bound = std::max(SAF_bound, fabs(sy.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) compare_deltax_deltayC2_SAF(
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		Static_filter_error(SAF_bound,0,1),
		SAF_epsilon_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (SAF_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return compare_deltax_deltayC2(
		px.exact(),
		qx.exact(),
		ry.exact(),
		sy.exact());
  }
}

