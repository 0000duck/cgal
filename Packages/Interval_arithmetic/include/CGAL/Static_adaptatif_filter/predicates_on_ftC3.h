// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/predicates_on_ftC3.h
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef CGAL_ARITHMETIC_FILTER_PREDICATES_ON_FTC3_H
#define CGAL_ARITHMETIC_FILTER_PREDICATES_ON_FTC3_H

CGAL_BEGIN_NAMESPACE

inline
bool
collinearC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    double & epsilon_0,
    double & epsilon_1,
    double & epsilon_2)
{
  Static_filter_error dpx = px-rx;
  Static_filter_error dpy = py-ry;
  Static_filter_error dpz = pz-rz;
  Static_filter_error dqx = qx-rx;
  Static_filter_error dqy = qy-ry;
  Static_filter_error dqz = qz-rz;
  return (sign_of_determinant2x2_SAF(dpx,dqx,dpy,dqy, epsilon_0) == ZERO)
      && (sign_of_determinant2x2_SAF(dpx,dqx,dpz,dqz, epsilon_1) == ZERO)
      && (sign_of_determinant2x2_SAF(dpy,dqy,dpz,dqz, epsilon_2) == ZERO);
}

inline
bool
collinearC3_SAF(
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const Restricted_double &rx,
    const Restricted_double &ry,
    const Restricted_double &rz,
    const double & epsilon_0,
    const double & epsilon_1,
    const double & epsilon_2)
{
  Restricted_double dpx = px-rx;
  Restricted_double dpy = py-ry;
  Restricted_double dpz = pz-rz;
  Restricted_double dqx = qx-rx;
  Restricted_double dqy = qy-ry;
  Restricted_double dqz = qz-rz;
  return (sign_of_determinant2x2_SAF(dpx,dqx,dpy,dqy, epsilon_0) == ZERO)
      && (sign_of_determinant2x2_SAF(dpx,dqx,dpz,dqz, epsilon_1) == ZERO)
      && (sign_of_determinant2x2_SAF(dpy,dqy,dpz,dqz, epsilon_2) == ZERO);
}

inline
bool
collinearC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;
  static double _epsilon_1;
  static double _epsilon_2;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound ||
        fabs(rx.value()) > _bound ||
        fabs(ry.value()) > _bound ||
        fabs(rz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return collinearC3_SAF(
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		Restricted_double(rx.value()),
		Restricted_double(ry.value()),
		Restricted_double(rz.value()),
		_epsilon_0,
		_epsilon_1,
		_epsilon_2);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));
      _bound = std::max(_bound, fabs(rx.value()));
      _bound = std::max(_bound, fabs(ry.value()));
      _bound = std::max(_bound, fabs(rz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) collinearC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0,
		_epsilon_1,
		_epsilon_2);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return collinearC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact());
  }
}

inline
Orientation
orientationC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    const Static_filter_error &sx,
    const Static_filter_error &sy,
    const Static_filter_error &sz,
    double & epsilon_0)
{
  return Orientation(sign_of_determinant3x3_SAF(qx-px,rx-px,sx-px,
                                            qy-py,ry-py,sy-py,
                                            qz-pz,rz-pz,sz-pz, epsilon_0));
}

inline
Orientation
orientationC3_SAF(
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const Restricted_double &rx,
    const Restricted_double &ry,
    const Restricted_double &rz,
    const Restricted_double &sx,
    const Restricted_double &sy,
    const Restricted_double &sz,
    const double & epsilon_0)
{
  return Orientation(sign_of_determinant3x3_SAF(qx-px,rx-px,sx-px,
                                            qy-py,ry-py,sy-py,
                                            qz-pz,rz-pz,sz-pz, epsilon_0));
}

inline
Orientation
orientationC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz,
    const Static_adaptatif_filter &sx,
    const Static_adaptatif_filter &sy,
    const Static_adaptatif_filter &sz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound ||
        fabs(rx.value()) > _bound ||
        fabs(ry.value()) > _bound ||
        fabs(rz.value()) > _bound ||
        fabs(sx.value()) > _bound ||
        fabs(sy.value()) > _bound ||
        fabs(sz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return orientationC3_SAF(
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		Restricted_double(rx.value()),
		Restricted_double(ry.value()),
		Restricted_double(rz.value()),
		Restricted_double(sx.value()),
		Restricted_double(sy.value()),
		Restricted_double(sz.value()),
		_epsilon_0);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));
      _bound = std::max(_bound, fabs(rx.value()));
      _bound = std::max(_bound, fabs(ry.value()));
      _bound = std::max(_bound, fabs(rz.value()));
      _bound = std::max(_bound, fabs(sx.value()));
      _bound = std::max(_bound, fabs(sy.value()));
      _bound = std::max(_bound, fabs(sz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) orientationC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return orientationC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact(),
		sx.exact(),
		sy.exact(),
		sz.exact());
  }
}

inline
Oriented_side
side_of_oriented_sphereC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    const Static_filter_error &sx,
    const Static_filter_error &sy,
    const Static_filter_error &sz,
    const Static_filter_error &tx,
    const Static_filter_error &ty,
    const Static_filter_error &tz,
    double & epsilon_0)
{
  Static_filter_error ptx = px - tx;
  Static_filter_error pty = py - ty;
  Static_filter_error ptz = pz - tz;
  Static_filter_error pt2 = square(ptx) + square(pty) + square(ptz);
  Static_filter_error qtx = qx - tx;
  Static_filter_error qty = qy - ty;
  Static_filter_error qtz = qz - tz;
  Static_filter_error qt2 = square(qtx) + square(qty) + square(qtz);
  Static_filter_error rtx = rx - tx;
  Static_filter_error rty = ry - ty;
  Static_filter_error rtz = rz - tz;
  Static_filter_error rt2 = square(rtx) + square(rty) + square(rtz);
  Static_filter_error stx = sx - tx;
  Static_filter_error sty = sy - ty;
  Static_filter_error stz = sz - tz;
  Static_filter_error st2 = square(stx) + square(sty) + square(stz);
  return Oriented_side(sign_of_determinant4x4_SAF(ptx,pty,ptz,pt2,
                                              rtx,rty,rtz,rt2,
                                              qtx,qty,qtz,qt2,
                                              stx,sty,stz,st2, epsilon_0));
}

inline
Oriented_side
side_of_oriented_sphereC3_SAF(
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const Restricted_double &rx,
    const Restricted_double &ry,
    const Restricted_double &rz,
    const Restricted_double &sx,
    const Restricted_double &sy,
    const Restricted_double &sz,
    const Restricted_double &tx,
    const Restricted_double &ty,
    const Restricted_double &tz,
    const double & epsilon_0)
{
  Restricted_double ptx = px - tx;
  Restricted_double pty = py - ty;
  Restricted_double ptz = pz - tz;
  Restricted_double pt2 = square(ptx) + square(pty) + square(ptz);
  Restricted_double qtx = qx - tx;
  Restricted_double qty = qy - ty;
  Restricted_double qtz = qz - tz;
  Restricted_double qt2 = square(qtx) + square(qty) + square(qtz);
  Restricted_double rtx = rx - tx;
  Restricted_double rty = ry - ty;
  Restricted_double rtz = rz - tz;
  Restricted_double rt2 = square(rtx) + square(rty) + square(rtz);
  Restricted_double stx = sx - tx;
  Restricted_double sty = sy - ty;
  Restricted_double stz = sz - tz;
  Restricted_double st2 = square(stx) + square(sty) + square(stz);
  return Oriented_side(sign_of_determinant4x4_SAF(ptx,pty,ptz,pt2,
                                              rtx,rty,rtz,rt2,
                                              qtx,qty,qtz,qt2,
                                              stx,sty,stz,st2, epsilon_0));
}

inline
Oriented_side
side_of_oriented_sphereC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz,
    const Static_adaptatif_filter &sx,
    const Static_adaptatif_filter &sy,
    const Static_adaptatif_filter &sz,
    const Static_adaptatif_filter &tx,
    const Static_adaptatif_filter &ty,
    const Static_adaptatif_filter &tz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound ||
        fabs(rx.value()) > _bound ||
        fabs(ry.value()) > _bound ||
        fabs(rz.value()) > _bound ||
        fabs(sx.value()) > _bound ||
        fabs(sy.value()) > _bound ||
        fabs(sz.value()) > _bound ||
        fabs(tx.value()) > _bound ||
        fabs(ty.value()) > _bound ||
        fabs(tz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return side_of_oriented_sphereC3_SAF(
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		Restricted_double(rx.value()),
		Restricted_double(ry.value()),
		Restricted_double(rz.value()),
		Restricted_double(sx.value()),
		Restricted_double(sy.value()),
		Restricted_double(sz.value()),
		Restricted_double(tx.value()),
		Restricted_double(ty.value()),
		Restricted_double(tz.value()),
		_epsilon_0);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));
      _bound = std::max(_bound, fabs(rx.value()));
      _bound = std::max(_bound, fabs(ry.value()));
      _bound = std::max(_bound, fabs(rz.value()));
      _bound = std::max(_bound, fabs(sx.value()));
      _bound = std::max(_bound, fabs(sy.value()));
      _bound = std::max(_bound, fabs(sz.value()));
      _bound = std::max(_bound, fabs(tx.value()));
      _bound = std::max(_bound, fabs(ty.value()));
      _bound = std::max(_bound, fabs(tz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) side_of_oriented_sphereC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return side_of_oriented_sphereC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact(),
		sx.exact(),
		sy.exact(),
		sz.exact(),
		tx.exact(),
		ty.exact(),
		tz.exact());
  }
}

inline
Bounded_side
side_of_bounded_sphereC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    const Static_filter_error &sx,
    const Static_filter_error &sy,
    const Static_filter_error &sz,
    const Static_filter_error &tx,
    const Static_filter_error &ty,
    const Static_filter_error &tz,
    double & epsilon_0,
    double & epsilon_1)
{
  Oriented_side s = side_of_oriented_sphereC3_SAF(px, py, pz,
                                              qx, qy, qz,
                                              rx, ry, rz,
                                              sx, sy, sz,
                                              tx, ty, tz, epsilon_0);
  Orientation o = orientationC3_SAF(px, py, pz,
                                qx, qy, qz,
                                rx, ry, rz,
                                sx, sy, sz, epsilon_1);
  return Bounded_side(s * o);
}

inline
Bounded_side
side_of_bounded_sphereC3_SAF(
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const Restricted_double &rx,
    const Restricted_double &ry,
    const Restricted_double &rz,
    const Restricted_double &sx,
    const Restricted_double &sy,
    const Restricted_double &sz,
    const Restricted_double &tx,
    const Restricted_double &ty,
    const Restricted_double &tz,
    const double & epsilon_0,
    const double & epsilon_1)
{
  Oriented_side s = side_of_oriented_sphereC3_SAF(px, py, pz,
                                              qx, qy, qz,
                                              rx, ry, rz,
                                              sx, sy, sz,
                                              tx, ty, tz, epsilon_0);
  Orientation o = orientationC3_SAF(px, py, pz,
                                qx, qy, qz,
                                rx, ry, rz,
                                sx, sy, sz, epsilon_1);
  return Bounded_side(s * o);
}

inline
Bounded_side
side_of_bounded_sphereC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz,
    const Static_adaptatif_filter &sx,
    const Static_adaptatif_filter &sy,
    const Static_adaptatif_filter &sz,
    const Static_adaptatif_filter &tx,
    const Static_adaptatif_filter &ty,
    const Static_adaptatif_filter &tz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;
  static double _epsilon_1;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound ||
        fabs(rx.value()) > _bound ||
        fabs(ry.value()) > _bound ||
        fabs(rz.value()) > _bound ||
        fabs(sx.value()) > _bound ||
        fabs(sy.value()) > _bound ||
        fabs(sz.value()) > _bound ||
        fabs(tx.value()) > _bound ||
        fabs(ty.value()) > _bound ||
        fabs(tz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return side_of_bounded_sphereC3_SAF(
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		Restricted_double(rx.value()),
		Restricted_double(ry.value()),
		Restricted_double(rz.value()),
		Restricted_double(sx.value()),
		Restricted_double(sy.value()),
		Restricted_double(sz.value()),
		Restricted_double(tx.value()),
		Restricted_double(ty.value()),
		Restricted_double(tz.value()),
		_epsilon_0,
		_epsilon_1);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));
      _bound = std::max(_bound, fabs(rx.value()));
      _bound = std::max(_bound, fabs(ry.value()));
      _bound = std::max(_bound, fabs(rz.value()));
      _bound = std::max(_bound, fabs(sx.value()));
      _bound = std::max(_bound, fabs(sy.value()));
      _bound = std::max(_bound, fabs(sz.value()));
      _bound = std::max(_bound, fabs(tx.value()));
      _bound = std::max(_bound, fabs(ty.value()));
      _bound = std::max(_bound, fabs(tz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) side_of_bounded_sphereC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0,
		_epsilon_1);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return side_of_bounded_sphereC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact(),
		sx.exact(),
		sy.exact(),
		sz.exact(),
		tx.exact(),
		ty.exact(),
		tz.exact());
  }
}

inline
Comparison_result
cmp_dist_to_pointC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    double & epsilon_0)
{
  return CGAL::compare_SAF(squared_distanceC3(px,py,pz,qx,qy,qz),
                       squared_distanceC3(px,py,pz,rx,ry,rz), epsilon_0);
}

inline
Comparison_result
cmp_dist_to_pointC3_SAF(
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const Restricted_double &rx,
    const Restricted_double &ry,
    const Restricted_double &rz,
    const double & epsilon_0)
{
  return CGAL::compare_SAF(squared_distanceC3(px,py,pz,qx,qy,qz),
                       squared_distanceC3(px,py,pz,rx,ry,rz), epsilon_0);
}

inline
Comparison_result
cmp_dist_to_pointC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound ||
        fabs(rx.value()) > _bound ||
        fabs(ry.value()) > _bound ||
        fabs(rz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return cmp_dist_to_pointC3_SAF(
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		Restricted_double(rx.value()),
		Restricted_double(ry.value()),
		Restricted_double(rz.value()),
		_epsilon_0);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));
      _bound = std::max(_bound, fabs(rx.value()));
      _bound = std::max(_bound, fabs(ry.value()));
      _bound = std::max(_bound, fabs(rz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) cmp_dist_to_pointC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return cmp_dist_to_pointC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact());
  }
}

inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const Static_filter_error &pa,
    const Static_filter_error &pb,
    const Static_filter_error &pc,
    const Static_filter_error &pd,
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    double & epsilon_0)
{
  return CGAL::compare_SAF(scaled_distance_to_planeC3(pa,pb,pc,pd,px,py,pz),
                       scaled_distance_to_planeC3(pa,pb,pc,pd,qx,qy,qz), epsilon_0);
}

inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const Restricted_double &pa,
    const Restricted_double &pb,
    const Restricted_double &pc,
    const Restricted_double &pd,
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const double & epsilon_0)
{
  return CGAL::compare_SAF(scaled_distance_to_planeC3(pa,pb,pc,pd,px,py,pz),
                       scaled_distance_to_planeC3(pa,pb,pc,pd,qx,qy,qz), epsilon_0);
}

inline
Comparison_result
cmp_signed_dist_to_planeC3(
    const Static_adaptatif_filter &pa,
    const Static_adaptatif_filter &pb,
    const Static_adaptatif_filter &pc,
    const Static_adaptatif_filter &pd,
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(pa.value()) > _bound ||
        fabs(pb.value()) > _bound ||
        fabs(pc.value()) > _bound ||
        fabs(pd.value()) > _bound ||
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return cmp_signed_dist_to_planeC3_SAF(
		Restricted_double(pa.value()),
		Restricted_double(pb.value()),
		Restricted_double(pc.value()),
		Restricted_double(pd.value()),
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		_epsilon_0);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(pa.value()));
      _bound = std::max(_bound, fabs(pb.value()));
      _bound = std::max(_bound, fabs(pc.value()));
      _bound = std::max(_bound, fabs(pd.value()));
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) cmp_signed_dist_to_planeC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return cmp_signed_dist_to_planeC3(
		pa.exact(),
		pb.exact(),
		pc.exact(),
		pd.exact(),
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact());
  }
}

inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const Static_filter_error &ppx,
    const Static_filter_error &ppy,
    const Static_filter_error &ppz,
    const Static_filter_error &pqx,
    const Static_filter_error &pqy,
    const Static_filter_error &pqz,
    const Static_filter_error &prx,
    const Static_filter_error &pry,
    const Static_filter_error &prz,
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    double & epsilon_0)
{
  return CGAL::compare_SAF(
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      px,py,pz),
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      qx,qy,qz) , epsilon_0);
}

inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const Restricted_double &ppx,
    const Restricted_double &ppy,
    const Restricted_double &ppz,
    const Restricted_double &pqx,
    const Restricted_double &pqy,
    const Restricted_double &pqz,
    const Restricted_double &prx,
    const Restricted_double &pry,
    const Restricted_double &prz,
    const Restricted_double &px,
    const Restricted_double &py,
    const Restricted_double &pz,
    const Restricted_double &qx,
    const Restricted_double &qy,
    const Restricted_double &qz,
    const double & epsilon_0)
{
  return CGAL::compare_SAF(
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      px,py,pz),
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      qx,qy,qz) , epsilon_0);
}

inline
Comparison_result
cmp_signed_dist_to_planeC3(
    const Static_adaptatif_filter &ppx,
    const Static_adaptatif_filter &ppy,
    const Static_adaptatif_filter &ppz,
    const Static_adaptatif_filter &pqx,
    const Static_adaptatif_filter &pqy,
    const Static_adaptatif_filter &pqz,
    const Static_adaptatif_filter &prx,
    const Static_adaptatif_filter &pry,
    const Static_adaptatif_filter &prz,
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz)
{
  bool tried = false;
  static double _bound = -1.0;
  static double _epsilon_0;

letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    // The throw mecanism is not useful here, it should be before the try{}.
    if (
        fabs(ppx.value()) > _bound ||
        fabs(ppy.value()) > _bound ||
        fabs(ppz.value()) > _bound ||
        fabs(pqx.value()) > _bound ||
        fabs(pqy.value()) > _bound ||
        fabs(pqz.value()) > _bound ||
        fabs(prx.value()) > _bound ||
        fabs(pry.value()) > _bound ||
        fabs(prz.value()) > _bound ||
        fabs(px.value()) > _bound ||
        fabs(py.value()) > _bound ||
        fabs(pz.value()) > _bound ||
        fabs(qx.value()) > _bound ||
        fabs(qy.value()) > _bound ||
        fabs(qz.value()) > _bound)
      throw Restricted_double::unsafe_comparison();
    // Try the epsilon variant of the predicate.
    return cmp_signed_dist_to_planeC3_SAF(
		Restricted_double(ppx.value()),
		Restricted_double(ppy.value()),
		Restricted_double(ppz.value()),
		Restricted_double(pqx.value()),
		Restricted_double(pqy.value()),
		Restricted_double(pqz.value()),
		Restricted_double(prx.value()),
		Restricted_double(pry.value()),
		Restricted_double(prz.value()),
		Restricted_double(px.value()),
		Restricted_double(py.value()),
		Restricted_double(pz.value()),
		Restricted_double(qx.value()),
		Restricted_double(qy.value()),
		Restricted_double(qz.value()),
		_epsilon_0);
  }
  catch (Restricted_double::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = std::max(_bound, fabs(ppx.value()));
      _bound = std::max(_bound, fabs(ppy.value()));
      _bound = std::max(_bound, fabs(ppz.value()));
      _bound = std::max(_bound, fabs(pqx.value()));
      _bound = std::max(_bound, fabs(pqy.value()));
      _bound = std::max(_bound, fabs(pqz.value()));
      _bound = std::max(_bound, fabs(prx.value()));
      _bound = std::max(_bound, fabs(pry.value()));
      _bound = std::max(_bound, fabs(prz.value()));
      _bound = std::max(_bound, fabs(px.value()));
      _bound = std::max(_bound, fabs(py.value()));
      _bound = std::max(_bound, fabs(pz.value()));
      _bound = std::max(_bound, fabs(qx.value()));
      _bound = std::max(_bound, fabs(qy.value()));
      _bound = std::max(_bound, fabs(qz.value()));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) cmp_signed_dist_to_planeC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		_epsilon_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return cmp_signed_dist_to_planeC3(
		ppx.exact(),
		ppy.exact(),
		ppz.exact(),
		pqx.exact(),
		pqy.exact(),
		pqz.exact(),
		prx.exact(),
		pry.exact(),
		prz.exact(),
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact());
  }
}

CGAL_END_NAMESPACE

#endif // CGAL_ARITHMETIC_FILTER_PREDICATES_ON_FTC3_H
