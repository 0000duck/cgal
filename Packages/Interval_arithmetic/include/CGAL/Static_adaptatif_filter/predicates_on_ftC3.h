// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Static_adaptatif_filter/predicates_on_ftC3.h
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef CGAL_STATIC_ADAPTATIF_FILTER_PREDICATES_ON_FTC3_H
#define CGAL_STATIC_ADAPTATIF_FILTER_PREDICATES_ON_FTC3_H

CGAL_BEGIN_NAMESPACE

double Filter_epsilon_collinearC3_9_0;
double Filter_epsilon_collinearC3_9_1;
double Filter_epsilon_collinearC3_9_2;

inline
bool
collinearC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    double & epsilon_0,
    double & epsilon_1,
    double & epsilon_2)
{
  Static_filter_error dpx = px-rx;
  Static_filter_error dpy = py-ry;
  Static_filter_error dpz = pz-rz;
  Static_filter_error dqx = qx-rx;
  Static_filter_error dqy = qy-ry;
  Static_filter_error dqz = qz-rz;
  return (sign_of_determinant2x2_SAF(dpx,dqx,dpy,dqy, epsilon_0) == ZERO)
      && (sign_of_determinant2x2_SAF(dpx,dqx,dpz,dqz, epsilon_1) == ZERO)
      && (sign_of_determinant2x2_SAF(dpy,dqy,dpz,dqz, epsilon_2) == ZERO);
}


inline
bool
collinearC3_SAF(
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
    const double &rx,
    const double &ry,
    const double &rz,
   const double & epsilon_0,
   const double & epsilon_1,
   const double & epsilon_2)
{
  double dpx = px-rx;
  double dpy = py-ry;
  double dpz = pz-rz;
  double dqx = qx-rx;
  double dqy = qy-ry;
  double dqz = qz-rz;
  return (sign_of_determinant2x2_SAF(dpx,dqx,dpy,dqy, epsilon_0) == ZERO)
      && (sign_of_determinant2x2_SAF(dpx,dqx,dpz,dqz, epsilon_1) == ZERO)
      && (sign_of_determinant2x2_SAF(dpy,dqy,dpz,dqz, epsilon_2) == ZERO);
}


inline
bool
collinearC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound ||
        fabs(rx) > _bound ||
        fabs(ry) > _bound ||
        fabs(rz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return collinearC3_SAF(
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		rx.value(),
		ry.value(),
		rz.value(),
		Filter_epsilon_collinearC3_9_0,
		Filter_epsilon_collinearC3_9_1,
		Filter_epsilon_collinearC3_9_2);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));
      _bound = max(_bound, fabs(rx));
      _bound = max(_bound, fabs(ry));
      _bound = max(_bound, fabs(rz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) collinearC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_collinearC3_9_0,
		Filter_epsilon_collinearC3_9_1,
		Filter_epsilon_collinearC3_9_2);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return collinearC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact());
  }
}

double Filter_epsilon_orientationC3_12_0;

inline
Orientation
orientationC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    const Static_filter_error &sx,
    const Static_filter_error &sy,
    const Static_filter_error &sz,
    double & epsilon_0)
{
  return Orientation(sign_of_determinant3x3_SAF(qx-px,rx-px,sx-px,
                                            qy-py,ry-py,sy-py,
                                            qz-pz,rz-pz,sz-pz, epsilon_0));
}


inline
Orientation
orientationC3_SAF(
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
    const double &rx,
    const double &ry,
    const double &rz,
    const double &sx,
    const double &sy,
    const double &sz,
   const double & epsilon_0)
{
  return Orientation(sign_of_determinant3x3_SAF(qx-px,rx-px,sx-px,
                                            qy-py,ry-py,sy-py,
                                            qz-pz,rz-pz,sz-pz, epsilon_0));
}


inline
Orientation
orientationC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz,
    const Static_adaptatif_filter &sx,
    const Static_adaptatif_filter &sy,
    const Static_adaptatif_filter &sz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound ||
        fabs(rx) > _bound ||
        fabs(ry) > _bound ||
        fabs(rz) > _bound ||
        fabs(sx) > _bound ||
        fabs(sy) > _bound ||
        fabs(sz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return orientationC3_SAF(
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		rx.value(),
		ry.value(),
		rz.value(),
		sx.value(),
		sy.value(),
		sz.value(),
		Filter_epsilon_orientationC3_12_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));
      _bound = max(_bound, fabs(rx));
      _bound = max(_bound, fabs(ry));
      _bound = max(_bound, fabs(rz));
      _bound = max(_bound, fabs(sx));
      _bound = max(_bound, fabs(sy));
      _bound = max(_bound, fabs(sz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) orientationC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_orientationC3_12_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return orientationC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact(),
		sx.exact(),
		sy.exact(),
		sz.exact());
  }
}

double Filter_epsilon_side_of_oriented_sphereC3_15_0;

inline
Oriented_side
side_of_oriented_sphereC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    const Static_filter_error &sx,
    const Static_filter_error &sy,
    const Static_filter_error &sz,
    const Static_filter_error &tx,
    const Static_filter_error &ty,
    const Static_filter_error &tz,
    double & epsilon_0)
{
  Static_filter_error ptx = px - tx;
  Static_filter_error pty = py - ty;
  Static_filter_error ptz = pz - tz;
  Static_filter_error pt2 = square(ptx) + square(pty) + square(ptz);
  Static_filter_error qtx = qx - tx;
  Static_filter_error qty = qy - ty;
  Static_filter_error qtz = qz - tz;
  Static_filter_error qt2 = square(qtx) + square(qty) + square(qtz);
  Static_filter_error rtx = rx - tx;
  Static_filter_error rty = ry - ty;
  Static_filter_error rtz = rz - tz;
  Static_filter_error rt2 = square(rtx) + square(rty) + square(rtz);
  Static_filter_error stx = sx - tx;
  Static_filter_error sty = sy - ty;
  Static_filter_error stz = sz - tz;
  Static_filter_error st2 = square(stx) + square(sty) + square(stz);
  return Oriented_side(sign_of_determinant4x4_SAF(ptx,pty,ptz,pt2,
                                              rtx,rty,rtz,rt2,
                                              qtx,qty,qtz,qt2,
                                              stx,sty,stz,st2, epsilon_0));
}


inline
Oriented_side
side_of_oriented_sphereC3_SAF(
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
    const double &rx,
    const double &ry,
    const double &rz,
    const double &sx,
    const double &sy,
    const double &sz,
    const double &tx,
    const double &ty,
    const double &tz,
   const double & epsilon_0)
{
  double ptx = px - tx;
  double pty = py - ty;
  double ptz = pz - tz;
  double pt2 = square(ptx) + square(pty) + square(ptz);
  double qtx = qx - tx;
  double qty = qy - ty;
  double qtz = qz - tz;
  double qt2 = square(qtx) + square(qty) + square(qtz);
  double rtx = rx - tx;
  double rty = ry - ty;
  double rtz = rz - tz;
  double rt2 = square(rtx) + square(rty) + square(rtz);
  double stx = sx - tx;
  double sty = sy - ty;
  double stz = sz - tz;
  double st2 = square(stx) + square(sty) + square(stz);
  return Oriented_side(sign_of_determinant4x4_SAF(ptx,pty,ptz,pt2,
                                              rtx,rty,rtz,rt2,
                                              qtx,qty,qtz,qt2,
                                              stx,sty,stz,st2, epsilon_0));
}


inline
Oriented_side
side_of_oriented_sphereC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz,
    const Static_adaptatif_filter &sx,
    const Static_adaptatif_filter &sy,
    const Static_adaptatif_filter &sz,
    const Static_adaptatif_filter &tx,
    const Static_adaptatif_filter &ty,
    const Static_adaptatif_filter &tz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound ||
        fabs(rx) > _bound ||
        fabs(ry) > _bound ||
        fabs(rz) > _bound ||
        fabs(sx) > _bound ||
        fabs(sy) > _bound ||
        fabs(sz) > _bound ||
        fabs(tx) > _bound ||
        fabs(ty) > _bound ||
        fabs(tz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return side_of_oriented_sphereC3_SAF(
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		rx.value(),
		ry.value(),
		rz.value(),
		sx.value(),
		sy.value(),
		sz.value(),
		tx.value(),
		ty.value(),
		tz.value(),
		Filter_epsilon_side_of_oriented_sphereC3_15_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));
      _bound = max(_bound, fabs(rx));
      _bound = max(_bound, fabs(ry));
      _bound = max(_bound, fabs(rz));
      _bound = max(_bound, fabs(sx));
      _bound = max(_bound, fabs(sy));
      _bound = max(_bound, fabs(sz));
      _bound = max(_bound, fabs(tx));
      _bound = max(_bound, fabs(ty));
      _bound = max(_bound, fabs(tz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) side_of_oriented_sphereC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_side_of_oriented_sphereC3_15_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return side_of_oriented_sphereC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact(),
		sx.exact(),
		sy.exact(),
		sz.exact(),
		tx.exact(),
		ty.exact(),
		tz.exact());
  }
}

double Filter_epsilon_side_of_bounded_sphereC3_15_0;
double Filter_epsilon_side_of_bounded_sphereC3_15_1;

inline
Bounded_side
side_of_bounded_sphereC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    const Static_filter_error &sx,
    const Static_filter_error &sy,
    const Static_filter_error &sz,
    const Static_filter_error &tx,
    const Static_filter_error &ty,
    const Static_filter_error &tz,
    double & epsilon_0,
    double & epsilon_1)
{
  Oriented_side s = side_of_oriented_sphereC3_SAF(px, py, pz,
                                              qx, qy, qz,
                                              rx, ry, rz,
                                              sx, sy, sz,
                                              tx, ty, tz, epsilon_0);
  Orientation o = orientationC3_SAF(px, py, pz,
                                qx, qy, qz,
                                rx, ry, rz,
                                sx, sy, sz, epsilon_1);
  return Bounded_side(s * o);
}


inline
Bounded_side
side_of_bounded_sphereC3_SAF(
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
    const double &rx,
    const double &ry,
    const double &rz,
    const double &sx,
    const double &sy,
    const double &sz,
    const double &tx,
    const double &ty,
    const double &tz,
   const double & epsilon_0,
   const double & epsilon_1)
{
  Oriented_side s = side_of_oriented_sphereC3_SAF(px, py, pz,
                                              qx, qy, qz,
                                              rx, ry, rz,
                                              sx, sy, sz,
                                              tx, ty, tz, epsilon_0);
  Orientation o = orientationC3_SAF(px, py, pz,
                                qx, qy, qz,
                                rx, ry, rz,
                                sx, sy, sz, epsilon_1);
  return Bounded_side(s * o);
}


inline
Bounded_side
side_of_bounded_sphereC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz,
    const Static_adaptatif_filter &sx,
    const Static_adaptatif_filter &sy,
    const Static_adaptatif_filter &sz,
    const Static_adaptatif_filter &tx,
    const Static_adaptatif_filter &ty,
    const Static_adaptatif_filter &tz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound ||
        fabs(rx) > _bound ||
        fabs(ry) > _bound ||
        fabs(rz) > _bound ||
        fabs(sx) > _bound ||
        fabs(sy) > _bound ||
        fabs(sz) > _bound ||
        fabs(tx) > _bound ||
        fabs(ty) > _bound ||
        fabs(tz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return side_of_bounded_sphereC3_SAF(
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		rx.value(),
		ry.value(),
		rz.value(),
		sx.value(),
		sy.value(),
		sz.value(),
		tx.value(),
		ty.value(),
		tz.value(),
		Filter_epsilon_side_of_bounded_sphereC3_15_0,
		Filter_epsilon_side_of_bounded_sphereC3_15_1);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));
      _bound = max(_bound, fabs(rx));
      _bound = max(_bound, fabs(ry));
      _bound = max(_bound, fabs(rz));
      _bound = max(_bound, fabs(sx));
      _bound = max(_bound, fabs(sy));
      _bound = max(_bound, fabs(sz));
      _bound = max(_bound, fabs(tx));
      _bound = max(_bound, fabs(ty));
      _bound = max(_bound, fabs(tz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) side_of_bounded_sphereC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_side_of_bounded_sphereC3_15_0,
		Filter_epsilon_side_of_bounded_sphereC3_15_1);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return side_of_bounded_sphereC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact(),
		sx.exact(),
		sy.exact(),
		sz.exact(),
		tx.exact(),
		ty.exact(),
		tz.exact());
  }
}

double Filter_epsilon_cmp_dist_to_pointC3_9_0;

inline
Comparison_result
cmp_dist_to_pointC3_SAF(
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    const Static_filter_error &rx,
    const Static_filter_error &ry,
    const Static_filter_error &rz,
    double & epsilon_0)
{
  return CGAL::compare_SAF(squared_distanceC3(px,py,pz,qx,qy,qz),
                       squared_distanceC3(px,py,pz,rx,ry,rz), epsilon_0);
}


inline
Comparison_result
cmp_dist_to_pointC3_SAF(
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
    const double &rx,
    const double &ry,
    const double &rz,
   const double & epsilon_0)
{
  return CGAL::compare_SAF(squared_distanceC3(px,py,pz,qx,qy,qz),
                       squared_distanceC3(px,py,pz,rx,ry,rz), epsilon_0);
}


inline
Comparison_result
cmp_dist_to_pointC3(
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz,
    const Static_adaptatif_filter &rx,
    const Static_adaptatif_filter &ry,
    const Static_adaptatif_filter &rz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound ||
        fabs(rx) > _bound ||
        fabs(ry) > _bound ||
        fabs(rz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return cmp_dist_to_pointC3_SAF(
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		rx.value(),
		ry.value(),
		rz.value(),
		Filter_epsilon_cmp_dist_to_pointC3_9_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));
      _bound = max(_bound, fabs(rx));
      _bound = max(_bound, fabs(ry));
      _bound = max(_bound, fabs(rz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) cmp_dist_to_pointC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_cmp_dist_to_pointC3_9_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return cmp_dist_to_pointC3(
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact(),
		rx.exact(),
		ry.exact(),
		rz.exact());
  }
}

double Filter_epsilon_cmp_signed_dist_to_planeC3_10_0;

inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const Static_filter_error &pa,
    const Static_filter_error &pb,
    const Static_filter_error &pc,
    const Static_filter_error &pd,
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    double & epsilon_0)
{
  return CGAL::compare_SAF(scaled_distance_to_planeC3(pa,pb,pc,pd,px,py,pz),
                       scaled_distance_to_planeC3(pa,pb,pc,pd,qx,qy,qz), epsilon_0);
}


inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const double &pa,
    const double &pb,
    const double &pc,
    const double &pd,
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
   const double & epsilon_0)
{
  return CGAL::compare_SAF(scaled_distance_to_planeC3(pa,pb,pc,pd,px,py,pz),
                       scaled_distance_to_planeC3(pa,pb,pc,pd,qx,qy,qz), epsilon_0);
}


inline
Comparison_result
cmp_signed_dist_to_planeC3(
    const Static_adaptatif_filter &pa,
    const Static_adaptatif_filter &pb,
    const Static_adaptatif_filter &pc,
    const Static_adaptatif_filter &pd,
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(pa) > _bound ||
        fabs(pb) > _bound ||
        fabs(pc) > _bound ||
        fabs(pd) > _bound ||
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return cmp_signed_dist_to_planeC3_SAF(
		pa.value(),
		pb.value(),
		pc.value(),
		pd.value(),
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		Filter_epsilon_cmp_signed_dist_to_planeC3_10_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(pa));
      _bound = max(_bound, fabs(pb));
      _bound = max(_bound, fabs(pc));
      _bound = max(_bound, fabs(pd));
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) cmp_signed_dist_to_planeC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_cmp_signed_dist_to_planeC3_10_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return cmp_signed_dist_to_planeC3(
		pa.exact(),
		pb.exact(),
		pc.exact(),
		pd.exact(),
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact());
  }
}

double Filter_epsilon_cmp_signed_dist_to_planeC3_15_0;

inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const Static_filter_error &ppx,
    const Static_filter_error &ppy,
    const Static_filter_error &ppz,
    const Static_filter_error &pqx,
    const Static_filter_error &pqy,
    const Static_filter_error &pqz,
    const Static_filter_error &prx,
    const Static_filter_error &pry,
    const Static_filter_error &prz,
    const Static_filter_error &px,
    const Static_filter_error &py,
    const Static_filter_error &pz,
    const Static_filter_error &qx,
    const Static_filter_error &qy,
    const Static_filter_error &qz,
    double & epsilon_0)
{
  return CGAL::compare_SAF(
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      px,py,pz),
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      qx,qy,qz) , epsilon_0);
}


inline
Comparison_result
cmp_signed_dist_to_planeC3_SAF(
    const double &ppx,
    const double &ppy,
    const double &ppz,
    const double &pqx,
    const double &pqy,
    const double &pqz,
    const double &prx,
    const double &pry,
    const double &prz,
    const double &px,
    const double &py,
    const double &pz,
    const double &qx,
    const double &qy,
    const double &qz,
   const double & epsilon_0)
{
  return CGAL::compare_SAF(
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      px,py,pz),
           scaled_distance_to_planeC3(ppx,ppy,ppz,pqx,pqy,pqz,
                                      prx,pry,prz,psx,psy,psz,
                                      qx,qy,qz) , epsilon_0);
}


inline
Comparison_result
cmp_signed_dist_to_planeC3(
    const Static_adaptatif_filter &ppx,
    const Static_adaptatif_filter &ppy,
    const Static_adaptatif_filter &ppz,
    const Static_adaptatif_filter &pqx,
    const Static_adaptatif_filter &pqy,
    const Static_adaptatif_filter &pqz,
    const Static_adaptatif_filter &prx,
    const Static_adaptatif_filter &pry,
    const Static_adaptatif_filter &prz,
    const Static_adaptatif_filter &px,
    const Static_adaptatif_filter &py,
    const Static_adaptatif_filter &pz,
    const Static_adaptatif_filter &qx,
    const Static_adaptatif_filter &qy,
    const Static_adaptatif_filter &qz)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(ppx) > _bound ||
        fabs(ppy) > _bound ||
        fabs(ppz) > _bound ||
        fabs(pqx) > _bound ||
        fabs(pqy) > _bound ||
        fabs(pqz) > _bound ||
        fabs(prx) > _bound ||
        fabs(pry) > _bound ||
        fabs(prz) > _bound ||
        fabs(px) > _bound ||
        fabs(py) > _bound ||
        fabs(pz) > _bound ||
        fabs(qx) > _bound ||
        fabs(qy) > _bound ||
        fabs(qz) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return cmp_signed_dist_to_planeC3_SAF(
		ppx.value(),
		ppy.value(),
		ppz.value(),
		pqx.value(),
		pqy.value(),
		pqz.value(),
		prx.value(),
		pry.value(),
		prz.value(),
		px.value(),
		py.value(),
		pz.value(),
		qx.value(),
		qy.value(),
		qz.value(),
		Filter_epsilon_cmp_signed_dist_to_planeC3_15_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(ppx));
      _bound = max(_bound, fabs(ppy));
      _bound = max(_bound, fabs(ppz));
      _bound = max(_bound, fabs(pqx));
      _bound = max(_bound, fabs(pqy));
      _bound = max(_bound, fabs(pqz));
      _bound = max(_bound, fabs(prx));
      _bound = max(_bound, fabs(pry));
      _bound = max(_bound, fabs(prz));
      _bound = max(_bound, fabs(px));
      _bound = max(_bound, fabs(py));
      _bound = max(_bound, fabs(pz));
      _bound = max(_bound, fabs(qx));
      _bound = max(_bound, fabs(qy));
      _bound = max(_bound, fabs(qz));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) cmp_signed_dist_to_planeC3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_cmp_signed_dist_to_planeC3_15_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return cmp_signed_dist_to_planeC3(
		ppx.exact(),
		ppy.exact(),
		ppz.exact(),
		pqx.exact(),
		pqy.exact(),
		pqz.exact(),
		prx.exact(),
		pry.exact(),
		prz.exact(),
		px.exact(),
		py.exact(),
		pz.exact(),
		qx.exact(),
		qy.exact(),
		qz.exact());
  }
}

CGAL_END_NAMESPACE

#endif // CGAL_STATIC_ADAPTATIF_FILTER_PREDICATES_ON_FTC3_H
