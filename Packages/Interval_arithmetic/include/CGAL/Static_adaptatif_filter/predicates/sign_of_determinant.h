// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Static_adaptatif_filter/predicates/sign_of_determinant.h
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef CGAL_STATIC_ADAPTATIF_FILTER_PREDICATES_SIGN_OF_DETERMINANT_H
#define CGAL_STATIC_ADAPTATIF_FILTER_PREDICATES_SIGN_OF_DETERMINANT_H

CGAL_BEGIN_NAMESPACE

double Filter_epsilon_sign_of_determinant2x2_4_0;

inline
Sign
sign_of_determinant2x2_SAF(
    const Static_filter_error &a00,
    const Static_filter_error &a01,
    const Static_filter_error &a10,
    const Static_filter_error &a11,
    double & epsilon_0)
{ return static_cast<Sign>(static_cast<int>(CGAL::compare_SAF( a00*a11, a10*a01, epsilon_0)));
}


inline
Sign
sign_of_determinant2x2_SAF(
    const double &a00,
    const double &a01,
    const double &a10,
    const double &a11,
   const double & epsilon_0)
{ return static_cast<Sign>(static_cast<int>(CGAL::compare_SAF( a00*a11, a10*a01, epsilon_0)));
}


inline
Sign
sign_of_determinant2x2(
    const Static_adaptatif_filter &a00,
    const Static_adaptatif_filter &a01,
    const Static_adaptatif_filter &a10,
    const Static_adaptatif_filter &a11)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(a00) > _bound ||
        fabs(a01) > _bound ||
        fabs(a10) > _bound ||
        fabs(a11) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return sign_of_determinant2x2_SAF(
		a00.value(),
		a01.value(),
		a10.value(),
		a11.value(),
		Filter_epsilon_sign_of_determinant2x2_4_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(a00));
      _bound = max(_bound, fabs(a01));
      _bound = max(_bound, fabs(a10));
      _bound = max(_bound, fabs(a11));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) sign_of_determinant2x2_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_sign_of_determinant2x2_4_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return sign_of_determinant2x2(
		a00.exact(),
		a01.exact(),
		a10.exact(),
		a11.exact());
  }
}

double Filter_epsilon_sign_of_determinant3x3_9_0;

inline
Sign
sign_of_determinant3x3_SAF(
    const Static_filter_error &a00,
    const Static_filter_error &a01,
    const Static_filter_error &a02,
    const Static_filter_error &a10,
    const Static_filter_error &a11,
    const Static_filter_error &a12,
    const Static_filter_error &a20,
    const Static_filter_error &a21,
    const Static_filter_error &a22,
    double & epsilon_0)
{
  return CGAL::sign_SAF(det3x3_by_formula(a00, a01, a02,
                                      a10, a11, a12,
                                      a20, a21, a22), epsilon_0);
}


inline
Sign
sign_of_determinant3x3_SAF(
    const double &a00,
    const double &a01,
    const double &a02,
    const double &a10,
    const double &a11,
    const double &a12,
    const double &a20,
    const double &a21,
    const double &a22,
   const double & epsilon_0)
{
  return CGAL::sign_SAF(det3x3_by_formula(a00, a01, a02,
                                      a10, a11, a12,
                                      a20, a21, a22), epsilon_0);
}


inline
Sign
sign_of_determinant3x3(
    const Static_adaptatif_filter &a00,
    const Static_adaptatif_filter &a01,
    const Static_adaptatif_filter &a02,
    const Static_adaptatif_filter &a10,
    const Static_adaptatif_filter &a11,
    const Static_adaptatif_filter &a12,
    const Static_adaptatif_filter &a20,
    const Static_adaptatif_filter &a21,
    const Static_adaptatif_filter &a22)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(a00) > _bound ||
        fabs(a01) > _bound ||
        fabs(a02) > _bound ||
        fabs(a10) > _bound ||
        fabs(a11) > _bound ||
        fabs(a12) > _bound ||
        fabs(a20) > _bound ||
        fabs(a21) > _bound ||
        fabs(a22) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return sign_of_determinant3x3_SAF(
		a00.value(),
		a01.value(),
		a02.value(),
		a10.value(),
		a11.value(),
		a12.value(),
		a20.value(),
		a21.value(),
		a22.value(),
		Filter_epsilon_sign_of_determinant3x3_9_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(a00));
      _bound = max(_bound, fabs(a01));
      _bound = max(_bound, fabs(a02));
      _bound = max(_bound, fabs(a10));
      _bound = max(_bound, fabs(a11));
      _bound = max(_bound, fabs(a12));
      _bound = max(_bound, fabs(a20));
      _bound = max(_bound, fabs(a21));
      _bound = max(_bound, fabs(a22));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) sign_of_determinant3x3_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_sign_of_determinant3x3_9_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return sign_of_determinant3x3(
		a00.exact(),
		a01.exact(),
		a02.exact(),
		a10.exact(),
		a11.exact(),
		a12.exact(),
		a20.exact(),
		a21.exact(),
		a22.exact());
  }
}

double Filter_epsilon_sign_of_determinant4x4_16_0;

inline
Sign
sign_of_determinant4x4_SAF(
    const Static_filter_error &a00,
    const Static_filter_error &a01,
    const Static_filter_error &a02,
    const Static_filter_error &a03,
    const Static_filter_error &a10,
    const Static_filter_error &a11,
    const Static_filter_error &a12,
    const Static_filter_error &a13,
    const Static_filter_error &a20,
    const Static_filter_error &a21,
    const Static_filter_error &a22,
    const Static_filter_error &a23,
    const Static_filter_error &a30,
    const Static_filter_error &a31,
    const Static_filter_error &a32,
    const Static_filter_error &a33,
    double & epsilon_0)
{
  return CGAL::sign_SAF(det4x4_by_formula(a00, a01, a02, a03,
                                      a10, a11, a12, a13,
                                      a20, a21, a22, a23,
                                      a30, a31, a32, a33), epsilon_0);
}


inline
Sign
sign_of_determinant4x4_SAF(
    const double &a00,
    const double &a01,
    const double &a02,
    const double &a03,
    const double &a10,
    const double &a11,
    const double &a12,
    const double &a13,
    const double &a20,
    const double &a21,
    const double &a22,
    const double &a23,
    const double &a30,
    const double &a31,
    const double &a32,
    const double &a33,
   const double & epsilon_0)
{
  return CGAL::sign_SAF(det4x4_by_formula(a00, a01, a02, a03,
                                      a10, a11, a12, a13,
                                      a20, a21, a22, a23,
                                      a30, a31, a32, a33), epsilon_0);
}


inline
Sign
sign_of_determinant4x4(
    const Static_adaptatif_filter &a00,
    const Static_adaptatif_filter &a01,
    const Static_adaptatif_filter &a02,
    const Static_adaptatif_filter &a03,
    const Static_adaptatif_filter &a10,
    const Static_adaptatif_filter &a11,
    const Static_adaptatif_filter &a12,
    const Static_adaptatif_filter &a13,
    const Static_adaptatif_filter &a20,
    const Static_adaptatif_filter &a21,
    const Static_adaptatif_filter &a22,
    const Static_adaptatif_filter &a23,
    const Static_adaptatif_filter &a30,
    const Static_adaptatif_filter &a31,
    const Static_adaptatif_filter &a32,
    const Static_adaptatif_filter &a33)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(a00) > _bound ||
        fabs(a01) > _bound ||
        fabs(a02) > _bound ||
        fabs(a03) > _bound ||
        fabs(a10) > _bound ||
        fabs(a11) > _bound ||
        fabs(a12) > _bound ||
        fabs(a13) > _bound ||
        fabs(a20) > _bound ||
        fabs(a21) > _bound ||
        fabs(a22) > _bound ||
        fabs(a23) > _bound ||
        fabs(a30) > _bound ||
        fabs(a31) > _bound ||
        fabs(a32) > _bound ||
        fabs(a33) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return sign_of_determinant4x4_SAF(
		a00.value(),
		a01.value(),
		a02.value(),
		a03.value(),
		a10.value(),
		a11.value(),
		a12.value(),
		a13.value(),
		a20.value(),
		a21.value(),
		a22.value(),
		a23.value(),
		a30.value(),
		a31.value(),
		a32.value(),
		a33.value(),
		Filter_epsilon_sign_of_determinant4x4_16_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(a00));
      _bound = max(_bound, fabs(a01));
      _bound = max(_bound, fabs(a02));
      _bound = max(_bound, fabs(a03));
      _bound = max(_bound, fabs(a10));
      _bound = max(_bound, fabs(a11));
      _bound = max(_bound, fabs(a12));
      _bound = max(_bound, fabs(a13));
      _bound = max(_bound, fabs(a20));
      _bound = max(_bound, fabs(a21));
      _bound = max(_bound, fabs(a22));
      _bound = max(_bound, fabs(a23));
      _bound = max(_bound, fabs(a30));
      _bound = max(_bound, fabs(a31));
      _bound = max(_bound, fabs(a32));
      _bound = max(_bound, fabs(a33));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) sign_of_determinant4x4_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_sign_of_determinant4x4_16_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return sign_of_determinant4x4(
		a00.exact(),
		a01.exact(),
		a02.exact(),
		a03.exact(),
		a10.exact(),
		a11.exact(),
		a12.exact(),
		a13.exact(),
		a20.exact(),
		a21.exact(),
		a22.exact(),
		a23.exact(),
		a30.exact(),
		a31.exact(),
		a32.exact(),
		a33.exact());
  }
}

double Filter_epsilon_sign_of_determinant5x5_25_0;

inline
Sign
sign_of_determinant5x5_SAF(
    const Static_filter_error &a00,
    const Static_filter_error &a01,
    const Static_filter_error &a02,
    const Static_filter_error &a03,
    const Static_filter_error &a04,
    const Static_filter_error &a10,
    const Static_filter_error &a11,
    const Static_filter_error &a12,
    const Static_filter_error &a13,
    const Static_filter_error &a14,
    const Static_filter_error &a20,
    const Static_filter_error &a21,
    const Static_filter_error &a22,
    const Static_filter_error &a23,
    const Static_filter_error &a24,
    const Static_filter_error &a30,
    const Static_filter_error &a31,
    const Static_filter_error &a32,
    const Static_filter_error &a33,
    const Static_filter_error &a34,
    const Static_filter_error &a40,
    const Static_filter_error &a41,
    const Static_filter_error &a42,
    const Static_filter_error &a43,
    const Static_filter_error &a44,
    double & epsilon_0)
{
  return CGAL::sign_SAF(det5x5_by_formula(a00, a01, a02, a03, a04,
                                      a10, a11, a12, a13, a14,
                                      a20, a21, a22, a23, a24,
                                      a30, a31, a32, a33, a34,
                                      a40, a41, a42, a43, a44), epsilon_0);
}


inline
Sign
sign_of_determinant5x5_SAF(
    const double &a00,
    const double &a01,
    const double &a02,
    const double &a03,
    const double &a04,
    const double &a10,
    const double &a11,
    const double &a12,
    const double &a13,
    const double &a14,
    const double &a20,
    const double &a21,
    const double &a22,
    const double &a23,
    const double &a24,
    const double &a30,
    const double &a31,
    const double &a32,
    const double &a33,
    const double &a34,
    const double &a40,
    const double &a41,
    const double &a42,
    const double &a43,
    const double &a44,
   const double & epsilon_0)
{
  return CGAL::sign_SAF(det5x5_by_formula(a00, a01, a02, a03, a04,
                                      a10, a11, a12, a13, a14,
                                      a20, a21, a22, a23, a24,
                                      a30, a31, a32, a33, a34,
                                      a40, a41, a42, a43, a44), epsilon_0);
}


inline
Sign
sign_of_determinant5x5(
    const Static_adaptatif_filter &a00,
    const Static_adaptatif_filter &a01,
    const Static_adaptatif_filter &a02,
    const Static_adaptatif_filter &a03,
    const Static_adaptatif_filter &a04,
    const Static_adaptatif_filter &a10,
    const Static_adaptatif_filter &a11,
    const Static_adaptatif_filter &a12,
    const Static_adaptatif_filter &a13,
    const Static_adaptatif_filter &a14,
    const Static_adaptatif_filter &a20,
    const Static_adaptatif_filter &a21,
    const Static_adaptatif_filter &a22,
    const Static_adaptatif_filter &a23,
    const Static_adaptatif_filter &a24,
    const Static_adaptatif_filter &a30,
    const Static_adaptatif_filter &a31,
    const Static_adaptatif_filter &a32,
    const Static_adaptatif_filter &a33,
    const Static_adaptatif_filter &a34,
    const Static_adaptatif_filter &a40,
    const Static_adaptatif_filter &a41,
    const Static_adaptatif_filter &a42,
    const Static_adaptatif_filter &a43,
    const Static_adaptatif_filter &a44)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(a00) > _bound ||
        fabs(a01) > _bound ||
        fabs(a02) > _bound ||
        fabs(a03) > _bound ||
        fabs(a04) > _bound ||
        fabs(a10) > _bound ||
        fabs(a11) > _bound ||
        fabs(a12) > _bound ||
        fabs(a13) > _bound ||
        fabs(a14) > _bound ||
        fabs(a20) > _bound ||
        fabs(a21) > _bound ||
        fabs(a22) > _bound ||
        fabs(a23) > _bound ||
        fabs(a24) > _bound ||
        fabs(a30) > _bound ||
        fabs(a31) > _bound ||
        fabs(a32) > _bound ||
        fabs(a33) > _bound ||
        fabs(a34) > _bound ||
        fabs(a40) > _bound ||
        fabs(a41) > _bound ||
        fabs(a42) > _bound ||
        fabs(a43) > _bound ||
        fabs(a44) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return sign_of_determinant5x5_SAF(
		a00.value(),
		a01.value(),
		a02.value(),
		a03.value(),
		a04.value(),
		a10.value(),
		a11.value(),
		a12.value(),
		a13.value(),
		a14.value(),
		a20.value(),
		a21.value(),
		a22.value(),
		a23.value(),
		a24.value(),
		a30.value(),
		a31.value(),
		a32.value(),
		a33.value(),
		a34.value(),
		a40.value(),
		a41.value(),
		a42.value(),
		a43.value(),
		a44.value(),
		Filter_epsilon_sign_of_determinant5x5_25_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(a00));
      _bound = max(_bound, fabs(a01));
      _bound = max(_bound, fabs(a02));
      _bound = max(_bound, fabs(a03));
      _bound = max(_bound, fabs(a04));
      _bound = max(_bound, fabs(a10));
      _bound = max(_bound, fabs(a11));
      _bound = max(_bound, fabs(a12));
      _bound = max(_bound, fabs(a13));
      _bound = max(_bound, fabs(a14));
      _bound = max(_bound, fabs(a20));
      _bound = max(_bound, fabs(a21));
      _bound = max(_bound, fabs(a22));
      _bound = max(_bound, fabs(a23));
      _bound = max(_bound, fabs(a24));
      _bound = max(_bound, fabs(a30));
      _bound = max(_bound, fabs(a31));
      _bound = max(_bound, fabs(a32));
      _bound = max(_bound, fabs(a33));
      _bound = max(_bound, fabs(a34));
      _bound = max(_bound, fabs(a40));
      _bound = max(_bound, fabs(a41));
      _bound = max(_bound, fabs(a42));
      _bound = max(_bound, fabs(a43));
      _bound = max(_bound, fabs(a44));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) sign_of_determinant5x5_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_sign_of_determinant5x5_25_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return sign_of_determinant5x5(
		a00.exact(),
		a01.exact(),
		a02.exact(),
		a03.exact(),
		a04.exact(),
		a10.exact(),
		a11.exact(),
		a12.exact(),
		a13.exact(),
		a14.exact(),
		a20.exact(),
		a21.exact(),
		a22.exact(),
		a23.exact(),
		a24.exact(),
		a30.exact(),
		a31.exact(),
		a32.exact(),
		a33.exact(),
		a34.exact(),
		a40.exact(),
		a41.exact(),
		a42.exact(),
		a43.exact(),
		a44.exact());
  }
}

double Filter_epsilon_sign_of_determinant6x6_36_0;

inline
Sign
sign_of_determinant6x6_SAF(
    const Static_filter_error &a00,
    const Static_filter_error &a01,
    const Static_filter_error &a02,
    const Static_filter_error &a03,
    const Static_filter_error &a04,
    const Static_filter_error &a05,
    const Static_filter_error &a10,
    const Static_filter_error &a11,
    const Static_filter_error &a12,
    const Static_filter_error &a13,
    const Static_filter_error &a14,
    const Static_filter_error &a15,
    const Static_filter_error &a20,
    const Static_filter_error &a21,
    const Static_filter_error &a22,
    const Static_filter_error &a23,
    const Static_filter_error &a24,
    const Static_filter_error &a25,
    const Static_filter_error &a30,
    const Static_filter_error &a31,
    const Static_filter_error &a32,
    const Static_filter_error &a33,
    const Static_filter_error &a34,
    const Static_filter_error &a35,
    const Static_filter_error &a40,
    const Static_filter_error &a41,
    const Static_filter_error &a42,
    const Static_filter_error &a43,
    const Static_filter_error &a44,
    const Static_filter_error &a45,
    const Static_filter_error &a50,
    const Static_filter_error &a51,
    const Static_filter_error &a52,
    const Static_filter_error &a53,
    const Static_filter_error &a54,
    const Static_filter_error &a55,
    double & epsilon_0)
{
  return CGAL::sign_SAF(det6x6_by_formula(a00, a01, a02, a03, a04, a05,
                                      a10, a11, a12, a13, a14, a15,
                                      a20, a21, a22, a23, a24, a25,
                                      a30, a31, a32, a33, a34, a35,
                                      a40, a41, a42, a43, a44, a45,
                                      a50, a51, a52, a53, a54, a55), epsilon_0);
}


inline
Sign
sign_of_determinant6x6_SAF(
    const double &a00,
    const double &a01,
    const double &a02,
    const double &a03,
    const double &a04,
    const double &a05,
    const double &a10,
    const double &a11,
    const double &a12,
    const double &a13,
    const double &a14,
    const double &a15,
    const double &a20,
    const double &a21,
    const double &a22,
    const double &a23,
    const double &a24,
    const double &a25,
    const double &a30,
    const double &a31,
    const double &a32,
    const double &a33,
    const double &a34,
    const double &a35,
    const double &a40,
    const double &a41,
    const double &a42,
    const double &a43,
    const double &a44,
    const double &a45,
    const double &a50,
    const double &a51,
    const double &a52,
    const double &a53,
    const double &a54,
    const double &a55,
   const double & epsilon_0)
{
  return CGAL::sign_SAF(det6x6_by_formula(a00, a01, a02, a03, a04, a05,
                                      a10, a11, a12, a13, a14, a15,
                                      a20, a21, a22, a23, a24, a25,
                                      a30, a31, a32, a33, a34, a35,
                                      a40, a41, a42, a43, a44, a45,
                                      a50, a51, a52, a53, a54, a55), epsilon_0);
}


inline
Sign
sign_of_determinant6x6(
    const Static_adaptatif_filter &a00,
    const Static_adaptatif_filter &a01,
    const Static_adaptatif_filter &a02,
    const Static_adaptatif_filter &a03,
    const Static_adaptatif_filter &a04,
    const Static_adaptatif_filter &a05,
    const Static_adaptatif_filter &a10,
    const Static_adaptatif_filter &a11,
    const Static_adaptatif_filter &a12,
    const Static_adaptatif_filter &a13,
    const Static_adaptatif_filter &a14,
    const Static_adaptatif_filter &a15,
    const Static_adaptatif_filter &a20,
    const Static_adaptatif_filter &a21,
    const Static_adaptatif_filter &a22,
    const Static_adaptatif_filter &a23,
    const Static_adaptatif_filter &a24,
    const Static_adaptatif_filter &a25,
    const Static_adaptatif_filter &a30,
    const Static_adaptatif_filter &a31,
    const Static_adaptatif_filter &a32,
    const Static_adaptatif_filter &a33,
    const Static_adaptatif_filter &a34,
    const Static_adaptatif_filter &a35,
    const Static_adaptatif_filter &a40,
    const Static_adaptatif_filter &a41,
    const Static_adaptatif_filter &a42,
    const Static_adaptatif_filter &a43,
    const Static_adaptatif_filter &a44,
    const Static_adaptatif_filter &a45,
    const Static_adaptatif_filter &a50,
    const Static_adaptatif_filter &a51,
    const Static_adaptatif_filter &a52,
    const Static_adaptatif_filter &a53,
    const Static_adaptatif_filter &a54,
    const Static_adaptatif_filter &a55)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (
        fabs(a00) > _bound ||
        fabs(a01) > _bound ||
        fabs(a02) > _bound ||
        fabs(a03) > _bound ||
        fabs(a04) > _bound ||
        fabs(a05) > _bound ||
        fabs(a10) > _bound ||
        fabs(a11) > _bound ||
        fabs(a12) > _bound ||
        fabs(a13) > _bound ||
        fabs(a14) > _bound ||
        fabs(a15) > _bound ||
        fabs(a20) > _bound ||
        fabs(a21) > _bound ||
        fabs(a22) > _bound ||
        fabs(a23) > _bound ||
        fabs(a24) > _bound ||
        fabs(a25) > _bound ||
        fabs(a30) > _bound ||
        fabs(a31) > _bound ||
        fabs(a32) > _bound ||
        fabs(a33) > _bound ||
        fabs(a34) > _bound ||
        fabs(a35) > _bound ||
        fabs(a40) > _bound ||
        fabs(a41) > _bound ||
        fabs(a42) > _bound ||
        fabs(a43) > _bound ||
        fabs(a44) > _bound ||
        fabs(a45) > _bound ||
        fabs(a50) > _bound ||
        fabs(a51) > _bound ||
        fabs(a52) > _bound ||
        fabs(a53) > _bound ||
        fabs(a54) > _bound ||
        fabs(a55) > _bound)
      throw (Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return sign_of_determinant6x6_SAF(
		a00.value(),
		a01.value(),
		a02.value(),
		a03.value(),
		a04.value(),
		a05.value(),
		a10.value(),
		a11.value(),
		a12.value(),
		a13.value(),
		a14.value(),
		a15.value(),
		a20.value(),
		a21.value(),
		a22.value(),
		a23.value(),
		a24.value(),
		a25.value(),
		a30.value(),
		a31.value(),
		a32.value(),
		a33.value(),
		a34.value(),
		a35.value(),
		a40.value(),
		a41.value(),
		a42.value(),
		a43.value(),
		a44.value(),
		a45.value(),
		a50.value(),
		a51.value(),
		a52.value(),
		a53.value(),
		a54.value(),
		a55.value(),
		Filter_epsilon_sign_of_determinant6x6_36_0);
  } 
  catch (Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;
      _bound = max(_bound, fabs(a00));
      _bound = max(_bound, fabs(a01));
      _bound = max(_bound, fabs(a02));
      _bound = max(_bound, fabs(a03));
      _bound = max(_bound, fabs(a04));
      _bound = max(_bound, fabs(a05));
      _bound = max(_bound, fabs(a10));
      _bound = max(_bound, fabs(a11));
      _bound = max(_bound, fabs(a12));
      _bound = max(_bound, fabs(a13));
      _bound = max(_bound, fabs(a14));
      _bound = max(_bound, fabs(a15));
      _bound = max(_bound, fabs(a20));
      _bound = max(_bound, fabs(a21));
      _bound = max(_bound, fabs(a22));
      _bound = max(_bound, fabs(a23));
      _bound = max(_bound, fabs(a24));
      _bound = max(_bound, fabs(a25));
      _bound = max(_bound, fabs(a30));
      _bound = max(_bound, fabs(a31));
      _bound = max(_bound, fabs(a32));
      _bound = max(_bound, fabs(a33));
      _bound = max(_bound, fabs(a34));
      _bound = max(_bound, fabs(a35));
      _bound = max(_bound, fabs(a40));
      _bound = max(_bound, fabs(a41));
      _bound = max(_bound, fabs(a42));
      _bound = max(_bound, fabs(a43));
      _bound = max(_bound, fabs(a44));
      _bound = max(_bound, fabs(a45));
      _bound = max(_bound, fabs(a50));
      _bound = max(_bound, fabs(a51));
      _bound = max(_bound, fabs(a52));
      _bound = max(_bound, fabs(a53));
      _bound = max(_bound, fabs(a54));
      _bound = max(_bound, fabs(a55));

      // recompute epsilons: "just" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) sign_of_determinant6x6_SAF(
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Static_filter_error(_bound,0,1),
		Filter_epsilon_sign_of_determinant6x6_36_0);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return sign_of_determinant6x6(
		a00.exact(),
		a01.exact(),
		a02.exact(),
		a03.exact(),
		a04.exact(),
		a05.exact(),
		a10.exact(),
		a11.exact(),
		a12.exact(),
		a13.exact(),
		a14.exact(),
		a15.exact(),
		a20.exact(),
		a21.exact(),
		a22.exact(),
		a23.exact(),
		a24.exact(),
		a25.exact(),
		a30.exact(),
		a31.exact(),
		a32.exact(),
		a33.exact(),
		a34.exact(),
		a35.exact(),
		a40.exact(),
		a41.exact(),
		a42.exact(),
		a43.exact(),
		a44.exact(),
		a45.exact(),
		a50.exact(),
		a51.exact(),
		a52.exact(),
		a53.exact(),
		a54.exact(),
		a55.exact());
  }
}

CGAL_END_NAMESPACE

#endif // CGAL_STATIC_ADAPTATIF_FILTER_PREDICATES_SIGN_OF_DETERMINANT_H
