#!/usr/local/bin/perl5
#
# Copyright (c) 1998-1999 The CGAL Consortium
#
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
#
# This script takes as STDIN "predicates_on_ftC2.h" or equivalent.
# It produces as STDOUT "Arithmetic_filter/predicates_on_ftC2.h" or equivalent.
#
# It is not supposed to be universal, and it can be considered a quick and
# dirty hack.  But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too (but the job can be done by hand if you
# don't have many to do).
#
# See the CGAL documentation:
# Support Library, Number Types, Filtered_exact.
#

# $old_protect_name: contains the protect macro name, e.g. CGAL_BASIC_H:
#                    It is set by $treat_CGAL_header().
# $new_protect_name: equivalent to CGAL_ARITHMETIC_FILTER_BASIC_H.

$in_def=0;
$in_decl=0;
$in_dont_filter=0; # We are in a piece of code that don't need to be filtered.
$after_template=0;
$result_type="";
@args=();

# A sub routine to treat the header: the first parsing step.
sub treat_CGAL_header {
  while (<>)
  {
    # get $file_name from the "file:" field in the headers.
    if (/\/\/ file[\s]*: include\/CGAL\/(.*)/) {
      $file_name = $1;
    }

    # get $old_protect_name.
    if (/ifndef[\s]*CGAL_(.*_H)/) {
      $old_protect_name = "CGAL_$1";
      $new_protect_name = "CGAL_ARITHMETIC_FILTER_$1";
      last;
    }
  }

  # We put the new header.
  print
"// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/$file_name
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion\@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec\@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef $new_protect_name\n";
}

# List of CGAL's enum types.
@CGAL_return_types=("Sign", "Comparison_result", "Orientation",
	            "Oriented_side", "Bounded_side");
%known_return_types=("bool", 1);

foreach (@CGAL_return_types) {
  $known_return_types{$_}=1;
  $known_return_types{"CGAL::$_"}=1;
}

# Warns if the return type is not known
# (to detect functions returning void or FT)
sub check_known_type {
  my ($type) = @_;
  if (not $known_return_types{$type}) {
    print STDERR "// Warning: \"$type\" is unknown\n";
  }
}

# Main program:

treat_CGAL_header();

while (<>)
{
  # First we treat the CGAL_NO_FILTER_BEGIN/CGAL_NO_FILTER_END section:
  # just remove the code, including the bounding lines.
  if (/\/\/CGAL_NO_FILTER_BEGIN/) {
    $in_dont_filter=1;
  }
  if (/\/\/CGAL_NO_FILTER_END/) {
    $in_dont_filter=0;
    next;
  }
  next if ($in_dont_filter);

  if (/^}$/) {
    $in_def=0;
    next;
  }
  next if ($in_def);
  if (/^{/) {
    $after_template=0;
    $in_decl=0;
    $in_def=1;
    check_known_type($result_type);
    print
"{
  CGAL::FPU_CW_t backup = CGAL::FPU_get_and_set_cw(CGAL::FPU_cw_up);
  try
  {
    $result_type result = $function_name(
";
    foreach (@args) {
      print "\t\t$_.interval()";
      if ($_ ne $last_arg) { print ",\n"; }
      else { print ");"; }
    }
    print "
    CGAL::FPU_set_cw(backup);
    return result;
  } 
  catch (CGAL::Interval_nt_advanced::unsafe_comparison)
  {
    CGAL::FPU_set_cw(backup);
    return $function_name(
";
    foreach (@args) {
      print "\t\t$_.exact()";
      if ($_ ne $last_arg) { print ",\n"; }
      else { print ");"; }
    }
    print "
  }
}
";
  # MipsPro complains about the following assertion at the end, so it's
  # removed: CGAL_assertion(false);
    # print "args: @args\n" ;
    @args=();
    next;
  }

  if ($after_template)
  {
    s/(CGAL_KERNEL_.*INLINE)/\/\/ $1/; # Comment the INLINE line.
    s/inline/\/\/ inline/;             # Comment the INLINE line.
    if ( /\(/ ) { $in_decl=1; }
    if (! $in_decl) {
      if (! (/INLINE/ || /inline/)) {
        $result_type = $_;
        chop($result_type);
        # print "RESULT_TYPE = $result_type\n";
      }
    }
    if ($in_decl)
    {
      @a = split /[,\)]/; # Stores the arguments names in @args.
      foreach (@a) {
	s/^.*\(//;
        next if /^$/;
        /(\w+)\s*$/;
        push(@args, $1);
        $last_arg=$1;
      }
      s/const/\n    const/g;  # Split lines.
      s/[RF]T/CGAL::Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>/g;
    }
    if (/\(/) {
      /([a-zA-Z_]\w*)\s*\(/;
      $function_name=$1;
      # print "Function name: $function_name\n";
    }
  }
  if (/template/) { $after_template = 1; }
  s/template\s*<\s*class\s*[RF]T\s*>/#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION\ntemplate < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >\n#endif/;

  s/$old_protect_name/$new_protect_name/g;

  print $_;
}
