#!/usr/local/bin/perl5 -w
#
# Copyright (c) 1998-1999 The CGAL Consortium
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
# This script takes as input a source code file containing template predicates.
# It outputs the filtered specializations.
#
# It is not supposed to be universal: it doesn't understand full C++.
# But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too.
#
# See the CGAL documentation: Support Library, Number Types, Filtered_exact.

# TODO list:
#      - Parse the _whole_ file as a string, process with regexps.
#      - Introduce a EPSILON_COMPUTATION section, so that the user can provide
#        in place the alternative code to be used to recompute the epsilons,
#        when the default is not correct or fast enough.
#      - String templates for the epsilons variants ?
#      - double needs to be replaced with "Restricted_double".
#        (make the epsilons by Restricted_double's ? )

use vars qw($opt_p $opt_h $opt_s $opt_d $opt_v); # Suppress stupid warnings
require 'getopt.pl';

# Global variables
$static_version=0;		# Default is the filtered_exact version.
%known_ret_types=("bool", 1);	# Known allowed return types (completed in main)
@predicates=(			# list of predicates, with the built-ins.
# CGAL::, template_type, inline, ret_type, fct_name, #eps, body, new_body, args
    [ "", "NT", "CGAL_KERNEL_INLINE", "Sign", "lexicographical_sign", 1, "",
      "", "x", "y" ],
    [ "", "NT", "inline", "Comparison_result", "compare", 1, "", "", "a", "b" ],
    [ "", "NT", "inline", "Sign", "sign", 1, "", "", "x"] );
# Note: we don't actually care about a few fields ($body...) for these.
$num_built_in_predicates=$#predicates+1;	# Number of built-in predicates.

# Note: the built-in predicates need their overloaded code to be somewhere :).

# We _must_ manipulate the fields of the struct predicate using these
# constants:  (aren't there structs in Perl ?  Are packs the way to go ? )
# ($CGAL_pos, $template_type_pos, $inline_pos, $ret_type_pos)=(0..3);
($fct_name_pos, $eps_pos, $body_pos, $new_body_pos, $args_pos)=(4..8);

# Useful regexps.
$C_symbol_re='[a-zA-Z_]\w*';			# A pure C symbol name.
$CGAL_symbol_re='(?:CGAL::|)'.$C_symbol_re;	# Idem with eventually 'CGAL::'

# Some template data.
$CGAL_header_template=
"// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : __FILE_FIELD__
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion\@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec\@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef __NEW_PROTECT_NAME__
#define __NEW_PROTECT_NAME__\n\n";

$Filtered_exact_template=
"#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
__INLINE_DIRECTIVE__
__RETURN_TYPE__
__FUNCTION_NAME__(__ARGUMENTS_CALL__)
{
  CGAL::FPU_CW_t backup = CGAL::FPU_get_and_set_cw(CGAL::FPU_cw_up);
  try
  {
    __RETURN_TYPE__ result = __FUNCTION_NAME__(__ARGUMENTS_INTERVAL__);
    CGAL::FPU_set_cw(backup);
    return result;
  } 
  catch (CGAL::Interval_nt_advanced::unsafe_comparison)
  {
    CGAL::FPU_set_cw(backup);
    return __FUNCTION_NAME__(__ARGUMENTS_EXACT__);
  }
}\n\n";

$Static_adaptif_template=
"__INLINE_DIRECTIVE__
__RETURN_TYPE__
__FUNCTION_NAME__(__ARGUMENTS_CALL__)
{
  bool tried = false;
  static double _bound=0;
letstry:
  try
  {
    // Check the bounds.  All arguments must be <= _bound.
    if (__BOUNDS_CHECK__)
      throw (CGAL::Static_adaptatif_filter::unsafe_comparison);
    // Try the epsilon variant of the predicate.
    return __FUNCTION_NAME___SAF(__ARGUMENTS_VALUE__,__ARGUMENTS_EPSILON__);
  }
  catch (CGAL::Static_adaptatif_filter::unsafe_comparison)
  {
    // It failed once, we re-adjust (bound, epsilons).
    if (!tried)
    {
      tried = true;
      // Recompute _bound (tighter or larger).
      _bound = 0;__COMPUTE_NEW_BOUND__

      // recompute epsilons: \"just\" call it over Static_filter_error.
      // That's the tricky part that might not work for everything.
      (void) __FUNCTION_NAME___SAF(__ARGUMENTS_ERROR____ARGUMENTS_EPSILON__);

      // We should verify that all epsilons have really been updated.

      // Try again with the updated (_bound, epsilon)
      goto letstry;
    }
    // This scheme definitely fails => exact computation (filtered_exact<> ?).
    return __FUNCTION_NAME__(__ARGUMENTS_EXACT__);
  }
}\n\n";

# Parse the command line options.
sub parse_command_line {
  Getopt('iod');
  $pedantic=$opt_p;
  if ($opt_h) {
    print STDERR "Usage: filtered_predicate_converter [options]
    -i file   : specify the main input source file [default is stdin]
    -o file   : specify the main output file       [default is stdout]
    -d files  : list of dependant predicates file (concatenated with \":\")
                by default, only the built-in predicates are known.
                (typically, it's just sign_of_determinant.h that you want)
		(it's only useful when \"-s\" is here too).
    -p        : be pedantic (changes warnings into errors)
    -s        : semi-static version [default is Filtered_exact<>]
    -v        : be verbose [to stderr]
    -h        : print this help\n";
    exit;
  }
  @dependancy_files = split(':', $opt_d) if ($opt_d);
  $opt_i = "-" unless $opt_i;
  $opt_o = "-" unless $opt_o;
  $static_version = 1 if $opt_s;
}

# Auxiliary routine to emit a warning and die if pedantic.
sub warning {
  my ($msg) = @_;
  print STDERR "// Warning : $msg\n";
  die if $pedantic;
}

# Emit a message in verbose mode only.
sub verbose {
  my ($msg) = @_;
  print STDERR "// Info : $msg\n" if $opt_v;
}

# Treats the CGAL header.
sub treat_CGAL_header {
  my $file_name="";
  my $directory = "Arithmetic_filter";
  my $new_protect_macro = "CGAL_ARITHMETIC_FILTER_";
  my $new_protect_name;
  if ($static_version) {
    $new_protect_macro="CGAL_STATIC_ADAPTATIF_FILTER_";
    $directory="Static_adaptatif_filter";
  }
  # skip the old header.
  while (<FI>) {
    # get $file_name from the "file:" field in the headers.
    $file_name = $1 if m#// file[\s]*: include/CGAL/(.*)#;

    # set $new_protect_name and exit.
    if (/^#ifndef[\s]*([\S]*_H)\s*/) {
      $_ = $1;
      $_ = "CGAL_$_" unless /CGAL_/;
      s/CGAL_/$new_protect_macro/;
      $new_protect_name = $_;
      last;
    }
  }
  # put the new header.
  $_ = $CGAL_header_template;
  s#__FILE_FIELD__#include/CGAL/$directory/$file_name#ms;
  s#__NEW_PROTECT_NAME__#$new_protect_name#msg;
  print FO;
  return $new_protect_name;
}

# Skips a "CGAL_NO_FILTER" section.
sub skip_no_filter_section {
  while (<FI>) { last if m#//CGAL_NO_FILTER_END#; }
}

# Output "$before$_$after$after_not_last" for each arg, except last.
sub arg_string {
  my ($before, $after, $after_not_last, @args) = @_;
  my $output="";
  foreach (@args) {
    $output.="$before$_$after";
    $output.= $after_not_last unless $_ eq $args[$#args];
  }
  return $output;
}

# Similar, but for epsilons, takes the number of them as arguments.
sub eps_string {
  my ($before, $after, $after_not_last, $eps) = @_;
  my $output="";
  for $i (0 .. $eps-1) {
    $output.="$before$i$after";
    $output.= $after_not_last unless $i eq $eps-1;
  }
  return $output;
}

# Print the Filtered_exact<> version of a predicate.
sub print_filtered_exact {
  my ($CGAL, $t, $inline, $ret_type, $fct_name, $e, $b, $n, @args) = @_;
  my $args_call  = arg_string("\n    const ${CGAL}Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE> &", "", ",",  @args);
  my $args_inter = arg_string("\n\t\t", ".interval()", ",", @args);
  my $args_exact = arg_string("\n\t\t", ".exact()", ",", @args);

  # Derive the function declaration from the template text.
  $_=$Filtered_exact_template;
  s#CGAL::#$CGAL#msg;
  s#__INLINE_DIRECTIVE__#/* $inline */#ms;	# No inline by default.
  s#__RETURN_TYPE__#$ret_type#msg;
  s#__FUNCTION_NAME__#$fct_name#msg;
  s#__ARGUMENTS_CALL__#$args_call#ms;
  s#__ARGUMENTS_INTERVAL__#$args_inter#ms;
  s#__ARGUMENTS_EXACT__#$args_exact#ms;
  print FO;
}

# Returns the new function
sub give_new_body {
  my ($ret_type, $fct_name, $body, $t, $eps, $new_t, $const, @args) = @_;
  my $new_body="inline\n";	# inline by default since it's not template.

  $new_body.="$ret_type\n";
  $new_body.="${fct_name}_SAF(";
  $new_body.=arg_string("\n    const $new_t &", ",", "", @args);
  $new_body.=eps_string("\n    ${const}double & epsilon_", "", ",", $eps).")";
  # Replace $template_type by the instantiated one.
  $_ = $body;
  s/$t/$new_t/smg; # Could be made more accurate ;-)
  $new_body.="$_\n\n";
  return $new_body;
}

# Print the Static Adaptatif version of a predicate.
sub print_static_adaptatif {
  my ($CGAL, $t, $inline, $ret_type, $fct_name, $eps, $b, $new_body, @args)=@_;

  if ($eps == 0) {
    warning("Predicate \"$fct_name\" (".scalar(@args)." args) _must_ have at least one epsilon.");
  }

  # Print the epsilons needed.
  print FO eps_string("double Filter_epsilon_${fct_name}_".scalar(@args)."_", ";\n", "", $eps)."\n";

  # Print the SFE version of the predicate.
  print FO give_new_body($ret_type, $fct_name, $new_body, $t, $eps,
  			 "${CGAL}Static_filter_error", "", @args);

  # Print the epsilon version of the predicate.
  print FO give_new_body($ret_type, $fct_name, $new_body, $t, $eps,
  			 "double", "const ", @args);

  # Print the function declaration
  my $bounds_check = arg_string("\n        fabs(", ") > _bound", " ||", @args);
  my $args_value   = arg_string("\n\t\t", ".value()", ",", @args);
  my $args_error   = "\n\t\tStatic_filter_error(_bound,0,1)," x ($#args+1);
  my $args_exact   = arg_string("\n\t\t", ".exact()", ",", @args);
  my $args_epsilons = eps_string("\n\t\tFilter_epsilon_${fct_name}_".scalar(@args)."_", "", ",", $eps);
  my $args_call = arg_string("\n    const ${CGAL}Static_adaptatif_filter &", "", ",", @args);
  my $compute_new_bounds = arg_string("\n      _bound = max(_bound, fabs(", "));", "", @args);

  $_=$Static_adaptif_template;
  s#CGAL::#$CGAL#msg;
  s#__INLINE_DIRECTIVE__#inline#ms;  # inline by default for the moment.
  s#__RETURN_TYPE__#$ret_type#msg;
  s#__FUNCTION_NAME__#$fct_name#msg;
  s#__ARGUMENTS_CALL__#$args_call#ms;
  s#__BOUNDS_CHECK__#$bounds_check#ms;
  s#__ARGUMENTS_VALUE__#$args_value#ms;
  s#__ARGUMENTS_EPSILON__#$args_epsilons#msg;
  s#__COMPUTE_NEW_BOUND__#$compute_new_bounds#ms;
  s#__ARGUMENTS_ERROR__#$args_error#msg;
  s#__ARGUMENTS_EXACT__#$args_exact#msg;
  print FO;
}

# Parse from "template" to end of body "}"
sub parse_function_definition {
  my ($def) = @_;
  # TODO: We should definitely simply match a balanced { ... }.
  while (<FI>) {
    $def .= $_;
    last if /^}\s*$/;
  }
  $_ = $def;
  /^\W*template\s*\<\s*(?:class|typename)\s*(\S*)\s*\>	# template type name
    \W*(CGAL_\w*INLINE|inline|)			# eventual inline directive
    \W*($CGAL_symbol_re)			# return type
    \W*($C_symbol_re)				# function name
    .*?\((.*?)\)/smx;				# argument list
  my @pred = ($1, $2, $3, $4, -1, $', "");
  my $fct_name = $4;
  if (not $known_ret_types{$3}) {
    warning("Return type \"$3\" of function \"$4\" is unknown");
  }
  foreach (split (',', $5)) {
    if (not /const/) {
      warning("Non const argument \"$_\" in function \"$fct_name\".");
    }
    /($C_symbol_re)\s*$/;
    push @pred, $1;
  }
  return @pred;
}

sub parse_input_code {
  my $CGAL = "CGAL::";
  while (<FI>) {
    # Treat the CGAL_NO_FILTER_BEGIN/CGAL_NO_FILTER_END section.
    if (m#//CGAL_NO_FILTER_BEGIN#) {
      skip_no_filter_section();
      next;
    }
  
    # Detect if we are in namespace CGAL:
    $CGAL="" if /CGAL_BEGIN_NAMESPACE/;
    $CGAL="CGAL::" if /CGAL_END_NAMESPACE/;
  
    # Treat next template function declaration.
    if (/template\s*\<.*\>/) {
      push @predicates, [ $CGAL, parse_function_definition($_) ];
      if ($static_version) { treat_predicate($#predicates); }
    }
  }
}

# Print the code of the overloaded predicates
sub print_predicates {
  my $was_in_CGAL = 0;
  # We skip the built-in predicates.
  for $i ( $num_built_in_predicates .. $#predicates ) {
    my ($CGAL) = @{$predicates[$i]};
    print "CGAL_BEGIN_NAMESPACE\n\n" if $CGAL eq "" && not $was_in_CGAL;
    print "CGAL_END_NAMESPACE\n\n"   if $CGAL ne "" && $was_in_CGAL;
    if ($static_version) {
      print_static_adaptatif(@{$predicates[$i]});
    } else {
      print_filtered_exact(@{$predicates[$i]});
    }
    $was_in_CGAL = $CGAL eq "";
  }
  print "CGAL_END_NAMESPACE\n\n" if $was_in_CGAL;
}

# Match the first closing parenthesis at level -1 (assumes "(" already open).
# Returns number of arguments found before, text before, and after.
sub extract_closing_paren {
  local ($_) = @_;
  my $num_args = 1;	# We don't handle 0 argument functions.
  my $before = "";
  my $quote_level = 0;
  while ( /./sm ) {
    if ($& eq "(") {
      ++$quote_level;
    } elsif ($& eq ")") {
      --$quote_level;
      last if ($quote_level == -1);
    } elsif ($& eq "," && not $quote_level) {
      ++$num_args;
    }
    $before .= $&;
    $_ = $';
  }
  return ($num_args, $before, $_);
}

# Find predicate calls in the function body
# Returns the number of epsilons that this predicate needs, and the new body.
sub match_calls_in_body {
  my ($body) = @_;
  my $new_body = "";
  my $predicates_re = "(?:";
  my $num_eps=0;

  # We prepare the $predicates_re (should be done at an upper level).
  # Final is sthg like "(?:compare|sign|orientationC2)".
  foreach ( @predicates ) {
    $predicates_re .= "@$_[$fct_name_pos]|";
  }
  chop($predicates_re);
  $predicates_re .= ')';

  # Maybe we should first globally remove comments ?
  # Note that the following are buggy if they appear in strings...
  # (http://www.perl.com/cgi-bin/pace/pub/doc/manual/html/pod/perlfaq6.html)
  $_ = $body;
  s#//.*##mg;      # Remove C++ "//" comments.
  s#/\*.*?\*/##sg; # Remove C "/* ... */" comments.

  # We match the first call to a known predicate function.
  while (/([^\w\d_])($predicates_re)(\s*\()/sm) {
    $predicate_name = $2;
    # We add "_SAF" to the predicate name.
    $new_body .= "$`$1$2_SAF$3";
    ($num_args, $before, $after) = extract_closing_paren($');
    $new_body .= $before;

    # Recognize the actual predicate.
    my $p;
    foreach ( @predicates ) {
      $p = $_;
      last if (scalar(@$p)-$args_pos == $num_args) && (@$p[$fct_name_pos] eq $predicate_name);
    }
    # Check the number of arguments corresponds.
    if (not ((scalar(@$p)-$args_pos == $num_args) && (@$p[$fct_name_pos] eq $predicate_name))) {
      warning("We beleive we matched a predicate, but it's not in our list !
             pred = \"$predicate_name\"");
    };

    # We add the epsilon arguments to the call in $new_body.
    for $i ( $num_eps .. ($num_eps + @$p[$eps_pos] - 1) ) {
      $new_body .= ", epsilon_$i";
    }
    
    $num_eps += @$p[$eps_pos];
    $_ = $after;
  }
  $new_body .= $_;

  return ($num_eps, $new_body);
}

# Calls match_calls_in_body over @predicates[$_], and updates $eps & $new_body.
sub treat_predicate {
  my ($i) = @_;
  my ($eps, $new_body) = match_calls_in_body($predicates[$i][$body_pos]);
  $predicates[$i][$new_body_pos] = $new_body;
  $predicates[$i][$eps_pos] = $eps;
}

# Parse the list of dependancy files, and populate @predicates with them.
sub parse_dependancy_files {
  foreach (@dependancy_files) {
    open(FI, "<$_") || die "Couldn't open dependancy file \"$_\"\n";
    parse_input_code();
    close(FI);
  }
  # Consider them as built-in now (i.e. don't output specializations).
  $num_built_in_predicates=$#predicates+1;
}

# Main program
sub main {
  for ("Sign", "Comparison_result", "Orientation", "Oriented_side",
            "Bounded_side") {
    $known_ret_types{$_}=1;
    $known_ret_types{"CGAL::$_"}=1;
  }
  parse_command_line();
  if ($static_version && $opt_d) { parse_dependancy_files(); }
  open(FI, "<$opt_i") || die "Couldn't open input file \"$opt_i\"\n";
  open(FO, ">$opt_o") || die "Couldn't open output file \"$opt_o\"\n";
  my $new_protect_name = treat_CGAL_header();
  parse_input_code();
  print_predicates();
  print FO "#endif // $new_protect_name\n";
}

main();
