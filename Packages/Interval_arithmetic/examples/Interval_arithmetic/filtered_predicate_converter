#!/usr/local/bin/perl5
#
# Copyright (c) 1998-1999 The CGAL Consortium
#
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
#
# This script takes as STDIN "predicates_on_ftC2.h" or equivalent.
# It produces as STDOUT "Arithmetic_filter/predicates_on_ftC2.h" or equivalent.
#
# It is not supposed to be universal, and it can be considered a quick and
# dirty hack.  But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too (but the job can be done by hand if you
# don't have many to do).
#
# See the CGAL documentation:
# Support Library, Number Types, Filtered_exact.
#

# $old_protect_name: contains the protect macro name, e.g. CGAL_BASIC_H:
#                    It is set by $treat_CGAL_header().
# $new_protect_name: equivalent to CGAL_ARITHMETIC_FILTER_BASIC_H.

# Treats the CGAL header.
sub treat_CGAL_header {
  # skip the old header.
  while (<>)
  {
    # get $file_name from the "file:" field in the headers.
    if (/\/\/ file[\s]*: include\/CGAL\/(.*)/) {
      $file_name = $1;
    }

    # get $old_protect_name and exit.
    if (/ifndef[\s]*CGAL_(.*_H)/) {
      $old_protect_name = "CGAL_$1";
      $new_protect_name = "CGAL_ARITHMETIC_FILTER_$1";
      last;
    }
  }

  # put the new header.
  print
"// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/$file_name
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion\@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec\@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef $new_protect_name\n";
}

# Skips a "CGAL_NO_FILTER" section.
sub skip_no_filter_section {
  while (<>) { last if /\/\/CGAL_NO_FILTER_END/; }
}

# Skips the old body of the function.
sub skip_old_body {
  while (<>) { last if /^}$/; }
}

# List of CGAL's enum types.
@CGAL_enum_types=("Sign", "Comparison_result", "Orientation", "Oriented_side",
                  "Bounded_side");
%known_return_types=("bool", 1);

foreach (@CGAL_enum_types) {
  $known_return_types{$_}=1;
  $known_return_types{"CGAL::$_"}=1;
}

# Warns if the return type is not known
# (to detect functions returning void or FT)
sub check_known_type {
  my ($type) = @_;
  if (not $known_return_types{$type}) {
    print STDERR "// Warning: \"$type\" is an unknown enumerative type\n";
  }
}

# Puts the new body 
sub put_new_body {
  local ($result_type, $function_name, @args) = @_;
  print
"{
  CGAL::FPU_CW_t backup = CGAL::FPU_get_and_set_cw(CGAL::FPU_cw_up);
  try
  {
    $result_type result = $function_name(
";
  foreach (@args) {
    print "\t\t$_.interval()";
    if ($_ eq $args[$#args]) { print ");"; } else { print ",\n"; }
  }
  print "
    CGAL::FPU_set_cw(backup);
    return result;
  } 
  catch (CGAL::Interval_nt_advanced::unsafe_comparison)
  {
    CGAL::FPU_set_cw(backup);
    return $function_name(
";
  foreach (@args) {
    print "\t\t$_.exact()";
    if ($_ eq $args[$#args]) { print ");"; } else { print ",\n"; }
  }
  print "
  }
}
";
}

# Treat the declaration of a function.
sub parse_function_declaration {
  local ($inline_decl, $return_type, $function_name, @args, $in_decl);
  while (<>) {
    # get the eventual inline declaration.
    if (/(CGAL_.*INLINE|inline)/) {
      $inline_decl=$1;
    }

    # get the function name.
    if ( /\(/ ) {
      $in_decl=1;
      /([a-zA-Z_]\w*)\s*\(/;
      $function_name=$1;
    }
    if (! $in_decl) {
      if (! (/inline/i)) {
        $return_type = $_;
        chop($return_type);
        check_known_type($return_type);
      }
    }
    else
    {
      @a = split /[,\)]/; # Stores the arguments names in @args.
      foreach (@a) {
	s/^.*\(//;
        next if /^$/;
        /(\w+)\s*$/;
        push(@args, $1);
      }
    }
    last if /\)/;
  }
  return ($inline_decl, $return_type, $function_name, @args);
}

# Print the new function declaration.
sub put_new_function_declaration {
  local ($inline_decl, $return_type, $function_name, @args) = @_;
  # The template line would be more pretty without the MipsPro hack...
  print
"#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif\n";
  # By default, we do not inline the filtered version.
  print "/* $inline_decl */\n" if $inline_decl;
  print "$return_type\n";
  print "$function_name(\n";
  foreach (@args) {
    print "    const CGAL::Filtered_exact ";
    print "<CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE> &$_";
    if ($_ eq $args[$#args]) { print ")\n"; } else { print ",\n"; }
  }
}

# Main program:

treat_CGAL_header();

while (<>)
{
  # Treat the CGAL_NO_FILTER_BEGIN/CGAL_NO_FILTER_END section.
  if (/\/\/CGAL_NO_FILTER_BEGIN/) {
    skip_no_filter_section();
    next;
  }

  # Treat next template function.
  if (/template/) {
    ($inline_decl, $result_type, $function_name, @arguments)
                                = parse_function_declaration();
    put_new_function_declaration($inline_decl, $result_type,
                                 $function_name, @arguments);
    next;
  }

  # Treat the body of a function.
  if (/^{/) {
    skip_old_body();
    put_new_body($result_type, $function_name, @arguments);
    next;
  }

  # Basically for the rest, we copy everything,
  # just update the protect macro name.
  s/$old_protect_name/$new_protect_name/g;
  print $_;
}
