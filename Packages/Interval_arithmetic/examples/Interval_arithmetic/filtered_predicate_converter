#!/usr/local/bin/perl5
#
# Copyright (c) 1998-1999 The CGAL Consortium
#
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
#
# This script takes as STDIN "predicates_on_ftC2.h" or equivalent.
# It produces as STDOUT "Arithmetic_filter/predicates_on_ftC2.h" or equivalent.
#
# It is not supposed to be universal, it doesn't understand full C++.
# But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too (but the job can be done by hand if you
# don't have many to do).
#
# See the CGAL documentation:
# Support Library, Number Types, Filtered_exact.


$old_protect_name="";	# contains the protect macro name, e.g. CGAL_BASIC_H:
			# It is set by $treat_CGAL_header().
$new_protect_name="";	# equivalent to CGAL_ARITHMETIC_FILTER_BASIC_H.
$line=0;		# current line number.

# Auxiliary routine to emit a warning.
sub warning {
  local ($_) = @_;
  print STDERR "// Warning [line $line]: $_\n";
}

# Treats the CGAL header.
sub treat_CGAL_header {
  # skip the old header.
  while (<>)
  {
    $line++;
    # get $file_name from the "file:" field in the headers.
    if (/\/\/ file[\s]*: include\/CGAL\/(.*)/) {
      $file_name = $1;
    }

    # get $old_protect_name and exit.
    if (/ifndef[\s]*([\S]*_H)/) {
      $old_protect_name = $1;
      $_ = $old_protect_name;
      if (not /CGAL_/) {
        $_ = "CGAL_$_";
      }
      s/CGAL_/CGAL_ARITHMETIC_FILTER_/;
      $new_protect_name = $_;
      last;
    }
  }

  # put the new header.
  print
"// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/$file_name
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion\@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec\@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.

#ifndef $new_protect_name\n";
}

# Skips a "CGAL_NO_FILTER" section.
sub skip_no_filter_section {
  while (<>) { $line++; last if /\/\/CGAL_NO_FILTER_END/; }
}

# Skips the old body of the function.
sub skip_old_body {
  while (<>) { $line++; last if /^}$/; }
}

# Warns if the return type is not known
# (to detect functions returning void or FT)
sub check_known_type {
  my ($type) = @_;
  if (not $known_return_types{$type}) {
    warning ("\"$type\" is an unknown enumerative type");
  }
}

# Puts the new body 
sub put_new_body {
  local ($result_type, $function_name, @args) = @_;
  print "{
  CGAL::FPU_CW_t backup = CGAL::FPU_get_and_set_cw(CGAL::FPU_cw_up);
  try
  {
    $result_type result = $function_name(\n";
  foreach (@args) {
    print "\t\t$_.interval()";
    if ($_ eq $args[$#args]) { print ");\n"; } else { print ",\n"; }
  }
  print "    CGAL::FPU_set_cw(backup);
    return result;
  } 
  catch (CGAL::Interval_nt_advanced::unsafe_comparison)
  {
    CGAL::FPU_set_cw(backup);
    return $function_name(\n";
  foreach (@args) {
    print "\t\t$_.exact()";
    if ($_ eq $args[$#args]) { print ");\n"; } else { print ",\n"; }
  }
  print "  }\n}\n";
}

# Treat the declaration of a function.
sub parse_function_declaration {
  local ($inline_decl, $return_type, $function_name, @args, $in_decl);
  while (<>) {
    $line++;
    # get the eventual inline declaration.
    if (/(CGAL_.*INLINE|inline)/) {
      $inline_decl=$1;
    }

    # get the function name.
    if ( /\(/ ) {
      $in_decl=1;
      /([a-zA-Z_]\w*)\s*\(/;
      $function_name=$1;
    }

    if (! $in_decl) {
      # get the return type.
      if (! (/inline/i)) {
        $return_type = $_;
        chop($return_type);
        check_known_type($return_type);
      }
    }
    else
    {
      # get the arguments.
      s/^.*\(//;
      foreach (split /[,\)]/) {
        next if /^\s*$/;
	if (not /const/) {
	  warning("Using non const argument \"$_\" in \"$function_name\".");
	}
        /(\w+)\s*$/;
        push(@args, $1);
      }
    }
    last if /\)/;
  }
  return ($inline_decl, $return_type, $function_name, @args);
}

# Print the new function declaration.
sub put_new_function_declaration {
  local ($inline_decl, $return_type, $function_name, @args) = @_;
  # The template line would be more pretty without the MipsPro hack...
  print
"#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif\n";
  # By default, we do not inline the filtered version.
  print "/* $inline_decl */\n" if $inline_decl;
  print "$return_type\n";
  print "$function_name(\n";
  foreach (@args) {
    print "    const CGAL::Filtered_exact ";
    print "<CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE> &$_";
    if ($_ eq $args[$#args]) { print ")\n"; } else { print ",\n"; }
  }
}

# Main program:

# List of CGAL's enum types.
@CGAL_enum_types=("Sign", "Comparison_result", "Orientation", "Oriented_side",
                  "Bounded_side");
%known_return_types=("bool", 1);

foreach (@CGAL_enum_types) {
  $known_return_types{$_}=1;
  $known_return_types{"CGAL::$_"}=1;
}

treat_CGAL_header();

while (<>)
{
  $line++;
  # Treat the CGAL_NO_FILTER_BEGIN/CGAL_NO_FILTER_END section.
  if (/\/\/CGAL_NO_FILTER_BEGIN/) {
    skip_no_filter_section();
    next;
  }

  # Treat next template function.
  if (/^template/) {
    ($inline_decl, $result_type, $function_name, @arguments)
                                = parse_function_declaration();
    put_new_function_declaration($inline_decl, $result_type,
                                 $function_name, @arguments);
    next;
  }

  # Treat the body of a function.
  if (/^{/) {
    skip_old_body();
    put_new_body($result_type, $function_name, @arguments);
    next;
  }

  # Basically for the rest, we copy everything,
  # just update the protect macro name.
  s/$old_protect_name/$new_protect_name/g;
  print $_;
}
