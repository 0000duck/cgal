#!/usr/local/bin/perl5
#
# Copyright (c) 1998-1999 The CGAL Consortium
# Author: Sylvain Pion <Sylvain.Pion@sophia.inria.fr>.
#
# This script takes as input a source code file containing template predicates.
# It outputs the filtered specializations.
#
# It is not supposed to be universal: it doesn't understand full C++.
# But it appears to work for CGAL's predicates, so you might want
# to use it for your predicates too.
#
# See the CGAL documentation: Support Library, Number Types, Filtered_exact.

require 'getopt.pl';

# Global variables
$new_protect_name="";	# equivalent to CGAL_ARITHMETIC_FILTER_BASIC_H.
$line=0;		# current line number.
$CGAL="CGAL::";		# by default, we are outside namespace CGAL.
@CGAL_enum_types=("Sign", "Comparison_result", "Orientation", "Oriented_side",
                  "Bounded_side"); # List of CGAL's enum types.
@predicates=(		# list of predicates.
# fct_name, template_type, result_type, inline, CGAL::, body, arguments
    [ "compare", "NT", "Comparison_result", "inline", "",
      "return (a < b) ? SMALLER : (b < a) ? LARGER : EQUAL;", "a", "b" ],
    [ "sign", "NT", "Sign", "inline", "",
      "return (x < NT(0)) ? NEGATIVE : (NT(0) < x) ? POSITIVE : ZERO;", "x"] );

# Parse the command line options.
sub parse_command_line {
  Getopt('io');
  $pedantic=$opt_p;
  if ($opt_h) {
    print STDERR "Usage: filtered_predicate_converter [options]
    -i file : specify the input source file [default is stdin]
    -o file : specify the output file       [default is stdout]
    -p      : be pedantic (changes warnings into errors)
    -h      : print this help\n";
    exit;
  }
  $opt_i = "-" unless $opt_i;
  $opt_o = "-" unless $opt_o;
}

# Auxiliary routine to emit a warning and die if pedantic.
sub warning {
  local ($_) = @_;
  print STDERR "// Warning [line $line]: $_\n";
  die if $pedantic;
}

# Treats the CGAL header.
sub treat_CGAL_header {
  # skip the old header.
  while (<FI>)
  {
    $line++;
    # get $file_name from the "file:" field in the headers.
    $file_name = $1 if /\/\/ file[\s]*: include\/CGAL\/(.*)/;

    # set $new_protect_name and exit.
    if (/ifndef[\s]*([\S]*_H)/) {
      $_ = $1;
      $_ = "CGAL_$_" unless /CGAL_/;
      s/CGAL_/CGAL_ARITHMETIC_FILTER_/;
      $new_protect_name = $_;
      last;
    }
  }

  # put the new header.
  print FO
"// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/$file_name
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion\@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec\@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by the script
// examples/Interval_arithmetic/filtered_predicate_converter.\n\n";
}

# Skips a "CGAL_NO_FILTER" section.
sub skip_no_filter_section {
  while (<FI>) { $line++; last if /\/\/CGAL_NO_FILTER_END/; }
}

# Returns the old body of the function.
sub get_old_body {
  my ($b);
  while (<FI>) { $line++; last if /^}\s*$/; $b = "$b$_"; }
  return $b;
}

# Warns if the return type is not known
# (to detect functions returning void or FT)
sub check_known_type {
  my ($type) = @_;
  if (not $known_return_types{$type}) {
    warning ("\"$type\" is an unknown enumerative type");
  }
}

# Puts the new body 
sub put_new_body {
  local ($result_type, $function_name, @args) = @_;
  print FO "{
  ${CGAL}FPU_CW_t backup = ${CGAL}FPU_get_and_set_cw(${CGAL}FPU_cw_up);
  try
  {
    $result_type result = $function_name(\n";
  foreach (@args) {
    print FO "\t\t$_.interval()", ($_ eq $args[$#args] ? ");\n" : ",\n");
  }
  print FO "    ${CGAL}FPU_set_cw(backup);
    return result;
  } 
  catch (${CGAL}Interval_nt_advanced::unsafe_comparison)
  {
    ${CGAL}FPU_set_cw(backup);
    return $function_name(\n";
  foreach (@args) {
    print FO "\t\t$_.exact()", ($_ eq $args[$#args] ? ");\n  }\n}\n" : ",\n");
  }
}

# Treat the declaration of a function.
sub parse_function_declaration {
  local ($inline_decl, $return_type, $function_name, @args, $in_decl);
  while (<FI>) {
    $line++;
    # get the eventual inline declaration.
    $inline_decl=$1 if /(CGAL_.*INLINE|inline)/;

    # get the function name.
    if ( /\(/ ) {
      $in_decl=1;
      /([a-zA-Z_]\w*)\s*\(/;
      $function_name=$1;
    }

    if (! $in_decl) {
      # get the return type.
      if (! (/inline/i)) {
        $return_type = $_;
        chop($return_type);
        check_known_type($return_type);
      }
    }
    else
    {
      # get the arguments.
      s/^.*\(//;
      foreach (split /[,\)]/) {
        next if /^\s*$/;
	if (not /const/) {
	  warning("Using non const argument \"$_\" in \"$function_name\".");
	}
        /(\w+)\s*$/;
        push @args, $1;
      }
    }
    last if /\)/;
  }
  return ($inline_decl, $return_type, $function_name, @args);
}

# Print the new function declaration.
sub put_new_function_declaration {
  local ($inline_decl, $return_type, $function_name, @args) = @_;
  # The template line would be more pretty without the MipsPro hack...
  print FO
"#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif\n";
  # By default, we do not inline the filtered version.
  print FO "/* $inline_decl */\n" if $inline_decl;
  print FO "$return_type\n";
  print FO "$function_name(\n";
  foreach (@args) {
    print FO "    const ${CGAL}Filtered_exact ";
    print FO "<CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE> &$_";
    print FO ($_ eq $args[$#args] ? ")\n" : ",\n");
  }
}

sub main_loop {
  while (<FI>)
  {
    $line++;
    # Detect if we are in namespace CGAL:
    $CGAL="" if /CGAL_BEGIN_NAMESPACE/;
    $CGAL="CGAL::" if /CGAL_END_NAMESPACE/;
  
    # Treat the CGAL_NO_FILTER_BEGIN/CGAL_NO_FILTER_END section.
    if (/\/\/CGAL_NO_FILTER_BEGIN/) {
      skip_no_filter_section();
      next;
    }
  
    # Treat next template function declaration.
    if (/^\s*template\s*\<\s*(\S*)\s*(\S*)\s*\>/) {
      $template_type = $2;
      ($inline_decl, $result_type, $function_name, @arguments)
                                  = parse_function_declaration();
      next;
    }
  
    # Treat the body of a function.
    if (/^{\s*/) {
      push @predicates, [$function_name, $template_type, $result_type,
                         $inline_decl, $CGAL, get_old_body(), @arguments];
    }
  }
}

# Prints the code of the overloaded predicates.
sub print_predicates {
  my $is_in_CGAL=0;
  # We skip the 2 built-in predicates sign() and compare().
  for $i ( 2 .. $#predicates ) {
    local ($function_name, $template_type, $result_type, 
           $inline_decl, $CGAL, $body, @args) = @{$predicates[$i]};
    if ($CGAL eq "" && not $is_in_CGAL) {
      print "CGAL_BEGIN_NAMESPACE\n\n";
      $is_in_CGAL = 1;
    }
    if ($CGAL ne "" && $is_in_CGAL) {
      print "CGAL_END_NAMESPACE\n\n";
      $is_in_CGAL = 0;
    }
    put_new_function_declaration($inline_decl, $result_type,
                                 $function_name, @args);
    put_new_body($result_type, $function_name, @args);
    print FO "\n";
  }
  print "CGAL_END_NAMESPACE\n\n" if $is_in_CGAL;
}

# Main program
sub main {
  %known_return_types=("bool", 1);
  foreach (@CGAL_enum_types) {
    $known_return_types{$_}=1;
    $known_return_types{"CGAL::$_"}=1;
  }
  parse_command_line();
  open(FI, "<$opt_i") || die "Couldn't open input file \"$opt_i\"\n";
  open(FO, ">$opt_o") || die "Couldn't open output file \"$opt_o\"\n";
  treat_CGAL_header();
  main_loop();
  print FO "#ifndef $new_protect_name\n";
  print FO "#define $new_protect_name\n\n";
  print_predicates();
  print FO "#endif // $new_protect_name\n";
}

main();
