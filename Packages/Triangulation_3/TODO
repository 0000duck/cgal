- For Delaunay, we can use the visibility (non stochastic) walk.  How to
  choose ?  Is it worth the complexity (benchmark first) ?
- Why are the iterators friend in the ds_cell ?
- coplanar_orientation()... faire marche arriere et recuperer l'ancienne
  interface (ie sans Vector) ? cf T2D
- remove() : ca plante dans le prog de test de la hierarchie... a investiguer.
  refaire marcher le vieux remove pour pouvoir tester (voire garder les deux
  versions si c'est mieux).
- hierarchie : verifier que l'interface est bonne (ie tous les insert(*) sont
  interceptes...).  Documenter.
- ameliorer user manual
- TEST SUITE
- Traits : mettre a jour la doc.
- locate() : verifier que l'interface est la meme que dans T2D concernant la
  cellule de depart.  Plutot que prendre une cellule sur le bord, on peut
  peut-etre prendre la premiere cellule de la liste, qui a de bonnes chances
  d'y avoir ete mise recemment, et donc d'etre plus pret... ?
- Faire des benchs/profiles de points non-randoms...
- Alignement des cellules en memoire : effets de cache + pointeurs a
  l'interieur des cellules pour le voisinage (Fred a deja fait => ask).
- La gestion memoire (interne a l'allocateur new/delete) prend pas mal de
  place (30%...).  Ca serait bien de ranger les cellules dans des tableaux,
  et ca permettrait de surcroi[tsx] aussi de se passer des listes doublements
  chainees.
  Le flag temporaire pourrait aller dans un des bits -> sizeof(cell) == 32 :)
  NB: Ca serait bien de factoriser ce probleme avec T2D !!!
- new Vertex
- Tds::insert conflict pourrait etre utilisee pour T3D insert_outside_CH
  (link() hat()...) -> virer les new cell (create_cell)
- idem regular
- Facet_circulator a l'air bugue (et lent) d'apres F&D quand on specifie une
  facet de depart.  Est-ce qu'il y A besoin de stocker un TDS * ?  Stocker
  deux Vertex * plutot que deux ints, ca permet de gagner une Cell *, et
  d'etre plus rapide, non ?  Voila le code que Frank utilise a la place :

  typedef CGAL::triple< void*, int, int > void_Edge;
  typedef std::pair< void_Edge, int > Edge_IFacet;

//---------------------------------------------------------------------

inline Edge_IFacet inc_facet_circ(const Edge_IFacet& e)
{
  Cell_handle c = (Cell*) e.first.first;
  int i = e.second;
  int i1 = e.first.second, i2 = e.first.third;
  int i3 = (6 - e.second - i1 - i2);

  Cell_handle n = c->neighbor(i);
  int j1 = n->index(c->vertex(i1)), j2 = n->index(c->vertex(i2));
  int j =  n->index(c->vertex(i3));
  return Edge_IFacet(void_Edge((void*) &*n, j1, j2), j);
}

//---------------------------------------------------------------------

inline Edge_IFacet dec_facet_circ(const Edge_IFacet& e)
{
  Cell_handle c = (Cell*) e.first.first;
  int i = e.second;
  int i1 = e.first.second, i2 = e.first.third;
  int i3 = (6 - e.second - i1 - i2);

  Cell_handle n = c->neighbor(i3);
  int j1 = n->index(c->vertex(i1)), j2 = n->index(c->vertex(i2));
  int j =  n->index(c->vertex(i));
  return Edge_IFacet(void_Edge((void*) &*n, j1, j2), j);
}

