-------------- POUR LA RELEASE

- revoir fonctions "dual" (robustesse dans le cas des tetraedres presque plats)

- bien tester le output_stream de T_3 et le copy_tds (ordre de creation des
  sommets). 
- Verifier qu'il n'y a pas d'autres operations du meme style a modifier. 

-------------- APRES LA RELEASE

- grep obsolete et deprecated et virer

-------------- POUR DES QU'ON PEUT

- Finir de decider pour find_conflicts, si on veut les facettes du bord du
  trou vues de l'interieur ou de l'exterieur. 
  Fournir un output iterator adaptator pour transformer l'iterateur de 
  facettes vues de l'interieur en iterateur de facettes vues de l'exterieur.

General
- constructeurs pour avoir Triangulation T(points.begin(), points.end()); 
- mettre des locate_2D, locate_3D, insert idem, pour eviter les tests 
  redondants sur la dimension a chaque insertion.
- trouver une interface avec T_2 qui permette d'eviter de reprogrammer 
  tout le 2d dans le 3d
- insure
- Pointer -> Comparable_iterator quand Comparable_iterator sera mis dans 
  STL extensions
- const handle, const it, const circ ...
- utiliser le cell_container_iterator partout ou c'est possible 
  (unifier le code pour differentes dimensions) 

TEST SUITE
- faire tourner GCOV sur la test-suite, et rajouter ce qu'il faut pour
  atteindre 100%.

Doc
- (optional) sphere et grille en couleur version eps
- (revoir les anciennes corrections de JF Dufourd)

Exemples - demo
- en rajouter si bonnes idees...
- Monique elle veut des exemples pour les output iterators.

TDS
- virer le truc infame dans DS_Container (le magic machin).
- reflechir a un support de facettes explicites (cf papier de Giesen)
- nettoyer les trucs 2d only (face_circulator etc)

T3
- virer push_back (qui n'est deja plus documente, mais il manque des trucs
  dans STL_extensions pour pouvoir le virer completement).
- is_valid devrait verifier l'enveloppe convexe
- prevoir differentes sorties : geomview (ameliorer le rendu pour
  donner un effet de perspective), vrml, viewer_3...
  cf Polyhedron_3, file I/O.

Delaunay
- remplacer les create_face du remove2D par des create_cell et virer 
  les create_face de la tds
- perturbation ne dependant plus de l'ordre d'insertion 
  (et enlever note a ce propos dans la doc)
- le numero de vertex necessaire au remove devrait etre un requirement de
  Delaunay sur VertexBase, et le compteur, un data member de Delaunay.
  (question sans objet si la perturbation change)
- optimiser remove :
  - algo d'Olivier si constructions filtrees disponibles (cf Olivier
	rappel de la reunion a ce sujet)
  - pour la creation de la TDS_2, on devrait pouvoir faire plus simple,
    sachant que le trou n'est pas quelconque, mais etoile, et donc on peut
    profiter de ca pour avoir les adjacences directement (peut-etre en
    squattant le flag des cellules pour y mettre un pointeur vers la facette
    2d correspondante).
- For Delaunay, we can use the visibility (non stochastic) walk.  How to
  choose ?  Is it worth the complexity (benchmark first) ?
- nearest neighbor
- natural neighbors de Raphaelle a integrer

Regular :
- la cell_base speciale qui stocke une liste de points caches ou pas (et un
  tag qui dit si oui ou non elle stocke les points caches ou pas), et un
  iterator pour y acceder.
- remove - devrait etre pareil que pour delaunay (a part les points caches a
  re-inserer apres coup).
- faire marcher la hierarchie avec.  Le probleme est qu'on delete des
  vertex, et donc la hierarchie est perdue avec ses pointeurs up/down qui
  pointent dans l'espace, du coup...
  La solution qu'on a discute est :
  - la hierarchy devrait avoir tous les etages superieurs simplement Delaunay,
    et pas autre chose.
  - le insert() (ou find_conflict) de Regular devrait fournir un iterator sur
    les Vertex_handle correspondant aux points qui seront caches, et en
    fonction de ca, une hierarchy speciale Regular fera ce qu'il faut.
- programmer centre ortho-sphere de 4 points. Aussi centre de l'ortho-cercle 
de 3 points... (requete Tamal Dey)