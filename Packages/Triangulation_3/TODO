- For Delaunay, we can use the visibility (non stochastic) walk.  How to
  choose ?  Is it worth the complexity (benchmark first) ?
- Why are the iterators friend in the ds_cell ?
- coplanar_orientation()... faire marche arriere et recuperer l'ancienne
  interface (ie sans Vector) ? cf T2D
- remove() : ca plante dans le prog de test de la hierarchie... a investiguer.
  refaire marcher le vieux remove pour pouvoir tester (voire garder les deux
  versions si c'est mieux).
- hierarchie : verifier que l'interface est bonne (ie tous les insert(*) sont
  interceptes...).  Documenter.
- ameliorer user manual
- TEST SUITE
- Traits : mettre a jour la doc.
- locate() : verifier que l'interface est la meme que dans T2D concernant la
  cellule de depart.  Plutot que prendre une cellule sur le bord, on peut
  peut-etre prendre la premiere cellule de la liste, qui a de bonnes chances
  d'y avoir ete mise recemment, et donc d'etre plus pret... ?
- Faire des benchs/profiles de points non-randoms...
- Alignement des cellules en memoire : effets de cache + pointeurs a
  l'interieur des cellules pour le voisinage (Fred a deja fait => ask).
- La gestion memoire (interne a l'allocateur new/delete) prend pas mal de
  place (30%...).  Ca serait bien de ranger les cellules dans des tableaux,
  et ca permettrait de surcroi[tsx] aussi de se passer des listes doublements
  chainees.
  Le flag temporaire pourrait aller dans un des bits -> sizeof(cell) == 32 :)
  NB: Ca serait bien de factoriser ce probleme avec T2D !!!
- new Vertex
- Tds::insert conflict pourrait etre utilisee pour T3D insert_outside_CH
  (link() hat()...) -> virer les new cell (create_cell)
- idem regular
- Facet_circulator : Est-ce qu'il y a besoin de stocker un TDS * ?  Stocker
  deux Vertex * plutot que deux ints, ca permet de gagner une Cell *, et
  d'etre plus rapide, non ? 

