% +------------------------------------------------------------------------+
% | Reference manual page: Delaunay_triangulation_3.tex
% +------------------------------------------------------------------------+
% | 27.3.2000   Monique Teillaud
% | Package: Triangulation3
% | 
\RCSdef{\RCSDelaunaytriangulationRev}{$Revision$}
\RCSdefDate{\RCSDelaunaytriangulationDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Delaunay_triangulation_3<DelaunayTriangulationTraits_3,TriangulationDataStructure_3>}

\ccDefinition
  
The class \ccc{Delaunay_triangulation_3} represents a three-dimensional
Delaunay triangulation.

The user is advised to use the class \ccc{Triangulation_hierarchy_3} rather
than this basic Delaunay triangulation class: it offers the same
functionalities but is much more efficient for large data sets.

\ccInclude{CGAL/Delaunay_triangulation_3.h}

\ccParameters

The first template argument must be a model of the
\ccc{DelaunayTriangulationTraits_3} concept.

The second template argument must be a model of the
\ccc{TriangulationDataStructure_3} concept.
It has the default value \ccc{Triangulation_data_structure_3<Triangulation_vertex_base_3<DelaunayTriangulationTraits_3>, Triangulation_cell_base_3<DelaunayTriangulationTraits_3> >}.

\ccInheritsFrom{\ccc{Triangulation_3<DelaunayTriangulationTraits_3,TriangulationDataStructure_3>}}

\ccTypes

\ccThree{typedef DelaunayTriangulationTraits_3::Object_3 Object;}{}
\ccThreeToTwo
In addition to those inherited, the following types are defined, for use by the
construction of the Voronoi diagram:

\ccTypedef{typedef DelaunayTriangulationTraits_3::Line_3 Line;}{}
\ccGlue
\ccTypedef{typedef DelaunayTriangulationTraits_3::Ray_3 Ray;}{}
\ccGlue
\ccTypedef{typedef DelaunayTriangulationTraits_3::Plane_3 Plane;}{}
\ccGlue
\ccTypedef{typedef DelaunayTriangulationTraits_3::Object_3 Object;}{}

\ccCreation
\ccCreationVariable{dt}
\ccThree{Vertex_handle}{dt.remove(Point p)toto}{}

\ccConstructor{Delaunay_triangulation_3
(const DelaunayTriangulationTraits_3& traits = DelaunayTriangulationTraits_3())}
{Creates an empty Delaunay triangulation, possibly specifying a traits class
\ccc{traits}.}

\ccConstructor{Delaunay_triangulation_3 (const Delaunay_triangulation_3 & dt1)}
{Copy constructor.}

\ccConstructor{template < class InputIterator >
       Delaunay_triangulation_3 (InputIterator first, InputIterator last,
 const DelaunayTriangulationTraits_3& traits = DelaunayTriangulationTraits_3())}
{Creates a Delaunay triangulation of the points specified by the iterator range
\ccc{[first,last)} of value type \ccc{Point}, possibly specifying a traits
class \ccc{traits}.}

\ccOperations

\ccHeading{Insertion}

The following methods overload the corresponding methods of
triangulations to ensure the empty sphere property of Delaunay 
triangulations.

In the degenerate case when there are cospherical points, the Delaunay
triangulation is known not to be uniquely defined. In this case, CGAL
chooses a particular Delaunay triangulation using a symbolic perturbation
scheme~\cite{dt-pvr3d-03}.

\ccThree{Vertex_handle}{dt.remove()}{}

\ccMethod{Vertex_handle insert(const Point & p,
                               Cell_handle start = Cell_handle() );}
{Inserts point \ccc{p} in the triangulation and returns the corresponding
 vertex. Similar to the insertion in a triangulation, but ensures in
addition the empty sphere property of all the created faces.
The optional argument \ccc{start} is used as a starting place for the search.}

\ccMethod{Vertex_handle insert(const Point & p, Locate_type lt,
                               Cell_handle loc, int li, int lj);}
{Inserts point \ccc{p} in the triangulation and returns the corresponding
 vertex. Similar to the above \ccc{insert()} function, but takes as additional
 parameter the return values of a previous location query.  See description of
 \ccc{Triangulation_3::locate()}.}

The following method allows one to insert several points. It returns the
number of inserted points. 

\ccMethod{template < class InputIterator >
          int
          insert(InputIterator first, InputIterator last);}
{Inserts the points in the iterator range $\left[\right.$\ccc{first},
\ccc{last}$\left.\right)$, of value type \ccc{Point}.}

\ccHeading{Point moving}

\ccMethod{Vertex_handle move_point(Vertex_handle v, const Point & p);}
{Moves the point stored in \ccc{v} to \ccc{p}, while preserving the Delaunay
property.  This performs an action semantically equivalent to \ccc{remove(v)}
followed by \ccc{insert(p)}, but is supposedly faster when the point has
not moved much.  Returns the handle to the new vertex.
\ccPrecond{\ccc{v} is a finite vertex of the triangulation.}}

\ccHeading{Removal}

When a vertex \ccc{v} is removed from a triangulation, all the cells
incident to \ccc{v} must be removed, and the polyhedral region
consisting of all the tetrahedra that are incident to \ccc{v} must be
retriangulated. 
So, the problem reduces to triangulating a polyhedral
region, while preserving its boundary, or to compute a
\textit{constrained} triangulation. This is known to be sometimes
impossible: the Sch\"onhardt polyhedron cannot be triangulated
\cite{cgal:s-cgehd-98}. 

However, when dealing with Delaunay triangulations, the case of such
polyhedra that cannot be retriangulated cannot happen, so \cgal\
proposes a vertex removal.

\ccMethod{void remove(Vertex_handle v);}
{Removes the vertex \ccc{v} from the triangulation.\\
Note that in {\sc Cgal} 3.0 we have implemented a new algorithm for
retriangulating the hole after the removal.
In case that you experience problems when removing a vertex, the old
code can be enabled with a \ccc{\#define CGAL_DELAUNAY_3_OLD_REMOVE 1}.
\ccPrecond{\ccc{v} is a finite vertex of the triangulation.}}

\ccMethod{template < typename InputIterator >
          int remove(InputIterator first, InputIterator beyond);}
{Removes the vertices specified by the iterator range [\ccStyle{first, beyond})
of value type \ccc{Vertex_handle}.
\ccc{remove()} is called over each element of the range.
The number of vertices removed is returned.
\ccPrecond{All vertices of the range are finite vertices of the triangulation.}}

\ccHeading{Queries}

\ccMethod{Bounded_side
          side_of_sphere(Cell_handle c, const Point & p) const;}
{Returns a value indicating on which side of the circumscribed sphere
of \ccc{c} the point \ccc{p} lies. More precisely, it returns:\\
- \ccc{ON_BOUNDED_SIDE} if \ccc{p} is inside the sphere. For an infinite
cell this means that \ccc{p} lies strictly either in the half space
limited by its finite facet and not containing any other point of the
triangulation, or in the interior of the disk circumscribing the
\textit{finite} facet. \\ 
- \ccc{ON_BOUNDARY} if p on the boundary of the sphere. For an infinite
cell this means that \ccc{p} lies on the circle circumscribing
the \textit{finite} facet.\\ 
- \ccc{ON_UNBOUNDED_SIDE} if \ccc{p} lies outside the sphere. For an
infinite cell this means that \ccc{p} does not satisfy either of the
two previous conditions. 
\ccPrecond{\ccVar.\ccc{dimension()} $=3$.}}
\ccMethod{Bounded_side
          side_of_circle(const Facet & f, const Point & p) const;}
{Returns a value indicating on which side of the circumscribed circle
of \ccc{f} the point \ccc{p} lies. More precisely, it returns:\\
- in dimension~3:\\
-- For a finite facet, \ccc{ON_BOUNDARY} if \ccc{p} lies
on the circle, \ccc{ON_UNBOUNDED_SIDE} when it lies in the exterior of
the disk, \ccc{ON_BOUNDED_SIDE} when it lies in its interior.\\
-- For an infinite facet, it considers the plane defined by the finite
facet of the same cell, and does the same as in dimension~2 in this
plane.\\
- in dimension~2:\\
-- For a finite facet, \ccc{ON_BOUNDARY} if \ccc{p} lies
on the circle, \ccc{ON_UNBOUNDED_SIDE} when it lies in the exterior of
the disk, \ccc{ON_BOUNDED_SIDE} when it lies in its interior.\\
-- For an infinite facet, \ccc{ON_BOUNDARY} if the
point lies on the finite edge of \ccc{f} (endpoints included),
\ccc{ON_BOUNDED_SIDE} for a point in the open half plane defined
by \ccc{f} and not containing any other point of the triangulation,
\ccc{ON_UNBOUNDED_SIDE} elsewhere. 
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$ and in dimension 3,
\ccc{p} is coplanar with \ccc{f}.}}

\ccMethod{Bounded_side
          side_of_circle(Cell_handle c, int i, const Point & p);}
{Same as the previous method for facet \ccc{i} of cell \ccc{c}.}

\ccMethod{Vertex_handle nearest_vertex(Point p,
                                       Cell_handle c = Cell_handle());}
{Returns any nearest vertex to the point \ccc{p}, or the default constructed
handle if the triangulation is empty.  The optional argument \ccc{c} is a hint
specifying where to start the search.
\ccPrecond{\ccc{c} is a cell of \ccVar.}
}

\ccMethod{Vertex_handle nearest_vertex_in_cell(Point p,
                                       Cell_handle c);}
{Returns the  vertex  of the cell \ccc{c} that is
nearest to $p$.
}

A point \ccc{p} is said to be in conflict with a cell \ccc{c} in dimension 3
(resp. a facet \ccc{f} in dimension 2) iff \ccVar.\ccc{side_of_sphere(c, p)}
(resp. \ccVar.\ccc{side_of_circle(f, p)}) returns \ccc{ON_BOUNDED_SIDE}.
The set of cells (resp. facets in dimension 2) which are in conflict with
\ccc{p} is connected, and it forms a hole.

\ccMethod{template <class OutputIteratorBoundaryFacets,
                    class OutputIteratorCells>
  std::pair<OutputIteratorBoundaryFacets, OutputIteratorCells>
  find_conflicts(Point p, Cell_handle c,
                 OutputIteratorBoundaryFacets bfit,
                 OutputIteratorCells cit);}
{Computes the conflict hole induced by \ccc{p}.  The starting cell
(resp.  facet) \ccc{c} must be in conflict.  Then this function returns
respectively in the output iterators:\\
-- \ccc{cit}: the cells (resp. facets) in conflict.\\
-- \ccc{bfit}: the facets (resp. edges) on the boundary, that is, the facets
(resp. edges) \ccc{(t, i)} where the cell (resp. facet) \ccc{t} is in
conflict, but \ccc{t->neighbor(i)} is not.\\
This function can be used in conjunction with \ccc{insert_in_hole()} in order
to decide the insertion of a point after seeing which elements of the
triangulation are affected.
Returns the pair composed of the resulting output iterators.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$, and \ccc{c} is in conflict
with \ccc{p}.}
}

\ccMethod{template <class OutputIteratorBoundaryFacets,
                    class OutputIteratorCells,
                    class OutputIteratorInternalFacets>
  Triple<OutputIteratorBoundaryFacets,
         OutputIteratorCells,
         OutputIteratorInternalFacets>
  find_conflicts(Point p, Cell_handle c,
                 OutputIteratorBoundaryFacets bfit,
                 OutputIteratorCells cit,
                 OutputIteratorInternalFacets ifit);}
{Same as the other \ccc{find_conflicts()} function, except that it also 
computes the internal facets, i.e. the facets common to two cells which
are in conflict with \ccc{p}.
Then this function returns respectively in the output iterators:\\
-- \ccc{cit}: the cells (resp. facets) in conflict.\\
-- \ccc{bfit}: the facets (resp. edges) on the boundary, that is, the facets
(resp. edges) \ccc{(t, i)} where the cell (resp. facet) \ccc{t} is in
conflict, but \ccc{t->neighbor(i)} is not.\\
-- \ccc{ifit}: the facets (resp. edges) inside the hole, that is, delimiting
two cells (resp facets) in conflict.\\
Returns the \ccc{Triple} composed of the resulting output iterators.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$, and \ccc{c} is in conflict
with \ccc{p}.}
}

\ccMethod{template <class OutputIterator>
  OutputIterator
  vertices_in_conflict(Point p, Cell_handle c,
                 OutputIterator res);}
{Similar to \ccc{find_conflicts()}, but reports the vertices which are on the
boundary of the conflict hole of \ccc{p}, in the output iterator \ccc{res}.
Returns the resulting output iterator.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$, and \ccc{c} is in conflict
with \ccc{p}.}
}



\ccHeading{Voronoi diagram}
\ccIndexMainItem{Voronoi diagram}
\cgal\ offers several functionalities to display the Voronoi diagram of 
a set of points in 3D.

Note that the user should use a kernel with exact constructions in order
to guarantee the computation of the Voronoi diagram (as opposed to computing
the triangulation only, which requires only exact predicates).

\ccMethod{Point dual(Cell_handle c) const;}
{Returns the circumcenter of the four vertices of c.
\ccPrecond{\ccVar.\ccc{dimension()}$=3$ and \ccc{c} is not infinite.}}

\ccMethod{Object dual(Facet f) const;}
{Returns the dual of facet \ccc{f}, which is \\
in dimension 3: either a segment, if the two cells incident to \ccc{f}  
are finite, or a ray, if one of them is infinite;\\
in dimension 2: a point.
\ccPrecond{\ccVar.\ccc{dimension()} $\geq 2$ and \ccc{f} is not infinite.}}

\ccMethod{Object dual(Cell_handle c, int i) const;}
{same as the previous method for facet \ccc{(c,i)}.}

\ccMethod{template <class Stream> Stream & draw_dual(Stream & os);}
{Sends the set of duals to all the facets of \ccVar\ into \ccc{os}.}


\begin{ccAdvanced}
\ccHeading{Checking}
\ccMethod{bool
          is_valid(bool verbose = false) const;}
{Checks the combinatorial validity of the triangulation and the
validity of its geometric embedding (see
Section~\ref{Triangulation3-sec-intro}). Also checks that all the
circumscribing spheres (resp. circles in dimension~2) of  cells
(resp. facets in dimension~2) are empty.\\ When \ccc{verbose} is set to
true,  messages describing the first invalidity encountered are
printed.}

\ccMethod{bool
          is_valid(Cell_handle c, bool verbose = false) const;}
{Checks the combinatorial and geometric validity of the cell (see
Section~\ref{Triangulation3-sec-intro}). Also checks that the
circumscribing sphere (resp. circle in dimension~2) of  cells
(resp. facet in dimension~2) is empty.\\
 When \ccc{verbose} is set to
true, messages are printed to give
a precise indication of the kind of invalidity encountered.}

These methods are  mainly a debugging help for the users of advanced features.
\end{ccAdvanced}

\ccSeeAlso

\ccc{CGAL::Triangulation_hierarchy_3}.

%% \ccExample

%% \ccIncludeExampleCode{examples/Triangulation3/Delaunay_triangulation_3_prog.C}

\end{ccRefClass}
