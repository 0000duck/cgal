% // ============================================================================
%//
%// Copyright (c) 1999 The CGAL Consortium
%//
%// This software and related documentation is part of an INTERNAL release
%// of the Computational Geometry Algorithms Library (CGAL). It is not
%// intended for general use.
%//
%// ----------------------------------------------------------------------------
%//
%// release       :
%// release_date  :
%//
%// file          : /doc_tex/basic/Triangulation3/Triangulation3.tex
%// revision      : $Revision$
%//
%// author(s)     : Monique Teillaud <Monique.Teillaud@sophia.inria.fr>
%//
%// coordinator   : INRIA Sophia Antipolis (Mariette Yvinec <Mariette.Yvinec@sophia.inria.fr>)
%//
%//============================================================================
\chapter{Triangulation in 3D}
\label{chapter-Triangulation3}
\begin{ccTexOnly}
\vspace*{-2cm}
\includegraphics{grille.eps} \hspace*{2cm} 
\includegraphics{sphere.eps} 
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./sphere.gif" align=center>
<img border=0 src="./grille.gif" align=center>
\end{ccHtmlOnly}
\section{Introduction}
\label{Triangulation3-sec-intro}
\subsection{Definition}
\label{Triangulation3-sec-def}
A three-dimensional triangulation is a three-dimensional simplicial
complex, pure connected and without singularities. (See
\cite{by-ag-98} or Chapter~\ref{I1_Chapter_Triangulations}.) Its
cells ($3$-faces) are such that two cells either do not intersect or
share a common facet ($2$-face), edge ($1$-face) or vertex ($0$-face).

The basic 3D-triangulation class of \cgal\ is primarily designed to
represent the triangulations of a set of points $A$ in $\R^3$.  It can
be viewed as a partition of the convex hull of {$A$} into tetrahedra
whose vertices are the points of {$A$}.  Together with the unbounded
cell having the convex hull boundary as its frontier, the triangulation
forms a partition of $\R^3$.

In order to deal
only with tetrahedra, which is convenient for many applications, the
unbounded cell can be subdivided into tetrahedra by considering that
each convex hull facet is incident to an \ccc{infinite cell} having as
fourth vertex an auxiliary vertex called the \ccc{infinite vertex}.  In
that way, each facet is incident to exactly two cells and special cases
at the boundary of the convex hull are simple to deal with.

The class \ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} of \cgal\ implements this
point of view and therefore considers the triangulation of the set
of points as a set of finite and infinite tetrahedra.  Notice that the
infinite vertex has no significant coordinates and that no
geometric predicate can be applied on it.

A triangulation is a collection of vertices and cells that are linked
together through incidence and adjacency relations. Each cell gives
access to its four incident vertices and to its four adjacent
cells. Each vertex gives access to one of its incident cells.

The four vertices of a cell are indexed with 0, 1, 2 and 3 in positive
orientation, the positive orientation being defined by the orientation
of the underlying Euclidean space $\R^3$. The neighbors of a cell are also
indexed with 0, 1, 2, 3 in such a way that the neighbor indexed by $i$
is opposite to the vertex with the same index. See
Figure~\ref{Triangulation3-fig-orient}.

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center} 
\includegraphics{orient.eps} 
\end{center}
\end{ccTexOnly}
\caption{Orientation of a cell (3-dimensional case).
\label{Triangulation3-fig-orient}}
\begin{ccHtmlOnly}
<CENTER>
<img border=0 src="./orient.gif" align=center alt="Orientation of a cell 
(3-dimensional case)">
</CENTER>
\end{ccHtmlOnly}
\end{figure} 

As in the underlying combinatorial triangulation (see
Chapter~\ref{chapter-TDS3}), edges ($1$-faces) and facets ($2$-faces)
are not explicitly 
represented: a facet is given by a cell and an index (the facet
\ccc{i} of a cell \ccc{c} is the facet of \ccc{c} that is opposite to
the vertex with index \ccc{i}) and an edge is given by a cell and two
indices (the edge \ccc{(i,j)} of a cell \ccc{c} is the edge whose
endpoints are the vertices of \ccc{c} with indices \ccc{i} and
\ccc{j}). See Figure~\ref{TDS3-fig-repres}.  

\subsection{Degenerate Dimensions}
\label{Triangulation3-sec-degen_dim}

The class \ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} can also deal with
triangulations whose dimension is less than~3. A triangulation of a
set of points in $\R^d$ covers the whole space $\R^d$ and consists of
cells having $d+1$ vertices: some of them are infinite, they are
obtained by linking the additional infinite vertex to each facet of
the convex hull of the points.
\begin{itemize}
\item {} \emph{dimension 2:} when a triangulation only contains
coplanar points (which is the case when there are only three points), 
it consists of triangular faces.
\item {} \emph{dimension 1:} the triangulation contains only collinear 
points (which is the case when there are only two points), it consists
of edges.
\item {} \emph{dimension 0:} the triangulation contains only one
finite point.
\item {} \emph{dimension -1:} this is a convention to handle the case
when the only vertex of the triangulation is the infinite one.
\end{itemize} 

The same cell class is used in all cases: triangular faces in
2D can be considered as degenerate cells, having only three vertices
(resp. neighbors)
numbered $(0,1,2)$, and one $NULL$ vertex (resp. neighbor);
edges in 1D have only two vertices (resp. neighbors) numbered $0$ and $1$. 

The implicit representation of facets (resp. edges) still holds
for degenerate dimensions (\textit{i.e.}dimensions $<3$) : in
dimension~2, each cell has only one facet of index 3, and 3 edges
$(0,1)$, $(1,2)$ and $(2,0)$; in dimension~1, each cell has one edge
$(0,1)$.  

\subsection{Validity}
\label{Triangulation3-sec-Valid}

A triangulation of $\R^3$ is said to be \ccc{locally valid} iff

{\bf (a)-(b)} Its underlying combinatorial graph, the triangulation
data structure, is \ccc{locally valid} 
(see Section~\ref{TDS3-sec-Valid} of Chapter~\ref{chapter-TDS3})\\
{\bf (c)} Any cell has its vertices ordered according to positive
orientation. See Figure~\ref{Triangulation3-fig-orient}.

When the triangulation is degenerated into a triangulation of
dimension~2, the  geometric validity reduces to:

{\bf (c-2D)} For any two adjacent triangles $(u,v,w_1)$ and $(u,v,w_2)$ with
common edge $(u,v)$, $w_1$ and $w_2$ lie on opposite sides of $(u,v)$
in the plane.

When all the points are collinear, this condition becomes:

{\bf (c-1D)} For any two adjacent edges $(u,v)$ and $(v,w)$, $u$ and
$w$ lie on opposite sides of the common vertex $v$ on the line.

The \ccc{is_valid()} method provided by \cgal\ checks the local
validity of a given triangulation. This does not always
ensure global validity \cite{mnssssu-cgpvg-96,dlpt-ccpps-98} but it is 
sufficient for practical cases.

\section{Software Design}
\label{Triangulation3-sec-design}

The class \ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} is
designed to be used as  
a layer upon a 3D-triangulation data structure as presented in 
Section~\ref{TDS3-sec-design} of Chapter~\ref{chapter-TDS3}.
It provides high level geometric operations such as location of a point
in the triangulation and insertion of a point, and is responsible for
the geometric validity. This class is parameterized by two classes:
\begin{itemize}
\item {} the \textbf{geometric traits} class, where the user can
specify the type of points to use as well as the elementary
operations on them (predicates,\ldots). The concept of such a class is
introduced in Section~\ref{Triangulation3-sec-Traits}\lcTex{ and described in 
\ccRefPage{Triangulation_traits_3}} and a
model is provided by \cgal\
(see \ccc{CGAL::Triangulation_geom_traits_3<R>}\lcTex{
(\ccRefPage{CGAL::Triangulation_geom_traits_3<R>})} and  
\ccc{CGAL::Regular_triangulation_euclidean_traits_3<R,Weight>}\lcTex{
(\ccRefPage{CGAL::Regular_triangulation_euclidean_traits_3<R,Weight>})}.
\item {} the \textbf{triangulation data structure} class of the middle level, 
described in Chapter~\ref{chapter-TDS3}.
\end{itemize}	

Delaunay triangulations as well as triangulation hierarchies
\cite{d-iirdt-98} are also implemented in the package: 
\ccc{Delaunay_triangulation_3<Triangulation_traits_3,Tds_3>} inherits from 
\ccc{Triangulation_3<Triangulation_traits_3,Tds_3>}, and 
\ccc{Triangulation_hierarchy_3<Tr>} inherits from \ccc{Tr}.

\ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} derives from
\ccc{Triangulation_utils_3<Triangulation_traits_3,Tds_3>}, 
which defines a set of tools
working on the indices of vertices in cells\lcTex{ 
(\ccRefPage{CGAL::Triangulation_utils_3})}. 

\subsection{Basic Triangulation}

\ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} expects a model of a 
\textit{geometric traits class} as its first template argument and a model 
of a \textit{triangulation data structure} as its second argument. The
requirements and defaults for these classes are described in
the reference pages for Triangulation\_traits\_3\lcTex{ (
\ccRefPage{Triangulation_traits_3})},
\ccc{CGAL::Triangulation_geom_traits_3<R>}\lcTex{
(\ccRefPage{CGAL::Triangulation_geom_traits_3<R>})} and
\ccc{CGAL::Regular_triangulation_euclidean_traits_3<R,Weight>}\lcTex{
(\ccRefPage{CGAL::Regular_triangulation_euclidean_traits_3<R,Weight>})}.


%\subsection{The Vertex of a Triangulation} 
%\label{Triangulation3-sec-class-Vertex}

%\begin{ccClassTemplate}{Triangulation_vertex_3<Triangulation_traits_3,Tds_3>}
%\ccCreationVariable{v}

%\ccDefinition
%The vertex stores a point and gives access to an incident face of
%maximal dimension.
%	\end{ccClassTemplate} 

%\subsection{The Cell of a Triangulation} 
%\label{Triangulation3-sec-class-Cell}

%\begin{ccClassTemplate}{Triangulation_cell_3<Triangulation_traits_3,Tds_3>}
%\ccCreationVariable{c}

%\ccDefinition

%A cell of a triangulation gives access to its four vertices indexed 0,
%1, 2, and 3 in positive orientation and to its four adjacent cells, also
%called neighbors. The neighbors are indexed in such a way that neighbor
%$i$ lies opposite to vertex $i$.

%In degenerate dimensions, cells are used to store faces of maximal
%dimension: (Section~\ref{Triangulation3-sec-degen_dim}).
%	\end{ccClassTemplate} 

\subsection{Delaunay Triangulation} 

The class \ccc{Delaunay_triangulation_3<Triangulation_traits_3,Tds_3>}
represents a three-dimensional Delaunay triangulation. 

\subsection{Triangulation hierarchy} 

The class \ccc{Triangulation_hierarchy_3<Tr>} implements a triangulation
augmented with a data structure which allows fast point location queries.
The data structure is a hierarchy of triangulations. The triangulation at the
lowest level is the original triangulation where operations and point location
are to be performed.  Then at each succedding level, the data structure stores
a triangulation of a small random sample of the vertices of the triangulation
at the preceeding level. Point location is done through a top-down nearest
neighbor query.  The nearest neighbor query is first performed naively in the
top level triangulation.  Then, at each following level, the nearest neighbor
at that level is found through a linear walk performed from the nearest
neighbor found at the preceeding level.  Because the number of vertices in
each triangulation is only a small fraction of the number of vertices of the
preceeding triangulation the data structure remains small and achieves fast
point location queries on real data. As proved in~\cite{d-iirdt-98}, this
structure has an optimal behaviour when it is built for Delaunay
triangulations.  However it can be used as well for other triangulations and
the \ccRefName\ class is templated by a parameter which is to be instantiated
by one of the \cgal\ triangulation classes.

\subsection{Regular Triangulation} 
\label{Triangulation3-sec-class-Regulartriangulation}

\ccc{Regular_triangulation_3<Triangulation_traits_3,Tds_3>} implements
regular triangulations.

Let ${S}^{(w)}$ be a set of weighted points in $\R^3$. Let
${p}^{(w)}=(p,w_p), p\in\R^3, w_p\in\R$ and 
${z}^{(w)}=(z,w_z), z\in\R^3, w_z\in\R$ be two weighted points. 
A weighted point
${p}^{(w)}=(p,w_p)$ can also be seen as a sphere of center $p$ and
radius $w_p$. 
The \textit{power product} between ${p}^{(w)}$ and ${z}^{(w)}$ is
defined as 
\[\Pi({p}^{(w)},{z}^{(w)}) = {\|{p-z}\|^2-w_p^2-w_z^2}\]
where $\|{p-z}\|$ is the Euclidean distance between $p$ and $z$. 
 ${p}^{(w)}$ and ${z}^{(w)}$
are said to be \textit{orthogonal} if $\Pi{({p}^{(w)}-{z}^{(w)})}
= 0$ (see Figure~\ref{Triangulation3-fig-ortho}).

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center} 
\includegraphics{ortho.eps} 
\end{center}
\end{ccTexOnly}
\caption{Orthogonal weighted points (picture in 2D).
\label{Triangulation3-fig-ortho}}
\begin{ccHtmlOnly}
<CENTER>
<img border=0 src="./ortho.gif" align=center alt="Orthogonal weighted
points (picture in 2D)"> 
</CENTER>
\end{ccHtmlOnly}
\end{figure} 

Four weighted points have a unique common orthogonal weighted point called
the \textit{power sphere}. A sphere ${z}^{(w)}$ is said to be
\textit{regular} if $\forall {p}^{(w)}\in{S}^{(w)},
\Pi{({p}^{(w)}-{z}^{(w)})}\geq 0$.

A triangulation of ${S}^{(w)}$ is \textit{regular} if the power spheres
of all simplices are regular. 

The regular triangulation of
${S}^{(w)}$ is in fact the projection onto $\R^3$ of the convex hull 
of the four-dimensional points $(p,\|p-O\|^2-w_p),$ for
${p}^{(w)}=(p,w_p)\in{S}^{(w)}$. 
Note that all points of ${S}^{(w)}$ do not
necessarily appear as vertices of the regular
triangulation. To know more about regular triangulations, see for
example \cite{es-itfwr-96}. 

When all weights are 0, power spheres are nothing more than
circumscribing spheres, and the regular triangulation is exactly the
Delaunay triangulation.

We will call the weighted point orthogonal to three weighted points in
the plane defined by these three points the \textit{power circle}. The
\textit{power segment} will denote the weighted point orthogonal to
two weighted points on the line defined by these two points.

To simplify notation, $p$ will often denote in the sequel either the
point $p\in\R^3$ or the weighted point ${p}^{(w)}=(p,w_p)$.

%\section{A Class of Tools \protect\ccc{Triangulation_utils_3}} 
%\section{A Class of Tools}
%\label{Triangulation3-sec-class-Utils}

%\begin{ccClass}{Triangulation_utils_3}
%The class \ccClassName\ defines operations on the indices of vertices
%and neighbors within a cell. These operations are used in
%\ccc{Triangulation_3.h},
%\ccc{Triangulation_data_structure_3.h},
%\ccc{Triangulation_ds_cell_3.h},
%\ccc{Triangulation_ds_circulators_3.h}. These classes inherit from
%\ccClassName\ so that they can use its methods.
%\end{ccClass}




%\section{Debugging}

%	\subsection{Pretty print}	
% \textit{to be written}

%	\subsection{Debugging with handles} 
%Most debuggers cannot understand \ccc{handles} well. Under the
%debugger, an instruction such as

%\texttt{(dbx) print -r c->vertex(0)}

%where \ccc{c} is a \ccc{Cell_handle}, is answered by:

%\texttt{can't find field "vertex" in "c"}

%To work around this problem, two functions have been defined to transform 
%\ccc{handles} into usual $C^{++}$ pointers for debugging purposes.

%\ccFunction{template <class Triangulation_traits_3, class Tds_3>
%	Triangulation_vertex_3<Triangulation_traits_3,Tds_3> * 
%debug(const Triangulation_vertex_handle_3<Triangulation_traits_3,Tds_3> v);}
%{}

%\ccFunction{template <class Triangulation_traits_3, class Tds_3>
%	Triangulation_cell_3<Triangulation_traits_3,Tds_3> * 
%	debug(const Triangulation_cell_handle_3<Triangulation_traits_3,Tds_3>
%c);}
%{}

%This allows the following:\\
%\texttt{(dbx) print -r CGAL\_debug(c)->vertex(0)\\
%CGAL\_debug(c)->vertex(0) = \{\\\
%\ldots\\
%\} }

\subsection{The Geometric Traits}
\label{Triangulation3-sec-Traits}

The first template parameter of the triangulation class
\ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} of \cgal\ is the geometric traits class.

The geometric traits class must define the geometric
objects (points, segments, triangles and tetrahedra) forming the
triangulation together with a few geometric predicates on these objects:
equality, coordinate comparison, orientation in space, orientation
in case of coplanar points, and collinearity tests.

In addition to the requirements described before, the geometric traits
class of a Delaunay triangulation must define predicates for the
\textit{empty sphere property}.

To be used as the traits class for the regular triangulation provided
by \cgal, a class must provide definitions for the \textit{power tests}.
(See Section~\ref{Triangulation3-sec-class-Regulartriangulation}.)
	
\cgal\ provides a predefined geometric traits class 
\ccc{Triangulation_geom_traits_3<R>} using the kernel
geometric objects and predicates.
This class is templated with a representation class.

The traits class \ccClassTemplateName\ is designed to deal with \cgal\ 
three-dimensional points. It supplies the user with all
the functionalities described for the concept
Triangulation\_traits\_3\lcTex{ (\ccRefPage{Triangulation_traits_3})}.
So, it can be used as a default traits
class for \ccc{Triangulation_3<Triangulation_traits_3,Tds_3>},
\ccc{Delaunay_triangulation_3<Triangulation_traits_3,Tds_3>}.

\ccc{Regular_triangulation_euclidean_traits_3<R,Weight>} is a traits class 
 designed to be used by the class
\ccc{Regular_triangulation_3<Triangulation_traits_3,Tds_3>}. It provides
\ccc{Weighted_point}, a class for weighted points
provided by the class, which derives from the \cgal\ three dimensional
point class. It supplies
the user with all the functionalities 
described for the concept Triangulation\_traits\_3\lcTex{
(\ccRefPage{Triangulation_traits_3})}. 
 It can be used as a default traits
class for \ccc{Regular_triangulation_3<Triangulation_traits_3,Tds_3>}.

%		\subsection{Weighted point}	
%		\label{Triangulation3-sec-class-Weightedpoints}

%		\subsubsection{Concept for a weighted point}

%The weighted point class is needed by 
%\ccc{Regular_triangulation_euclidean_traits_3}. 


%		\subsubsection{Model of weighted point} 

%		\begin{ccClassTemplate}{Weighted_point<Point,Weight>}
%This class provides \ccc{Regular_triangulation_euclidean_traits_3}
%with all the required functionalities.

%\ccInclude{CGAL/Weighted_point.h}

%\ccInheritsFrom{\ccc{Point} (the template parameter) }

%		\end{ccClassTemplate}

\subsection{The Triangulation Data Structure Parameter}
\label{Triangulation3-sec-tds}

The second template parameter of the basic triangulation class
\ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} is a triangulation 
data structure class.  This class can be seen as a container for the
cells and vertices maintaining incidence and adjacency relations (see
Chapter~\ref{chapter-TDS3}).  A model of this triangulation data
structure is \ccc{Triangulation_data_structure_3}\lcTex{ 
(\ccRefPage{CGAL::Triangulation_data_structure_3<Triangulation_vb_3,Triangulation_cb_3>})}.

\section{Examples}
\label{Triangulation3-sec-examples}
This example shows the incremental construction of a 3D triangulation, 
the location of a point, and how to manipulate elementary operations
on indices in a cell.

\begin{verbatim}
#include <CGAL/basic.h>

#include <iostream>

#include <assert.h>
#include <list>
#include <vector>

#include <CGAL/Cartesian.h>

#include <CGAL/Triangulation_cell_base_3.h>
#include <CGAL/Triangulation_vertex_base_3.h>
#include <CGAL/Triangulation_data_structure_3.h>
#include <CGAL/Triangulation_geom_traits_3.h>
#include <CGAL/Triangulation_3.h>

// for this simple example, using doubles is ok
//
typedef double NT;

// for more complicated examples with degenerate configurations,
// using Filtered_exact number type is advised :
// 
// #include <CGAL/Arithmetic_filter.h>
// #include <CGAL/MP_Float.h>
// 
// typedef CGAL::Filtered_exact<double, CGAL::MP_Float> NT;

typedef CGAL::Cartesian<NT> Repr;
typedef CGAL::Triangulation_geom_traits_3<Repr> Gt;

typedef CGAL::Triangulation_vertex_base_3<Gt> Vb;
typedef CGAL::Triangulation_cell_base_3<Gt>  Cb;

typedef CGAL::Triangulation_data_structure_3<Vb,Cb> TDS;
typedef CGAL::Triangulation_3<Gt,TDS> Triangulation;

typedef typename Triangulation::Cell_handle Cell_handle;
typedef typename Triangulation::Vertex_handle Vertex_handle;
typedef typename Triangulation::Locate_type Locate_type;

typedef Gt::Point_3 Point;

int main(int argc, char* argv[])
{

  Triangulation T;

  // insertion from a list :
  std::list<Point> L;
  L.push_front(Point(0,0,0));
  L.push_front(Point(1,0,0));
  L.push_front(Point(0,1,0));

  int n = T.insert(L.begin(), L.end());

  // insertion from a vector :
  std::vector<Point> V(3);
  V[0] = Point(0,0,1);
  V[1] = Point(1,1,1);
  V[2] = Point(2,2,2);

  n = n + T.insert(V.begin(), V.end());

  // 6 points have been inserted :
  assert( n == 6 );

  // checking validity of T :
  assert( T.is_valid(false) );

  Locate_type lt;
  int li, lj;
  Point p(0,0,0);
  Cell_handle c = T.locate(p, lt, li, lj);
  // p is the vertex of c of index li :
  assert( lt == Triangulation::VERTEX );
  assert(  c->vertex(li)->point() == p );

  Vertex_handle v = c->vertex( (li+1)&3 );
  // v is another vertex of c
  Cell_handle nc = c->neighbor(li);
  // nc = neighbor of c opposite to the vertex associated with p
  // nc must have vertex v :
  int nli;
  assert( nc->has_vertex( v, nli ) );
  // nli is the index of v in nc

  std::ofstream oFileT("output",ios::out);
  // writing file output; 
  // this file is meant to be read only by the operator >>
  oFileT << T; 

  Triangulation T1;
  std::ifstream iFileT("output",std::ios::in);
  // reading file output; 
  iFileT >> T1; 
  assert( T1.is_valid() );
  assert( T1.number_of_vertices() == T.number_of_vertices() );
  assert( T1.number_of_cells() == T.number_of_cells() );

  return 0;
}
\end{verbatim}

