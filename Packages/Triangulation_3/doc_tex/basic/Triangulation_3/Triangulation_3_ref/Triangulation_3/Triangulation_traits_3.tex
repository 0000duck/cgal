% +------------------------------------------------------------------------+
% | Reference manual page: Triangulation_Traits_3.tex
% +------------------------------------------------------------------------+
% | 27.3.2000   Monique Teillaud
% | Package: Triangulation3
% | 
\RCSdef{\RCSTriangulationTraitsRev}{$Revision$}
\RCSdefDate{\RCSTriangulationTraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{Triangulation_traits_3}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\subsubsection{To be used by \protect \ccc{Triangulation_3<Triangulation_traits_3, Tds_3>}}

\ccDefinition
The concept \ccRefName\ is the first template parameter of the
triangulation class \ccc{Triangulation_3<Triangulation_traits_3,Tds_3>} of \cgal. It
defines the geometric
objects (points, segments, triangles and tetrahedra) forming the
triangulation together with a few geometric predicates on these objects:
equality, coordinate comparison, orientation in space, orientation
in case of coplanar points, and collinearity tests.

\ccTypes
\ccTwo{Triangulation_traits_3::Tetrahedron}{}

\ccNestedType{Point_3}
{The type must provide a copy constructor and assignment operator.}
\ccGlue
\ccNestedType{Segment_3}
{The  type must provide a constructor that takes two points as arguments.}
\ccGlue
\ccNestedType{Triangle_3}
{The type must provide a constructor that takes three points as
arguments.}
\ccGlue
\ccNestedType{Tetrahedron_3}
{The type must provide a constructor that takes four points as
arguments.}

\ccCreation
\ccCreationVariable{traits}  %% choose variable name
\ccThree{Comparison_result}{compare_x()toto}{}

\ccConstructor{Triangulation_Triangulation_traits_3_3();}{default constructor.}
Only a default constructor is required.

\ccConstructor{Triangulation_traits_3();} 
{A default constructor.}

\ccOperations

\ccThree{Comparison_result}{traits.orientation_in_plane( Point q, Point r, Point s, Point test)}{} 

\ccHeading{Predicates}
\ccMethod{bool equal(const Point & p, const Point & q) const;}
{Equality test.}

\ccMethod{Comparison_result compare_x(const Point & p, const Point
& q) const;}
{Comparison of \ccc{x}-coordinates. Returns \ccc{LARGER}
(resp. \ccc{EQUAL}, \ccc{SMALLER}) when the \ccc{x}
coordinate of \ccc{p} is larger than (resp. equal to, smaller than)
the \ccc{x} coordinate of \ccc{q}.} 
\ccGlue
\ccMethod{Comparison_result compare_y(const Point & p, const Point
& q) const;}
{Comparison of \ccc{y}-coordinates.}
\ccGlue
\ccMethod{Comparison_result compare_z(const Point & p, const Point
& q) const;}
{Comparison of \ccc{z}-coordinates.}

\ccMethod{Orientation orientation(const Point& p0,
                                       const Point& p1,
                                       const Point& p2,
                                       const Point& p3) const;}
{Orientation test in three dimensions.}

\ccMethod{Orientation orientation_in_plane
				(const Point & q,	
				 const Point & r,
				 const Point & s,
				 const Point & test) const;}
{Tests whether \ccc{test} is on the same side of \ccc{(q, r)} as
\ccc{s} in the common plane of the four points. Returns \ccc{COLLINEAR} if
\ccc{test, q, r} are collinear, \ccc{POSITIVE} if \ccc{(q, r, test)}
and \ccc{(q, r, s)} have the same orientation, \ccc{NEGATIVE} if
\ccc{(q, r, test)} and \ccc{(q, r, s)} have opposite orientations. 
\ccPrecond{\ccc{test, q, r, s} are coplanar and \ccc{q, r, s} are not
collinear.}} 

\ccMethod{bool collinear(const Point & p,
		 	 const Point & q,
		 	 const Point & r) const;}
{Collinearity test.}

\subsubsection{To be used by \protect 
\ccc{Delaunay_triangulation_3<Triangulation_traits_3, Tds_3>}}

\ccDefinition
In addition to the requirements described before, the geometric traits
class of a Delaunay triangulation must fulfill the following
requirements:

\ccHeading{Predicates}

\ccMethod{Oriented_side 
  	side_of_oriented_sphere(const Point & p,
			  const Point & q,
			  const Point & r,
			  const Point & s,
			  const Point & test) const;}
{Determines on which side of the oriented sphere circumscribing 
\ccc{p, q, r, s} the point \ccc{test} lies.} 

\ccMethod{Oriented_side 
  side_of_oriented_circle(const Point & p,
			  const Point & q,
			  const Point & r,
			  const Point & test) const;}
{Determines on which side of the oriented circle circumscribing
\ccc{p, q, r} the point \ccc{test} lies. 
\ccPrecond{\ccc{p, q, r, test} are coplanar and \ccc{p, q, r} are not
collinear.}}  

\subsubsection{To be used by \protect 
\ccc{Delaunay_hierarchic_triangulation_3<Triangulation_traits_3, Tds_3>}}

\textit{Not yet implemented}

\subsubsection{To be used by \protect 
\ccc{Regular_triangulation_3<Triangulation_traits_3, Tds_3>}}

\ccDefinition

To be used as the traits class for the regular triangulation provided
by \cgal, a class must provide definitions for the \textit{power tests}.

We use here the same notation as in
Section~\ref{Triangulation3-sec-class-Regulartriangulation}. 

\ccMethod{Oriented_side power_test(const Weighted_point &p,
			   const Weighted_point &q,
			   const Weighted_point &r,
			   const Weighted_point &s,
			   const Weighted_point &t) const;}
{Let ${z(p,q,r,s)}^{(w)}$ be the power sphere of the weighted points 
$(p,q,r,s)$. Returns \\
\ccc{ON_ORIENTED_BOUNDARY} if \ccc{t} is orthogonal to
${z(p,q,r,s)}^{(w)}$,\\ 
\ccc{ON_NEGATIVE_SIDE} if \ccc{t} lies outside the oriented sphere of
center $z(p,q,r,s)$ and radius $\sqrt{ w_{z(p,q,r,s)}^2 + w_t^2 }$
(which is equivalent to $\Pi({t}^{(w)},{z(p,q,r,s)}^{(w)} >0$)),\\
\ccc{ON_POSITIVE_SIDE} if \ccc{t} lies inside this oriented sphere.
\ccPrecond{\ccc{p, q, r, s} are not coplanar.}}

Note that with this definition, if all the points have a weight equal
to 0, then
\ccc{power_test(p,q,r,s,t)} = \ccc{side_of_oriented_sphere(p,q,r,s,t)}.

\ccMethod{Oriented_side power_test(const Weighted_point &p,
			   const Weighted_point &q,
			   const Weighted_point &r,
			   const Weighted_point &t) const;}
{Analogous definition as the previous method, for coplanar points,
with the power circle ${z(p,q,r)}^{(w)}$.
\ccPrecond{\ccc{p, q, r} are not collinear and \ccc{p, q, r, t} are
coplanar.}}

If all the points have a weight equal to 0, then
\ccc{power_test(p,q,r,s,t)} = \ccc{side_of_oriented_circle(p,q,r,s,t)}.

\ccMethod{Oriented_side power_test(const Weighted_point &p,
			   const Weighted_point &q,
			   const Weighted_point &t) const;}
{Same for collinear points, where ${z(p,q)}^{(w)}$ is the
power segment of \ccc{p} and \ccc{q}.
\ccPrecond{\ccc{p} and \ccc{q} have different Bare\_points, and
\ccc{p, q, t} are collinear.}}

If all the points have a weight equal to 0, then
\ccc{power_test(p,q,t)} gives the same answer as the kernel predicate
\ccc{s(p,q).has_on(t)} would give, where  \ccc{s(p,q)} denotes the
segment with endpoints \ccc{p} and \ccc{q}.

\ccHasModels

\ccc{CGAL::Triangulation_geom_traits_3<R>},\\
\ccc{CGAL::Regular_triangulation_euclidean_traits_3<R,Weight>}.


%% \ccExample

%% \ccIncludeExampleCode{examples/Triangulation3/Triangulation_Traits_3_prog.C}

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

