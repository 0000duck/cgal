\chapter*{Bounding Box Intersection}

\section*{Introduction}
This chapter describes the functions provided in \cgal{} 
to test large numbers of bounding boxes for intersection.

Computing information about complex geometric primitives is often
expensive. While researchers in computational geometry have discovered
many asymptotically efficient algorithms for such problems, the
algorithms are often of theoretical interest only, as they are hard to
implement or slow if implemented. One general approach is to reduce
the problem size enough so that a brute force method is feasible and
fast. By putting axis-aligned bounding boxes around complicated
primitives, we can compute, in a short amount of time, an approximate
answer in the form of a small set of pairs with potential interaction.
We then refine our answer by looking inside the boxes, computing the
exact answer for the original data.

Many geometric problems can be restated in terms of box intersections
since if the bounding boxes of two primitives intersect, we know that
the primitives may intersect or have close proximity. Some practical
problems we may solve with this approach include detecting surface
self-intersection, intersection of two different objects and
performing proximity queries.


\section*{Bounding Box Intersection}
\subsection*{Bounding Box}

Bounding boxes can have any dimension. In each dimension, an interval
defines the size of the box in that dimension. For the starting point
and end point of the interval, any number type can be used.

Depending on your problem, the box can be half open or closed. A
bounding box is half open, if in each dimension the interval $[lo,hi)$
is also half open. Similarly, a closed bounding box contains only
closed intervals $[lo,hi]$ in each dimension. Closed intervals allow
for zero-width boxes and for intersections at the boundary of objects.
The distinction between closed or half open intervals does not require
a different representation of boxes, but instead a different
interpretation when comparing boxes. This is handled inside the traits
class.

There has to be an arbitrary fixed order between boxes, for example by
assigning unique numbers to each box. If boxes are allocated on the
heap, also the memory location could define such an order. 

The default bounding box 
\begin{itemize} 
  \item implements a standard bounding box 
  \item is generic in terms of number type and dimension: \\
  \texttt{template< class T, unsigned int DIM > struct Default\_box\_d} 
  \item provides unique numbering
  \item can be used as a base class to derive a user defined box with
  additional information, for example, an exact geometric primitive
  that was approximated with the bounding box.
\end{itemize}

\subsection*{Box Adapter}
Bounding box access is exclusively done using a box adapter. This adapter hides the specific interface a box may have. A model of a box adapter may look as follows:
\begin{ccExampleCode}
template< class Box_ >
struct Default_box_d_adapter {
    typedef Box_ Box;
    typedef typename Box::Number_type Number_type;

    static Number_type get_lo( const Box& b, unsigned int dim )
    { return b.get_lo( dim ); }

    static Number_type get_hi( const Box& b, unsigned int dim )
    { return b.get_hi( dim ); }

    static unsigned int get_num( const Box& b )
    { return b.get_num();     }

    static unsigned int get_dim() 
    { return Box::get_dim(); }
};
\end{ccExampleCode}

This specific example of a box adapter is tailored for box classes that implement the default bounding box given above. If another implementation of box classes is used that (for example) does not allow access via dimension indices directly, a custom box adapter has to be written that translates dimension indices to whatever method invocations needed.

Box adapter requirements:
\begin{itemize}
 \item The type of \texttt{Box} can be either a pointer or a plain structure.
 \item \texttt{Number\_type} must be the same type as for the \texttt{BoundingBox}. In the example above, \texttt{Number\_type} is just propagated.
 \item \texttt{get\_lo} and \texttt{get\_hi} return the vector components of dimension \texttt{dim}, where the first  dimension has the index zero.
 \item \texttt{get\_num} returns the unique number of that box. Note that the return type is not constrained to \texttt{unsigned int}. Instead, it can be anything for which both \texttt{==} and \texttt{<} operators are defined.
\end{itemize}

\subsection*{Box Traits}
The box traits class specifies predicates between boxes. It propagates number type, box type, dimension and all other fields from the box adapter to the actual implementation of bounding box intersection. Some of the predicates it defines are:

\begin{itemize}
 \item \texttt{bool contains\_lo\_point(Box interval, Box point, int dim)}: regard the first box in dimension \texttt{dim} as an interval, and the second as a point being the low point of an interval. Returns true iff \texttt{interval} contains \texttt{point}.
 \item \texttt{bool is\_lo\_less\_lo(Box a, Box b, int dim)}: interval starting point less than another intervals starting point (wrt. dimension \texttt{dim})
 \item a binary predicate object \texttt{class Compare} that compares two boxes using the predicate \texttt{is\_lo\_less\_lo}.
\end{itemize}

Usually, the default predicates need not be changed. Detailed requirements for box traits can be found in the reference. The default implementation of box predicates is a template with two parameters:

\texttt{template< class BoxAdapter, bool closed > struct Default\_Box\_Traits}

Box access is required inside the predefined predicates, therefore a box adapter has to be given to the traits class. The boolean constant \texttt{closed} chooses between closed and half open box interpretation. 


\subsection*{Usage}
First, for each geometric primitive, a bounding box has to be computed. Any bounding box class can be used, as long as a box adapter exists for it. The bounding box sets have to be supplied to the algorithm by pairs of \ccc{Random Access Iterators}. While checking, each bounding box intersection is written to an output iterator as two box references.

If the used box class is derived from the default bounding box (or at least has the same fields), there is no need to specify a box adapter. When no box adapter is given, it is assumed that the default box adapter can be used to access the supplied boxes.


\begin{itemize}
  \item runtime $O(n\log^{d-1}n+k)$ where n is the number of boxes, d is dimension (starting with one) and k is number of intersections
  \item space requirement $O(n)$ where n is number of boxes. no new space is allocated. instead, user provided box iterators are reused.
  \item some fine-tuning required for last percent of performance (cutoff parameter) 
  \item segment tree has some overhead. if callback runtime is low, better use scanning for lower numbers of boxes. \cgal uses exact arithmetic. may slow down the computation inside the callbacks. segment tree faster even for low numbers of boxes.  
\end{itemize}

 
\section*{Examples}
All examples use closed boxes and the bipartite setting. \texttt{fill\_boxes}, \texttt{callback} and \texttt{main} are almost identical.
\subsection*{Minimal Example}
Minimal example using random boxes. Boxes are default boxes without any geometric primitives inside. Each intersection is directly reported as a pair of numbers. 
\ccIncludeExampleCode{../../examples/Box_intersection_d/minimal.cc}

\subsection*{Custom Box}
box containing some nondeterministic primitive. 
\ccIncludeExampleCode{../../examples/Box_intersection_d/custombox.cc}

\subsection*{Custom BoxAdapter }
Here, a bounding box is a cube. This saves some space, at the expense of precision. The custom box only contains a vector to the minimal point plus a size for all three dimensions.

\ccIncludeExampleCode{../../examples/Box_intersection_d/customadapter.cc}


%% EOF %%
