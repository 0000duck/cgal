% +------------------------------------------------------------------------+
% | Reference manual page: Box_with_handle_d.tex
% +------------------------------------------------------------------------+


\begin{ccRefClass}[Box_intersection_d::]{Box_with_handle_d<NT, int N, Handle, IdPolicy>}
\ccDefinition

\ccRefName\ is a generic iso-oriented bounding box that stores a
handle to some other geometry. It provides an
interval with lower and upper endpoints represented with the number
type \ccc{NT} for each dimension of the total of \ccc{N} dimensions.
This class is provided to work smoothly with the algorithms for
intersecting sequences of iso-oriented boxes. For degeneracy handling,
the boxes need to provide a unique \ccc{id}-number. The policy
parameter \ccc{IdPolicy} offers several choices. The template
parameters have to comply with the following requirements:

\begin{itemize}
  \item
    \ccc{NT}: number type for the box boundaries, needs to be a model
    of the \ccc{Assignable} and the \ccc{LessThanComparable} concept.
  \item
    \ccc{int N}: the dimension of the box.
  \item
    \ccc{Handle} concept, e.g., a pointer, an iterator, or a circulators.
  \item
    \ccc{IdPolicy}: specifies how the \ccc{id}-number will be
    provided. Can be one of the following types, where
    \ccc{ID_EXPLICIT} is the default for this parameter:
    \begin{itemize}
      \item
        \ccc{ID_NONE}: no \ccc{id}-number is provided. Can be useful
        to have this class as a base class for different
        implementations of \ccc{id}-numbers than the ones provided
        here.
      \item
        \ccc{ID_EXPLICIT}: the \ccc{id}-number is stored explicitly in
        the box and automatically created and assigned at construction
        time of the box. Note that copying a box (copy-constructor and
        assignment) does not create a new \ccc{id}-number but keeps
        the old one, which is the behavior needed by the
        \ccc{CGAL::box_self_intersection} algorithm. This is therefore
        the safe default implementation. 
      \item
        \ccc{ID_FROM_BOX_ADDRESS}: casts the address of the box into a
        \ccc{std::ptrdiff_t} to create the \ccc{id}-number. Works fine 
        if the intersection algorithms work effectively with pointers
        to boxes, but not in the case where the algorithms work with
        box values, because the algorithms modify the order of the
        boxes, and the \ccc{CGAL::box_self_intersection} algorithm
        creates copies of the boxes that would not have identical
        \ccc{id}-numbers.  
      \item
        \ccc{ID_FROM_HANDLE}: casts the address of the value of the
        handle into a \ccc{std::ptrdiff_t} to create the
        \ccc{id}-number. Works fine in many conceivable settings, e.g.,
        it works fine with boxes copied by value or by pointer, and
        the self intersection test. It would not work fine if there
        is no one-to-one mapping between boxes and the geometry that
        is referred to with the handles, i.e., this \ccc{id}-number
        scheme might fail if there are several boxes referring to the
        same geometry. Note that this option was not
        available for the \ccc{CGAL::Box_intersection_d::Box_d} type
        that does not store a handle.
    \end{itemize}
\end{itemize}

\ccInclude{CGAL/Box_intersection_d/Box_with_handle_d.h}\\
and also automatically with\\
\ccInclude{CGAL/box_intersection_d.h}

\ccIsModel

\ccRefConceptPage{BoxIntersectionBox_d}

\ccTypes
\ccThree{std::size_tMMMMM}{Mbox.min_coord( int dim)}{}\ccThreeToTwo

\ccNestedType{NT}{number type to represent the box
  boundaries. Supported are the builtin types \ccc{int}, \ccc{unsigned
  int}, \ccc{float}, and \ccc{double}\footnote{The support is limited
  since we need the largest and the smallest number representable for
  this number type, which are currently only provided for the types
  \ccc{int}, \ccc{unsigned int}, \ccc{float}, and \ccc{double} with the
  class \ccc{CGAL::Box_intersection_d::box_limits<NT>}.}.}  

\ccTypedef{typedef std::size_t ID;}{type for the box \ccc{id}-number.}


\ccCreation
\ccCreationVariable{box}
\ccThree{std::size_t}{MMMMMMbox.min_coord( int dim)}{}\ccThreeToTwo

\ccConstructor{Box_with_handle_d();}{Default constructor. No particular initialization.}

\ccConstructor{Box_with_handle_d(bool complete, Handle h);}{initializes to the
  complete or the empty space. If empty, all interval starting(end)
  points will be set to positive(negative) infinity, sets handle to $h$.} 

\ccConstructor{Box_with_handle_d(NT lo[N], NT hi[N], Handle h);}{initializes 
  the box intervals to [\ccc{lo[i]}, \ccc{hi[i]} for $0 \leq i <
  $\ccc{dimension()}, sets the handle to $h$.}

\ccConstructor{Box_with_handle_d( const Bbox_2& bbox, Handle h);}{constructs
 from bbox and sets the handle to $h$, exists iff $N=2$ and \ccc{NT}$
 \equiv $\ccc{double}.} 
\ccGlue
\ccConstructor{Box_with_handle_d( const Bbox_3& bbox, Handle h);}{constructs
 from bbox and sets the handle to $h$, exists iff $N=3$ and \ccc{NT}$
 \equiv $\ccc{double}.}  


\ccModifiers

\ccMethod{void init( bool complete = false);}{initializes to the complete or 
  the empty space. If empty, all interval starting(end) points will be
  set to positive(negative) infinity.}

\ccMethod{void extend(NT point[N]);}{\ccPostcond box contains \ccc{point}.}

\ccAccessFunctions

\ccMethod{Handle handle() const;}{returns the handle stored in \ccc{box}.}

\ccFunction{const int Box_with_handle_d::dimension();}{%
  returns the number of dimensions.}

\ccMethod{std::size_t id();} {returns a unique box id, see the
  \ccc{IdPolicy} template parameter above for the different
  choices. Does not exist if \ccc{ID_NONE} has been chosen for the
  \ccc{IdPolicy}.}

\ccMethod{NT min_coord( int dim) const;}{%
  returns the lower boundary value of the \ccc{box} in dimension
  \ccc{dim}, $0 \leq $\ccc{dim}$ < $\ccc{dimension()}.}

\ccMethod{NT max_coord( int dim) const;}{%
  returns the upper boundary value of the \ccc{box} in dimension
  \ccc{dim}, $0 \leq $\ccc{dim}$ < $\ccc{dimension()}.}

\ccMethod{const Bbox_2& bbox() const;}{returns the bounding box iff
  $N=2$ and \ccc{NT}$ \equiv $\ccc{double}.}
\ccGlue
\ccMethod{const Bbox_3& bbox() const;}{returns the bounding box iff
  $N=3$ and \ccc{NT}$ \equiv $\ccc{double}.}

\ccSeeAlso

\ccRefIdfierPage{CGAL::box_intersection_d}\\
\ccRefIdfierPage{CGAL::box_self_intersection_d}\\
\ccRefIdfierPage{CGAL::box_intersection_all_pairs_d}

\ccRefIdfierPage{CGAL::Box_intersection_d::Box_traits_d<Box>}\\
\ccRefConceptPage{BoxIntersectionTraits_d}



\end{ccRefClass}
