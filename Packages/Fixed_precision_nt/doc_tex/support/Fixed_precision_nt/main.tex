% // ============================================================================
%//
%// Copyright (c) 1998 The CGAL Consortium
%//
%// This software and related documentation is part of an INTERNAL release
%// of the Computational Geometry Algorithms Library (CGAL). It is not
%// intended for general use.
%//
%// ----------------------------------------------------------------------------
%//
%// release       :
%// release_date  :
%//
%// file          : doc_tex/fixed.tex
%// revision      : $Revision$
%//
%// author(s)     : Olivier Devillers <Olivier.Devillers@sophia.inria.fr>
%//
%// coordinator   : Olivier Devillers <Olivier.Devillers@sophia.inria.fr>
%//
%//============================================================================

\begin{ccClass}{Fixed_precision_nt}

\ccSubsection{Fixed precision numbers}
\label{I1_Chapter_Fixed_precision_nt}

The class \ccStyle{Fixed_precision_nt} provides 24 bits numbers in 
fixed point representation.
Basically these numbers are integers in the range
$[-2^{24},2^{24}]$ with a multiplying factor $2^b$.
The multiplying factor $2^b$ has to be initialized by the user
before the construction of the first \ccStyle{Fixed_precision_nt}
and is common to all variables.

The interest of such a number type is that geometric predicates
can be overloaded to get exact and very efficient predicates.
The drawback is that any \ccStyle{Fixed_precision_nt} is rounded to 
the nearest multiple of $2^b$, which yields to a very poor arithmetic.
The idea is to not use the arithmetic on \ccStyle{Fixed_precision_nt}
but only the specialized predicates.


\ccSetTwoColumns{}{\hspace*{6.5cm}}

\ccCreation
\ccCreationVariable{fvar}

\ccInclude{CGAL/Fixed_precision_nt.h}

\ccConstructor{Fixed_precision_nt();}
            {Declaration.}

\ccConstructor{Fixed_precision_nt(double d);}
            {Initialization of a variable. The variable is rounded to the
                nearest legal fixed number (i.e. a multiple of $2^b=$
                \ccStyle{Fixed_precision_nt::unit_value()}}


\ccConstructor{Fixed_precision_nt(const Fixed_precision_nt &fval);}
            {Declaration and initialization.}


\ccConstructor{Fixed_precision_nt(int i)}
            {Declaration and initialization with an integer.}

\ccSetThreeColumns{Fixed_precision_nt &}{}{\hspace*{6.5cm}}
\ccOperations


\ccMethod{Fixed_precision_nt & operator=(const Fixed_precision_nt &fval);}
        {Assignment. 
}

\ccFunction{bool is_valid(const Fixed_precision_nt &fval);}
{In case of overflow or division by 0, numbers becomes invalid.
If the precision is changed by usage of 
\ccStyle{Fixed_precision_nt::init()}, already existing numbers may become invalid
if they are no longer multiple of $2^b$.}

\ccFunction{bool is_finite(const Fixed_precision_nt &fval);}
{ \ccClassName\ do not implement infinite numbers. 
  \ccStyle{is_finite} is identical to \ccStyle{is_valid}.}

The comparison operations $==$, $!=$, $<$, $>$, $<=$, and $>=$ are all
available.

The arithmetic operators $+$, $-$, $*$, $/$, $+=$, $-=$, $*=$ and $/=$
are all available. The result of the computation is rounded to the
nearest legal \ccClassName. Overflow is possible, and even probable in case
of multiplication or division. \ccClassName\ are designed to use
specialized predicates, not to use arithmetic.


\ccFunction{double to_double(const Fixed_precision_nt &fval);}
         {casts to \ccStyle{double}.}


%\section{Parametrization routines}

\ccHeading{Precision initialization}
As mentioned before, the \ccClassName\ numbers takes their values in an
interval $[-2^{24+b},2^{24+b}]$ of multiples of $2^b$,
this number $b$ as to be defined before any
 use of \ccStyle{Fixed_precision_nt}.

\ccSetThreeColumns{Oriented_side}{}{\hspace*{7.5cm}}

\ccFunction{static bool Fixed_precision_nt::init(float B);}
{$B$ is an upper bound on the data, $b$ is the smallest integer such that 
$|B|\leq 2^b$. The result of the function is false if initialization was
already done, in that case already existing \ccClassName\ may become invalid.}

\ccFunction{static float Fixed_precision_nt::unit_value();}
{returns $2^b$.}

\ccFunction{static float Fixed_precision_nt::upper_bound();}
{returns $2^{24+b}$.}

\ccHeading{Perturbation scheme}

\ccClassName\ implements the perturbation scheme as described by
Alliez, Devillers and Snoeyink \cite{ads-rdppw-97}.
The perturbation mode can be activated or deactivated for different kinds
of perturbations. The default mode is no perturbation.

\ccFunction{static void Fixed_precision_nt::perturb_incircle();}
{Activate. \ccstyle{side_of_oriented_circle} predicate
 of 4 cocircular points answers degenerate only if
the 4 points are colinear.}

\ccFunction{static void Fixed_precision_nt::unperturb_incircle();}
{Deactivate}

\ccFunction{static bool Fixed_precision_nt::is_perturbed_incircle();}
{returns current mode}

\ccFunction{static void Fixed_precision_nt::perturb_insphere();}
{Activate. \ccstyle{side_of_oriented_sphere} predicate
 of 5 cospherical points answers degenerate only if
the 5 points are coplanar.}

\ccFunction{static void Fixed_precision_nt::unperturb_insphere();}
{Deactivate}

\ccFunction{static bool Fixed_precision_nt::is_perturbed_insphere();}
{returns current mode}

%\section{Geometric predicates}
\ccHeading{Geometric predicates}

Through overloading mechanisms, functions such that
\ccStyle{orientation} for 
\ccStyle{Point_2<Cartesian< Fixed_precision_nt> >}
will correctly call the function below.

\ccSetThreeColumns{Oriented_side}{}{\hspace*{7.5cm}}

%\subsection{Two dimensional}

\ccFunction{Orientation orientationC2(
  Fixed_precision_nt x0, Fixed_precision_nt y0,
  Fixed_precision_nt x1, Fixed_precision_nt y1,
  Fixed_precision_nt x2, Fixed_precision_nt y2);}{}

\ccFunction{Oriented_side side_of_oriented_circleC2 (
  Fixed_precision_nt x0, Fixed_precision_nt y0,
  Fixed_precision_nt x1, Fixed_precision_nt y1,
  Fixed_precision_nt x2, Fixed_precision_nt y2,
  Fixed_precision_nt x3, Fixed_precision_nt y3);}{Perturbation mode can be activated.}

%\subsection{Three dimensional}

\ccFunction{Orientation orientationC3(  
  Fixed_precision_nt x0, Fixed_precision_nt y0, Fixed_precision_nt z0,
  Fixed_precision_nt x1, Fixed_precision_nt y1, Fixed_precision_nt z1,
  Fixed_precision_nt x2, Fixed_precision_nt y2, Fixed_precision_nt z2,
  Fixed_precision_nt x3, Fixed_precision_nt y3, Fixed_precision_nt z3);}{}

\ccSetThreeColumns{x}{}{\hspace*{7.5cm}}

\ccFunction{Oriented_side side_of_oriented_sphereC3 (
  Fixed_precision_nt x0, Fixed_precision_nt y0, Fixed_precision_nt z0,
  Fixed_precision_nt x1, Fixed_precision_nt y1, Fixed_precision_nt z1,
  Fixed_precision_nt x2, Fixed_precision_nt y2, Fixed_precision_nt z2,
  Fixed_precision_nt x3, Fixed_precision_nt y3, Fixed_precision_nt z3,
  Fixed_precision_nt x4, Fixed_precision_nt y4, Fixed_precision_nt z4);}
{Perturbation mode can be activated.}

\end{ccClass} 
