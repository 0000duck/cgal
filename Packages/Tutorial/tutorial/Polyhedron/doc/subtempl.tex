Based on the techniques and functionalities described in 
the previous sections, we now show how to design and implement
a subdivision library for a generic CGAL polyhedron. This 
library is named as the \emph{C}ombinatorial \emph{S}ubdivision 
\emph{L}ibrary, short CSL. CSL contains a set of refinement 
functions and geomtry smoothing rules. Subdivisions 
are specilaized as a proper combination of the refinement 
schemes and the smoothing rules. The goals of CSL are the 
\emph{generic polyhedron data},
\emph{user-friendly functional forms}, 
\emph{user-customizable subdivsions}, and a
\emph{extendible library}. 

CSL is designed based on the policy-based design 
\cite{Alexandrescu:2001:MCD}.
The policy-based design assembles a class
(called \emph{host}) with complex behavior out of many 
small and generic behaviors (called \emph{policies}).
Each policy defines an interface for a
specific behavior and cumstomizable by the user. 
Policies are usually implemented as the functions or functors.
One gentle example is the \CodeFmt{for\_each} algorithm in STL 
\footnote{\path|http://www.sgi.com/tech/stl/for_each.html|}. 
\begin{lstlisting}
template <class InputIterator, class UnaryFunction>
UnaryFunction for_each(InputIterator first, InputIterator last, UnaryFunction f);
\end{lstlisting}
The \CodeFmt{UnaryFunction f} is the generic behavior cunstomizable 
by the user. 

Based on the policy-based design, CSL
is designed for both the generic types, i.e.\ the polyhedron,
and the generic behaviors, i.e.\ the subdivisions.
%This means users can customize the subdivisions at compile time. 
The interface of the generic types is specified as a \cgalpoly .
In addition to the connectivity interface like circulators or
the adjacency pointers of a halfedge, CSL requires the
\CodeFmt{Point\_3} of the vertex item. \CodeFmt{Point\_3} serves
as the only geometry interface of the polyhedron in CSL.

There are three key behaviors in a subdivision: \emph{refinement}, 
\emph{smoothing} and \emph{stencil correspondence}. The refinement is
acted as a \CodeFmt{for\_each} algorithm on the source \emph{and} refined
polyhedron while applying the smoothing behaviors. CSL implement the
refinements as the host functions with the smoothing rules as the
policies. Some major refinement schemes are shown in 
\figurename\ \ref{fig:RefSchemes}. The refinements also define the
stencil correspondences as shown in \figurename\ \ref{fig:RefMap}.
These stencil correspondences specified the policy interface 
between the refinements and the smoothing.

%% \cgalpoly\ provides two
%% mechanisms to implement refinements as introduced in the previous
%% sections. The geometry smoothing is mixed with the refinement
%% in the previous examples and hence implicitly maintain
%% the stencil correspondence. CSL extracts the geometry smoothing
%% from the refinement as policies and maintain the stencil 
%% correspondence explicitly. 



%-----------------------------------------------------------------------
\subsubsection{Primal Quad Quadralization}
A subdivision algorithm in CSL is constructed as a
\emph{refinement function} parameterized with the 
\emph{geometry smoothing rules}. For example, Catmull-Clark
subdivision is instanciated as the PQQ scheme with
the Catmull-Clark geometry rules as following,
\begin{lstlisting}
void CatmullClark_subdivision(Polyhedron& p, int step = 1) {
  quad_quadralize_polyhedron(p, CatmullClark_rule<Polyhedron>(), step);
}
\end{lstlisting}

\CodeFmt{quad\_quadralize\_polyhedron} is the refinement host
that refines the control polyhedron using PQQ scheme. It also
applies the smoothing stencils provided by the geometry policy 
class, which in this example is the \CodeFmt{CatmullClark\_rule}.
\\
\noindent \textbf{Geometry policies} are represented as
the policy functions of the policy class. Each policy function
receive a primitve handle of the represented 1-ring submesh and
a reference of the smoothed point. A policy class for the PQQ
reifnement host looks like,
\begin{lstlisting}
template <class _Poly>
class quadralize_rule {
public:
  void face_point_rule(Facet_handle, Point&) {};
  void edge_point_rule(Halfedge_handle, Point&) {};
  void vertex_point_rule(Vertex_handle, Point&) {};
};
\end{lstlisting}
The interface of the geometry policies is defined according to
the stencil correspondence. The PQQ scheme contains three 
stencils (\figurename\ \ref{fig:RefMap} (a--c)) and each of them
defined a policy function, i.e.\ the \CodeFmt{facet\_rule()}, the 
\CodeFmt{edge\_rule()}, and the \CodeFmt{vertex\_rule()} 
respectively. Any customized policy class of the goemetry 
rules should provide the proper functions.
To assure the interface consistence, CSL provides
a geometry rule class for each refinement scheme. To create a new
geometry policy class, the class inheritance is used.
\begin{lstlisting}
template <class _Poly>
class CatmullClark_rule : public quadralize_rule<_Poly> {...}
\end{lstlisting}

In the refinement host, the smoothing point 
is generated by calling the policies. 
Inside each policy function, applying the 
stencil is simplified to the mesh traversal of a 
1-ring neighborhood which can be done with the 
circulators or a simple seqence of the adacency pointers 
of the haledges. The \CodeFmt{face\_point\_rule} for 
Catmull-Clark subdivision demonstrates the circulators. 
\begin{lstlisting}
  void face_point_rule(Facet_handle facet, Point& pt) {
    Halfedge_around_facet_circulator hcir = facet->facet_begin();
    int n = 0;
    Kernel::FT p[] = {0,0,0};
    do {
      Point t = hcir->vertex()->point();
      p[0] += t[0], p[1] += t[1], p[2] += t[2]; 
      ++n;
    } while (++hcir != facet->facet_begin());
    pt = Point(p[0]/n, p[1]/n, p[2]/n);
  }
\end{lstlisting}
The facet circulator provides a convenient way to
traverse and collect the points. The point calculation use
the covenetional interface \CodeFmt{[i]} of the point type. 
For \CodeFmt{Point} not equipped with
the \CodeFmt{[i]}, a customized policy class need to be 
provided. Though it should be an easy task as the example policy
shown. The CGAL \CodeFmt{Point\_3}/\CodeFmt{Vector\_3}
computation can be used if the \CodeFmt{Point} is the equvalent
type of \CodeFmt{Point\_3}. 
\begin{lstlisting}
  void face_point_rule(Facet_handle facet, Point& pt) {
    Halfedge_around_facet_circulator hcir = facet->facet_begin();
    Vector vec = hcir->vertex()->point() - CGAL::ORIGIN;
    ++hcir;
    do {
      vec = vec + hcir->vertex()->point();
    } while (++hcir != facet->facet_begin());
    pt = CGAL::ORIGIN + vec/circulator_size(hcir);
  }
\end{lstlisting}

The \CodeFmt{vertex\_point\_rule} for Catmull-Clark subdivision
is more complicated because more computations involved for smoothing.
The extra-ordinary vertex introduce dynamic weights of the vertex 
stencil. Nonetheless, the connectivity trversal is simplified into
a vertex circulation.  
\begin{lstlisting}
  void vertex_point_rule(Vertex_handle vertex, Point& pt) {
    Halfedge_around_vertex_circulator vcir = vertex->vertex_begin();
    int n = circulator_size(vcir);    

    float Q[] = {0.0, 0.0, 0.0}, R[] = {0.0, 0.0, 0.0};
    Point& S = vertex->point();
    
    Point q;
    for (int i = 0; i < n; i++, ++vcir) {
      Point& p2 = vcir->opposite()->vertex()->point();
      R[0] += (S[0]+p2[0])/2; R[1] += (S[1]+p2[1])/2; R[2] += (S[2]+p2[2])/2;
      face_point_rule(vcir->facet(), q);
      Q[0] += q[0]; Q[1] += q[1]; Q[2] += q[2];
    }
    R[0] /= n;    R[1] /= n;    R[2] /= n;
    Q[0] /= n;    Q[1] /= n;    Q[2] /= n;
      
    pt = Point((Q[0] + 2*R[0] + S[0]*(n-3))/n,
	       (Q[1] + 2*R[1] + S[1]*(n-3))/n,
	       (Q[2] + 2*R[2] + S[2]*(n-3))/n );
  }
\end{lstlisting}

The \CodeFmt{edge\_point\_rule} for Catmull-Clark subdivision
is an example that require the low lever halfedge traversal.
The \CodeFmt{edge->opposite()} is used to locate the
opposite point and the opposite facets. Instead of using 
the facet circulator for each facet, we let
the \CodeFmt{face\_point\_rule} to calculate the facet centroid.
\begin{lstlisting}
  void edge_point_rule(Halfedge_handle edge, Point& pt) {
    Point p1 = edge->vertex()->point();
    Point p2 = edge->opposite()->vertex()->point();
    Point f1, f2;
    face_point_rule(edge->facet(), f1);
    face_point_rule(edge->opposite()->facet(), f2);
    pt = Point((p1[0]+p2[0]+f1[0]+f2[0])/4,
	       (p1[1]+p2[1]+f1[1]+f2[1])/4,
	       (p1[2]+p2[2]+f1[2]+f2[2])/4 );
  }
\end{lstlisting}


\noindent \textbf{Connectivity refinement} is 
design as a host function that refines the control polyhedron,
maintains the stencil correspondence and assign the smoothed
point. The \CodeFmt{quad\_quadralize\_polyhedron} is the host
function for the PQQ scheme. It redirects 
the refinement by looping the \CodeFmt{quad\_quadralize\_1step}.
\begin{lstlisting}
template <template <typename> class RULE>
void quad_quadralize_polyhedron(Polyhedron& p, RULE<Polyhedron> rule, int step) {
  for (int i = 0; i < step; i++) quad_quadralize_1step(p, rule);
}
\end{lstlisting}
The \CodeFmt{quad\_quadralize\_1step} excutes one-step PQQ refinement
on the input control polyhedron. The refinement is implemented
based on a sequence of the Euler operations which is shown 
in \figurename\ \ref{fig:CCRefinement}.
\begin{lstlisting}
  // Build the connectifty using insert_vertex() and insert_edge()
  // 1. insert_vertex() to all edges and set them to new positions
  // 2. insert_edge() between 2 randomly selected neighboring new inserted 
  //    vertices
  // 3. insert_vertex() to the new inserted edge and set them to new positions
  // 4. insert_edge() between all other new inserted vetices of step 1 and
  //    the new inserted vertex of step 3  eitr = p.edges_begin();

  // step1
  for (int i = 0; i < num_edge; i++, ++eitr) {
    Vertex_handle vh = insert_vertex(p, eitr);
    vh->point() = edge_point_buffer[i];
  }
  fitr = p.facets_begin();
  for (int i = 0; i < num_facet; i++, ++fitr) {
    Halfedge_around_facet_circulator hcir_begin = fitr->facet_begin();
    Halfedge_around_facet_circulator hcir = hcir_begin;
    
    // step2
    Halfedge_handle e1 = ++hcir;
    ++hcir; 
    Halfedge_handle e2 = ++hcir;
    ++hcir; // Must move the cir before inserts the new edge !!
    Halfedge_handle newe = insert_edge(p, e1, e2);
    
    // step3
    Halfedge_handle newv = insert_vertex_return_edge(p, newe);
    newv = newv->opposite()->prev(); // change newv to the larger face and 
                                     // still points to the newly inserted 
                                     // vertex
    // Update the geometry data of the newly inserted face-vertices
    newv->vertex()->point() = face_point_buffer[i];
   
    // step4
    while (hcir != hcir_begin) {
      e1 = ++hcir;
      ++hcir; // Must move the cir before inserts the new edge !!
      insert_edge(p, e1, newv); 
    }
  }
  // Update the geometry data of the newly inserted vertices by the 
  // vertices buffer
  vitr = p.vertices_begin();
  for (int i = 0; i < num_vertex; i++, ++vitr) 
    vitr->point() = vertex_point_buffer[i];
\end{lstlisting}
The details of the step2 and step3 are shown in 
\figurename\ \ref{fig:CCRefinementStep23}. Note that the
\CodeFmt{insert\_vertex} and \CodeFmt{insert\_edge} are functions
composed of the Euler operators provided by \cgalpoly . 

\begin{figure}
  \centering 
  \psfrag{A}[]{step1}
  \psfrag{B}[]{step2}
  \psfrag{C}[]{step3}
  \psfrag{D}[]{step4}
  \epsfig{file=figs/CCRefinement.eps, width=10cm}
  \caption{A PQQ refinement of a facet is encoded into a sequence of
  vertex insertions and edge insertions. Red indicates the inserted
  vertices and edges in each step.}
  \label{fig:CCRefinement}
  \vspace{0.6cm}
  \epsfig{file=figs/CCRefinementStep23.eps, width=10cm}
  \caption{The Euler operations for the step2 and step3 of 
  the PQQ refinement.}
  \label{fig:CCRefinementStep23}
\end{figure}

The refinement host employs the gemoetry policies
to generate the smoothed point and applys them in the
proper vertives of the refined polyhedron. Three temporary
point buffers, \CodeFmt{vertex\_point\_buffer}, 
\CodeFmt{edge\_point\_buffer} and \CodeFmt{face\_point\_buffer}, 
are used in the connectivity refinement to
assign the smoothed point to the points on the refined
polyhedron. Since CSL is designed
to accept a customized \cgalpoly , item flags in the 
Quad-Triangle example is not an option here.
To maintain the stencil correspondence, CSL implicitly
records the storage position. Note \cgalpoly\ allocates new
geometry items by appending them at the end of the underlying
containers, in most cases the linked-list or the vector.
Hence, the storage order can be encoded as the order of
the allocations and able to used to distincish the
stencil correspondence, e.g.\ facet to vertex, edge to facet
of vertex to vertex in Catmull-Clark subdivision.
In other words, smoothed points are pre-generated 
from the geometry policies in the order of the vertex
creation in the refinement stage. 
\begin{lstlisting}
  // Build a new vertices buffer has the following structure
  //
  // 0 1 ... e_begin ... f_begin ... (end_of_buffer)
  // 0 ... e_begin-1       : store the positions of the vertex-vertices
  // e_begin ... f_begin-1 : store the positions of the edge-vertices
  // f_begin ... (end)     : store the positions of the face-vertices
  // The index of the vertices buffer should 1-1 map to the distance
  // of the corresponding iterator to the begin of the iterator.
  int num_vertex = p.size_of_vertices();
  int num_edge = p.size_of_halfedges()/2;
  int num_facet = p.size_of_facets();

  // If Polyhedron is using vector, we need to reserve the memory to prevent 
  // the CGAL_assertion.
  // This function for polyhedron using list is VOID.
  p.reserve(num_vertex+num_edge+num_facet, 4*2*num_edge, 4*num_edge/2);

  Point* vertex_point_buffer = new Point[num_vertex + num_edge + num_facet];
  Point* edge_point_buffer = vertex_point_buffer + num_vertex;
  Point* face_point_buffer = edge_point_buffer + num_edge;

  std::vector<bool> v_onborder(num_vertex);

  Facet_iterator fitr = p.facets_begin();
  for (int i = 0; i < num_facet; i++, ++fitr)
    rule.face_point_rule(fitr, face_point_buffer[i]);

  int sb = p.size_of_border_edges();

  Edge_iterator eitr = p.edges_begin();
  for (int i = 0; i < num_edge-sb; i++, ++eitr)
    rule.edge_point_rule(eitr, edge_point_buffer[i]);
  for (int i = num_edge-sb; i < num_edge; i++, ++eitr) {
    int v = std::distance(p.vertices_begin(), eitr->vertex());
    v_onborder[v] = true;
    rule.border_point_rule(eitr, edge_point_buffer[i], vertex_point_buffer[v]);
  }

  Vertex_iterator vitr = p.vertices_begin();
  for (int i = 0; i < num_vertex; i++, ++vitr)
    if (!v_onborder[i]) rule.vertex_point_rule(vitr, vertex_point_buffer[i]);
\end{lstlisting}

The border points usually have special stencil (usually degenerated from
2-variable to 1-variable) and hence we introduced a new policy ---
\CodeFmt{border\_point\_rule} --- in the geometry policy class.

The full list of the refinement host and the geometry policies can be 
found in the accompanying source code.

%-----------------------------------------------------------------------
\subsubsection{Dual Quad Quadralization}
\begin{lstlisting}
void DooSabin_subdivision(Polyhedron& p, int step = 1) {
  dualize_polyhedron(p, DooSabin_rule<Polyhedron>(), step);
}
\end{lstlisting}

The refinement functions, i.e.\ the \CodeFmt{quad\_quadralize\_polyhedron} 
and the \CodeFmt{dualize\_polyhedron}, 
refine the control mesh, maintain the correspondence between the 
control mesh and refined mesh, and apply the smoothing stencils 
provided by the policy class, i.e.\ the \CodeFmt{CatmullClark\_rule} 
and the \CodeFmt{DooSabin\_rule}. 

Some refinement schemes is not easy to devise a sequence
of the Euler operations. For example the Doo-Sabin subdivision.
Fot these schemes, the refinements are supported based on the
modifier callback mechanism (MCM). In the example of 
Quad-Triangle subdivision, MCM is used to devise 
customized Euler-like atomic operators.
In CSL, MCM is used to \emph{rebuild} the refinement
mesh based on simplified mesh data, e.g.\ facet-vertex index list.
The facet-vertex index list is build based on the encoded order
of the connectivity. It is demonstrated in the following code,

\begin{lstlisting}
template <template <typename> class RULE>
void dualize_polyhedron(Polyhedron& p, RULE<Polyhedron> rule, int step = 1) {
  for (int i = 0; i < step; ++i) dualize_1step(p, rule);
}
\end{lstlisting}


\begin{lstlisting}
template <class _P> template <template <typename> class RULE>
void Polyhedron_subdivision<_P>::dualize_1step(_P& p, RULE<_P> rule) {
  int num_v = p.size_of_vertices();
  int num_e = p.size_of_halfedges()/2;
  int num_f = p.size_of_facets();
  int num_facet = num_v + num_e + num_f;
  
  // init the buffer for the next level
  Point* point_buffer = new Point[num_e*2];
  int** facet_buffer = new int*[num_facet];
  for (int i = 0; i < num_facet; ++i) facet_buffer[i] = NULL;

  // build the point_buffer
  Halfedge_iterator he_itr = p.halfedges_begin(); 
  for (int i = 0; i < num_e*2; ++i, ++he_itr) {
    Halfedge_around_facet_circulator cir = he_itr->facet_begin();
    rule.point_rule(cir, point_buffer[i]);
  }

  // build the facet_buffer
  he_itr = p.halfedges_begin(); 
  Facet_iterator fitr = p.facets_begin();  
  for (int i = 0; i < num_f; ++i, ++fitr) {
    Halfedge_around_facet_circulator  cir = fitr->facet_begin();
    int n =  CGAL::circulator_size(cir); 
    facet_buffer[i] = new int[n+1];
    facet_buffer[i][0] = n;
    for (int j = 1; j < n+1; ++j, ++cir)
      facet_buffer[i][j] = 
	std::distance(he_itr, Halfedge_handle(cir.operator->())); 
  }
  Halfedge_iterator eitr = p.halfedges_begin();
  for (int i = num_f; i < num_f+num_e; ++i, ++eitr) {
    facet_buffer[i] = new int[4+1];
    facet_buffer[i][0] = 4;
    facet_buffer[i][1] = (i-num_f)*2;
    facet_buffer[i][2] = std::distance(he_itr, eitr->prev());    
    ++eitr;
    facet_buffer[i][3] = (i-num_f)*2+1; 
    facet_buffer[i][4] = std::distance(he_itr, eitr->prev());    
  }
  Vertex_iterator vitr = p.vertices_begin();
  for (int i = num_f+num_e; i < num_f+num_e+num_v; ++i, ++vitr) {
    Halfedge_around_vertex_circulator  cir = vitr->vertex_begin();
    int n =  CGAL::circulator_size(cir); 
    facet_buffer[i] = new int[n+1];
    facet_buffer[i][0] = n;

    for (int j = 1; j < n+1; ++j, --cir)
      facet_buffer[i][j] = 
	std::distance(he_itr, Halfedge_handle(cir.operator->())); 
  }
  
  p.clear();
  Polyhedron_memory_builder<Polyhedron> pb(num_e*2, point_buffer, 
					   num_f+num_e+num_v, facet_buffer);
  p.delegate(pb);
  
  // release the buffer of the new level
  for (int i = 0; i < num_facet; ++i) delete[] facet_buffer[i];
  delete[] facet_buffer;
  delete[] point_buffer;
}
\end{lstlisting}


\begin{lstlisting}
template <class _Poly>
class dualize_rule {
public:
  void point_rule(Halfedge_around_facet_circulator cir, Point& pt) {};
};
template <class _Poly>
class DooSabin_rule : public dualize_rule<_Poly> {
public:
  void point_rule(Halfedge_around_facet_circulator cir, Point& pt) {
    int n =  CGAL::circulator_size(cir); 

    Vector cv(0,0,0), t;
    if (n == 4) {
      cv = cv + (cir->vertex()->point()-CGAL::ORIGIN)*9;
      cv = cv + ((++cir)->vertex()->point()-CGAL::ORIGIN)*3;
      cv = cv + ((++cir)->vertex()->point()-CGAL::ORIGIN);
      cv = cv + ((++cir)->vertex()->point()-CGAL::ORIGIN)*3;
      cv = cv/16;
    } else {
      double a;
      for (int k = 0; k < n; ++k, ++cir) {
	if (k == 0) a = ((double)5/n) + 1;
	else a = (3+2*std::cos(2*k*3.141593/n))/n;
	cv = cv + (cir->vertex()->point()-CGAL::ORIGIN)*a;
      }
      cv = cv/4;
    }
    pt = CGAL::ORIGIN + cv;
  }
};
\end{lstlisting}




%-----------------------------------------------------------------------
\subsubsection{CSL}
This policy-based approach offers a convenient way to
specialize a subdivision with the template smoothing rules.
CSL currently supports Catmull-Clark, 
Loop, Doo-Sabin, $\sqrt{3}$ and Quad-Triangle
subdivisions. %(\figurename\ \ref{fig:subzoo}).
Though demonstrated with a specific enriched \poly\ in our 
polyhedron viewer, CSL accepts any polyhedron mesh specialized 
from the \poly\ with the \CodeFmt{Point} type defined in the vertex.  
Subdivisions in CSL are build as proper combinations of the
refinement functions and the geometry policy classes.
The proper combination is constrained by the stencil correspondence.

Current version of CSL only supports the geometry modification 
of the vertex (hence only the isotrophic subdivision). Boundary
can be easily supported by introducing the boundary policy. But
for anisotrophic subdivisions (e.g.\ Pixar's crease rules), data
modifications of the halfedge are required. It can be done by 
introduce halfedge policy, though a much complex structures
is need in the refinement host.


\begin{lstlisting}
  template <template <typename> class RULE>
  static void quad_quadralize_1step(Polyhedron& p, RULE<Polyhedron> rule);
  template <template <typename> class RULE>
  static void tri_quadralize_1step(Polyhedron& p, RULE<Polyhedron> rule);
  template <template <typename> class RULE>
  static void dualize_1step(Polyhedron& p, RULE<Polyhedron> rule);
\end{lstlisting}


