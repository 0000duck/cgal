% Related work and background

% C++ and generic programming
\noindent \textbf{CGAL and generic programming paradigm.}
Before using CGAL, it is mandatory to be familiar with C++,
\emph{design patterns} and the \emph{generic programming paradigm}. 
Design patterns \cite{Gamma:1995:DP} describe successful and
\emph{reusable} solutions to standard software problems. The generic
programming paradigm \cite{Alexandrescu:2001:MCD} features the notion
of C++ class templates and function templates, which is at the corner
stone of all features provided by CGAL. 

The generic programming paradigm provides a
soft-coupled framework to support data structures and algorithms. 
It focuses on representing families of the data structures 
or the algorithms by identifying 
the \emph{abstract representations}.
With the \CC\ template, the standard template library
\cite{ms-stl-96} (STL) is the pioneer library based on
the generic programming paradigm. The STL provides a set of 
data structure families (or containers), such as vectors, 
lists and trees, and a set of generic algorithms 
that can be dynamicly coupled with a container. In general, 
the abstract representation of a data structure family
is the \emph{entity type} and of an algorithm family
is the \emph{operation type}. 
%For example are the entity sorting and searching where users
%supply the equality predicates to specialize the algorithms.  
To soft couple the containers and the algorithms, STL 
use the \italic{iterator} concept to be the interface.
An iterator allows both referring to an enitity (as a \CC\ pointer) 
and visiting a sequence of entities in the container.
The STL frees software engineers from rebuilding the fundamental 
data structures and let them focus on the design of the algorithms.
Since CGAL is strongly inspired
from the generality of STL, it is important to become familiar with
its concepts before starting using it.

\noindent \textbf{Geometry data structures.}
A polyhedral mesh consists the adjacency relationships
among a set of primitives, i.e.\ vertices, edges and 
facets. A polyhedron data structure describes 
the adjacency relationships and the storage of the
primitives. Several different data structures
of polyhedral meshes are proposed in the past.
Most prominent of them are the so-called
edge-based data structures 
\cite{Weiler:1985:EDS,Baumgart:1975:PRCV,Guibas:1983:PMG}.
Edge-based data structures highlight the
adjacency relationships among the edges
and link the incidental vertices and facets
by the stored pointers. Edge-based data structures
are commonly used and allow for maximal flexibility.
Among them, the \emph{halfedge data structure} is the most
commonly used. 

\input hds

OpenMesh \cite{Botsch:2002:OPENMESH} is ...

\noindent \textbf{Geometry algorithms.}
Subdivision surfaces \cite{cc,ds,loop,sqrt3,qts}
is the limit surface resulted from the
application of a subdivision algorithm to a control polyhedron.
Subdivision algorithms recursively \emph{refine} (subdivide) the
control polyhedron and \emph{modify} (smooth) the geometry according
to the stencils of the source mesh.  
%Subdivisions consist of two
%meta-steps that most geometry processing algorithms have: the
%\emph{connectivity operation} and the
%\emph{geometry operation}. In this paper, we use subdivision
%as the template of the geometry processing algorithms because it
%connectivity operations are more complex than most other
%algorithms. Some other simple algorithms, e.g.\ displacement map, the
%connectivity operation is a null operation. In other words, the source
%and the target mesh have the same connectivity.
Further details on subdivisions can be found at \cite{Sub:course:2000}
and \cite{Warren:subdivision}. The OpenMesh library has
supports of Loop and $\sqrt{3}$ subdivisions \cite{Abhijit:2004:APISUB}.
