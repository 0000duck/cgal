% +------------------------------------------------------------------------+
% | Reference manual page: Point_container.tex
% +------------------------------------------------------------------------+
% | 1.07.2001   Johan W.H. Tangelder
% | Package: ASPAS
% |
\RCSdef{\RCSPointcontainerRev}{$Revision$}
\RCSdefDate{\RCSPointcontainerDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Point_container<PointTraits>}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries


\begin{ccAdvanced}


\ccDefinition
A custom container for points used to build a tree. Each point container
holds the points from a rectangle associated with a node of the tree.
In the remainder of this reference page this rectangle is called the
associated rectangle.
Provides a method to split a container and a number of methods
to support the implementation of splitting rules.

\ccInclude{CGAL/Point_container.h}

\ccParameters
xpects for the  template argument
an implementation for
$d$-dimensional points of
the concept \ccc{PointTraits}, 
for example \ccc{CGAL::Kd_tree_traits_point_d< Cartesian_d<double> >}.

\ccTypes

\ccTypedef{PointTraits::NT NT;}{Number type.}
\ccTypedef{PointTraits::Point Point;}{Point type.}
\ccNestedType{iterator;}{An iterator with value type \ccc{Point*}.}

%----------------------------------------
\ccCreation
\ccCreationVariable{c}

\ccConstructor{Point_container(int d);}
{
Construct an empty container for storing \ccc{d}-dimensional points.
}

\ccConstructor{
template <class InputIterator>
Point_container(int d, InputIterator begin, InputIterator end);}
{
Construct the container of $d$-dimensional points of type \ccc{Point}
given by the iterator sequence \ccc{[begin, end)}.
}



\ccOperations

\ccMethod{template <class SpatialSeparator>
void split(Point_container<PointTraits> &C, SpatialSeparator sep, bool sliding=false);}
{Given an empty container \ccc{C} with the same dimension as \ccc{c}, splits \ccc{c} into
\ccc{c} and \ccc{C} using the separator \ccc{sep}. If sliding is true after splitting 
each container contains at least one point. \ccc{c} should contain at least two points.}


\ccMethod{void swap(Point_container<SpatialPoint> &C);}
{Swap the contents of \ccc{c} and \ccc{C}}


\ccMethod{void recompute_tight_bounding_box();}
{Recompute the bounding box of the points in the container.}


\ccMethod{iterator begin();}
{
Return an iterator pointing to the pointer to the first point.
}

\ccMethod{iterator end();}
{
Return the iterator to the corresponding past-the-end iterator.
}

\ccMethod{int dimension() const;}
{
Return the dimension.
}

\ccMethod{int built_coordinate();}
{
Return coordinate for which the pointer list is built.
}

\ccMethod{int max_span_coord();}
{
Return coordinate where the associated rectangle has maximal span.
}

\ccMethod{int max_tight_span_coord();}
{
Return coordinate where the point coordinates have maximal span.
}

\ccMethod{NT max_span_lower();}
{
Return lower value of the interval corresponding to
\ccc{max_span_coord()}.
}


\ccMethod{NT max_tight_span_lower();}
{
Return lower value of the interval corresponding to
\ccc{max_tight_span_coord()}. That is, the smallest
\ccc{max_tight_span_coord()}-th coordinate of the points in
\ccc{c}.
}


\ccMethod{NT max_span_upper();}
{
Return upper value of the interval corresponding to
\ccc{max_span_coord()}.
}

\ccMethod{NT max_span_upper_without_dim(int d);}
{
Return upper value of the interval over all dimensions
without taking dimension \ccc{d} into account.
}

\ccMethod{NT max_tight_span_upper();}
{
Return upper value of the interval corresponding to
\ccc{max_tight_span_coord()}.
}

\ccMethod{NT  max_spread();}
{
Return the size of the interval corresponding to \ccc{max_span_coord()}.
}

\ccMethod{NT max_tight_spread();}
{
Return the size of the interval corresponding to \ccc{max_tight_span_coord()}.
}

\ccMethod{NT median(int split_coord);}
{
Return the median value of the points stored in the container for
dimension \ccc{split_coord}.
}

\ccMethod{const Kd_tree_rectangle<PointTraits> & bounding_box();}
{Return the associated rectangle.}

\ccMethod{const Kd_tree_rectangle<PointTraits> & tight_bounding_box();}
{Return the bounding box of the items in associated rectangle.}

\ccMethod{int max_tight_span_coord_balanced(NT aspect_ratio);}
{Return the dimension with the maximal point spread, for which after fair splitting
the ratio of the length of the longest side and the smallest side of the bounding box of
the items in associated rectangle,
does not exceed \ccc{aspect_ratio}.}

\ccMethod{NT balanced_fair(int d, NT aspect_ratio);}
{Return the splitting value for fair splitting.}

\ccMethod{NT balanced_sliding_fair(int d, NT aspect_ratio);}
{Return the splitting value for sliding fair splitting.}

\ccMethod{int size();}
{
Return the number of points stored.
}

\ccMethod{bool empty();}
{
Return true if no points are present, false otherwise.
}




\ccHeading{Output Routines}

\ccGlobalFunction{ template<class PointTraits>
std::ostream& operator<<(std::ostream& s, Point_container<PointTraits> c);}
{Prints the point container \ccc{c} to the output stream \ccc{s} and returns \ccc{s}.}


\ccSeeAlso

\ccc{PointTraits},\\
\ccc{SpatialSeparator},\\
\ccc{PointContainer}.

\end{ccAdvanced}
\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

