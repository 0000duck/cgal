% +------------------------------------------------------------------------+
% | Reference manual page: SweepLineTraits_2.tex
% +------------------------------------------------------------------------+
% | 17.02.2002   Author
% | Package: Sweep_line_2
% | 
\RCSdef{\RCSSweepLineTraitsRev}{$Revision$}
\RCSdefDate{\RCSSweepLineTraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{SweepLineTraits_2}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
A model of the concept \ccRefName\ aggregates the geometric types and
primitive operations used by the sweep line functions.

%\ccGeneralizes

\ccTypes

  A class \ccClassTemplateName\ that satisfies the requirements of an
  interface class for a planar map class must provide the following types
  and operations. 

  \ccNestedType{Curve_2}{A type that holds a general curve in the plane. The
  sweep-line operation operates on curves of this type.}
  \ccNestedType{X_curve_2}{A type that holds an $x$-monotone curve in the
  plane. Sweeping the plane produces $x$-monotone curves.}
  \ccNestedType{Point_2}{A type that holds the position of a vertex in
  the plane. The type of the end points of curves of type \ccc{Curve_2} and
  \ccc{X_curve_2}.}
  
  The following methods that have a parameter of type \ccc{X_curve_2} have the
  implicit precondition that requires the parameter to be $x$-monotone.

\ccHeading{Enumerations}

  \ccEnum{enum Comparison_result {SMALLER, EQUAL, LARGER};}
  {a constant describing the relative position between objects.}

\ccCreation
    
% Only a default constructor is required. Note that further constructors
% can be provided.

  \ccConstructor{Traits();}
  {A default constructor.}

\ccCreationVariable{tr} 

\ccOperations

  \ccMethod{Comparison_result compare_x(const Point_2& p0,
                                        const Point_2& p1);}
  {compares the \ccStyle{x}-coordinates of $p0$ and $p1$.  Returns
  \ccStyle{LARGER} if $x(p0) > x(p1)$; \ccStyle{SMALLER} if $x(p0) < x(p1)$;
  \ccStyle{EQUAL} otherwise.}
    
  \ccMethod{Comparison_result compare_xy(const Point_2& p0,
                                         const Point_2& p1);}
  {compares lexigoraphically the two points $p0$ and $p1$ by their
  \ccStyle{x}-coordinates, then by their \ccStyle{y}-coordinates.
  Returns \ccStyle{LARGER} if $x(p1) > x(p2)$, or if
  $x(p1) = x(p2)$ and $y(p1) > y(p2)$;
  \ccStyle{SMALLER} if $x(p1) < x(p2)$, or if $x(p1) = x(p2)$ and
  $y(p1) < y(p2)$;
  \ccStyle{EQUAL} otherwise.}

  \ccMethod{bool curve_is_vertical(const X_curve_2& cv);} 
  {returns \ccStyle{true} if \ccStyle{cv} is a vertical segment, 
  \ccStyle{false} otherwise.}

  \ccMethod{bool curve_is_in_x_range( const X_curve_2& cv,
            const Point_2& pnt );}
  {returns \ccStyle{true} if \ccStyle{pnt} is in the $x$ range of
  \ccStyle{cv}, \ccStyle{false} otherwise.}
    
  \ccMethod{Comparison_result curve_compare_at_x(const X_curve_2& cv1,
            const X_curve_2& cv2, const Point_2& pnt );}
  {compares the $y$-coordinate of $cv1$ and $cv2$ at the $x$-coordinate 
  of $pnt$. Returns \ccStyle{LARGER} if $cv1(x(q)) > cv2(x(q))$;
  \ccStyle{SMALLER} if $cv1(x(q)) < cv2(x(q))$; \ccStyle{EQUAL} otherwise.
  \ccPrecond{$cv1$ and $cv2$ are defined at $pnt$'s $x$-coordinate.}}

  \ccMethod{Comparison_result curve_compare_at_x_right(const X_curve_2& cv1,
            const X_curve_2& cv2, const Point_2& pnt);}
  {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the right of
  the $x$-coordinate of $pnt$.
  \ccPrecond{$cv1$ and $cv2$ meet at $pnt$ $x$-coordinate.}
  \ccPrecond{$cv1$ and $cv2$ are defined to the left of $pnt$'s
  $x$-coordinate.}}

  \ccMethod{Comparison_result curve_get_point_status(const X_curve_2& cv,
            const Point_2& pnt);}
  {compares the y-coordinates of $pnt$ and the vertical projection of $pnt$
  on $cv$. Returns \ccStyle{SMALLER} if $cv(x(p)) < y(p)$; \ccStyle{LARGER}
  if $cv(x(p)) > y(p)$; \ccStyle{EQUAL} otherwise (p is on the curve).
  \ccPrecond{$cv$ is defined at $pnt$'s $x$-coordinate.}}
          
  \ccMethod{bool curve_is_same(const X_curve_2 & cv1,
                               const X_curve_2 & cv2);}
  {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} have the same graph, 
  \ccc{false} otherwise.}

  \ccMethod{bool point_is_same(const Point_2 & p1,
                               const Point_2 & p2);}
  {returns \ccc{true} if \ccc{p1} is the same as \ccc{p2}, \ccc{false}
  otherwise.}
    
%construction function
%---------------------   

  \ccMethod{Point curve_source(const X_curve& cv);}
  {returns the source of \ccc{cv}.}

  \ccMethod{Point curve_target(const X_curve& cv);}
  {returns the target of \ccc{cv}.}

  \ccMethod{void make_x_monotone(const Curve& cv, list<X_curve>& l);}
  {cuts \ccc{cv} into $x$-monotone subcurves and stores them in $l$.
  The order in which they are inserted into $l$ defines their order
  in the hierarchy tree.}

  \ccMethod{void curve_split(const X_curve_2& cv, X_curve_2& c1, X_curve_2& c2,
                             const Point_2& split_pt);}
  {splits $cv$ at \ccc{split_pt} into two curves, and assigns them to
  \ccc{c1} and \ccc{c2} respectively.
  \ccPrecond{\ccc{split_pt} is on \ccc{cv} but is not an endpoint.}}

  \ccMethod{bool nearest_intersection_to_right(const X_curve& c1,
                                               const X_curve& c2,
                                               const Point& pt,
                                               Point& p1, Point& p2);}
  {finds the nearest intersection point (or points) of \ccc{c1} and \ccc{c2}
  to the right lexicographically of \ccc{pt} not includin \ccc{pt} itself,
  (with one exception explained below).
  If the intersection of \ccc{c1} and \ccc{c2} is an \ccc{X_curve_2}, that is,
  they overlap at infinitely many points, then if the right endpoint and the
  left endpoint of the overlapping subcurve are strickly to the right of \
  \ccc{pt}, they are returned through the two point references \ccc{p1} and
  \ccc{p2} respectively. If \ccc{pt} is between the overlapping-subcurve
  endpoints, or \ccc{pt} is its left endpoint, \ccc{pt} and the right endpoint
  of the subcurve are returned through \ccc{p1} and \ccc{p2} respectively. If
  the intersection of the two curves is a point to the right of \ccc{pt}, it
  is returned through \ccc{p1} and \ccc{p2}.
  Returns \ccc{true} if \ccc{c1} and \ccc{c2} do intersect to the right of
  \ccc{pt}, \ccc{false} otherwise.}

  \ccMethod{bool curves_overlap(const X_curve& cv1, const X_curve& cv2);}
  {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} overlap in a one-dimensional
  subcurve (i.e., not in a finite number of points), \ccc{false} otherwise.}

\ccHasModels
  \ccc{Arr_segment_traits_2<R>}\\
  \ccc{Arr_segment_cached_traits_2<R>}\\
  \ccc{Arr_circles_real_traits<NT>}\\
  \ccc{Arr_polyline_traits<R, Container>} \\
  \ccc{Arr_segment_circle_traits<NT>}

  Note that the concept ArrangementTraits\_2 is a refinement of the 
  concept \ccRefName\ so each model of the former is a model of the latter.

\ccSeeAlso

\ccc{CGAL::Sweep_line_2}


% \ccExample

% A short example program.
% Instead of a short program fragment, a full running program can be
% included using the 
% \verb|\ccIncludeExampleCode{examples/Sweep_line_2/SweepLineTraits_2_prog.C}| 
% macro. The program example would be part of the source code distribution and
% also part of the automatic test suite.

% \begin{ccExampleCode}
% void your_example_code() {
% }
% \end{ccExampleCode}

%% \ccIncludeExampleCode{examples/Sweep_line_2/SweepLineTraits_2_prog.C}

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

