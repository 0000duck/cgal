% +------------------------------------------------------------------------+
% | Reference manual page: sweep_to_produce_points_2.tex
% +------------------------------------------------------------------------+
% | 17.02.2002   Author
% | Package: Sweep_line_2
% | 
\RCSdef{\RCSsweeptoproducepointsRev}{$Revision$}
\RCSdefDate{\RCSsweeptoproducepointsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefFunction}{sweep_to_produce_points_2}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[function]{} %% add further index entries

\ccDefinition
  
The function \ccRefName\ generates the set of intersection points of a
given set of input curves. It is also possible to ask the function to
include the endpoints of the input curves within the output.
Non $x$-monotone curves are split into $x$-monotone portions using the \ccc{make_x_monotone} 
function of \ccc{SweepLineTraits_2}. The spliting points are treated as new endpoints rather than 
intersection points.

\ccInclude{sweep_to_produce_points_2.h}

\ccFunction{
   template<class InputIterator, class SweepLineTraits_2, class OutputIterator>
   void 
   sweep_to_produce_points_2(InputIterator curves_begin, 
   InputIterator curves_end,  
   SweepLineTraits_2& traits, 
   OutputIterator points,
   bool endpoints = true);}
   {reports all intersections induced by the arrangement of the curves
   given in the range \ccStyle{[curves_begin, curves_end)}. The
   parameter \ccStyle{points} is an inserter iterator which 
   will eventually point to all the reported intersection points. 
   \ccc{sweep_to_produce_points_2} supports
   curves which are interior intersect, overlap or non x-monotone, and
   hence users may provide their input curves without any
   restriction of the kind mentioned above. 
   Users may obtain the input points in addition to the intersection 
   by setting the flag \ccStyle{endpoints} to true. 
   The default choice provides this first possibility. 
   Notice that if the input curves are not $x$-monotone, their splitting points 
   to $x$-monotone curves are treated as new endpoints points, and hence 
   when setting \ccStyle{endpoints} to false, this new endpoints are not part 
   of the output.}

\ccHeading{Requirements}
\begin{enumerate}
   \item    \ccc{InputIterator::value_type} is equivalent to \ccc{Traits::Curve_2}.
   \item    \ccc{SweepLineTraits_2} is a model of the \ccc{SweepLineTraits_2} concept
   \item    \ccc{InputIterator::value_type} is equivalent to \ccc{Traits::Point_2}..
\end{enumerate}


\ccSeeAlso
\ccc{CGAL::sweep_to_construct_planar_map_2} \\
\ccc{CGAL::sweep_to_produce_subcurves_2} \\
\ccc{CGAL::sweep_do_curves_intersect_2} \\
\ccc{CGAL::sweep_to_report_intersecting_curves_2}

% \ccImplementation
% The implementation uses the container $map$ defined in STL for
% implementing the event queue and the status line.  The implementation
% also keeps per each input curve an associated container of all its
% intersection points ordered from left to right, and also keeps per
% each event point all its outcoming curves.  The complexity of this
% algorithm is $O(n\log{n} + k\log{n})$ where $n$ is the number of the 
% input curves and $k$ is the number of intersection points 
% induced by these curves.

\ccIncludeExampleCode{Sweep_line_2/example5.C}

And the output of the program looks like this:

\ccIncludeExampleCode{Sweep_line_2/example5.cout}

\end{ccRefFunction}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+









