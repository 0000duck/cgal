% +------------------------------------------------------------------------+
% | Reference manual page: sweep_to_produce_subcurves_2.tex
% +------------------------------------------------------------------------+
% | 17.02.2002   Author
% | Package: Sweep_line_2
% | 
\RCSdef{\RCSsweeptoproducesubcurvesRev}{$Revision$}
\RCSdefDate{\RCSsweeptoproducesubcurvesDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefFunction}[CGAL::]{sweep_to_produce_subcurves_2}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[function]{} %% add further index entries

\ccDefinition

The function \ccRefName\ generates the set of interior disjoint
subcurves induced by the given set of input curves. It is also
possible to ask the function to include the each overlapping subcurve
as many times as it is covered by input curves.

\def\ccLongParamLayout{\ccTrue} 

\ccFunction{
   template <class Curve_iterator, class Traits, class Container>
   void 
   sweep_to_produce_planar_map_subcurves(
   Curve_iterator curves_begin, 
   Curve_iterator curves_end, 
   Traits& traits, 
   Container &subcurves, 
   bool overlapping = false);}
   {reports all the disjoint interior subcurves induced by the curves
   given in the range \ccStyle{[curves_begin, curves_end)}. The
   parameter \ccStyle{subcurves} is a container which will evantually
   hold all the reported
   subcurves. \ccc{sweep_to_produce_planar_map_subcurve} supports
   curves which are interior intersect, overlap or non x-monotone, and
   hence the user may provide his curves as input without any
   resriction of the kind mentioned above. When providing overlapping
   curves as input users can make a choice by the boolean parameter
   \ccStyle{overlapping} whether the output they will get will contain
   each overlapping subcurve only once or that the reported subcurves
   will have each overlapping subcurve per each original curve it
   created of. The default choice provides the first possibility.}

\ccSeeAlso

\ccc{CGAL::sweep_to_construct_planar_map_2} \\
\ccc{CGAL::sweep_to_produce_points_2}

\ccImplementation 

The implementation uses the container $map$ defined in STL for
implementing the event queue and the status line.  The implementation
also keeps per each input curve an associated container of all its
intersection points ordered from left to right, and also keeps per
each event point all its outcoming curves.  The complexity of this
algorithm is $O(nlogn + k)$ where $n$ is the number of the input
curves and $k$ is the number of intersection points induced by these
curves.

\ccExample
\label{ssec:example3_sweep}
The following example is a demonstration of the usage of the \ccc
{Sweep line} algorithm. In this example we shall present the usage of
the sweep line technique when inserting the resulting disjoint
interior subcurves to a container. The input segments are just like as
in ~\ref{ssec:example1_sweep} , and the result we are interested with
is only reporting the sub segments obtained by the \ccc{Sweep line}
algorithm.

\ccIncludeExampleCode{Sweep_line/example3.C}

And the output of the program looks like this:

\ccIncludeExampleCode{Sweep_line/example3.cout}

\end{ccRefFunction}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

