% +------------------------------------------------------------------------+
% | Reference manual page: SweepLineTraits_2.tex
% +------------------------------------------------------------------------+
% | 17.02.2002   Author
% | Package: Sweep_line_2
% | 
\RCSdef{\RCSSweepLineTraitsRev}{$Revision$}
\RCSdefDate{\RCSSweepLineTraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{SweepLineTraits_2}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
A model of the concept \ccRefName\ aggregates the geometric types and
primitive operations used by the
\ccc{Sweep_line_2<CurveInputIterator,SweepLineTraits_2>}
data structure.

%\ccGeneralizes

\ccTypes

The geometric types defined below must have a default constructor,
copy constructor, and assignment operator.
    
\ccNestedType{X_monotone_curve_2}{A type that holds an $x$-monotone curve in
  the plane.}

\ccNestedType{Point_2}{A type that holds the position of a vertex in
  the plane. The type of the end points of \ccc{X_monotone_curve_2} curves.}

\ccNestedType{Curve_2}{A type that holds a general curve in the plane.
  Its endpoints must be of type \ccc{Point_2}.
  Curves of type either \ccc{X_monotone_curve_2} or \ccc{Curve_2} can be
  inserted into a \ccc{Planar_map_with_intersections_2<Dcel,Traits>} object.}

\ccCreationVariable{tr} 

\ccOperations

\ccMethod{Comparison_result compare_x(const Point_2& p0, const Point_2& p1);}
         {compares the \ccStyle{x}-coordinates of $p0$ and $p1$.  Returns
          \ccStyle{LARGER} if $x(p0) > x(p1)$; \ccStyle{SMALLER} if
	  $x(p0) < x(p1)$; \ccStyle{EQUAL} otherwise.}
    
\ccMethod{Comparison_result compare_xy(const Point_2& p0, const Point_2& p1);}
	 {compares the two points $p0$ and $p1$ lexigoraphically. First the
	   $x$-coordinates are compared. In case of a tie, the $y$-coordinates
	   are compared. Returns \ccStyle{LARGER} if $x(p1) > x(p2)$, or if
	   $x(p1) = x(p2)$ and $y(p1) > y(p2)$;
	   \ccStyle{SMALLER} if $x(p1) < x(p2)$, or if $x(p1) = x(p2)$ and
	   $y(p1) < y(p2)$;
	   \ccStyle{EQUAL} otherwise.}

\ccMethod{bool curve_is_vertical(const X_monotone_curve_2& cv);} 
         {returns \ccStyle{true} if \ccStyle{cv} is a vertical segment, 
          \ccStyle{false} otherwise.}
        
\ccMethod{bool point_in_x_range(const X_monotone_curve_2& cv,
                                const Point_2& pnt );}
         {returns \ccStyle{true} if \ccStyle{pnt} is in the $x$ range of
          \ccStyle{cv}, \ccStyle{false} otherwise.}
    
\ccMethod{Comparison_result curves_compare_y_at_x(const X_monotone_curve_2& cv1,
                                                  const X_monotone_curve_2& cv2,
						  const Point_2& pnt );}
         {compares the $y$-coordinate of $cv1$ and $cv2$ at the $x$-coordinate 
          of $pnt$. Returns \ccStyle{LARGER} if $cv1(x(q)) > cv2(x(q))$;
          \ccStyle{SMALLER} if $cv1(x(q)) < cv2(x(q))$; \ccStyle{EQUAL}
	  otherwise.
          \ccPrecond{$cv1$ and $cv2$ are defined at $pnt$'s $x$-coordinate.}}

\ccMethod{Comparison_result
  curves_compare_y_at_x_right(const X_monotone_curve_2& cv1,
                              const X_monotone_curve_2& cv2,
			      const Point_2& pnt);}
         {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the
	   right of the $x$-coordinate of $pnt$.
           \ccPrecond{$cv1$ and $cv2$ meet at $pnt$ $x$-coordinate.}
           \ccPrecond{$cv1$ and $cv2$ are defined to the left of $pnt$'s
             $x$-coordinate.}}
    
\ccMethod{Comparison_result curve_compare_y_at_x(const Point_2& pnt,
                                                 const X_monotone_curve_2& cv);}
         {compares the $y$-coordinates of $pnt$ and the vertical projection of
	   $pnt$ on $cv$. Returns \ccStyle{SMALLER} if $y(p) < cv(x(p))$;
	   \ccStyle{LARGER} if $y(p) > cv(x(p))$;
	   \ccStyle{EQUAL} otherwise (p is on the curve).
           \ccPrecond{$cv$ is defined at $pnt$'s $x$-coordinate.}}

\ccMethod{bool curve_equal(const X_monotone_curve_2 & cv1,
                           const X_monotone_curve_2 & cv2);}
         {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} have the same graph, 
           \ccc{false} otherwise.}

\ccMethod{bool point_equal(const Point_2 & p1, const Point_2 & p2);}
         {returns \ccc{true} if \ccc{p1} is the same as \ccc{p2}, \ccc{false}
           otherwise.}

\ccMethod{bool curves_overlap(const X_monotone_curve_2& cv1,
                              const X_monotone_curve_2& cv2);}
         {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} overlap
          in a one-dimensional subcurve (i.e., non countable and non infinite
	  number of points), \ccc{false}. otherwise.}

%construction function
%---------------------   

\ccMethod{Point_2 curve_source(const X_monotone_curve_2& cv);}
         {returns the source of \ccc{cv}.}

\ccMethod{Point_2 curve_target(const X_monotone_curve_2& cv);}
             {returns the target of \ccc{cv}.}

\ccMethod{template<class OutputIterator>
          OutputIterator make_x_monotone(const Curve_2& cv,
                                         OutputIterator res);}
	 {cuts \ccc{cv} into $x$-monotone subcurves and stores them in a
	   sequence starting at \ccc{res}. The order in which they are stored
	   defines their order in the hierarchy tree. Returns past-the-end
	   iterator of the sequence.}

\ccMethod{void curve_split(const X_monotone_curve_2& cv,
                           X_monotone_curve_2& c1, X_monotone_curve_2& c2,
                           const Point_2& split_pt);}
         {splits $cv$ at \ccc{split_pt} into two curves, and assigns them to
           \ccc{c1} and \ccc{c2} respectively.
           \ccPrecond{\ccc{split_pt} is on \ccc{cv} but is not one of its
	     endpoint.}}

\ccMethod{bool nearest_intersection_to_right(const X_monotone_curve_2& c1,
                                             const X_monotone_curve_2& c2,
                                             const Point_2& pt,
                                             Point_2& p1, Point_2& p2);}
	 {finds the nearest intersection point (or points) of \ccc{c1} and
	   \ccc{c2} lexicographically to the right of \ccc{pt} not including
	   \ccc{pt} itself, (with one exception explained below).
	   If the intersection of \ccc{c1} and \ccc{c2} is an
	   \ccc{X_monotone_curve_2}, that is, they overlap at infinitely many
	   points, then if the right endpoint and the left endpoint of the
	   overlapping subcurve are strictly to the right of \ccc{pt}, they are
	   returned through the two point references \ccc{p1} and \ccc{p2}
	   respectively. If \ccc{pt} is between the overlapping-subcurve
	   endpoints, or \ccc{pt} is its left endpoint, \ccc{pt} and the right
	   endpoint of the subcurve are returned through \ccc{p1} and \ccc{p2}
	   respectively. If the intersection of the two curves is a point to the
	   right of \ccc{pt}, it is returned through \ccc{p1} and \ccc{p2}.
	   Returns \ccc{true} if \ccc{c1} and \ccc{c2} do intersect to the right
	   of \ccc{pt}, \ccc{false} otherwise.}

\ccHasModels
  \ccc{Arr_segment_traits_2<Kernel>}\\
  \ccc{Arr_segment_cached_traits_2<Kernel>}\\
  \ccc{Arr_leda_segment_traits_2<Kernel>}\\
  \ccc{Arr_polyline_traits<Kernel, Container>} \\
  \ccc{Arr_leda_polyline_traits<Kernel, Container>} \\
  \ccc{Arr_conic_traits_2<Kernel>}

  Note that the concept ArrangementTraits\_2 is a refinement of the 
  concept \ccRefName\ so each model of the former is a model of the latter.

\ccSeeAlso

\ccc{CGAL::Sweep_line_2}

\end{ccRefConcept}

