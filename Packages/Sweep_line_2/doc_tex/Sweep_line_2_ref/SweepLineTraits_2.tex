% +------------------------------------------------------------------------+
% | Reference manual page: SweepLineTraits_2.tex
% +------------------------------------------------------------------------+
% | 17.02.2002   Author
% | Package: Sweep_line_2
% | 
\RCSdef{\RCSSweepLineTraitsRev}{$Revision$}
\RCSdefDate{\RCSSweepLineTraitsDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{SweepLineTraits_2}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
A model of the concept \ccRefName\ aggregates the geometric types and
primitive operations used by the sweep line functions.

%\ccGeneralizes

\ccTypes

  \ccNestedType{Point_2}{The point type for the endpoints of the curves. }
  \ccNestedType{X_curve_2}{The x-montone curve type}
  \ccNestedType{Curve_2}{The curve type on which the sweep line functions
                         operates.}

  The curve type \ccc{Curve_2} should be {\it syntactically} identical
  to the \ccc{X_curve_2} type (i.e., it should {\em be} the same
  type).  However, {\it semantically} it differs from the
  \ccc{X_curve_2} in that it is not necessarily $x$-monotone. In the
  following methods when we require an \ccc{X_curve_2} as a parameter,
  we assume that the curve is $x$-monotone.

\ccCreationVariable{tr} 

\ccOperations

    \ccMethod{Comparison_result compare_x(const Point& p0,
       const Point& p1);} {compares the \ccStyle{x}-coordinates
       of $p0$ and $p1$.  Return \ccStyle{LARGER} if $x(p0) >
       x(p1)$, \ccStyle{SMALLER} if $x(p0) < x(p1)$, or else
       \ccStyle{EQUAL}.  }
    
    \ccMethod{Comparison_result compare_y(const Point& p0,
       const Point& p1);} {compares the
       \ccStyle{y}-coordinates of $p0$ and $p1$.}


    \ccMethod{bool curve_is_vertical(const X_curve& cv);} 
   {returns \ccStyle{true} if \ccStyle{cv} is a vertical segment.}
        
%redundant - we have curve point status ?
    \ccMethod{bool curve_is_in_x_range( const X_curve& cv,
       const Point& pnt );}{returns \ccStyle{true} if \ccStyle{pnt} is
       in the $x$ range of \ccStyle{cv}.}
    
    \ccMethod{Comparison_result curve_compare_at_x(
       const X_curve& cv1, const X_curve& cv2, const Point& pnt );}
    {compares the $y$-coordinate of $cv1$ and $cv2$ at the $x$-coordinate 
     of $pnt$. Return \ccStyle{EQUAL} if at least one of $cv1$ and $cv2$  
     is not defined at $pnt$'s $x$-coordinate.}
   
  \ccMethod{Comparison_result curve_compare_at_x_left(
     const X_curve& cv1, const X_curve& cv2, const Point& pnt);}
  {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the
     left of the $x$-coordinate of $pnt$. Return \ccStyle{EQUAL}
     if at least one of $cv1$ and $cv2$ is not defined to the left of $pnt$'s
     $x$-coordinate.}
    
  \ccMethod{Comparison_result
     curve_compare_at_x_right(const X_curve& cv1, const X_curve& cv2,
     const Point& pnt);} {compares the $y$-coordinate of $cv1$ and
     $cv2$ immediately to the right of the $x$-coordinate of $pnt$.
     Return \ccStyle{EQUAL} if at least one of $cv1$ and $cv2$ is
     not defined to the right of $pnt$'s $x$-coordinate.}

    
    \ccMethod{Curve_point_status curve_get_point_status(const X_curve& cv,
       const Point& pnt);} {returns a constant describing the
       relative position between $cv$ and $pnt$:
       \begin{itemize}
       \item[]\ccStyle{CURVE_NOT_IN_RANGE} - $pnt$ is not in the $x$-range of
       $cv$, 
%       \item[]\ccStyle{CURVE_VERTICAL} - $cv$ is a vertical segment,
       \item[]\ccStyle{UNDER_CURVE} - $pnt$ is below $cv$,
       \item[]\ccStyle{ABOVE_CURVE} - $pnt$ is above $cv$, and
       \item[]\ccStyle{ON_CURVE} - $pnt$ is on $cv$.
       \end{itemize}}


       \ccMethod{bool curve_is_same(const X_curve &cv1, const X_cur
          ve &cv2);}{returns \ccc{true} if \ccc{cv1} is the same as \ccc{cv2}.}

%construction function
%---------------------   

    \ccMethod{Point curve_source(const X_curve& cv);}{returns the source of 
       \ccc{cv}.}
    \ccMethod{Point curve_target(const X_curve& cv);}{returns the target of 
       \ccc{cv}.}

%additions needed for the default point location strategy
\ccMethod{Point point_to_left(const Point& p);}{returns a point to 
   the left of \ccc{p}.}
\ccMethod{Point point_to_right(const Point& p);}{returns a point to the right
   of \ccc{p}.} %}


\ccMethod{bool is_x_monotone(const Curve& c);}{returns true if $c$ is
an $x$-monotone curve.}


\ccMethod{void make_x_monotone(const Curve& cv, list<X_curve>& l);}{
   cuts \ccc{cv} into $x$-monotone subcurves and stores them in $l$.
   The order in which they are inserted into $l$ defines their order
   in the hierarchy tree.}

\ccMethod{Point point_reflect_in_x_and_y(const Point& pt);}{returns the
\ccc{Point}
that is the reflection of \ccc{pt} about the origin (both the $x$ and $y$ 
axes). E.g., the point $(2,2)$ will be reflected as $(-2,-2)$. }

\ccMethod{X_curve curve_reflect_in_x_and_y(const X_curve& cv);}{returns the \ccc{X_curve}
that is the reflection of \ccc{cv} about the origin 
(both the $x$ and $y$ axes). E.g., the line segment $((2,2),(3,3))$ will be reflected as $((-2,-2),(-3,-3))$. }

\ccMethod{void curve_split(const X_curve& cv, X_curve& c1, X_curve& c2,
                   const Point& split_pt);}{splits $cv$ at \ccc{split_pt}
and assigns the resulting two curves to \ccc{c1} and \ccc{c2}.
\ccPrecond{\ccc{split_pt} is on \ccc{cv} but is not an endpoint.}
}

\ccMethod{bool do_intersect_to_right(const X_curve& c1, const X_curve& c2,
                             const Point& pt);}{returns $true$ if \ccc{c1}
and \ccc{c2} intersect at a point that is lexicographically larger than 
\ccc{pt}
% to the right of the point \ccc{pt}.
% Intersection to the right of \ccc{pt} is defined as
% an intersection which is lexicographically strictly to the right of \ccc{pt}
(i.e., an intersection above or to the right of
\ccc{pt} but {\em not} on \ccc{pt}).}

\ccMethod{bool nearest_intersection_to_right(const X_curve& c1,
                                      const X_curve& c2,
                                      const Point& pt,
                                      Point& p1, Point& p2);}
{finds the
nearest intersection point to the right of \ccc{pt}. Nearest is defined as the
one lexicographically closest to \ccc{pt} not including \ccc{pt} itself.
If the intersection of \ccc{c1} and \ccc{c2} to the
right of \ccc{pt} is an \ccc{X_curve} (i.e., there is an overlapping subcurve
to the right of \ccc{pt}),
then \ccc{p1} will hold the source point of the intersection and
\ccc{p2} will hold its target point. Otherwise \ccc{p1} and \ccc{p2} are
identical. In the case of an overlap we regard the intersection
to the right as the open curve between \ccc{p1} and \ccc{p2}. This means that
if the overlapping subcurve contains \ccc{pt} either \ccc{p1} or \ccc{p2} will
be equal to \ccc{pt}, this is the only case in which \ccc{p1} or \ccc{p2} are
 equal to \ccc{pt}.
If \ccc{c1} and \ccc{c2} do not intersect to the right of \ccc{pt}
the function returns \ccc{false}, otherwise it returns true.
%\ccPrecond{\ccc{do_intersect_to_right(c1,c2,pt) == true}}
}

%The intersection function is defined in such a way to enable dealing with
%degenerate cases when two curves inserted into the arrangement overlap.

\ccMethod{bool curves_overlap(const X_curve& cv1, const X_curve& cv2);}
{returns \ccc{true} if \ccc{cv1} and \ccc{cv2} overlap
in a one-dimensional subcurve (i.e., not in a finite number
of points), otherwise returns
\ccc{false}.}

\ccHasModels
  \ccc{Arr_segment_exact_traits<R>}\\
  \ccc{Arr_leda_segment_exact_traits}\\
  \ccc{Arr_circles_real_traits<NT>}\\
  \ccc{Arr_polyline_traits<R, Container>} \\
  \ccc{Arr_leda_polyline_traits<Container>} \\
  \ccc{Arr_segment_circle_traits<NT>}

  Note that the concept ArrangementTraits\_2 is a refinement of the 
  concept \ccRefName\ so each model of the former is a model of the latter.

\ccSeeAlso

\ccc{CGAL::sweep_to_produce_subcurves_2} \\
\ccc{CGAL::sweep_to_produce_points_2} \\
\ccc{CGAL::sweep_to_construct_planar_map_2}

% \ccExample

% A short example program.
% Instead of a short program fragment, a full running program can be
% included using the 
% \verb|\ccIncludeExampleCode{examples/Sweep_line_2/SweepLineTraits_2_prog.C}| 
% macro. The program example would be part of the source code distribution and
% also part of the automatic test suite.

% \begin{ccExampleCode}
% void your_example_code() {
% }
% \end{ccExampleCode}

%% \ccIncludeExampleCode{examples/Sweep_line_2/SweepLineTraits_2_prog.C}

\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

