%% ==============================================================
%% Specification: Random Simple Polygons
%% --------------------------------------------------------------
%% author: Susan Hert
%% ==============================================================

\newpage

\ccParDims

\section{Random Simple Polygons}
\label{section_RandomSimplePolygons}
\lcTex{\ccIndexMainItem[c]{random simple polygon}}

This section describes a function to compute a random simple polygon
from points that are drawn from a specific domain.

\ccInclude{CGAL/random_polygon_2.h}


\ccGlobalFunction{
template < class OutputIterator, class PointGenerator, class Traits > 
OutputIterator random_polygon_2( int n, OutputIterator result, 
                    const PointGenerator& pg, Traits t = Default_traits);
}

%\ccGlobalFunction{
%template <class InputIterator, class OutputIterator, class Traits>
%OutputIterator random_polygon_2( InputIterator first, InputIterator beyond,
%                                 OutputIterator result, const Traits& traits);
%}

computes a random simple polygon by writing its vertices (oriented
counterclockwise) to \ccc{result}. The polygon generated will have $n'$ 
vertices, where $n'$ is the number of unique points in the first $n$
points generated by $pg$.  Though each simple polygon defined
on this set of $n'$ points has a non-zero 
probability of being constructed, some polygons may have higher 
probabilities than others.

\ccHeading{Preconditions}
\begin{enumerate}
\item \ccc{Traits} satisfies the requirements stated in
      section \ref{req_random_polygon_2_traits} and \ccc{Traits::Point_2} 
      is the same as \ccc{PointGenerator::value_type},
\item \ccc{OutputIterator} accepts \ccc{PointGenerator::value_type} as its
      value type.
\end{enumerate}

\ccSeeAlso \ccc{Random_points_in_square_2} and
\ccc{Random_points_in_disc_2}.

\ccImplementation 
The implementation is based on the method of eliminating self-intersections in
a polygon by using so-called ``2-opt'' moves.  Such a move eliminates an 
intersection between two edges by reversing the order of the vertices between 
the edges.  No more than $O(n^3)$ such moves are required to simplify a polygon
defined on $n$ points \cite{ls-utstp-82}.
Intersecting edges are detected using a simple sweep through the vertices
and then one intersection is chosen at random to eliminate after each sweep. 
The worse-case running time is therefore $O(n^4 \log n)$.

\ccExample

The following program displays a random simple polygon with up to 50
vertices, where the vertex coordinates are drawn uniformly from the 
unit square centered at the origin.

\ccIncludeVerbatim{random_poly.C}

\begin{ccAdvanced}
\lcTex{\ccAutoIndexingOff}
\ccHtmlNoIndex\ccHtmlNoClassLinks\begin{ccClass}{Traits}
\ccCreationVariable{t}
\subsection{Requirements for Random Simple Polygon Traits Classes}
\label{req_random_polygon_2_traits}
\lcTex{\ccIndexSubitem[c]{random simple polygon}{traits requirements}}

\ccDefinition
A class \ccClassName\ has to provide the following type and operations in
order to qualify as a traits class for \ccc{random_polygon_2}.

\ccTypes
\ccNestedType{FT}{ The coordinate type of the points of the polygon 
                   ({\em i.e.}, a field type)}
\ccNestedType{Point_2}{The point type of the polygon.}
\ccNestedType{Vector_2}{The vector type that can be constructed from the
                        difference of two objects of type \ccc{Point_2}.}
\ccNestedType{Less_yx} 
       {Binary predicate object type comparing \ccc{Point_2}s lexicographically.
        It must provide \ccc{bool operator()(Point_2 p, Point_2 q)} that 
        returns \ccc{true} iff $p <_{yx} q$.
        We have $p<_{yx}q$, iff $p_y < q_y$ or $p_y = q_y$ and $p_x < q_x$,
        where $p_x$ and $p_y$ denote the $x$ and $y$ coordinates of point $p$,
        resp.
       }
                        

\ccOperations

\ccMemberFunction{
    Comparison_result compare_x(const Point_2 &p, const Point_2 &q) const;
}
{
\lcTex{
Returns
$
  \left\{
  \begin{array}{lll}
     \ccStyle{SMALLER} & \mbox{if} & p_x < q_x \\
     \ccStyle{EQUAL}   & \mbox{if} & p_x = q_x \\
     \ccStyle{LARGER}  & \mbox{if} & p_x > q_x
  \end{array}
  \right.%}
$
}
\lcHtml{
Returns SMALLER if p_x < q_x, EQUAL if p_x = q_x and LARGER if p_x > q_x
}
}



\ccMemberFunction{
    Comparison_result compare_y(const Point_2 &p, const Point_2 &q) const;
}
{
\lcTex{
Returns
$
  \left\{
  \begin{array}{lll}
     \ccStyle{SMALLER} & \mbox{if} & p_y < q_y \\
     \ccStyle{EQUAL}   & \mbox{if} & p_y = q_y \\
     \ccStyle{LARGER}  & \mbox{if} & p_y > q_y
  \end{array}
  \right.%}
$
}
\lcHtml{
Returns SMALLER if p_y < q_y, EQUAL if p_y = q_y and LARGER if p_y > q_y
}
}

\ccMemberFunction{
    FT cross_product_2(const Vector_2& p, const Vector_2& q) const;
}
{
Returns $p_x q_y - p_y q_x$.
}
\ccMemberFunction{
    bool do_intersect(const Point_2& p1,
                      const Point_2& q1,
                      const Point_2& p2,
                      const Point_2& q2) const;
}
{
Returns \ccc{true} iff the segments \ccStyle{[p1,q1]} and \ccStyle{[p2,q2]} 
intersect.
}

\ccMemberFunction{
    bool have_equal_direction(const Vector_2& v1,
                              const Vector_2& v2 ) const;
}
{
Returns \ccc{true} iff the vectors \ccStyle{v1} and \ccStyle{v2} have the
same direction.
}

\ccMemberFunction{
    bool is_negative(const FT& x) const;
}
{
Returns \ccStyle{true} iff \ccStyle{x<0}.
}

\ccMemberFunction{
    bool lexicographically_yx_smaller_or_equal(const Point_2& p,
                                               const Point_2& q) const;
}
{
Returns \ccc{true} iff $p_y \leq q_y$ or $p_y = q_y$ and $p_x \leq q_x$.
}


\end{ccClass}
\lcTex{\ccAutoIndexingOn}
\end{ccAdvanced}
