% +------------------------------------------------------------------------+
% | Reference manual page: Delaunay_triangulation_2.tex
% +------------------------------------------------------------------------+
% | 12.04.2000   Author
% | Package: Package
% | 
\RCSdef{\RCSDelaunaytriangulationRev}{$Revision$}
\RCSdefDate{\RCSDelaunaytriangulationDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Delaunay_triangulation_2<Traits,Tds>}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition
  
The class \ccRefName\ is designed to represent
the Delaunay triangulation of a set of points in a plane.
A  Delaunay triangulation of a set of points
is a triangulation of the sets of points that fulfills
the following {\em empty circle property} 
(also called {\em Delaunay property}): the circumscribing
circle of each
 face does not contain any vertex.
For a point set with no case of cocircularity 
of more than three points,
the Delaunay triangulation is unique, it is  the dual
of the Voronoi diagram of the points.
A Delaunay triangulation is a special triangulation of a set of points.
So it is natural to derive  the class \ccRefName\
from the basic class \ccc{Triangulation_2<Traits,Tds>}.
The template parameters \ccc{Traits} and \ccc{Tds} 
are to be instantiated with models of respectively
\ccc{Delaunay_triangulation_traits_2}  and
\ccc{Triangulation_data_structure_2}.

The concept of triangulation data structure
is described \ccRefPage{Triangulation_data_structure_2}
and the same models can be used to instantiate the
triangulation data structure of either a \ccc{Triangulation_2<Traits,Tds>}
or a \ccRefName. On the contrary, because the
Delaunay triangulation relies on the notions of 
empty circles and of distance, 
the concept of \ccc{Delaunay_triangulation_traits_2}, described
\ccRefPage{Delaunay_triangulation_traits_2},
 has to provide
the \ccc{side_of_oriented_circle} predicate
a Distance class. 
Changing the Distance class and the \ccc{side_of_oriented_circle} predicate 
allows to build Delaunay triangulations for different metrics
such that $L_1$ or $L_{\infty}$ or any metric defined by a
convex object. However, the user of an exotic metric
must be carefull that the constructed triangulation 
has to be a triangulation of the convex hull
which means that convex hull edges have to be Delaunay edges.
This is granted for any smooth convex metric (like $L_2$)
and can be ensured for other metrics (like  $L_{\infty}$)
by the addition to the point set of well chosen sentinel points.


\ccInclude{Delaunay_triangulation_2.h}

\ccInheritsFrom

\ccc{Triangulation_2<Traits,Tds>}

\ccTypes
Inherits all the types of the \ccc{Triangulation_2<Traits>}.
In addition to the types inherited from \ccc{Triangulation_2<Traits,Tds>}
the class \ccClassTemplateName\
defines a type for the distance object function, and 
some types to
represent the dual Voronoi diagram.

\ccTypedef{typedef Traits::Distance Distance;}{}

\ccTypedef{typedef Traits::Line Line;}{}
\ccGlue
\ccTypedef{typedef Traits::Direction Direction;}{}
\ccGlue
\ccTypedef{typedef Traits::Ray Ray;}{}



\ccCreation
\ccCreationVariable{dt}  %% choose variable name

\ccConstructor{Delaunay_triangulation_2(const Traits& gt =
Traits());}{default constructor.}

\ccConstructor{Delaunay_triangulation_2(
	       const Delaunay_triangulation_2<Traits,Tds> &tr);}
{Copy constructor. All the vertices and faces are duplicated.}

\ccHeading{Insertion and Removal}

The following insertion and removal  functions overwrite
the functions inherited from the class
\ccc{Triangulation_2<Traits,Tds>} to maintain the Delaunay property.




\ccMethod{Vertex_handle insert(const Point& p, Face_handle f=Face_handle());}
{Inserts  point \ccc{p}.
If point \ccc{p} coincides with an already existing vertex, this 
vertex is returned and the triangulation is not updated.
Optional parameter \ccc{f} is used to initialize the location of \ccc{p}.
}

\ccMethod{Vertex_handle insert(const Point& p, Locate_type& lt,
Face_handle loc, int li );}
{ inerts a point \ccc{p}, the location of which is supposed to be
given by \ccc{(lt,loc,li)}, see the description of member function
\ccc{locate} in class \ccc{Triangulation_2<Traits,Tds>}.}

\ccMethod{Vertex_handle push_back(const Point& p);}
{Equivalent to \ccc{insert(p)}.}

\ccMethod{template < class InputIterator >
          int
          insert(InputIterator first, InputIterator last);}
{inserts the points in the range
 $\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$.
 Returns the number of inserted points.
 \ccPrecond The \ccc{value_type} of \ccc{first} and \ccc{last}
 is \ccc{Point}.}



\ccMethod{void    remove(Vertex_handle v);}
{removes the vertex from the triangulation.}

Note that the other modifier functions  of
\ccc{Triangulation_2<Traits,Tds>} are not overwritten.
Thus a  call to \ccc{insert_in_face}
\ccc{insert_in_edge}, \ccc{insert_outside_convex_hull},
\ccc{insert_outside_affine_hull}  or \ccc{flip}
on a valid Delaunay triangulation might lead to a triangulation
which is no longer a Delaunay triangulation.

\ccHeading{Queries}

\ccMethod{Vertex_handle
        nearest_vertex(const Point& p, Face_handle f=Face_handle());}
{returns any nearest vertex of \ccc{p}. The implemented function
begins with a location step and
\ccc{f} may be used to initialize the location.}




\ccHeading{Duality}

\ccMethod{Point dual(const Face_handle &f) const;}
{Returns the center of the circle circumscribed to face \ccc{f}.
\ccPrecond \ccc{f} is not infinite}

\ccMethod{Object dual(const Edge &e) const;}
{returns a segment, a ray or a line supported by the bisector of the
endpoints of \ccc{e}.
If faces incident to \ccc{e} are both finite, a segment whose endpoints are the
duals of each incident face is returned. If only one incident face is
finite, a
ray whose endpoint is the dual of the finite incident face is returned.
Otherwise both incident faces
are infinite and the bisector line is returned.}

\ccMethod{Object dual(const Edge_circulator& ec) const;}
{Idem}

\ccMethod{Object dual(const Edge_iterator& ei) const;}
{Idem}



\ccPredicates
\ccThree{Oriented_side}{side_of_}{}
\ccThreeToTwo

\ccMethod{Oriented_side
  side_of_oriented_circle(Face_handle f,
                          const Point& p) const;}
{Returns the side of \ccc{p} with respect to the circle circumscribing
 the triangle associated with \ccc{f}}

\begin{ccAdvanced}
\ccHeading{Miscellaneous}
\ccThree{Vertex_handle}{T.push_back(const Point &p);}{}

The checking function \ccc{is_valid()} is also overwritten
to additionally test the empty circle property.

\ccMethod{bool is_valid(bool verbose = false, int level = 0) const;}
{ Tests the validity of the triangulation as a \ccc{Triangulation_2}
and additionally test the Delaunay property. This method is
 mainly  useful for debugging Delaunay triangulation algorithms designed by
 the user.}
\end{ccAdvanced}

\ccHeading{I/O}
The I/O operators for \ccc{iostream} and for
the window stream are simply those defined for the base class
\ccc{Triangulation_2<Traits, Tds>}.
In addition, there is a template member function to ouput
the dual Voronoi diagram on a stream

\ccMethod{
template < class Stream>
  Stream& draw_dual(Stream & ps);}
{output the dual voronoi diagram to stream ps.}



\ccSeeAlso

\ccc{CGAL::Triangulation_2<Traits,Tds>}, \\
\ccc{Triangulation_data_structure_2}, \\
\ccc{Delaunay_triangulation_traits_2}

\ccExample

The following code fragment creates a Delaunay triangulation with 
the usual Euclidean metric for the vertical projection of a 
terrain model. The points have elevation, that is they are 3D points
and the predicates which are defined in the Delaunay triangulation 
traits class forget about the $z$-coordinate of these points. 

%\ccIncludeExampleCode{examples/Triangulation/terrain.C}
\ccIncludeExampleCode{../../../examples/Triangulation/terrain.C}

\ccHeading{Implementation}

Insertion is implemented by inserting in the triangulation, then
performing a sequence of Delaunay flips. The number of flips is \ccTexHtml{$O(d)$}{O(d)}
if the new vertex is of degree \ccTexHtml{$d$}{d} in the new triangulation. For
points distributed uniformly at random, insertion takes time \ccTexHtml{$O(1)$}{O(1)} on
average.

Removal calls the removal in the triangulation and then retriangulates
the hole in such a way that  the Delaunay criterion is satisfied. Removal of a
vertex of degree \ccTexHtml{$d$}{d} takes time \ccTexHtml{$O(d^2)$}{O(d^2)},
which is \ccTexHtml{$O(1)$}{O(1)} for a random
vertex in the triangulation.

Nearest neighbor is found in time \ccTexHtml{$O(n)$}{O(n)} in the
worst case, but in time \ccTexHtml{$O(1)$}{O(1)}
for vertices distributed uniformly at random  and any query point. 


\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

