
\begin{ccRefFunctionObjectConcept}{CircularKernel::ConstructCircularArcPoint_2}
\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{CircularKernel::Circular_arc_point_2 operator()
	(const CircularKernel::Root_for_circles_2_2 & r);}
{}

\ccMemberFunction{CircularKernel::Circular_arc_point_2 operator()
	(const CircularKernel::Point_2 & p);}
{}

\end{ccRefFunctionObjectConcept}

\begin{ccRefFunctionObjectConcept}{CircularKernel::ConstructLineArc_2}
\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{CircularKernel::Line_arc_2 operator()
	(const CircularKernel::Line_2 &l,
	const CircularKernel::Circular_arc_point_2 &p1,
	const CircularKernel::Circular_arc_point_2 &p2);}
{Construct the line segment supported by \ccc{l}, whose source 
is \ccc{p1} and whose target is \ccc{p2}.
\ccPrecond{\ccc{p1} and \ccc{p2} lie on \ccc{l}.}}

\ccMemberFunction{CircularKernel::Line_arc_2 operator()
	(const CircularKernel::Line_2 &l,
	const CircularKernel::Point_2 &p1,
	const CircularKernel::Point_2 &p2);}
{Same.}

\ccMemberFunction{CircularKernel::Line_arc_2 operator()
	(const CircularKernel::Segment_2 &s);}
{}

\ccMemberFunction{CircularKernel::Line_arc_2 operator()
	(const CircularKernel::Line_2 &l,
	const CircularKernel::Circle_2 &c1, int i1,
	const CircularKernel::Circle_2 &c2, int i2);}
{Constructs the line segment whose supporting line is \ccc{l}, whose 
source endpoint is the $i_1^{th}$ intersection of \ccc{l} with \ccc{c1}, 
and whose target endpoint is the $i_2^{th}$ intersection of \ccc{l} 
and \ccc{c2}, where intersections are ordered lexicographically.
\ccPrecond{\ccc{l} intersects both \ccc{c1} and \ccc{c2}, and the arc
defined by the intersections has non-zero length.}}

\ccMemberFunction{CircularKernel::Line_arc_2 operator()
	(const CircularKernel::Line_2 &l,
	const CircularKernel::Line_2 &l1, int i1,
	const CircularKernel::Line_2 &l2, int i2);}
{Same, for intersections defined by lines instead of circles.}

\end{ccRefFunctionObjectConcept}

\begin{ccRefFunctionObjectConcept}{CircularKernel::ConstructCircularArc_2}
\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{CircularKernel::Circular_arc_2 operator()
	(const CircularKernel::Circle_2 &c);}
{Constructs an arc from a full circle.}

\ccMemberFunction{CircularKernel::Circular_arc_2 operator()
	(const CircularKernel::Circle_2 &c,
	const CircularKernel::Circular_arc_point_2 &p1,
	const CircularKernel::Circular_arc_point_2 &p2);}
{Construct the line segment supported by \ccc{c}, that is oriented 
counterclockwise, whose source is \ccc{p1} and whose target is \ccc{p2}.
\ccPrecond{\ccc{p1} and \ccc{p2} lie on \ccc{c}.}}

\ccMemberFunction{CircularKernel::Circular_arc_2 operator()
	(const CircularKernel::Circle_2 &c,
		const CircularKernel::Point_2 &p1,
		const CircularKernel::Point_2 &p2);}
{Same.}

\ccMemberFunction{CircularKernel::Circular_arc_2 operator()
	(const CircularKernel::Circle_2 &c, 
		   const CircularKernel::Circle_2 &c1, int i1,
		   const CircularKernel::Circle_2 &c2, int i2);}
{Constructs the unique circular arc that is oriented counterclockwise,
whose supporting circle is \ccc{c}, and whose source endpoint is the
intersection of \ccc{c} and \ccc{c1} with index $i_1$, and whose target
is the intersection of \ccc{c} and \ccc{c2} of index $i_2$, where
intersections are ordered lexicographically.
\ccPrecond{\ccc{c} intersects both \ccc{c1} and \ccc{c2}, and the arc
defined by the intersections has non-zero length.}}

\ccMemberFunction{CircularKernel::Circular_arc_2 operator()
	(const CircularKernel::Circle_2 &c,
	const CircularKernel::Line_2 &l1, int i1,
 	const CircularKernel::Line_2 &l2, int i2);}
{Same, for intersections defined by lines instead of circles.}

\end{ccRefFunctionObjectConcept}


\begin{ccRefFunctionObjectConcept}{CircularKernel::MakeXMonotone_2}

\ccDefinition

Splitting curves into monotone pieces. 

\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{template < class OutputIterator >
    OutputIterator
    operator()(const CircularKernel::Circular_arc_2 &ca, OutputIterator oit);}
{Splits the arc \ccc{ca} into monotone arcs that are returned through the 
output iterator.}

\ccHasModels

\ccc{Circular_kernel::Make_x_monotone_2;}

\ccSeeAlso

\ccRefIdfierPage{CGAL::make_x_monotone}

\end{ccRefFunctionObjectConcept}
\begin{ccRefFunctionObjectConcept}{CircularKernel::Intersect_2}

\ccDefinition

To compute intersections of objects.

\ccRefines

\ccc{CGAL::Kernel::Intersect_2}

\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{template < class OutputIterator >
    OutputIterator
    operator()(const CircularKernel::Line_arc_2 &l, const Type &c);}
{Copies in the output iterators the intersection points between the
two objects, sorted lexicographically. \ccc{points} iterates on
elements of type \ccc{std::pair<CircularKernel::Circular_arc_point_2,
int>}, where the integer is the multiplicity of the corresponding
intersection point between \ccc{obj1} and \ccc{obj2}. }
and
\ccMemberFunction{template < class OutputIterator >
    OutputIterator
    operator()(const Type &c, const CircularKernel::Line_arc_2 &l);}
{same}

where \ccc{Type} is either \ccc{CircularKernel::Circle_2} or
\ccc{CircularKernel::Circular_arc_2}. 

\ccMemberFunction{template < class OutputIteratorPoints, class OutputIteratorArcs >
    std::pair< OutputIteratorPoints, OutputIteratorArcs >
    operator()(const Type1 &obj1, const Type2 &obj2, 
	OutputIteratorPoints points, OutputIteratorArcs arcs);}
{Copies in the output iterators the intersections between the two
objects, sorted lexicographically. \ccc{points} iterates on elements
of type \ccc{std::pair<CircularKernel::Circular_arc_point_2, int>},
where the integer is the multiplicity of the corresponding
intersection point between \ccc{obj1} and \ccc{obj2}, and \ccc{arcs}
iterates on elements of type \ccc{CircularKernel::Circular_arc_2} (or
\ccc{CircularKernel::Circle_2} in the special case of two equal input circles)
that are arcs on which \ccc{obj1} and \ccc{obj2} overlap.} 

where \ccc{Type1} and \ccc{Type2} can both be either
\ccc{CircularKernel::Circle_2} or
\ccc{CircularKernel::Circular_arc_2}. 

\ccHasModels

\ccc{Circular_kernel::Intersect_2;}

\ccSeeAlso

\ccRefIdfierPage{CGAL::intersect}

\end{ccRefFunctionObjectConcept}

\begin{ccRefFunctionObjectConcept}{CircularKernel::Split_2}

\ccDefinition

To split curves at a given point.

\ccCreationVariable{fo}

A model \ccVar\ of this type must provide:

\ccMemberFunction{void operator()
	(const CircularKernel::Circular_arc_2 &a, 
	const CircularKernel::Circular_arc_point_2 &p,
	CircularKernel::Circular_arc_2 &a1, 
	CircularKernel::Circular_arc_2 &a2);}
{Splits arc $a$ at point $p$, which creates arcs $a1$ and $a2$.
\ccPrecond{$a$ is $x$-monotone, and $p$ lies on $a$.}}

\ccMemberFunction{void operator()
	(const CircularKernel::Line_arc_2 &l, 
	 const CircularKernel::Circular_arc_point_2 &p,
	 CircularKernel::Line_arc_2 &l1, CircularKernel::Line_arc_2 &l2);}
{Same for a line arc.}

\ccHasModels

\ccc{Circular_kernel::Split_2}

\ccSeeAlso

\ccRefIdfierPage{CGAL::split}

\end{ccRefFunctionObjectConcept}
