\begin{ccRefConcept}{CircularKernel::MakeXMonotone_2}

\ccDefinition

\ccCreationVariable{mkxmon}

A model \ccVar\ of this type must provide:

\ccMethod{template < class OutputIterator >
    OutputIterator
    operator()(const CircularKernel::Circular_arc_2 &ca, OutputIterator res);}
{Splits the arc \ccc{ca} into monotone arcs that are returned into the 
output iterator.}

\ccHasModels

\ccc{Curved_kernel::Make_x_monotone_2;}

\ccSeeAlso

\ccRefIdfierPage{CGAL::make_x_monotone}

\end{ccRefConcept}
\begin{ccRefConcept}{ConicKernel::MakeXMonotone_2}

\ccDefinition

\ccCreationVariable{mkxmon}

A model \ccVar\ of this type must provide:

\ccMethod{template < class OutputIterator >
    OutputIterator
    operator()(const ConicKernel::Conic_arc_2 &ca, OutputIterator res);}
{Splits the arc \ccc{ca} into monotone arcs that are returned into the 
output iterator.}

\ccHasModels

\ccc{Curved_kernel::Make_x_monotone_2;}

\ccSeeAlso

\ccRefIdfierPage{CGAL::make_x_monotone}

\end{ccRefConcept}

\begin{ccRefConcept}{CircularKernel::ConstructIntersections_2}

\ccDefinition

\ccCreationVariable{consinter}

A model \ccVar\ of this type must provide:

\ccMethod{template < class OutputIteratorPoints, class OutputIteratorArcs >
    std::pair< OutputIteratorPoints, OutputIteratorArcs >
    operator()(const CircularKernel::Circular_arc_2 &ca1, 
	const CircularKernel::Circular_arc_2 &ca2, 
	OutputIteratorPoints points, OutputIteratorArcs arcs);}
{Copies in the output iterators the intersections between the two arcs. 
More precisely, \ccc{points} iterates on elements of type \ccc{std::pair<CurvedKernel::Circular_arc_endpoint_2, int>}, where the integer is the multiplicity of the corresponding intersection point between \ccc{ca1} and \ccc{ca2}, and \ccc{arcs} iterates on elements of type \ccc{CurvedKernel::Circular_arc_2} that are arcs on which \ccc{ca1} and \ccc{ca2} overlap.}

\footnote{sorted or not ?}

\ccMethod{template < class OutputIteratorPoints, class OutputIteratorArcs >
    std::pair< OutputIteratorPoints, OutputIteratorArcs >
    operator()(const CircularKernel::Circular_arc_2 &ca1, 
	const CircularKernel::Circular_arc_2 &ca2, 
	OutputIteratorPoints points, OutputIteratorArcs arcs, int foo);}
{Same as the previous one, except that \ccc{points} gives intersections 
with the parity of their multiplicity only.}

\ccHasModels

\ccc{Curved_kernel::Construct_intersections_2;}

\ccSeeAlso

\ccRefIdfierPage{CGAL::construct_intersections}

\end{ccRefConcept}
\begin{ccRefConcept}{ConicKernel::ConstructIntersections_2}

\ccDefinition

\ccCreationVariable{consinter}

A model \ccVar\ of this type must provide:

\ccMethod{template < class OutputIteratorPoints, class OutputIteratorArcs >
    std::pair< OutputIteratorPoints, OutputIteratorArcs >
    operator()(const ConicKernel::Conic_arc_2 &ca1, 
	const ConicKernel::Conic_arc_2 &ca2, 
	OutputIteratorPoints points, OutputIteratorArcs arcs);}
{Copies in the output iterators the intersections between the two arcs. 
More precisely, \ccc{points} iterates on elements of type \ccc{std::pair<CurvedKernel::Conic_arc_endpoint_2, int>}, where the integer is the multiplicity of the corresponding intersection point between \ccc{ca1} and \ccc{ca2}, and \ccc{arcs} iterates on elements of type \ccc{CurvedKernel::Conic_arc_2} that are arcs on which \ccc{ca1} and \ccc{ca2} overlap.}

\footnote{sorted or not ?}

\ccMethod{template < class OutputIteratorPoints, class OutputIteratorArcs >
    std::pair< OutputIteratorPoints, OutputIteratorArcs >
    operator()(const ConicKernel::Conic_arc_2 &ca1, 
	const ConicKernel::Conic_arc_2 &ca2, 
	OutputIteratorPoints points, OutputIteratorArcs arcs, int foo);}
{Same as the previous one, except that \ccc{points} gives intersections 
with the parity of their multiplicity only.}

\ccHasModels

\ccc{Curved_kernel::Construct_intersections_2;}

\ccSeeAlso

\ccRefIdfierPage{CGAL::construct_intersections}

\end{ccRefConcept}