\begin{ccRefClass}{Circular_arc_2<CircularKernel>}

\ccIsModel

\ccc{CircularKernel::CircularArc_2}

\ccInclude{CGAL/Circular_arc_2.h}

\ccCreation
\ccCreationVariable{ca}

\ccThree{Circular_arc_point_2}{ca.is_x_monotone()}{}
\ccThreeToTwo

\ccConstructor{Circular_arc_2(const CircularKernel::Circle_2 &c)}
{Constructs an arc from a full circle.}

\ccConstructor{Circular_arc_2(const CircularKernel::Circle_2 &c, 
		   const CircularKernel::Circle_2 &c1, int i1,
		   const CircularKernel::Circle_2 &c2, int i2)}
{Constructs the unique circular arc that is oriented counterclockwise,
whose supporting circle is \ccc{c}, and whose source endpoint is the
intersection of \ccc{c} and \ccc{c1} with index $i1$, and whose target
is the intersection of \ccc{c} and \ccc{c2} of index $i2$, where
intersections are ordered lexicographically.
\ccPrecond{\ccc{c} intersects both \ccc{c1} and \ccc{c2}, and the arc
defined by the intersections has non-zero length.}} 

\ccConstructor{Line_arc_2(const CircularKernel::Circle_2 &c,
		const CircularKernel::Line_2 &l1, int i1,
		 const CircularKernel::Line_2 &l2, int i2)}
{Same, for intersections defined by lines instead of circles.}

\ccConstructor{Line_arc_2(const CircularKernel::Circle_2 &c,
		const CircularKernel::Circular_arc_point_2 &p1,
		const CircularKernel::Circular_arc_point_2 &p2)}
{Construct the line segment supported by \ccc{c}, that is oriented 
counterclockwise, whose source is \ccc{p1} and whose target is \ccc{p2}.
\ccPrecond{\ccc{p1} and \ccc{p2} lie on \ccc{c}.}}

\ccConstructor{Line_arc_2(const CircularKernel::Circle_2 &c,
		const CircularKernel::Point_2 &p1,
		const CircularKernel::Point_2 &p2)}
{Same.}

\ccAccessFunctions

\ccThree{CircularKernel::Circular_arc_point_2}{ca.is_x_monotone()}{}
\ccThreeToTwo

\ccMethod{CircularKernel::Circle_2 supporting_circle();}{}

A circular arc is supposed to be oriented counterclockwise, from 
\ccc{source} to \ccc{target}. 

\ccMethod{CircularKernel::Circular_arc_point_2 source();}{}
\ccGlue
\ccMethod{CircularKernel::Circular_arc_point_2 target();}{}

When the methods \ccc{source} and \ccc{target} return the same point, then 
the arc is in fact a full circle. \footnote{so far, arcs of zero length are
points, not arcs. But see Menelaos' remark: add functors to test whether an
arc is degenerate... to be fixed}

When an arc is x-monotone, its left and right points can be accessed
directly:

\ccMethod{CircularKernel::Circular_arc_point_2 left();}{\ccPrecond{\ccVar.\ccc{is_x_monotone()}}.}
\ccGlue
\ccMethod{CircularKernel::Circular_arc_point_2 right();}{\ccPrecond{\ccVar.\ccc{is_x_monotone()}}.}

\ccQueryFunctions

\ccMethod{bool is_x_monotone();}{Tests whether the arc is x-monotone.}
\ccGlue
\ccMethod{bool is_y_monotone();}{Tests whether the arc is y-monotone.}

\ccHeading{I/O}

\ccFunction{istream& operator>> (std::istream& is, Circular_arc_2 & ca);}{}
\ccGlue
\ccFunction{ostream& operator<< (std::ostream& os, const Circular_arc_2 & ca);}{}

\end{ccRefClass}
