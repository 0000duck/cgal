\begin{ccRefClass}{Circular_arc_point_2<CircularKernel>}

\ccIsModel

\ccc{CircularKernel::CircularArcPoint_2}

\ccInclude{CGAL/Circular_arc_endpoint_2.h}

\ccParameters

\ccc{CircularKernel}

\ccIsModel

\ccc{Default Constructible}, \ccc{CopyConstructible}

\ccCreation
\ccCreationVariable{p}

\ccThree{Circular_arc_point_2}{ca.is_x_monotone()}{}
\ccThreeToTwo

\footnote{quid of a constructor from a Point\_2 ?}
\ccConstructor{Circular_arc_point_2(const CircularKernel::Point_2 &q)}{}

\ccConstructor{Circular_arc_point_2(
		const CircularKernel::Circle_2 & c1, 
		const CircularKernel::Circle_2 & c2, 
		const int i)}
{Constructs an point defined as the $i^{th}$ intersection (for the 
order given by the $x$-coordinates) of the two circles \ccc{c1} and \ccc{c2}.} 
\footnote{more intrinsecail indexing possible...}

\ccAccessFunctions

\ccThree{CircularKernel::Root_of_2}{ca.is_x_monotone()}{}
\ccThreeToTwo

\ccMethod{const CircularKernel::Root_of_2 & x();}{$x$-coordinate of the point.}
\ccGlue
\ccMethod{const CircularKernel::Root_of_2 & y();}{$y$-coordinate of the point.}

\ccMethod{Bbox_2 bbox() const;}
{Returns a bounding box around the point.}

\footnote{The next 2 methods should be removed. They were implemented 
in the prototype because corresponding methods were not available in 
the arrangements (?) to access edges from vertices. To be discussed.}

\ccMethod{const CircularKernel::Circle_2 & circle(int i);}
{\ccPrecond{\ccc{i}==0 or \ccc{i}==1}. Returns one of the two circles defining the point.}
\ccGlue
\ccMethod{int index();}{Returns the index (in lexicographic order)
of the point among the intersections between the two circles
defining it.}

\ccOperations

\ccFunction{bool operator==(const Circular_arc_point_2<CircularKernel> &p,
			const Circular_arc_point_2<CircularKernel> &q);}
{Test for equality. Two points are equal, iff their $x$ and $y$ coordinates are equal.} 

\ccFunction{bool operator!=(const Circular_arc_point_2<CircularKernel> &p,
			const Circular_arc_point_2<CircularKernel> &q);}
{Test for nonequality.} 

\ccFunction{bool operator<(const Circular_arc_point_2<CircularKernel> &p,
			const Circular_arc_point_2<CircularKernel> &q);}
{Returns true iff $p$ is lexicographically smaller than $q$, i.e. either if $p.x() < q.x()$
 or if $p.x() == q.x()$ and $p.y() < q.y()$.}

\ccFunction{bool operator>(const Circular_arc_point_2<CircularKernel> &p,
			const Circular_arc_point_2<CircularKernel> &q);}
{Returns true iff $p$ is lexicographically greater than $q$.}

\ccFunction{bool operator<=(const Circular_arc_point_2<CircularKernel> &p,
			const Circular_arc_point_2<CircularKernel> &q);}
{Returns true iff $p$ is lexicographically smaller than or equal to $q$.}

\ccFunction{bool operator>=(const Circular_arc_point_2<CircularKernel> &p,
			const Circular_arc_point_2<CircularKernel> &q);}
{Returns true iff $p$ is lexicographically greater than or equal to $q$.}

\ccHeading{I/O}

\ccFunction{ostream& operator<< (std::ostream& os, const Circular_arc_point_2 &ce);}{}

\end{ccRefClass}
