\begin{ccRefClass}{Circular_arc_endpoint_2<CircularKernel>}

\footnote{To be renamed into \ccc{Circular_arc_point}? would be ok for both intersections and endpoints (not specifying at all the implementation of endpoints)}

\ccDefinition

\ccInclude{CGAL/Circular_arc_endpoint_2.h}

\ccParameters

\ccc{CircularKernel}

\ccIsModel

\ccc{Default Constructible}, \ccc{CopyConstructible}

\ccCreation
\ccCreationVariable{cae}

\ccThree{Circular_arc_endpoint_2}{ca.is_x_monotone()}{}
\ccThreeToTwo

\footnote{quid of a constructor from a Point\_2 ?}

\ccConstructor{Circular_arc_endpoint_2(
		const CircularKernel::Circle_2 & c1, 
		const CircularKernel::Circle_2 & c2, 
		const int i)}
{Constructs an endpoint defined as the $i^{th}$ intersection (for the 
order given by the $x$-coordinates) of the two circles \ccc{c1} and \ccc{c2}.} 
\footnote{more intrinsecail indexing possible...}

\ccAccessFunctions

\ccThree{CircularKernel::Root_of_2}{ca.is_x_monotone()}{}
\ccThreeToTwo

\ccMethod{const CircularKernel::Root_of_2 & x();}{$x$-coordinate of the endpoint.}
\ccGlue
\ccMethod{const CircularKernel::Root_of_2 & y();}{$y$-coordinate of the endpoint.}

\footnote{The next 2 methods should be removed. They were implemented 
in the prototype because corresponding methods were not available in 
the arrangements (?) to access edges from vertices. To be discussed.}

\ccMethod{const CircularKernel::Circle_2 & circle(int i);}
{\ccPrecond{\ccc{i}==0 or \ccc{i}==1}. Returns one of the two circles defining the endpoint.}
\ccGlue
\ccMethod{int index();}{Returns the index (in lexicographic order)
of the endpoint among the intersections between the two circles
defining it.}

\ccHeading{I/O}

\ccFunction{ostream& operator<< (std::ostream& os, const Circular_arc_endpoint_2 &ce);}{}

\end{ccRefClass}
