{

\def\note#1{ {\color{red}
  \textsf{$\langle\!\langle${#1}$\rangle\!\rangle$}}
}

\section{Introduction\label{triangulation:intro}}

A \textbf{finite abstract simplicial complex} is built on a finite set of
vertices $V$ and consists of a collection $S$ of subsets of $V$ such that
\begin{itemize}
\item if $s$ is a set of vertices in $S$, then all the subsets of $s$ are also
in $S$.
\end{itemize}
See the
\ccAnchor{http://en.wikipedia.org/wiki/Abstract_simplicial_complex}{wikipedia
entry} for more about abstract simplicial complexes.

The sets in $S$ (which are subsets of $V$) are called
\textbf{faces} or \textbf{simplices} (the
singular of which is \textbf{simplex}).
%
A simplex $s\in S$ is \textbf{maximal} if it is not a proper subset of some other
set in $S$. The simplicial complex is \textbf{pure} (or \textbf{homogeneous})
if all the maximal simplices have the same cardinality ({\emph{i.e.,}\ they have the same
number of vertices). A \textbf{face} of a simplex is a subset of it. A
\textbf{proper face} of a simplex is a strict subset of it.

If the vertices are embedded into euclidean space $\real^d$, we deal with
\textbf{finite simplicial complexes} which have slightly different simplices
and additional requirements:
\begin{itemize}
\item vertices corresponds to points in space.
\item a simplex $s\in S$ is the convex hull of its vertices.
\item the vertices of a simplex $s\in S$ are affinely independent.
\item the intersection of any two simplices of $S$ is a proper face of both
simplices (the empty set counts).
\end{itemize}
See the \ccAnchor{http://en.wikipedia.org/wiki/Simplicial_complex}{wikipedia
entry} for more about simplicial complexes.

This \cgal\ package deals with pure finite simplicial complexes, which
we will simply call in the sequel \textbf{triangulations}. It provides four main classes
for creating and manipulating triangulations.

The class \ccc{CGAL::Triangulation_data_structure<Dimensionality,
TDSVertex, TDSFullCell>} models an abstract triangulation: vertices in this
class are not embedded in euclidean space but are only of combinatorial
nature.

The class \ccc{CGAL::Triangulation<TrTraits, TDS>} embeds an abstract
triangulation in euclidean space, thus forming a triangulation. Methods are
provided for the insertion %and removal
of points in the triangulation, the
traversal of various elements of the triangulation, as well as the localization of a
query point inside the triangulation.

The class \ccc{CGAL::Delaunay_triangulation<DelaunayTraits, TDS>} adds further
constraints to a triangulation, in that all its simplices must have the
so-called \textbf{Delaunay} or \textbf{empty-ball} property: the interior of
a ball circumscribing any face of a Delaunay simplex must be free from any
vertex of the complex.

%The class \ccc{CGAL::Regular_triangulation<RegularTraits, TDS>} is a generalization of
%the Delaunay triangulation.

%The rest of this user manual gives more details about these classes and the
%data they store, but does not tell the whole story. For the latter, the user
%should have a look at the reference manual of this package. 
%A last remark:
%pure complexes are also called \emph{triangulations}. We feel more confortable
%in using the word \emph{complexes} as it forces us to think ``in dimension
%higher than 3''.

\paragraph{Further definitions}

An $i$-face denotes an $i$-dimensional simplex, or a simplex
with $i+1$ (affinely independent if embedded) vertices.

If the maximal dimension of a simplex in the simplicial complex is
$d$, we call:\\
--- an $i$-face for some $i\in[0,d]$ a  \textbf{face};\\
--- a $(d-2)$-face a \textbf{ridge};\\
--- a $(d-1)$-face a \textbf{facet}; and\\
--- a $d$-face  a \textbf{full cell}.

In particular, vertices are $0$-faces.

Two faces $\sigma$ and $\sigma'$ are \textbf{incident} if and only if
$\sigma'$ is a proper sub-face of $\sigma$ or \emph{vice versa}.

\section{Triangulation data structure\label{triangulation:tds}}

\newcommand{\tds}{\ccc{TDS}}
\newcommand{\ad}{\ensuremath{D}}
\newcommand{\cd}{\ensuremath{d}}

In this section, we describe the concept \ccc{TriangulationDataStructure} for
which \cgal\ provides one model class:
\ccc{CGAL::Triangulation_data_structure<Dimensionality, TDSVertex,
TDSFullCell>}.  For simplicity, we use the abbreviation \tds.

A \tds\ can not represent any abstract pure complex, but rather the
combinatorial nature of a (geometric) triangulation. For example, a facet
may be incident to arbitrarily many simplices in an abstract pure complex, but
to at most two in a \tds\ (and in fact exactly two as we explain below).

A \tds\ has a property called the \textbf{ambient dimension} which is a
positive integer equal to the maximum dimension a full cell can have.
This ambient dimension can be chosen by the user at the creation of a \tds\
and can then be queried using the method \ccc{tds.ambient_dimension()}.
A \tds\ also knows the \textbf{current dimension} of its full cells,
which can be queried with \ccc{tds.current_dimension()}. In the sequel, let
us denote the ambient dimension with \ad\ and the current dimension with \cd.
It always holds that $\ad>0$ and $\cd\le\ad$.

\paragraph{On the \ccc{Facet} nested type}

\note{A mon avis ce paragraphe est pas tres approprie, en 3D le type
\ccc{Cell} est utilise en dimension degenere}

In the \ccc{Triangulation_3} \cgal\ package, the ambient dimension is always
3. With respect to this reference dimension (3), a \ccc{Facet} is always a
2-face (triangle),
irrespective of the 3D triangulation's current dimension. In
particular, full cells in degenerate planar 3D triangulation are
\ccc{Facet}s, not \ccc{Cell}s.

By contrast, in the present \ccc{Triangulation} \cgal\ package, the reference
dimension of a pure complex (or a pure complex data structure) is its current
dimension. This means that, whatever the current dimension is, a full
cell is always represented by the \ccc{FullCell} nested type, And a
\ccc{Facet} represents a face of dimension \ccc{current_dimension()-1}
\textbf{and not} \ccc{ambient_dimension()-1}.

\newcommand{\sphere}{\ensuremath{\mathcal S}}

\paragraph{The data structure triangulates $\sphere^\cd$}

In a first approximation,
a \tds, can be viewed as
a \emph{triangulation} of the topological sphere $\sphere^\cd$,
\emph{i.e.}, its faces can be embedded to form a partition of $\sphere^\cd$ into $\cd$-simplices. When a
\tds\ is used as the combinatorial part of a geometric triangulation, one
vertex of the \tds\ will be the \textbf{vertex at
infinity}; we can consider that the triangulation covers the whole
affine hull of its vertices
using \textbf{infinite} or \textbf{unbounded} cells to fill the space  outside the convex
hull of the triangulation's finite vertices. (More details are given in the next section.)

One nice consequence of the above important fact is that the $\cd+1$ neighbors
of a full cell always exist.

Values of $\cd$ (the \emph{current dimension} of the complex) include
\begin{itemize}
\item[$\cd=-2$] This corresponds to the non-existence of any object in
$\sphere^\ad.$
\item[$\cd=-1$] This corresponds to a single vertex and a single cell. In a
geometric triangulation, this vertex corresponds to the vertex at infinity.
\item[$\cd=0$] This corresponds to two vertices, each adjacent to one $0$-simplex;
the two cells being neighbor of each other. This is the unique
triangulation of the $0$-sphere.
\item[$0<\cd\le\ad$] This corresponds to a standard triangulation of
the sphere $\sphere^\cd$.
\end{itemize}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - TDS IMPLEMENTATION

\subsection{The class \ccc{Triangulation_data_structure}\label{triangulation:tds:impl}}

We give here some details about the class
\ccc{Triangulation_data_structure<Dimensionality, TDSVertex, 
TDSFullCell>}
implementing the concept \ccc{TriangulationDataStructure}.


\paragraph{Storage}

A \tds\ explicitely stores its vertices and full cells.

Each vertex stores a reference (a \ccc{Handle}) to one of its incident
full cell.

A full cell $\sigma'$ adjacent to the full cell $\sigma$ is called
a \textbf{neighbor} of $\sigma$ (and $\sigma$ is also a neighbor of
$\sigma'$). Each full cell stores references to its $\cd+1$ vertices and
neighbors. Its vertices and neighbors are indexed from $0$ to \cd. The indexes
of its neighbors have the following meaning: the $i$-th neighbor of $\sigma$
is the unique neighbor of $\sigma$ that does not contain the $i$-th vertex of
$\sigma$; in other words, it is the neighbor of $\sigma$ \textbf{opposite} to
the $i$-th vertex of $\sigma$.

\begin{figure}[htbp]
\begin{ccTexOnly}
\begin{center}
\includegraphics{Triangulation/fig/simplex-structure.pdf}
\end{center}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<center>
<img border=0 src="./fig/simplex-structure.png" align="middle" alt="Index the vertices and neighbors of a simplex">
</center>
\end{ccHtmlOnly}
\caption{Indexing the vertices and neighbors of a simplex $s$.}
\label{triangulation:fig:simplex}
\end{figure} 

\paragraph{Instanciating the class template}

The \ccc{Triangulation_data_structure<Dimensionality, TDSVertex, TDSFullCell>}
class template is designed in such a way that its user can choose
\begin{itemize}
\item the ambient dimension of the pure complex data structure,
\item the type used to represent vertices, by specifying the \ccc{TDSVertex}
template parameter and
\item the type used to represent simplices, by specifying the
\ccc{TDSFullCell} template parameter.
\end{itemize}

The last two parameters have default values and are thus not necessary, unless
the user needs custom types (see the reference manual page for this class
template). The first template parameter, \ccc{Dimensionality}, must be either
\begin{itemize}
\item \ccPureGlobalScope\ccc{Dimension_tag<D>} for some integer \ad. This
indicates that the pure complex can store simplices of dimension at most
\ad. The maximum dimension \ad\ is known by the compiler, which
triggers some optimizations. Or
\item \ccPureGlobalScope\ccc{Dynamic_dimension_tag}. In this case, the maximum
dimension of the simplices must be passed as an integer argument to an instance
constructor (see \ccc{TriangulationDataStructure}).
\end{itemize}

The \ccc{TDSVertex} and \ccc{TDSFullCell} parameters to the class template
must be models of the concepts \ccc{TriangulationDSVertex} and
\ccc{TriangulationDSFullCell} respectively. \cgal\ provides models for these
concepts: \ccc{Triangulation_ds_vertex<TDS>} and
\ccc{Triangulation_ds_simplex<TDS, TDSFullCellStoragePolicy>}, which, as one
can see, take the \tds\ as a template parameter in order to get access to
some nested types in \tds.

\textbf{This creates a circular dependency}, which we resolve in the same way
as in the \cgal\ \ccc{Triangulation_3} package (see FIXME). Thus, models of
the concepts \ccc{Triangulation_ds_vertex<TDS>} and
\ccc{Triangulation_ds_simplex<TDS, TDSFullCellStoragePolicy>} (typically a
user's custom classes) must provide a nested template \ccc{Rebind_TDS} which
is documented in those two concept's reference manual pages.

\begin{ccAdvanced}
Thus, to the user in need of a custom vertex of simplex class, we recommend
the reading of the documentation of the \cgal\ \ccc{Triangulation_3} package.
\end{ccAdvanced}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - TDS EXAMPLES

\subsection{Examples\label{triangulation:tds:examples}}
 
\paragraph{Incremental Construction}
The following example shows how to construct a pure complex data structure by
inserting vertices. The reader will make the best use of this example by
reading it slowly, together with the reference manual documentation of the
methods that are called (see here: \ccc{TriangulationDataStructure}).

\ccIncludeExampleCode{Triangulation/triangulation_data_structure.cpp}


% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - TRIANGULATIONS

\section{Triangulations}

The class \ccc{CGAL::Triangulation<TrTraits, TDS>} embeds an abstract pure
complex in euclidean space, thus forming a pure complex. More precisely, it
maintains a triangulation (a partition into pairwise interior-disjoint full
cells) of the convex hull of the points (the embedded vertices) of the
pure complex, as well as a triangulation of the complement of the convex hull
\textbf{in the affine subspace} spanned by the complex's points.

Methods are provided for the insertion of points in the complex, the
contraction of faces, the traversal of various elements of the complex
as well as the localization of a query point inside the complex.

Unbounded (or infinite) simplices outside the convex hull are each incident to
a finite facet on the convex hull of the complex and to a unique special
\textbf{vertex at infinity}. In every infinite simplex, the vertex at infinity
always has index $0$.

As long as no \emph{advanced} class method is called, it is guaranteed that
all finite simplices have positive orientation. The infinite simplices are
oriented so that the convex hull of the complex lies on the negative side of
the oriented hyperplane defined by the simplex's finite facet.


% - - - - - - - - - - - - - - - - - - - - - - - - - Triangulation IMPLEMENTATION

\subsection{Implementation}

The class \ccc{CGAL::Triangulation<TrTraits, TDS>} stores a model \ccc{TDS}
of the concept \ccc{TriangulationDataStructure} which is instanciated with a
vertex type that stores a point, and a simplex type that allows the retrieval
of the point of its vertices.

The template parameter \ccc{TrTraits} must be a model of the concept
\ccc{TriangulationTraits} which provides the geometric \ccc{Point} type as well
as various geometric predicates used by the \ccc{Triangulation} class.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - Triangulation EXAMPLES

\subsection{Examples}

\paragraph{Incremental Construction}

The following example shows how to construct a pure complex in which we insert
random points. In \ccc{STEP 1}, we generate one hundred random points in
$\real^5$, which we then insert into a pure complex. In \ccc{STEP 2}, we have
a little fun and ask the pure complex to construct the set of edges
($1$-simplices) incident to the vertex at infinity. It is easy to see that
these edges are in bijection with the vertices on the convex hull of the
points. This gives us a handy way to count the convex hull vertices.

\ccIncludeExampleCode{Triangulation/triangulation.cpp}

\paragraph{Traversing the facets of the convex hull}

Remember that a pure complex triangulates the convex hull of its points. Each
facet of the convex hull is adjacent to one finite simplex and one infinite
simplex. In fact there is a bijection between the infinite simplices and the
facets of the convex hull. So, in order to traverse the convex hull facets,
there are (at least) two possibilities:

The first is to iterate over the simplices of the complex and check if they
are infinite or not:

\begin{ccExampleCode}
Triangulation t;

// ... insert points in the pure complex here.

typedef Triangulation::Simplex_iterator Simplex_iterator;
typedef Triangulation::Facet Facet;

for( Simplex_iterator sit = t.simplices_begin(); sit != t.simplices_end(); ++sit )
{
    if( t.is_finite(sit) )
        continue;
    Facet ft(sit, 0); // |ft| is a facet of the convex hull
}
\end{ccExampleCode}
(\textbf{Remark}: the code example above will not compile unless you provide
the missing \ccc{typedef}s and variables declarations.)

A second possibility is to ask the pure complex to gather all the simplices
incident to the infinite vertex: they form precisely the set of infinite
simplices:

\begin{ccExampleCode}
Triangulation t;

// ... insert points in the pure complex here.

typedef Triangulation::Simplex_handle Simplex_handle;
typedef Triangulation::Facet Facet;
typedef std::vector<Simplex_handle> Simplices;

Simplices infinite_simplices;
std::back_insert_iterator<Simplices> out(infinite_simplices);

t.gather_incident_simplices(t.infinite_vertex(), out);

for( Simplices::iterator sit = infinite_simplices.begin(); sit != infinite_simplices.end(); ++sit )
{
    Facet ft(*sit, 0); // |ft| is a facet of the convex hull
}
\end{ccExampleCode}
(\textbf{Remark}: the code example above will not compile unless you provide
the missing \ccc{typedef}s and variables declarations.)

One important difference between the two examples above is that the first uses
\emph{little} memory but traverses \emph{all} the simplices, while the second
visits \emph{only} the infinite simplices but stores handles to them into a
\emph{potentially big} array.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - DELAUNAY TRIANGULATIONS

\section{Delaunay triangulations}%and regular complexes}

The class \ccc{CGAL::Delaunay_complex<DCTraits, TDS>} derives from
\ccc{CGAL::Triangulation<Triangulation Traits, TDS>} and adds further constraints to a
pure complex, in that all its simplices must have the so-called
\textbf{Delaunay} or \textbf{empty-ball} property: the interior of a ball
circumscribing any simplex of a Delaunay simplex must be free from any vertex
of the complex.

The \textbf{circumscribing sphere} of a simplex \ccc{s} is the smallest sphere
touching all vertices of the simplex. A pure complex triangulating the convex
hull of a finite point set has the Delaunay (or empty-ball) property if all
its simplices have the Delaunay (or empty-ball) property.

Informally, a finite simplex has the Delaunay (or empty-ball) property---with
respect to the complex---if no point of the complex lies in the interior of
its circumscribing sphere.

When a new point \ccc{p} is inserted into a Delaunay complex, the set of
finite simplices whose circumscribing sphere contains \ccc{p} are said to
\textbf{be in conflict} with point \ccc{p}. The set of simplices that are in
conflict with \ccc{p} form the \textbf{conflict zone}. That conflict zone is
augmented with the infinite simplices whose finite facet does not lie
anymore on the convex hull of the complex (with \ccc{p} added). The simplices
in the conflict zone are removed, leaving a hole that contains \ccc{p}. That
hole is then re-triangulated in a ``star shape'' centered at \ccc{p}.

% - - - - - - - - - - - - - - - - - - - - - - - - - DELAUNAY IMPLEMENTATION

\subsection{Implementation}

The class \ccc{CGAL::Delaunay_complex<DCTraits, TDS>} derives from
\ccc{CGAL::Triangulation<DCTraits, TDS>}. It thus stores a model \ccc{TDS} of
the concept \ccc{TriangulationDataStructure} which is instanciated with a vertex
type that stores a geometric point, and a simplex type that allows the
retrieval of the point of its vertices.

The template parameter \ccc{DCTraits} must be a model of the concept
\ccc{DelaunayComplexTraits} which provides the geometric \ccc{Point} type as
well as various geometric predicates used by the \ccc{Delaunay_complex} class.
The concept \ccc{DelaunayComplexTraits} refines the concept
\ccc{TriangulationTraits} by requiring a few other geometric predicate necessary
for the computation of Delaunay complexes.

% - - - - - - - - - - - - - - - - - - - - - - - - - - - - DELAUNAY EXAMPLES

\subsection{Examples}

\paragraph{Access to the conflict zone and created simplices during point
insertion}

When using a simplex type containing additional custom information, it may be
useful to get an efficient access to the simplices that are going to be erased
upon the insertion of a new point in the Delaunay complex, and to the newly
created simplices. The code example below shows how one can have efficient
access to both the conflict zone and the created simplices, while still
retaining an efficient update of the Delaunay complex.

\textbf{Remark}: the code below will not compile unless you provide the
missing \ccc{typedef}s and variables declarations.

\begin{ccExampleCode}
Delaunay_complex dc;
Vertex_handle v;
// Conflict zone in dimension 0 or 1 are pretty boring.
assert( 2 <= dc.current_dimension() );

// We insert the points stored in the vector |points|.
for( pit = points.begin(); pit != points.end(); ++pit )
{
    Face           f = dc.make_empty_face();
    Facet          ft;
    Simplex_handle s;
    Locate_type    lt;

    s = dc.locate(*pit, lt, f, ft, v);

    if(    lt == Delaunay_complex::ON_VERTEX
        || lt == Delaunay_complex::OUTSIDE_AFFINE_HULL )
    {
        // There is, a priori, no simplex of interest here.
        v = t.insert(*pit, lt, f, ft, s);
    }
    else
    {
        typedef std::vector<Simplex_handle> Simplices;
        Simplices conflict_zone, new_simplices;
        std::back_insert_iterator<Simplices> out(conflict_zone);
        Facet ftc = dc.compute_conflict_zone(*pit, s, out);
        /*----------------------------------------------------\
        | Here, do something with the conflict zone simplices |
        | stored in |conflict_zone|.                          |
        | DO NOT MODIFY the vector |conflict_zone|.           |
        \----------------------------------------------------*/
        out = std::back_inserter(new_simplices);
        v = dc.insert_in_hole(p, conflict_zone.begin(), conflict_zone.end(), ftc, out);
        /*-----------------------------------------------------\
        |  Here, do something with the newly created simplices |
        |  stored in |new_simplices|.                          |
        \-----------------------------------------------------*/
    }
}
\end{ccExampleCode}

\section{Complexity and performances}

\note{todo}

\section{Design and Implementation History}

This package is heavily inspired by the works of Michael Seel
(\ccc{Kernel_d}), Monique Teillaud and Sylvain Pion (\ccc{Triangulation_3})
and Mariette Yvinec (\ccc{Triangulation_2}).
The first version was written by Samuel Hornus and then
pursued by Samuel Hornus and Olivier Devillers.
}
