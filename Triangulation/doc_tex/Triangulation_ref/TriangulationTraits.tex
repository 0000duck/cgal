\begin{ccRefConcept}{TriangulationTraits}

\ccDefinition

The concept \ccRefName\ describes the various types and functions that a class
must provide as the first parameter (\ccc{TrTraits}) to the class template
\ccc{Triangulation<TrTraits, TDS>}. It brings the geometric ingredient to the
definition of a triangulation, while the combinatorial ingredient is brought by
the second template parameter, \ccc{TDS}.

Inserting a range of points in a triangulation is optimized using
spatial sorting, thus besides the requirements below, 
a class provided as \ccc{TrTraits} should also satisfies the concept 
\ccc{SpatialSortingTraits_d}.

\ccRefines
\ccc{SpatialSortingTraits_d}

{If range of points are inserted, the
  traits must refine \ccc{SpatialSortingTraits_d}, this is not needed
  if the points are inserted one by one.}

\ccTypes

\ccNestedType{Point_d}%
{A type representing a point in Euclidean space.}


\ccNestedType{Point_dimension_d}%
       {Functor object type returning the dimension of a  \ccc{Point_d}.
       Must provide 
        \ccc{int operator()(Point_d p)}  returning the dimension of $p$. 
       }

\ccNestedType{Orientation_d}{A predicate object that must provide the
templated operator\\\ccc{template<typename ForwardIterator> Orientation
operator()(ForwardIterator start, ForwardIterator end)}.\\The operator returns
\ccc{POSITIVE}, \ccc{NEGATIVE} or \ccc{COPLANAR}  depending on
the orientation of the simplex defined by the points in the range \ccc{[start,
end)}.
 \ccPrecond \ccc{std::distance(start,end)=D+1}, where 
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in \ccc{[start,end)}.
}

\ccNestedType{Contained_in_affine_hull_d}{A predicate object that must provide
the templated operator\\\ccc{template<typename ForwardIterator> bool
operator()(ForwardIterator start, ForwardIterator end, const Point_d &
p)}.\\The operator returns \ccc{true} if and only if point \ccc{p} is
contained in the affine space spanned by the points in the range \ccc{[start,
end)}. That affine space is also called the \textbf{affine hull} of the points
in the range.
\ccPrecond  The $k$ points in the range
must be affinely independent. 
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in
\ccc{[start,end)}.
$2\leq k\leq D$.
}

\ccNestedType{Flat_orientation_d}{
  A type representing an orientation of an affine subspace of
  dimension $k$ strictly smaller than the ambiant dimension.
}


\ccNestedType{Construct_flat_orientation_d}{
   A construction object that must 
provide the templated operator\\\ccc{template<typename ForwardIterator> Flat_orientation_d
operator()(ForwardIterator start, ForwardIterator end)}.\\The operator
return an orientation of the flat spanned by the points in
the range \ccc{R=[start, end)}. \ccPrecond The $k$ points in the range
must be affinely independent. 
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in \ccc{R}.
$2\leq k\leq D$.
}


\ccNestedType{In_flat_orientation_d}{
A predicate object that must provide the
templated operator\\\ccc{template<typename ForwardIterator> Orientation
operator()(Flat_orientation_d orient,ForwardIterator start,
ForwardIterator end)}.\\
The operator returns
\ccc{POSITIVE}, \ccc{NEGATIVE} or \ccc{COPLANAR}  depending on
the orientation of the simplex defined by the points in the range \ccc{[start,
end)}.
The points are supposed to belong to the lower dimensional flat
 whose orientation is given by \ccc{orient}.
\ccPrecond \ccc{std::distance(start,end)=k} where $k$ is the number of
points
used to construct \ccc{orient}.
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in
\ccc{[start,end)}.
$2\leq k\leq D$.
}




\ccNestedType{Compare_lexicographically_d}{A predicate object that must
provide the operator\\\ccc{Comparison_result operator()(const Point_d & p,
const Point_d & q)}.\\The operator returns \ccc{SMALLER} if \ccc{p} is
lexicographically smaller than point \ccc{q}, \ccc{EQUAL} if both points are
the same and \ccc{LARGER} otherwise.}

%%%%%%% currently unused in the code
% \ccNestedType{Affinely_independent_d}{A predicate object that must provide the
% templated operator\\\ccc{template<typename ForwardIterator> bool
% operator()(ForwardIterator start, ForwardIterator end)}.\\The operator returns
% \ccc{true} if and only if the dimension of the affine hull of the points in
% the range \ccc{R=[start, end)} is one less than the number of points in
% \ccc{R}.}

\ccCreation
\ccCreationVariable{traits}

\ccConstructor{TriangulationTraits();}{The default constructor.}

\ccOperations

The following methods permit access to the traits class's predicates:

\ccMethod{Orientation_d orientation_d_object() const;}%
{}
\ccGlue
\ccMethod{Contained_in_affine_hull_d contained_in_affine_hull_d_object()
const;}%
{}
\ccGlue
\ccMethod{Construct_flat_orientation_d construct_flat_orientation_d_object() const;}%
{}
\ccGlue
\ccMethod{In_flat_orientation_d in_flat_orientation_d_object() const;}%
{}
\ccGlue
\ccMethod{Compare_lexicographically_d compare_lexicographically_d_object()
const;}%
{}
%\ccGlue
%\ccMethod{ Affinely_independent_d affinely_independent_d_object() const;}%
%{}

\ccHasModels

\ccc{Cartesian_d<FT, Dim, LA>},\\
%\ccc{Simple_cartesian_d<FT, Dim, LA>},\\
\ccc{????<K>} (recommended).
\note{The new kernel is currently under developement}

\ccSeeAlso

\ccc{DelaunayTriangulationTraits}


\end{ccRefConcept}
