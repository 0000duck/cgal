
\begin{ccRefConcept}{DelaunayTriangulationTraits}

\ccDefinition

The concept \ccRefName\ describes the various types and functions that a class
has to provide as the first parameter (\ccc{DCTraits}) to the class template
\ccc{Delaunay_triangulation<DTTraits, TDS>}. It brings the geometric ingredient to
the definition of a Delaunay complex, while the combinatorial ingredient is
brought by the second template parameter, \ccc{TDS}.

\ccRefines

\ccc{TriangulationTraits}.

\ccTypes

%\ccNestedType{Point_d}{This nested type is defined in the ``parent'' concept
%\ccc{TriangulationTraits}.}

\ccNestedType{Side_of_oriented_sphere_d}{A predicate object that must provide
the templated operator\\\ccc{template<typename ForwardIterator> Oriented_side
operator()(ForwardIterator start, ForwardIterator end, const Point_d &
p)}.\\The operator returns \ccc{ON_POSITIVE_SIDE},
\ccc{ON_NEGATIVE_SIDE} 
or \ccc{ON_ORIENTED_BOUNDARY}  depending of the side of the query
point \ccc{p}
 with respect to the sphere circumscribing the simplex
defined by the points in range \ccc{[start,end)}. 
If the simplex is positively
oriented, then the positive side of sphere corresponds geometrically
to its bounded side.
%\\ The range's size must of course be one more
%than the dimension of the Euclidean space the points live in: 
\ccPrecond
 \ccc{std::distance(start,end)=D+1}, where 
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in
\ccc{[start,end)}. \ccc{Point_dimension_d(p)} is also $D$
 The points in range
\ccc{[start,end)} must be affinely independent, \emph{i.e.,} the simplex must
not be flat.}

\ccNestedType{In_flat_side_of_oriented_sphere_d}{A predicate object that must
provide the templated operator\\
\ccc{template<typename ForwardIterator>
Oriented_side operator()(Flat_orientation_d orient, ForwardIterator start, ForwardIterator end, const
Point_d & p)}.\\
The operator returns \ccc{ON_POSITIVE_SIDE},
\ccc{ON_NEGATIVE_SIDE} 
or \ccc{ON_ORIENTED_BOUNDARY}  depending of the side of the query
point \ccc{p}
 with respect to the sphere circumscribing the simplex
defined by the points in range \ccc{[start,end)}. 
If the simplex is positively
oriented according to \ccc{orient}, 
then the positive side of sphere corresponds geometrically
to its bounded side. 
The points in range \ccc{[start,end)} and \ccc{p} are supposed to belong to the lower dimensional flat
 whose orientation is given by \ccc{orient}.
\ccPrecond 
 \ccc{std::distance(start,end)=k} where $k$ is the number of
points used to construct \ccc{orient}.
\ccc{Point_dimension_d(*it)} is $D$ for all \ccc{it} in
\ccc{[start,end)}. \ccc{Point_dimension_d(p)} is also $D$.
 The points in range
\ccc{[start,end)} must be affinely independent, \emph{i.e.,} the simplex must
not be flat.
}



%%%%%%%% currently unused
% \ccNestedType{Center_of_sphere_d}{A construction object that must
% provide the templated operator\\\ccc{template<typename ForwardIterator> bool
% operator()(ForwardIterator start, ForwardIterator end)}.\\The operator
% constructs the center of the sphere circumscribing the points in
% the range \ccc{R=[start, end)}. \ccPrecond The number of points in the range
% must be equal to one more than the dimension of the Euclidean space the points
% live in, \emph{i.e.}, \ccc{std::distance(start,end)} is equal to \ccc{start->dimension()+1}.}


\ccCreation
\ccCreationVariable{traits}

\ccConstructor{DelaunayTriangulationTraits();}{The default constructor.}

\ccOperations

The following methods permit access to the traits class's predicates:

\ccMethod{Side_of_oriented_sphere_d side_of_oriented_sphere_d_object() const;}
{}
\ccGlue
\ccMethod{In_flat_side_of_oriented_sphere_d in_flat_side_of_oriented_sphere_d_object()
const;}
{}

%%%%%%% unused !
%\ccGlue
%\ccMethod{ Center_of_sphere_d center_of_sphere_d_object()
%const;}%
%{}

\ccHasModels

\ccc{Cartesian_d<FT, Dim, LA>},\\
\ccc{Simple_cartesian_d<FT, Dim, LA>},\\
\ccc{Filtered_kernel_d} (recommended)

\ccSeeAlso

\ccc{TriangulationTraits}

\end{ccRefConcept}
