\begin{ccRefClass}{Triangulation<TrTraits, TDS>}

\ccDefinition

The class \ccRefName\ is used to store and query the cells and vertices of
a triangulation embedded in $\real^d$.

\ccInclude{CGAL/Triangulation.h}

\ccParameters

\ccc{TrTraits} is the geometric traits class that provides the geometric types
and predicates needed by triangulations. \ccc{TrTraits} must be a model of the
concept \ccc{TriangulationTraits}.

\ccc{TDS} is the class used to store the underlying triangulation data
structure. \ccc{TDS} must be a model of the concept
\ccc{TriangulationDataStructure}. The class template \ccRefName\ accepts that no
second parameter be specified. It also accepts the tag \ccc{CGAL::Default} as
second parameter. In both cases, \ccc{TDS} defaults to
\ccc{Triangulation_data_structure<Ambient_dimension<TrTraits::Point_d>::type,
Triangulation_vertex<TrTraits>, Triangulation_full_cell<TrTraits>>}.

\ccTypes

%The following types are self-explanatory: % but we are explaining anyway

\ccTypedef{typedef TrTraits Geom_traits;}%
{The model for the \ccc{TriangulationTraits} concept.}

\ccTypedef{typedef  TrTraits::Point_d Point;}{A point in euclidean space.}

\ccTypedef{typedef Ambient_dimension<TrTraits::Point_d>::type
 Ambient_dimension;}%
{This indicates whether the dimension of the ambient euclidean space is static
(\ccc{Ambient_dimension}=\ccGlobalScope\ccc{Dimension_tag<int dim>}) or
dynamic (\ccc{Ambient_dimension}=\ccGlobalScope\ccc{Dynamic_dimension_tag}).
In the latter case, the \ccc{dim} parameter passed to the class's constructor
is used.}

\ccTypedef{typedef TDS Triangulation_ds;}%
{The second template parameter.}

\ccTypedef{typedef TDS::Vertex Vertex;}{A model of the concept
\ccc{TriangulationVertex}.}
\ccGlue
\ccTypedef{typedef TDS::Full_cell Full_cell;}{A model of the concept
\ccc{TriangulationFullCell}.}
\ccGlue
\ccTypedef{typedef TDS::Facet Facet;}{}
\ccGlue
\ccTypedef{typedef TDS::Face Face;}%
{A model of the concept \ccc{TriangulationFace}.}

The vertices and cells of triangulations are accessed through handles,
iterators and circulators. A handle is a model of the \ccc{Handle} concept,
and supports the two dereference operators \ccc{operator*} and
\ccc{operator->}. A circulator is a model of the concept \ccc{Circulator}.
Iterators and circulators are bidirectional and non-mutable.
%The edges and facets of the triangulation can also be visited through
%iterators and circulators which are bidirectional and non-mutable.

Iterators and circulators are convertible to the corresponding handles, thus
the user can pass them directly as arguments to the functions.

\ccTypedef{typedef  TDS::Vertex_handle            Vertex_handle;}{}
\ccGlue\ccTypedef{typedef  TDS::Vertex_iterator    Vertex_iterator;}{}
%\ccGlue\ccTypedef{typedef TDS::Vertex_const_handle Vertex_const_handle;}{}
%\ccGlue\ccTypedef{typedef TDS::Vertex_const_iterator Vertex_const_iterator;}{}

\ccTypedef{typedef  TDS::Full_cell_handle           Full_cell_handle;}{}
\ccGlue\ccTypedef{typedef  TDS::Full_cell_iterator         Full_cell_iterator;}{}
%\ccGlue\ccTypedef{typedef TDS::Full_cell_const_handle Full_cell_const_handle;}{}
%\ccGlue\ccTypedef{typedef TDS::Full_cell_const_iterator Full_cell_const_iterator;}{}

\ccTypedef{typedef  TDS::Facet_iterator Facet_iterator;}{}

\ccTypedef{typedef TDS::size_type size_type;}{Size type (an unsigned integral
type).}
\ccGlue\ccTypedef{typedef TDS::difference_type difference_type;}{Difference
type (a signed integral type).}

The \ccRefName\ class also defines the following enum type to specify
which case occurs when locating a point in the triangulation:

\ccEnum{
enum  Locate_type
{
      ON_VERTEX
    , IN_FACE
    , IN_FACET
    , IN_FULL_CELL
    , OUTSIDE_CONVEX_HULL
    , OUTSIDE_AFFINE_HULL
};}{See \ccc{CGAL::Triangulation::Locate_type}}

\ccCreation
\ccCreationVariable{tr}

\ccConstructor{Triangulation(const int dim, const Geom_traits & k =
Geom_traits())}
{Instantiates a triangulation with one vertex (the vertex at infinity). See the
description of the nested type \ccc{Ambient_dimension} above for an
explanation of the use of the parameter \ccc{dim}. The triangulation stores a copy
of the geometric traits \ccc{k}.}

\ccConstructor{Triangulation(const Triangulation & t2);}
{The copy constructor. All vertices and full cells are duplicated.}

\ccHeading{Access functions}

\ccMethod{const Triangulation_ds & tds() const;}%
{Returns a const reference to the underlying triangulation data structure.}

\begin{ccAdvanced}
\ccMethod{Triangulation_ds & tds();}%
{Returns a %(non-const) 
reference to the underlying triangulation data structure.
The responsability of keeping the data structure valid belongs to the
user when using advanced operations.}
\end{ccAdvanced}

\ccMethod{const Geom_traits & geom_traits() const;}%
{Returns a const reference to the geometric traits instance.}

\ccMethod{int ambient_dimension() const;}%
{Returns the dimension of the embedding euclidean space.}
\ccGlue
\ccMethod{int current_dimension() const;}%
{Returns the dimension of the triangulation (as an embedded manifold).}

\ccMethod{bool empty() const;}%
{Returns \ccc{true} if the triangulation has no finite vertex. Returns
\ccc{false} otherwise.}
\ccGlue
\ccMethod{size_type number_of_vertices() const;}%
{Returns the number of finite vertices in the triangulation.}
\ccGlue
\ccMethod{size_type number_of_full_cells() const;}%
{Returns the number of cells of maximal dimension in the triangulation
(cells incident to the vertex at infinity are counted).}

\ccMethod{Vertex_handle infinite_vertex() const;}%
{Returns a handle to the vertex at infinity.}

\ccMethod{Full_cell_handle infinite_full_cell() const;}%
{Returns a handle to some cell incident to the vertex at infinity.}

\ccHeading{Non-constant-time access functions}

\ccMethod{size_type number_of_finite_full_cells() const;}%
{Returns the number of cells of maximal dimension that are not
  incident to the vertex at infinity.}

\ccHeading{Tests for finite and infinite elements}

\ccMethod{bool is_infinite(const Vertex_handle v) const;}
{Returns \ccc{true} if and only if the vertex \ccc{v} is the infinite vertex.}

\ccGlue

\ccMethod{bool is_infinite(const Full_cell_handle s) const;}
{Returns \ccc{true} if and only if \ccc{s} is incident to the infinite vertex.
%\ccPrecond $0\leq$\ccVar.\ccc{current_dimension()}.
}

\ccGlue

\ccMethod{bool is_infinite(const Facet & ft) const;}
{Returns \ccc{true} if and only if facet \ccc{ft} is incident to the infinite
vertex. 
%\ccPrecond$1\leq$\ccVar.\ccc{current_dimension()}.
}
\note{SH: en dimension 0, la notion de Facet n'a pas de sens}

\ccGlue

\ccMethod{bool is_infinite(const Face & f) const;}{Returns \ccc{true} if and
only if the face \ccc{f} is incident to the infinite vertex. 
%\ccPrecond $2\leq$\ccVar.\ccc{current_dimension()}.
}
\note{OD: je comprends pas bien toute ces preconditions, je les vire,
et je vire aussi les is-finite.}
\note{SH: en dimension 0 et 1, la notion de Face n'a pas de sens}

% \ccMethod{bool is_finite(const Vertex_handle v) const;} {Returns \ccc{true} if
% and only if the vertex \ccc{v} is not the infinite vertex.}

% \ccGlue

% \ccMethod{bool is_finite(const Full_cell_handle s) const;}{Returns \ccc{true} if
% and only if all vertices of \ccc{s} are finite. 
% %\ccPrecond\ccc{0 <=}\ccVar.\ccc{current_dimension()}.
% }

% \ccGlue

% \ccMethod{bool is_finite(const Facet & ft) const;}{Returns \ccc{true} if and
% only if all vertices of the facet \ccc{ft} are finite. 
% %\ccPrecond\ccc{1 <=}\ccVar.\ccc{current_dimension()}.
% }

% \ccGlue

% \ccMethod{bool is_finite(const Face & f) const;}{Returns \ccc{true} if and
% only if all vertices of the face \ccc{f} are finite. 
% %\ccPrecond{\ccc{2 <=}\ccVar.\ccc{current_dimension()}}.
% }

\ccHeading{Queries}

\ccMethod{bool is_vertex(const Point & p, Vertex_handle & v) const;} {Tests
whether \ccc{p} is a vertex of \ccVar\ by locating \ccc{p} in the triangulation.  If
\ccc{p} is found, the associated vertex \ccc{v} is given.}

\ccGlue\ccMethod{bool is_vertex(const Point & p, Vertex_handle & v,
Full_cell_handle hint) const;} {Same as above.  The \ccc{Full_cell_handle hint} is
an optional parameter that is used as a hint for the point location.}

\ccGlue\ccMethod{bool is_vertex(Vertex_handle v) const;}
{Tests whether \ccc{v} is a vertex of \ccVar.}

\ccMethod{bool is_full_cell(Full_cell_handle c) const;}
{Tests whether \ccc{c} is a cell of \ccVar.}

\ccMethod{Orientation orientation(Full_cell_const_handle c) const;}
{Returns the orientation of the finite cell \ccc{c}:
\ccGlobalScope\ccc{POSITIVE}, \ccGlobalScope\ccc{NEGATIVE} or
\ccGlobalScope\ccc{COPLANAR}. If \ccVar.\ccc{current_dimension() == 0}, then
\ccGlobalScope\ccc{POSITIVE} is returned. Under normal circumstances, the function
should always return \ccGlobalScope\ccc{POSITIVE}.
\ccPrecond Full cell \ccc{c} must be finite.
\note{should be removed, a valid cell is positive}\note{SH: what if user modifies the triangulation arbitrarily?}
}

\ccMethod{template< typename OutputIterator > OutputIterator
incident_full_cells(Vertex_const_handle v, OutputIterator out) const;}
{Insert in \ccc{out} all the cells that are incident to the vertex
\ccc{v}, \emph{i.e.}, the cells that have the \ccc{Vertex v} as a vertex.
Returns the (modified) output iterator.
%\ccPrecond\ccc{is_full_cell(f.full_cell())}.
}

\ccMethod{template< typename OutputIterator > OutputIterator
incident_full_cells(const Face & f, OutputIterator out) const;}
{Insert in \ccc{out} all the cells that are incident to the face \ccc{f},
\emph{i.e.}, the cells that have the \ccc{Face f} as a subface.
Returns the (probably modified) output iterator.
%\ccPrecond\ccc{is_full_cell(f.full_cell())}.
}

\ccMethod{template< typename OutputIterator > OutputIterator
star(const Face & f, OutputIterator out) const;}
{Insert in \ccc{out} all the cells that share at least one vertex with the \ccc{Face
f}. Returns the (probably modified) output iterator.
%\ccPrecond\ccc{is_full_cell(f.full_cell())}.
}

\ccMethod{template< typename OutputIterator > OutputIterator
incident_faces(Vertex_handle v, const int d, OutputIterator
out);}{Constructs all the \ccc{Face}s of dimension \ccc{d} incident to
\ccc{Vertex} v and inserts them in the \ccc{OutputIterator out}. If
$d\geq$  \ccVar.\ccc{current_dimension()}, then no \ccc{Face} is
constructed.
\ccPrecond$0 < d$.
}

\ccMethod{template< typename OutputIterator > OutputIterator
incident_upper_faces(Vertex_const_handle v, int d, OutputIterator
out);}{Constructs all the \textbf{upper} \ccc{Face}s of dimension \ccc{d}
incident to \ccc{Vertex} v and inserts them in the \ccc{OutputIterator out}.\\
Assuming some total ordering on the vertices of the triangulation (which is
invariant as long as no vertex is inserted in or removed from the triangulation), a
\ccc{Face} incident to \ccc{v} is an \emph{upper} \ccc{Face} if and only if
its vertices occur at \ccc{v} or beyond \ccc{v} in the ordering.\\ In
particular, taking the disjoint union of the upper \ccc{Face}s of dimension
\ccc{d} incident to every vertex of the triangulation yields exactly the set of
faces of dimension \ccc{d} of the triangulation.\\ The constructed \ccc{Faces} are
lexicographically ordered using the vertex order as base ordering. In order to
make it easy to find the infinite \ccc{Faces}, the latter ordering makes the
vertex at infinity the smallest vertex; so calling the method on a finite
vertex will construct only finite faces and calling it on the vertex at
infinity will produce all infinite \ccc{d}-faces. (Elle est pas belle, la vie
?) If $d\geq $\ccVar.\ccc{current_dimension()}, then no \ccc{Face} is
constructed.
\ccPrecond$0 < d$.
}

\ccGlue\ccMethod{template< typename OutputIterator, typename Comparator >
OutputIterator incident_upper_faces(Vertex_const_handle v, const int d,
OutputIterator out, Comparator cmp);} {Same as above, but uses \ccc{cmp} as
the vertex ordering to define the upper faces.}

\ccHeading{Faces and Facets} % - - - - - - - - - - - - - - - - - - - - FACETS

\ccMethod{Full_cell_handle full_cell(const Facet & f) const;}
{Returns a cell containing the facet \ccc{f}}

\ccMethod{int index_of_covertex(const Facet & f) const;}
{Returns the index of the vertex of the cell
\ccc{c=}\ccVar.\ccc{full_cell(f)} which does \textbf{not} belong to \ccc{c}.}

%\begin{ccAdvanced}
%\ccMethod{Face make_empty_face() const;}{Returns an empty \ccc{Face}.}
%%\note{to be removed, internal use only. at least should be advanced}
%\end{ccAdvanced}

\ccHeading{Triangulation traversal} % - - - - - - - - - - - - - - - - - - TRAVERSAL

%\ccMethod{Vertex_const_iterator vertices_begin() const;}{}
%\ccGlue
\ccMethod{Vertex_iterator vertices_begin();}
{The first vertex of \ccVar.}
%\ccGlue\ccMethod{Vertex_const_iterator vertices_end() const;}{}
\ccGlue\ccMethod{Vertex_iterator vertices_end();}
{The beyond vertex of \ccVar.}

%\ccMethod{Finite_vertex_const_iterator finite_vertices_begin() const;}{}
%\ccGlue
\ccMethod{Finite_vertex_iterator finite_vertices_begin();}
{The first finite vertex of \ccVar.}
%\ccGlue\ccMethod{Finite_vertex_const_iterator finite_vertices_end() const;}{}
\ccGlue\ccMethod{Finite_vertex_iterator finite_vertices_end();}
{The beyond finite vertex of \ccVar.}

%\ccMethod{Full_cell_const_iterator full_cells_begin()const;}{}\ccGlue
\ccMethod{Full_cell_iterator full_cells_begin();}
{The first cell of \ccVar.}
%\ccGlue\ccMethod{Full_cell_const_iterator full_cells_end() const;}{}
\ccGlue\ccMethod{Full_cell_iterator full_cells_end();}
{The beyond cell of \ccVar.}

%\ccMethod{Finite_full_cell_const_iterator finite_full_cells_begin()  const;}{}\ccGlue
\ccMethod{Finite_full_cell_iterator finite_full_cells_begin();}
{The first finite cell of \ccVar.}
%\ccGlue\ccMethod{Finite_full_cell_const_iterator finite_full_cells_end() const;}{}
\ccGlue\ccMethod{Finite_full_cell_iterator finite_full_cells_end();}
{The beyond finite cell of \ccVar.}

\ccMethod{Facet_iterator facets_begin();}
{Iterator to the first facet of the triangulation.}
\ccGlue
\ccMethod{Facet_iterator facets_end();}
{Iterator to the beyond facet of the triangulation.}

\ccMethod{Finite_facet_iterator finite_facets_begin();}
{Iterator to the first finite facet of the triangulation.}
\ccGlue
\ccMethod{Finite_facet_iterator finite_facets_end();}
{Iterator to the beyond finite facet of the triangulation.}

\ccHeading{Point location} % - - - - - - - - - - - - - - - - - POINT LOCATION

The class \ccRefName\ provides methods to locate a query point with respect to
the triangulation:

\ccMethod{Full_cell_handle locate(const Point & query,
Full_cell_handle start = Full_cell_handle()) const;}
{If the point \ccc{query} lies inside a bounded (finite) cell of \ccVar,
the latter cell is returned.\\
If \ccc{query} lies on the boundary of some finite cells, one of them
is returned.\\
Let $d=$\ccVar.\ccc{current_dimension()}. If the point \ccc{query} lies
outside the convex hull of the points, an infinite cell with vertices $\{
p_1, p_2, \ldots, p_d, \infty\}$ is returned such that the cell $(p_1, p_2,
\ldots, p_d, query)$ is positively oriented (the rest of the triangulation lies
on the other side of facet $(p_1, p_2, \ldots, p_d)$).\\
The optional argument \ccc{start} is used as a starting place for the search.}

\ccMethod{Full_cell_handle locate(const Point & query, Vertex_handle hint)
const;}
{Same as above but uses \ccc{hint} as the starting place for the search.}

\ccMethod{Full_cell_handle locate(const Point & query, Locate_type & loc_type,
Face & f, Facet & ft, Full_cell_handle start = Full_cell_handle()) const;}
{The optional argument \ccc{start} is used as a starting place for the
search.\\ If the \ccc{query} point lies outside the affine hull of the points,
which can happen when \ccVar.\ccc{current_dimension() < }
\ccVar.\ccc{ambient_dimension()}, \ccc{loc_type} is set to
\ccc{OUTSIDE_AFFINE_HULL}, and the returned cell has no meaning. As a
particular case, if there is no finite vertex yet in the triangulation,
\ccc{loc_type} is set to \ccc{OUTSIDE_AFFINE_HULL} and \textit{locate} returns
\ccc{Full_cell_handle()}.\\ If the \ccc{query} point lies inside the affine hull
of the points, a $k$-face that contains \ccc{query} \textbf{in its relative
interior} is returned. (If the $k$-face is finite, it is
unique.)\begin{itemize} \item[$k=0$] \ccc{loc_type} is set to \ccc{ON_VERTEX},
\ccc{f} is set to the vertex \ccc{v} the \ccc{query} lies on and a cell
having \ccc{v} as a vertex is returned.
\item[$0<k<$\ccc{c.current_dimension()-1}] \ccc{loc_type} is set to
\ccc{IN_FACE}, \ccc{f} is set to the unique finite face containing the
\ccc{query} point. A cell having \ccc{f} on its boundary is returned.
\item[$k=$\ccc{c.current_dimension()-1}] \ccc{loc_type} is set to
\ccc{IN_FACET}, \ccc{ft} is set to one of the two finite facets containing the
\ccc{query} point. The cell of \ccc{ft} is returned.
\item[$k=$\ccc{c.current_dimension()}] If the \ccc{query} point lies
\textbf{outside} the convex hull of the points in the triangulation, then
\ccc{loc_type} is set to \ccc{OUTSIDE_CONVEX_HULL} and a cell is returned
as in the \ccc{locate} method above. If the \ccc{query} point lies
\textbf{inside} the convex hull of the points in the triangulation, then
\ccc{loc_type} is set to \ccc{IN_FULL_CELL} and the unique cell containing
the \ccc{query} point is returned. \end{itemize}}

\ccMethod{Full_cell_handle
          locate(const Point & query, Locate_type & loc_type,
                 Face & f, Vertex_handle hint) const;}
{Same as above but uses \ccc{hint} as the starting place for the search.}

\ccHeading{Removal} % - - - - - - - - - - - - - - - - - - - - - - - REMOVALS

\begin{ccAdvanced}

\ccMethod{Vertex_handle collapse_face(const Point & p, const Face & f);}
{Contracts the \ccc{Face f} to a single vertex at position \ccc{p}. Returns a
handle to that vertex. \ccPrecond The contracted triangulation must be valid
(\emph{i.e.}, be a triangulation of a sphere of dimension
\ccVar.\ccc{current_dimension()}).}

\end{ccAdvanced}

% - - - - - - - - - - - - - - - - - - - - - - - - - - - INSERTION

\ccHeading{Point insertion}

The class \ccRefName\ provides functions to insert a given point in the
triangulation:

\ccMethod{template< typename ForwardIterator >
size_type insert(ForwardIterator s, ForwardIterator e);}%
{Inserts the points found in range \ccc{[s,e)} in the triangulation. Returns
the number of vertices actually inserted. (If several vertices share the
same position in space, only the first insertion is counted.)}

\ccMethod{Vertex_handle insert(const Point & p, Full_cell_handle start =
Full_cell_handle());}{Inserts point \ccc{p} in the triangulation.  Returns a
\ccc{Vertex_handle} to the vertex of the triangulation with position \ccc{p}.
Prior to the actual insertion, \ccc{p} is located in the triangulation;
\ccc{start} is used as a starting place  for locating \ccc{p}.}

\ccMethod{Vertex_handle insert(const Point & p, Vertex_handle v);}%
{Same as above but uses \ccc{v} as the starting place for the search.}

\begin{ccAdvanced}

\ccMethod{Vertex_handle insert(const Point & p, const Locate_type
loc_type, const Face & f, const Facet & ft, const Full_cell_handle c);} {Inserts
point \ccc{p} into the triangulation and returns a handle to the
\ccc{Vertex} at that position. The action taken depends on the value of
\ccc{loc_type}:\begin{itemize} \item[\ccc{ON_VERTEX}] The point of the
\ccc{Vertex} described by \ccc{f} is set to \ccc{p}. \item[\ccc{IN_FACE}]
The point \ccc{p} is inserted in the \ccc{Face f}. \item[\ccc{IN_FACET}]
The point \ccc{p} is inserted in the \ccc{Facet ft}. \item[Anything else]
The point \ccc{p} is inserted in the triangulation according to the value
of \ccc{loc_type}, using the cell \ccc{c}.\end{itemize} This method is used
internally by the other \ccc{insert()} methods.}

\ccMethod{template < typename ForwardIterator, typename OutputIterator >
Vertex_handle insert_in_hole(const Point & p, ForwardIterator s,
ForwardIterator e, const Facet & ft, OutputIterator out);}{The cells in
the range $C=$\ccc{[s, e)} are removed, thus forming a hole. A \ccc{Vertex} is
inserted at position \ccc{p} and connected to the boundary of the hole in
order to ``fill it''. A \ccc{Vertex_handle} to the new \ccc{Vertex} is
returned. The facet \ccc{ft} must lie on the boundary of $C$ and its
defining cell, \ccVar.\ccc{full_cell(ft)} must lie inside $C$. Handles
to the newly created cells are output in the \ccc{out} output iterator.
\ccPrecond $C$ must be a (geometric) ball, must contain \ccc{p} in its
interior and not contain any vertex all of whose incident cells are in
$C$. (This implies that \ccVar.\ccc{current_dimension()}$\geq2$ if
$|C|>1$.) The boundary of $C$ must be a triangulation of the sphere
$\sphere^{k-1}$.}

\ccMethod{template < typename ForwardIterator > Vertex_handle
insert_in_hole(const Point & p, ForwardIterator s, ForwardIterator e, const
Facet & ft);}{Same as above, but the newly created cells are not
retrieved.}

\ccMethod{Vertex_handle insert_in_face(const Point & p, const Face & f);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie in the relative interior of \ccc{f}.}

\ccMethod{Vertex_handle insert_in_facet(const Point & p, const Facet & ft);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie in the relative interior of \ccc{ft}.}

\ccMethod{Vertex_handle insert_in_full_cell(const Point & p, Full_cell_handle
s);}%
{Inserts point \ccc{p} in the triangulation. \ccPrecond \ccc{p} must lie in the
interior of \ccc{s}.}

\ccMethod{Vertex_handle insert_outside_convex_hull(const Point &,
        Full_cell_handle s);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie outside the convex hull of \ccVar. The half-space
defined by the infinite cell \ccc{s} must contain \ccc{p}.}

\ccMethod{Vertex_handle insert_outside_affine_hull(const Point &);}%
{Inserts point \ccc{p} in the triangulation.
\ccPrecond \ccc{p} must lie outside the \textbf{affine} hull of \ccVar.}

\end{ccAdvanced}

\ccHeading{Validity check}

\ccMethod{bool is_valid(bool verbose = true, int level = 0) const;}
{Partially checks whether \ccVar\ is a triangulation. This function returns
\ccc{true} if the combinatorial triangulation data structure's \ccc{is_valid()}
test returns \ccc{true} and if some geometric tests are passed with success.
\note{is it really necessary to have the following :
For each infinite cell, it is checked that the index of the infinite vertex
is 0. }
For each finite cell, it is checked that its orientation is
positive.}

\ccMethod{bool are_incident_full_cells_valid(Vertex_const_handle v, bool
verbose = true, int level = 0) const;} {Returns \ccc{true} if and only if all
finite cells incident to \ccc{v} have positive orientation.}

\ccHeading{Input/Output}

\ccFunction{istream & operator>> (istream & is, Triangulation & t);}
{Reads the underlying combinatorial triangulation from \ccc{is} by
calling the corresponding input operator of the triangulation data
structure class (note that the infinite vertex is numbered 0), and the
non-combinatorial information by calling the corresponding input
operators of the vertex and the cell classes (such as point
coordinates), which are provided by overloading the stream operators
of the vertex and cell types. Assigns the resulting triangulation to
\ccc{t}.}

\ccFunction{ostream& operator<< (ostream& os, const Triangulation & t);}
{Writes the triangulation \ccc{t} into \ccc{os}.}

The information in the \ccc{iostream} is: the current dimension, the number of
finite vertices, the non-combinatorial information about vertices (point,
\emph{etc.}), the number of cells, the indices of the vertices of each
cell, plus the non-combinatorial information about each cell, then the
indices of the neighbors of each cell, where the index corresponds to the
preceding list of cells.

\ccSeeAlso

\ccc{Triangulation_data_structure<Dimensionality, TDSVertex, TDSFullCell>},\\
\ccc{Delaunay_triangulation<DTTraits, TDS>},\\
%\ccc{Regular_triangulation<RTTraits, TDS>}.

\end{ccRefClass}

