
--------------------------------------------------
Problems to be solved from the reviews
--------------------------------------------------

example delaunay  does not execute properly

in Triangulation_data_structure :
put a default value for dim in the constructor
(does not work, I do not understand why).

check that the perturbation scheme is independant of the order of insertion

Add a template parameter Location_policy

ambient dim vs max dim

check all is_valid function, precise in the doc what they are doing.
(do sth like 2/3 d)

small feature with iterator "all tuples"

make the code and doc agree on Flat_* stuff  (orientation in a flat)

iterator on points in concept TriangulationVertex should be removed to keep requirements minimal


make doc of  TDS-FullCellStoragePolicy in user manual













--------------------------------------------------
Vieille liste (mais pas forcement perimee)
--------------------------------------------------
Je me replonge dans Triangulation en dim d

ma liste de trucs à faire ou questions à résoudre:


--- Constructeur de triangulation 
   prévoir un constructeur qui prends d+1 points en position générale

--- Index du sommet à l'infini.
   Il est en ce moment prévu que le sommet à l'infini est l'index 0 dans les full
   cell où il apparraît. Ça me semble très discutable, en particulier la tds ne sait
   pas qui est à l'infini, et donc comment peut-elle garantir dans une manipulation
   que toutes les cellules crées ou modifiées vont préserver cette position.

   je suis donc pour virer ce truc ce qui implique des modifs dans la doc
     (1.3 - ?  p54) et dans le code.

   en plus il y a des trucs pas cohérent, i.e. p. 50 dans la doc de locate
   l'infini est en dernier, pas en premier.

   finite_vertex_iterator marche pas
        SAM: J'ai corrigé le problème, mais c'est pas super propre. Le problème
        vient de boost::filter_iterator qui suppose que le prédicat de filtrage
        prend en argument |const value_type &| plutôt que |iterator|. Mais
        quand on veut tester si un sommet est infini, on a envie de comparer
        les iterator (ou handle)... ce qui n'est pas possible avec le
        filter_iterator de boost. (Le filter_iterator de CGAL appele le
        prédicat de filtrage sur l'itérateur, et non pas sur la valeur vers
        lequel il pointe, comme le fait boost. Mais je ne sais pas si le filtre
        d'iterateur de CGAL est destiné à durer)

--- Doc 1.5 à faire
 
--- Orientation des cellules.
   les cellules sont orientées positivement par convention
   - le dire dans la doc (deux full cell partagent une facet, elles doivent avoir 
     des orientation complémentaires
   - dans Triangulation, il faut virer la méthode "orientation" 
     (ou au minimum, la mettre advanced)

--- mirror_index
   - policy a ajouter dans le user manual
   - le code ne fait pas ce qui est dit dans la doc (ça ne retourne pas -1)

   PS: Samuel tu as benché la policy ? ça vaut vraiment la peine de s'embeter avec ça ?

--- Face
   - pourquoi une face ne pourrait pas être de pleine dimension ?
     c'est pas la peine d'avoir un truc générique pour les faces de toutes dim sauf un
   Je propose de virer cette restriction

--- TriangulationTraits et DelaunayTraits
   lower dimensional predicates
   le truc de l'orientation "consistante"est quand même un peu délicat
   - d'une part, je proposerai un truc du genre: le noyau doit fournir un iterateur
   de points en position générale 
   (un truc fixe, ça donne toujours les mêmes points e.g. l'origine et les points
    avec une coordonnée à 1 et les autres à 0).
   Ce générateur permet donc de compléter tout ensemble de points pour obtenir 
   des points en position générale.
   - d'autre part ???? il faut un minimum en plus pour qu'on comprenne que 
   l'orientation du sous-espace est stocké qq part.

---  TriangulationTraits has models
   ... il faut voir ce que l'on met vraiment.

--- Triangulation   is_infinite
   j'avais viré les préconditions, et je maintiens.
   en dim 0 on a une full cell finie et une infinie
   en dim 1 on a 2 full cell infinie, 1 vertex/facet infini
   et ok, en d=0, facet n'a pas de sens, mais l'utilisateur aura du mal a en avoir une

--- Triangulation  fonctions incident_* et star
   est-il nécessaire de reprendre leur doc? (on pourrait pointer sur celle de TDS)
   au moins pour incident_upper_faces

--- dans Triangulation_data_structure.h  insert_in_tagged_hole
     on a l'air de supposer que full_cell(f) est marqué visité
      (pourquoi ça serait pas l'autre représentation de la Facet f ?)

--- Marque visité.
     elle devrait etre dans le concept TDSFullCell








__________________________________________________________________________RENAMING

*) doc :
--------

*) code not done :
------------------

bring part of Delaunay::remove into TDS (see comments in Delaunay_triangulation.h, and item FUTURE below)

__________________________________________________________________________ALL

*) FUTURE: better system for simplex's flags to know if we can use them or not
    in Delaunay_triangulation::remove(Vertex_handle)

_________________________________________________TRIANGULATION_DATA_STRUCTURE

*) Un-recursify insert_in_tagged_hole : crashed in dimension 8 : stack overflow.

*) TriangulationDataStructure:
  - Should we put >> and << in the documentation of the class
    Triangulation_data_structure ?

*) Triangulation_data_structure.h:
  - Ensure that it is topologically possible to collapse the Face in
    collapse_face(Face)

*) TriangulationDSVertex
  - Should we put >> and << in the documentation of the class
    Triangulation_ds_vertex instead of in that of the concept ?

*) TDSFullCellStoragePolicy
   what is it ? => see the doc.
   it is undocumented. => it is documented (Triangulation_ds_full_cell)
   if the aim is to choose between "full representation" and "1-skeleton"
   I would prefer a different TDS class, at least the doc has to rewriten a sentence
   like "class TDS explicitely stores its vertices and full cells" 
   does not apply to 1-skeleton representation
   => no, this has nothing to do with 1-skeleton.

*) default dim parameter in constructor (especially in the static case)

________________________________________________________________TRIANGULATION

*) default dim parameter in constructor (especially in the static case)

*) Why vertex at infinity should have index 0 in all cells it appears ?
    This is a convention that is enforced throughout the code. Makes it faster
    to check for an infinite cell.
    The "old" package "Convex_hull_d" does the same.

_______________________________________________________DELAUNAY_TRIANGULATION

________________________________________________________REGULAR_TRIANGULATION

*) write Regular_triangulaion.h (!)
*) write RegularTriangulationTraits.tex
*) write Regular_triangulation.tex
