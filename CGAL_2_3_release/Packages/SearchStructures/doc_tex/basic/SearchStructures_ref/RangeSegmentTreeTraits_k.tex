\begin{ccRefConcept}{RangeSegmentTreeTraits_k}

\ccDefinition
A tree traits class gives the range tree and segment tree class the necessary
type information of the keys and intervals. Further more, they define function objects that allow to access
the keys and intervals, and provide comparison functions that
are needed for window queries.

\ccCreationVariable{t}
\ccTypes

\ccNestedType{Key}{The k-dimensional key type.}
\ccNestedType{Interval}{The k-dimensional interval type.}
\ccNestedType{Key_i}{The type in dimension $i$, with $1\leq i
  \leq k$.}
\ccNestedType{key_i}{function object providing an
  \ccc{operator()} that takes an argument of type \ccc{Key} and returns
  a component of type \ccc{Key_i}.}
\ccNestedType{low_i}{function object providing an
  \ccc{operator()} that takes an argument of type \ccc{Interval} and returns
  a component of type \ccc{Key_i}.}
\ccNestedType{high_i}{function object providing an
  \ccc{operator()} that takes an argument of type \ccc{Interval} and returns
  a component of type \ccc{Key_i}.}
\ccNestedType{compare_i}{function object providing an
  \ccc{operator()} that takes two arguments argument $a$, $b$ of type \ccc{Key_i} and returns
  true if $a<b$, false otherwise.}



\ccExample

The following piece of code gives an example of how a traits class
might look like, if you have keys that are of the type \ccc{int}
in the first and that are of the type \ccc{double} in the second
dimension.

\begin{verbatim}
class Int_double_tree_traits_2{
 public:
  typedef std::pair<int, double> Key;
  typedef int Key_1;
  typedef double Key_2;
  typedef std::pair<Key,Key> Interval;

  class C_Key_1{
  public:
    Key_1 operator()(const Key& k)
    { return k.first;}
  };
  class C_Key_2{
  public:
    Key_2 operator()(const Key& k)
    { return k.second;}
  };
  class C_Low_1{
  public:
    Key_1 operator()(const Interval& i)
    { return i.first.first;}
  };
  class C_High_1{
  public:
    Key_1 operator()(const Interval& i)
    { return i.second.first;}
  };
  class C_Low_2{
  public:
    Key_2 operator()(const Interval& i)
    { return i.first.second;}
  };
  class C_High_2{
  public:
    Key_2 operator()(const Interval& i)
    { return i.second.second;}
  };
  class C_Compare_1{
  public:
    bool operator()(Key_1 k1, Key_1 k2)
    { return less<int>()(k1,k2);}
  };
  class C_Compare_2{
  public:
    bool operator()(Key_2 k1, Key_2 k2)
    { return less<double>()(k1,k2);}
  };
  typedef C_Compare_1 compare_1;
  typedef C_Compare_2 compare_2;
  typedef C_Low_1 low_1;
  typedef C_High_1 high_1;
  typedef C_Key_1 key_1;
  typedef C_Low_2 low_2;
  typedef C_High_2 high_2;
  typedef C_Key_2 key_2;
};
\end{verbatim} 

\end{ccRefConcept} 
