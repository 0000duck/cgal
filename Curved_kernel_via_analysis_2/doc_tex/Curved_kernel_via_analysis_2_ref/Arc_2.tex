% +------------------------------------------------------------------------+
% | Reference manual page: Arc_2.tex
% +------------------------------------------------------------------------+
% | 13.03.2008   Author
% | Package: Package
% |
\RCSdef{\RCSArcRev}{$Id: header.tex 40270 2007-09-07 15:29:10Z lsaboret $}
\RCSdefDate{\RCSArcDate}{$Date: 2007-09-07 17:29:10 +0200 (Fri, 07 Sep 2007) $}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Arc_2}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition
  
\ccInclude{Arc_2.h}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

class defines a point on a generic curve

%END-AUTO(\ccDefinition)

\ccParameters

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccParameters)

template$<$  \\
class \ccc{CurvedKernelViaAnalysis_2},   \\
class \ccc{Rep_}$>$   \\
class \ccc{Arc_2};

%END-AUTO(\ccParameters)

\ccIsModel

\ccTypes

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\ccNestedType{Rep}
{
this instance's second template parameter
}
\ccGlue
\ccNestedType{Self}
{
this instance itself
}
\ccGlue
\ccNestedType{Curve_kernel_2}
{
type of curve kernel
}
\ccGlue
\ccNestedType{X_coordinate_1}
{
type of an x-coordinate
}
\ccGlue
\ccNestedType{Xy_coordinate_2}
{
type of a finite point on curve
}
\ccGlue
\ccNestedType{Curve_analysis_2}
{
type of analysis of a pair of curves
}
\ccGlue
\ccNestedType{Curve_pair_analysis_2}
{
type of analysis of a pair of curves
}
\ccGlue
\ccNestedType{Point_2}
{
type of a point on generic curve
}
\ccGlue
\ccNestedType{Kernel_arc_2}
{
type of kernel arc
}
\ccGlue

%END-AUTO(\ccTypes)

\ccHeading{Variables}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccHeading{Variables})

\ccMethod{CGAL::Arr_parameter_space location(CGAL::Arr_curve_end end) const;}
{
returns location of arc's end in parameter space
}
\ccGlue
\ccMethod{void set_location(CGAL::Arr_curve_end end, CGAL::Arr_parameter_space loc) const;}
{
sets boundary type for curve end end
it's supposed that the user thoroughly understands malicious consequences that may result from the misuse of boundary conditions
}
\ccGlue
\ccMethod{bool is_finite(CGAL::Arr_curve_end end) const;}
{
returns whether curve-end can be accessed
}
\ccGlue
\ccMethod{Point_2 curve_end(CGAL::Arr_curve_end end) const;}
{
returns arc's finite curve end end
}
\ccGlue
\begin{description}
\item[Precondition:]accessed curve end has finite x/y-coordinates \end{description}
\ccGlue
\ccMethod{X_coordinate_1 curve_end_x(CGAL::Arr_curve_end end) const;}
{
returns arc's curve end end x-coordinate
}
\ccGlue
\begin{description}
\item[Precondition:]accessed curve end has finite x-coordinate \end{description}
\ccGlue
\ccMethod{const Curve_analysis_2& curve() const;}
{
returns supporting curve of the arc
}
\ccGlue
\ccMethod{int arcno() const;}
{
returns arc number
}
\ccGlue
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{int arcno(CGAL::Arr_curve_end end) const;}
{
returns this arc's end arc number
!\ccc{is_vertical}()
}
\ccGlue
\ccMethod{int arcno(const X_coordinate_1& x0) const;}
{
arc number at given x-coordinate
If x0 equals to source's or target's x-coordinate, then the arc number of that point is returned. Otherwise the arc number of the interior is returned.
}
\ccGlue
\begin{description}
\item[Precondition:]!\ccc{is_vertical}()
x0 must be within arcs's x-range. \end{description}
\ccGlue
\ccMethod{bool is_vertical() const;}
{
checks if the arc is vertical
}
\ccGlue
\ccMethod{const X_coordinate_1& x() const;}
{
returns x-coordinate of vertical arc
}
\ccGlue
\begin{description}
\item[Precondition:]\ccc{is_vertical} \end{description}
\ccGlue
\ccMethod{int interval_id() const;}
{
returns the index of an open interval between two events $\ast$this arc belongs to
}
\ccGlue
\begin{description}
\item[Precondition:]!\ccc{is_vertical}() \end{description}
\ccGlue
\ccMethod{Boundary boundary_in_x_range_interior() const;}
{
returns boundary value in interior of x-range of non-vertical interval
}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_x_near_boundary(CGAL::Arr_curve_end end, const Point_2& p) const;}
{
Compare the relative positions of a vertical curve and unbounded this arc's end
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]A reference point; we refer to a vertical line incident to p. \item[end]\ccc{ARR_MIN_END} if we refer to cv's minimal end, \ccc{ARR_MAX_END} if we refer to its maximal end. \end{description}
\end{description}
\begin{description}
\item[Precondition:]curve's relevant end is defined at y = +/- oo. \end{description}
\begin{description}
\item[Returns:]SMALLER if p lies to the left of cv; LARGER if p lies to the right of cv; EQUAL in case of an overlap. \end{description}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_x_near_boundary(CGAL::Arr_curve_end end1, const Kernel_arc_2& cv2, CGAL::Arr_curve_end end2) const;}
{
Compare the relative positions of the unbounded curve ends of this and cv2
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[end1]\ccc{ARR_MIN_END} if we refer to this' minimal end, \ccc{ARR_MAX_END} if we refer to this' maximal end. \item[cv2]The second curve. \item[end2]\ccc{ARR_MIN_END} if we refer to its minimal end, \ccc{ARR_MAX_END} if we refer to its maximal end. \end{description}
\end{description}
\begin{description}
\item[Precondition:]the curve ends have a bounded x-coord and unbounded y-coord, namely each of this and cv2 is vertical or asymptotic \end{description}
\begin{description}
\item[Returns:]SMALLER if this lies to the left of cv2; LARGER if this lies to the right of cv2; EQUAL in case of an overlap. \end{description}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_x_near_boundary(CGAL::Arr_curve_end end1, const Kernel_arc_2& cv2, CGAL::Arr_curve_end end2) const;}
{
}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_y_near_boundary(const Kernel_arc_2& cv2, CGAL::Arr_curve_end end) const;}
{
Compare the relative y-positions of two arcs at x = +/- oo.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second curve \item[end]\ccc{ARR_MIN_END} if we compare at x = -oo; \ccc{ARR_MAX_END} if we compare at x = +oo. \end{description}
\end{description}
\begin{description}
\item[Precondition:]The curves are defined at x = +/- oo. \end{description}
\begin{description}
\item[Returns:]SMALLER if this arc lies below cv2; LARGER if this arc lies above cv2; EQUAL in case of an overlap. \end{description}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_y_at_x(const Point_2& p) const;}
{
Return the location of the given point with respect to this arc
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]The point. \end{description}
\end{description}
\begin{description}
\item[Precondition:]p is in the x-range of the arc. \end{description}
\begin{description}
\item[Returns:]SMALLER if y(p) $<$ arc(x(p)), i.e. the point is below the arc; LARGER if y(p) $>$ arc(x(p)), i.e. the point is above the arc; EQUAL if p lies on the arc. \end{description}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_y_at_x(const Point_2& p) const;}
{
}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_y_at_x_left(const Kernel_arc_2& cv2, const Point_2& p) const;}
{
Compares the y value of two x-monotone curves immediately to the left of their intersection point. If one of the curves is vertical (emanating downward from p), it's always considered to be below the other curve.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second curve. \item[p]The intersection point. \end{description}
\end{description}
\begin{description}
\item[Precondition:]The point p lies on both curves, and both of them must be also be defined (lexicographical) to its left. \end{description}
\begin{description}
\item[Returns:]The relative position of this arc with respect to cv2 immdiately to the left of p: SMALLER, LARGER or EQUAL. \end{description}
\ccGlue
\ccMethod{CGAL::Comparison_result compare_y_at_x_right(const Kernel_arc_2& cv2, const Point_2& p) const;}
{
Compares the y value of two x-monotone curves immediately to the right of their intersection point. If one of the curves is vertical (emanating upward from p), it's always considered to be above the other curve.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv1]The first curve. \item[cv2]The second curve. \item[p]The intersection point. \end{description}
\end{description}
\begin{description}
\item[Precondition:]The point p lies on both curves, and both of them must be also be defined (lexicographically) to its right. \end{description}
\begin{description}
\item[Returns:]The relative position of cv1 with respect to cv2 immdiately to the right of p: SMALLER, LARGER or EQUAL. \end{description}
\ccGlue
\ccMethod{bool is_in_x_range(const X_coordinate_1& x, bool * eq_min = NULL, bool * eq_max = NULL) const;}
{
Check if the given x-value is in the x-range of the arc inclusive.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The x-value. \item[$\ast$\ccc{eq_min}]Output: Is this value equal to the x-coordinate of the \ccc{ARR_MIN_END} point. \item[$\ast$\ccc{eq_max}]Output: Is this value equal to the x-coordinate of the \ccc{ARR_MAX_END} point. \end{description}
\end{description}
\ccGlue
\ccMethod{bool is_in_x_range_interior(const X_coordinate_1& x) const;}
{
checks whether x-coordinate x belongs to this arc's interior
}
\ccGlue
\ccMethod{bool is_equal(const Kernel_arc_2& cv2) const;}
{
returns true iff this arc is equal to cv
}
\ccGlue
\ccMethod{bool do_overlap(const Kernel_arc_2& cv2) const;}
{
checks whether two curve arcs have infinitely many intersection points, i.e., they overlap
}
\ccGlue
\ccMethod{int multiplicity_of_intersection(const Kernel_arc_2& cv2, const Point_2& p) const;}
{
multiplicity of intersection
The intersection multiplicity of $\ast$this and cv2 at point p is returned.
}
\ccGlue
\begin{description}
\item[Precondition:]p must be an intersection point. \end{description}
\ccGlue
\ccMethod{OutputIterator intersections(const Kernel_arc_2& cv2, OutputIterator oi) const;}
{
Find all intersections of the two given curves and insert them to the output iterator. If two arcs intersect only once, only a single will be placed to the iterator. Type of output iterator is \ccc{CGAL::Object} containing either an \ccc{Arc_2} object (overlap) or a \ccc{Point_2} object with multiplicity (point-wise intersections) are inserted to the output iterator oi as objects of type $<$tt$>$\ccc{std::pair<Point_2, unsigned int>} (intersection point + multiplicity).
}
\ccGlue
\ccMethod{bool intersect_right_of_point(const Kernel_arc_2& cv2, const Point_2& p, Point_2& intersection) const;}
{
computes the next intersection of $\ast$this and cv2 right of p in lexicographical order and returns it through intersection argument
\ccc{intersect_right_of_point} is not called when using \ccc{sweep_curves}() with intersection dictionary and without validation of internal structures (as is standard). Hence we can be lazy here for the moment without losing performance.
}
\ccGlue
\ccMethod{bool intersect_left_of_point(const Kernel_arc_2& cv2, const Point_2& p, Point_2& intersection) const;}
{
computes the next intersection of $\ast$this and cv2 left of p in lexicographical order and returns it through intersection argument
\ccc{intersect_right_of_point} is not called when using \ccc{sweep_curves}() with intersection dictionary and without validation of internal structures (as is standard). Hence we can be lazy here for the moment without losing performance.
}
\ccGlue
\ccMethod{Kernel_arc_2 trim(const Point_2& p, const Point_2& q) const;}
{
returns a trimmed version of this arc with new end-points p and q; lexicographical order of the end-points is ensured in case of need.
}
\ccGlue
\begin{description}
\item[Precondition:]p != q
p and q lie on $\ast$this arc \end{description}
\ccGlue
\ccMethod{void split(const Point_2& p, Kernel_arc_2& s1, Kernel_arc_2& s2) const;}
{
Splits a given x-monotone curve at a given point into two sub-curves.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[p]The split point. \item[c1]Output: The left resulting subcurve (p is its right endpoint) \item[c2]Output: The right resulting subcurve (p is its left endpoint) \end{description}
\end{description}
\begin{description}
\item[Precondition:]p lies on this arc but is not one of its curve ends \end{description}
\ccGlue
\ccMethod{bool are_mergeable(const Kernel_arc_2& cv2) const;}
{
Check whether two given curves (arcs) are mergeable.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv]The second curve. \end{description}
\end{description}
\begin{description}
\item[Returns:](true) if the two arcs are mergeable, i.e., they are supported by the same curve and share a common endpoint; (false) otherwise. \end{description}
\ccGlue
\ccMethod{Kernel_arc_2 merge(const Kernel_arc_2& cv2) const;}
{
Merge two given x-monotone curves into a single one.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[cv2]The second curve. \item[c]Output: The resulting curve. \end{description}
\end{description}
\begin{description}
\item[Precondition:]Two curves are mergeable,if they are supported by the same curve and share a common end-point. \end{description}
\ccGlue
\ccMethod{static bool simplify(const Kernel_arc_2& cv, const Xy_coordinate_2& p);}
{
[static] \\
simplifies representation of cv and/or p in case they have non-coprime supporting curves.
returns true if simplification took place
}
\ccGlue
\ccMethod{static bool simplify(const Kernel_arc_2& cv1, const Kernel_arc_2& cv2);}
{
[static] \\
simplifies representation of cv1 and/or cv2 in case they have non-coprime supporting curves.
returns true if simplification took place
}
\ccGlue
\ccMethod{bool trim_by_arc(const Kernel_arc_2& cv2, Kernel_arc_2& trimmed1, Kernel_arc_2& trimmed2) const;}
{
}
\ccGlue
\ccMethod{void write(std::ostream& os) const;}
{
output operator
}
{
\subsubsection{Friends And Related Function Documentation}
\ccMethod{std::ostream& operator<<(std::ostream& os, const Arc_2< CurvedKernelViaAnalysis_2, Rep_>& arc);}
{
[related] \\
output operator
\subsubsection{Member Data Documentation}
\ccVariable{name publuic typedefs* typedef CurvedKernelViaAnalysis_2 Curved_kernel_via_analysis_2;}
{
this instance's first template parameter
}
\ccGlue

%END-AUTO(\ccHeading{Variables})

\ccCreation
\ccCreationVariable{a}  %% choose variable name

\ccConstructor{Arc_2();}{default constructor.}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\ccConstructor{Arc_2();}
{
Default constructor.
}
\ccGlue
\ccConstructor{Arc_2(const Self& a);}
{
copy constructor
}
\ccGlue
\ccConstructor{Arc_2(const Point_2& p, const Point_2& q, const Curve_analysis_2& c, int arcno, int arcno_p, int arcno_q);}
{
constructs an arc with two finite end-points, supported by curve c with arcno (segment)
\ccc{arcno_p} and \ccc{arcno_q} define arcnos of p and q w.r.t. the curve c
}
\ccGlue
\begin{description}
\item[Precondition:]p.x() != q.x() \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, CGAL::Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno, int arcno_o);}
{
constructs an arc with one finite end-point origin and one x-infinite end, supported by curve c with arcno (ray I)
\ccc{inf_end} defines whether the ray emanates from +/- x-infinity, \ccc{arcno_o} defines an arcno of point origin w.r.t. curve c
}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, const X_coordinate_1& asympt_x, CGAL::Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno, int arcno_o);}
{
constructs an arc with one finite end-point origin and one asymtpotic (y-infinite) end given by x-coordinate \ccc{asympt_x} (ray II)
\ccc{inf_end} specifies +/-oo an asymptotic end is approaching, \ccc{arcno_o} defines an arcno of point origin (arcno of asymptotic end is the same as arcno )
}
\ccGlue
\begin{description}
\item[Precondition:]origin.x() != \ccc{asympt_x} \end{description}
\ccGlue
\ccConstructor{Arc_2(const Curve_analysis_2& c, int arcno);}
{
constructs an arc with two x-infinite ends supported by curve c with arcno (branch I)
}
\ccGlue
\ccConstructor{Arc_2(const X_coordinate_1& asympt_x1, CGAL::Arr_curve_end inf_end1, const X_coordinate_1& asympt_x2, CGAL::Arr_curve_end inf_end2, const Curve_analysis_2& c, int arcno);}
{
constructs an arc with two asymptotic ends defined by \ccc{asympt_x1} and \ccc{asympt_x2} respectively, supported by curve c with arcno (branch II)
\ccc{inf_end1}/2 define +/-oo the repspective asymptotic end is approaching
}
\ccGlue
\begin{description}
\item[Precondition:]\ccc{asympt_x1} != \ccc{asympt_x2} \end{description}
\ccGlue
\ccConstructor{Arc_2(CGAL::Arr_curve_end inf_endx, const X_coordinate_1& asympt_x, CGAL::Arr_curve_end inf_endy, const Curve_analysis_2& c, int arcno);}
{
constructs an arc with one x-infinite end and one asymptotic end defined by x-coordinate \ccc{asympt_x} supported by curve c with arcno (branch III)
\ccc{inf_endx} specifies whether the branch goes to +/- x-infinity, \ccc{inf_endy} specifies +/-oo the asymptotic end approaches
}
\ccGlue
\ccConstructor{Arc_2(const Point_2& p, const Point_2& q, const Curve_analysis_2& c);}
{
constructs a vertcial arc with two finite end-points p and q , supported by curve c (vertical segment)
}
\ccGlue
\begin{description}
\item[Precondition:]p != q \&\& p.x() == q.x()
c must have a vertical component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(const Point_2& origin, CGAL::Arr_curve_end inf_end, const Curve_analysis_2& c);}
{
constructs a vertical arc with one finite end-point origin and one y-infinite end, supported by curve c (vertical ray)
\ccc{inf_end} defines whether the ray emanates from +/- y-infninty,
}
\ccGlue
\begin{description}
\item[Precondition:]c must have a vertical line component at this x \end{description}
\ccGlue
\ccConstructor{Arc_2(const X_coordinate_1& x, const Curve_analysis_2& c);}
{
constructs a vertical arc with two y-infinite ends, at x-coordinate x , supported by curve c (vertical branch)
}
\ccGlue
\begin{description}
\item[Precondition:]c must have a vertical line component at this x \end{description}
\ccGlue

%END-AUTO(\ccCreation)

%% \ccIncludeExampleCode{Package/Arc_2.C}

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

